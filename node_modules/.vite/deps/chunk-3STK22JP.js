import {
  Host,
  h
} from "./chunk-HB73EBAH.js";

// node_modules/@dytesdk/ui-kit/dist/esm/index-e2bee3ae.js
var computeSelectors = ({ element, size, states = {}, config = {} }) => {
  let selectors = [];
  const data = config === null || config === void 0 ? void 0 : config.root[element];
  const add = (selector) => {
    selectors.push(selector);
    if (typeof size === "string") {
      selectors.push(`${selector}.${size}`);
    }
  };
  add(element);
  if (typeof data === "object" && !Array.isArray(data) && data !== null) {
    const { state, states: elementStates } = data;
    let selector = element;
    let activeStates = [];
    if (Array.isArray(elementStates)) {
      activeStates = elementStates.filter((state2) => states[state2]);
      activeStates.sort();
      for (const state2 of activeStates) {
        add(`${selector}.${state2}`);
      }
      if (activeStates.length > 1) {
        const booleanStateSelector = [selector, ...activeStates].join(".");
        add(booleanStateSelector);
      }
    }
    if (typeof state === "string") {
      const keyValueSelector = `${element}[${state}=${states[state]}]`;
      add(keyValueSelector);
      for (const state2 of activeStates) {
        add(`${keyValueSelector}.${state2}`);
      }
      if (activeStates.length > 1) {
        const withBooleanStateSelector = [keyValueSelector, ...activeStates].join(".");
        add(withBooleanStateSelector);
      }
    }
  }
  return selectors;
};
var getComputedStyles = ({ selectors, styles }) => {
  if (!Array.isArray(selectors) || styles == null)
    return {};
  const computedStyles = {};
  for (const selector of selectors) {
    const style = styles[selector];
    if (style != null) {
      Object.assign(computedStyles, style);
    }
  }
  return computedStyles;
};
var getComputedChildren = ({ selectors, root }) => {
  if (!root || !Array.isArray(selectors))
    return [];
  let children = [];
  for (const selector of selectors) {
    const el = root[selector];
    if (Array.isArray(el)) {
      children = [...el];
    } else if (el) {
      if (el.children) {
        children = [...el.children];
      }
      if (Array.isArray(el.remove)) {
        for (const toRemove of el.remove) {
          children = children.filter((child) => {
            if (typeof child === "string") {
              return child !== toRemove;
            } else if (Array.isArray(child)) {
              return child[0] !== toRemove;
            }
            return true;
          });
        }
      }
      if (el.addBefore) {
        for (const [beforeEl, toAdd] of Object.entries(el.addBefore)) {
          const idx = children.findIndex((child) => {
            if (typeof child === "string") {
              return child === beforeEl;
            } else if (Array.isArray(child)) {
              return child[0] === beforeEl;
            }
            return false;
          });
          if (idx >= 0) {
            children.splice(idx, 0, ...toAdd);
          }
        }
      }
      if (Array.isArray(el.add)) {
        children = children.concat(el.add);
      }
      if (Array.isArray(el.prepend)) {
        children = el.prepend.concat(children);
      }
    }
  }
  return children;
};
var RenderChildren = ({ elements, defaults, props = {}, deepProps = false, elementProps = {} }) => {
  if (!Array.isArray(elements) || elements.length === 0)
    return null;
  return elements.map((element) => {
    return h(Render, { element, defaults, props, childProps: deepProps && props, elementProps });
  });
};
var lenChildren = ({ element, defaults, props = {}, elementProps = {} }) => {
  var _a;
  const { config, size, states } = defaults;
  let Tag, configProps = {}, configChildren = [];
  if (Array.isArray(element)) {
    [Tag, configProps, ...configChildren] = element;
  } else {
    Tag = element;
  }
  const elemData = (_a = config === null || config === void 0 ? void 0 : config.root) === null || _a === void 0 ? void 0 : _a[Tag];
  if (elemData != null && "props" in elemData) {
    props = Object.assign(Object.assign({}, elemData["props"]), props);
  }
  props = Object.assign(Object.assign({}, props), configProps);
  if (Tag in elementProps) {
    props = Object.assign(Object.assign({}, props), elementProps[Tag]);
  }
  const selectors = computeSelectors({ element: Tag, size, states, config });
  const computedChildren = getComputedChildren({ selectors, root: config.root });
  return computedChildren.length;
};
var Render = ({ element, defaults, childProps = {}, props = {}, onlyChildren = false, asHost = false, deepProps = false, elementProps = {} }, children) => {
  var _a;
  const { config, size, states } = defaults;
  let Tag, configProps = {}, configChildren = [];
  if (Array.isArray(element)) {
    [Tag, configProps, ...configChildren] = element;
  } else {
    Tag = element;
  }
  const elemData = (_a = config === null || config === void 0 ? void 0 : config.root) === null || _a === void 0 ? void 0 : _a[Tag];
  if (elemData != null && "props" in elemData) {
    props = Object.assign(Object.assign({}, elemData["props"]), props);
  }
  props = Object.assign(Object.assign({}, props), configProps);
  if (Tag in elementProps) {
    props = Object.assign(Object.assign({}, props), elementProps[Tag]);
  }
  const selectors = computeSelectors({ element: Tag, size, states, config });
  const computedChildren = getComputedChildren({ selectors, root: config.root });
  if (onlyChildren) {
    return h(RenderChildren, { elements: computedChildren, defaults, props: childProps, deepProps, elementProps });
  }
  const styles = getComputedStyles({ selectors, styles: config.styles });
  if (asHost) {
    return h(
      Host,
      Object.assign({}, defaults, { style: styles }, props),
      h(RenderChildren, { elements: computedChildren, defaults, props: childProps, deepProps, elementProps }),
      children,
      configChildren.map((child) => {
        if (Array.isArray(child)) {
          const [Tag2, props2] = child;
          return h(Tag2, Object.assign({}, defaults, props2));
        }
        return child;
      })
    );
  }
  if (["dyte-header", "dyte-controlbar"].includes(Tag)) {
    props["disableRender"] = true;
  }
  if (Tag.startsWith("dyte-")) {
    return h(
      Tag,
      Object.assign({}, defaults, { style: styles }, props),
      h(RenderChildren, { elements: computedChildren, defaults, props: childProps, deepProps, elementProps }),
      children,
      configChildren.map((child) => {
        if (Array.isArray(child)) {
          const [Tag2, props2] = child;
          return h(Tag2, Object.assign({}, defaults, props2));
        }
        return child;
      })
    );
  } else {
    const [HTMLTag, id] = Tag.split("#");
    return h(
      HTMLTag,
      Object.assign({ id, style: styles }, props),
      h(RenderChildren, { elements: computedChildren, defaults, props: childProps, deepProps, elementProps }),
      children,
      configChildren.map((child) => {
        if (Array.isArray(child)) {
          const [Tag2, props2] = child;
          return h(Tag2, Object.assign({}, defaults, props2));
        }
        return child;
      })
    );
  }
};

export {
  lenChildren,
  Render
};
//# sourceMappingURL=chunk-3STK22JP.js.map
