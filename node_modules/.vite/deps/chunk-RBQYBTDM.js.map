{
  "version": 3,
  "sources": ["../../@dytesdk/ui-kit/dist/esm/hark-6327d91e.js"],
  "sourcesContent": ["/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nvar wildemitter = WildEmitter$1;\n\nfunction WildEmitter$1() { }\n\nWildEmitter$1.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter$1.mixin(WildEmitter$1);\n\nvar WildEmitter = wildemitter;\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  }\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nvar hark = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  };\n  harker.resume = function() {\n    return audioContext.resume();\n  };\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  };\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n};\n\nexport { hark as h };\n"],
  "mappings": "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",
  "names": ["i", "history"]
}
