{
  "version": 3,
  "sources": ["../../@dytesdk/ui-kit/dist/esm/chat-8cb0e3a4.js"],
  "sourcesContent": ["import { f as chatUnreadTimestamps } from './ui-store-9dd5dd86.js';\n\nconst parseMessageForTarget = (message) => {\n    let parsedMessage = null;\n    try {\n        const parsed = JSON.parse(message.message);\n        const { target, message: m } = parsed;\n        if (target === undefined || m === undefined) {\n            parsedMessage = message;\n        }\n        else {\n            parsedMessage = Object.assign(Object.assign({}, message), { targetUserIds: target, message: m });\n        }\n    }\n    catch (error) {\n        parsedMessage = message;\n    }\n    return parsedMessage;\n};\nfunction alphabeticalSorter(a, b) {\n    return a.localeCompare(b);\n}\n/**\n * Generate a unique chat group key used in `<dyte-chat-messages-ui />`\n * @param ids An array of user ids\n * @returns A unique key from the user ids\n */\nfunction generateChatGroupKey(ids) {\n    return ids.sort((a, b) => a.localeCompare(b)).join('_');\n}\nfunction handleFilesDataTransfer(items, callback) {\n    if (items == null)\n        return true;\n    for (const item of items) {\n        if (item.kind === 'file') {\n            const file = item.getAsFile();\n            if (item.type.startsWith('image/')) {\n                callback('image', file);\n            }\n            else {\n                callback('file', file);\n            }\n        }\n    }\n}\nfunction getChatGroups({ messages, participants, selfUserId }) {\n    const groups = {};\n    // create empty chat groups for all participants\n    for (const participant of participants) {\n        groups[generateChatGroupKey([participant.userId, selfUserId])] = [];\n    }\n    messages.forEach((message) => {\n        var _a;\n        const parsedMessage = parseMessageForTarget(message);\n        let key = 'everyone';\n        if (((_a = parsedMessage.targetUserIds) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n            const allParticipants = new Set([\n                parsedMessage.userId,\n                ...parsedMessage.targetUserIds,\n            ]);\n            key = generateChatGroupKey(Array.from(allParticipants));\n        }\n        if (!groups[key]) {\n            groups[key] = [];\n        }\n        groups[key].push({ type: 'chat', message: parsedMessage });\n    });\n    return groups;\n}\nfunction getUnreadChatCounts({ messages, selfUserId, selectedGroupId, participants, }) {\n    var _a;\n    const groups = getChatGroups({\n        messages,\n        selfUserId,\n        participants,\n    });\n    const unreadCounts = {};\n    for (const key in groups) {\n        const lastReadTimestamp = (_a = chatUnreadTimestamps[key]) !== null && _a !== void 0 ? _a : 0;\n        if (key === selectedGroupId) {\n            // reset count to 0 when you select a group\n            unreadCounts[key] = 0;\n            chatUnreadTimestamps[key] = new Date();\n        }\n        else {\n            unreadCounts[key] = groups[key].filter((c) => {\n                return (c.type == 'chat' && c.message.time > lastReadTimestamp && c.message.userId !== selfUserId);\n            }).length;\n        }\n    }\n    return unreadCounts;\n}\nfunction getParticipantUserId({ groupId, selfUserId, }) {\n    return groupId.split('_').find((id) => id != selfUserId);\n}\nconst TEMPORARY_CHANNEL_PREFIX = 'dm__';\nfunction isDirectMessageChannel(channel) {\n    return channel.isDirectMessage;\n}\nfunction getDMComparator(memberIds) {\n    const uniqueMemberIds = [...new Set(memberIds)];\n    return uniqueMemberIds.sort(alphabeticalSorter).join('<>');\n}\nfunction reverse(str) {\n    return str.split('').reverse().join('');\n}\nconst boldPattern = /^\\*([^*\\s]+)\\*/;\nconst italicsPattern = /^_([^_\\s]+)_/;\nconst strikethroughPattern = /^~([^~\\s]+)~/;\n// Source: https://stackoverflow.com/a/8234912/2013580\nconst linkPattern = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.,~#?&//=]*)/;\nconst replyBlockPattern = /<blockquote>[.\\s\\S]*<\\/blockquote>\\n\\n/m;\nfunction extractReplyBlock(message, excludeTags = false) {\n    if (!replyBlockPattern.test(message)) {\n        return '';\n    }\n    let startOffset = 0;\n    let endOffset = '</blockquote>'.length;\n    if (excludeTags) {\n        startOffset = '<blockquote>'.length;\n        endOffset = 0;\n    }\n    return message.substring(message.indexOf('<blockquote>') + startOffset, message.indexOf('</blockquote>') + endOffset);\n}\nfunction stripOutReplyBlock(message) {\n    return message.replace(replyBlockPattern, '');\n}\nconst MAX_TEXT_LENGTH = 2000;\nconst KNOWN_TAGS = ['<a>', '<b>', '<i>', '<q>', '<s>'];\nfunction parseRichText(text) {\n    text = text\n        .split(' ')\n        .map((word) => {\n        if (linkPattern.test(word)) {\n            const res = linkPattern.exec(word);\n            word = word.replace(res[0], `<a>${res[0]}</a>`);\n        }\n        else {\n            if (boldPattern.test(word)) {\n                const res = boldPattern.exec(word);\n                word = word.replace(res[0], `<b>${res[1]}</b>`);\n            }\n            if (italicsPattern.test(word)) {\n                const res = italicsPattern.exec(word);\n                word = word.replace(res[0], `<i>${res[1]}</i>`);\n            }\n            if (strikethroughPattern.test(word)) {\n                const res = strikethroughPattern.exec(word);\n                word = word.replace(res[0], `<s>${res[1]}</s>`);\n            }\n        }\n        return word;\n    })\n        .join(' ');\n    text = text\n        .split(' ')\n        .map((word, idx) => {\n        if (word === '>' && (idx === 0 || word[idx - 1] === '>')) {\n            return `<q></q>`;\n        }\n        return word;\n    })\n        .join(' ');\n    const [tokens] = tokenizeRichText(text);\n    return tokens;\n}\nfunction tokenizeRichText(text, endTag = '') {\n    const tokens = [];\n    if (text.length === 0) {\n        return [tokens, 0];\n    }\n    let i = 0;\n    while (i < text.length) {\n        if (endTag.length && endTag === text.substring(i, i + endTag.length)) {\n            return [tokens, i + endTag.length];\n        }\n        if (KNOWN_TAGS.includes(text.substring(i, i + 3))) {\n            const [subtokens, pos] = tokenizeRichText(text.substring(i + 3), `</${text[i + 1]}>`);\n            tokens.push({\n                type: text[i + 1],\n                content: subtokens.length === 1 && subtokens[0].type === 'plain_text'\n                    ? subtokens[0].content\n                    : subtokens,\n            });\n            i += pos + 3;\n        }\n        else {\n            let top = tokens[tokens.length - 1];\n            if (!top || top.type !== 'plain_text') {\n                tokens.push({ type: 'plain_text', content: '' });\n                top = tokens[tokens.length - 1];\n            }\n            top.content += text[i];\n            i++;\n        }\n    }\n    return [tokens, i];\n}\n\nexport { MAX_TEXT_LENGTH as M, TEMPORARY_CHANNEL_PREFIX as T, getChatGroups as a, getUnreadChatCounts as b, getParticipantUserId as c, alphabeticalSorter as d, getDMComparator as e, parseRichText as f, generateChatGroupKey as g, handleFilesDataTransfer as h, isDirectMessageChannel as i, extractReplyBlock as j, replyBlockPattern as k, parseMessageForTarget as p, reverse as r, stripOutReplyBlock as s };\n"],
  "mappings": "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",
  "names": []
}
