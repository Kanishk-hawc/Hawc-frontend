import {
  require_react
} from "./chunk-YMZL3G5R.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-HFNDKYVF.js";

// node_modules/sdp-transform/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/sdp-transform/lib/grammar.js"(exports2, module2) {
    var grammar = module2.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      // TODO: this one can actually be parsed properly...
      r: [{ name: "repeats" }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o) {
            return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o) {
            return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o) {
            return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o) {
            return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o) {
            return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o.tcptype != null ? " tcptype %s" : "%v";
            if (o.generation != null) {
              str += " generation %d";
            }
            str += o["network-id"] != null ? " network-id %d" : "%v";
            str += o["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o) {
            var str = "ssrc:%d";
            if (o.attribute != null) {
              str += " %s";
              if (o.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o) {
            return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o) {
            return o.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o) {
            return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o) {
            return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o) {
            return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o) {
            var str = "mediaclk:";
            str += o.id != null ? "id=%s %s" : "%v%s";
            str += o.mediaClockValue != null ? "=%s" : "";
            str += o.rateNumerator != null ? " rate=%s" : "";
            str += o.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar).forEach(function(key) {
      var objs = grammar[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
  }
});

// node_modules/sdp-transform/lib/parser.js
var require_parser = __commonJS({
  "node_modules/sdp-transform/lib/parser.js"(exports2) {
    var toIntIfInt = function(v) {
      return String(Number(v)) === v ? Number(v) : v;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i = 0; i < names.length; i += 1) {
          if (match[i + 1] != null) {
            location[names[i]] = toIntIfInt(match[i + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar = require_grammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports2.parse = function(sdp) {
      var session = {}, media = [], location = session;
      sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location = media[media.length - 1];
        }
        for (var j2 = 0; j2 < (grammar[type] || []).length; j2 += 1) {
          var obj = grammar[type][j2];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s = expr.split(/=(.+)/, 2);
      if (s.length === 2) {
        acc[s[0]] = toIntIfInt(s[1]);
      } else if (s.length === 1 && expr.length > 1) {
        acc[s[0]] = void 0;
      }
      return acc;
    };
    exports2.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports2.parseFmtpConfig = exports2.parseParams;
    exports2.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports2.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i = 0; i < parts.length; i += 3) {
        candidates.push({
          component: parts[i],
          ip: parts[i + 1],
          port: parts[i + 2]
        });
      }
      return candidates;
    };
    exports2.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports2.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  }
});

// node_modules/sdp-transform/lib/writer.js
var require_writer = __commonJS({
  "node_modules/sdp-transform/lib/writer.js"(exports2, module2) {
    var grammar = require_grammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x2) {
        if (i >= len) {
          return x2;
        }
        var arg = args[i];
        i += 1;
        switch (x2) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i = 0; i < obj.names.length; i += 1) {
          var n = obj.names[i];
          if (obj.name) {
            args.push(location[obj.name][n]);
          } else {
            args.push(location[obj.names[i]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = [
      "v",
      "o",
      "s",
      "i",
      "u",
      "e",
      "p",
      "c",
      "b",
      "t",
      "r",
      "z",
      "a"
    ];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    module2.exports = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp = [];
      outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el2) {
              sdp.push(makeLine(type, obj, el2));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el2) {
                sdp.push(makeLine(type, obj, el2));
              });
            }
          });
        });
      });
      return sdp.join("\r\n") + "\r\n";
    };
  }
});

// node_modules/sdp-transform/lib/index.js
var require_lib = __commonJS({
  "node_modules/sdp-transform/lib/index.js"(exports2) {
    var parser = require_parser();
    var writer = require_writer();
    var grammar = require_grammar();
    exports2.grammar = grammar;
    exports2.write = writer;
    exports2.parse = parser.parse;
    exports2.parseParams = parser.parseParams;
    exports2.parseFmtpConfig = parser.parseFmtpConfig;
    exports2.parsePayloads = parser.parsePayloads;
    exports2.parseRemoteCandidates = parser.parseRemoteCandidates;
    exports2.parseImageAttributes = parser.parseImageAttributes;
    exports2.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  }
});

// node_modules/@dytesdk/react-web-core/dist/index.es.js
var import_react = __toESM(require_react());

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x2 = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x2.length; i += 16) {
    var olda = a2;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a2 = md5ff(a2, b, c, d, x2[i], 7, -680876936);
    d = md5ff(d, a2, b, c, x2[i + 1], 12, -389564586);
    c = md5ff(c, d, a2, b, x2[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a2, x2[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b, c, d, x2[i + 4], 7, -176418897);
    d = md5ff(d, a2, b, c, x2[i + 5], 12, 1200080426);
    c = md5ff(c, d, a2, b, x2[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a2, x2[i + 7], 22, -45705983);
    a2 = md5ff(a2, b, c, d, x2[i + 8], 7, 1770035416);
    d = md5ff(d, a2, b, c, x2[i + 9], 12, -1958414417);
    c = md5ff(c, d, a2, b, x2[i + 10], 17, -42063);
    b = md5ff(b, c, d, a2, x2[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b, c, d, x2[i + 12], 7, 1804603682);
    d = md5ff(d, a2, b, c, x2[i + 13], 12, -40341101);
    c = md5ff(c, d, a2, b, x2[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a2, x2[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b, c, d, x2[i + 1], 5, -165796510);
    d = md5gg(d, a2, b, c, x2[i + 6], 9, -1069501632);
    c = md5gg(c, d, a2, b, x2[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a2, x2[i], 20, -373897302);
    a2 = md5gg(a2, b, c, d, x2[i + 5], 5, -701558691);
    d = md5gg(d, a2, b, c, x2[i + 10], 9, 38016083);
    c = md5gg(c, d, a2, b, x2[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a2, x2[i + 4], 20, -405537848);
    a2 = md5gg(a2, b, c, d, x2[i + 9], 5, 568446438);
    d = md5gg(d, a2, b, c, x2[i + 14], 9, -1019803690);
    c = md5gg(c, d, a2, b, x2[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a2, x2[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b, c, d, x2[i + 13], 5, -1444681467);
    d = md5gg(d, a2, b, c, x2[i + 2], 9, -51403784);
    c = md5gg(c, d, a2, b, x2[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a2, x2[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b, c, d, x2[i + 5], 4, -378558);
    d = md5hh(d, a2, b, c, x2[i + 8], 11, -2022574463);
    c = md5hh(c, d, a2, b, x2[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a2, x2[i + 14], 23, -35309556);
    a2 = md5hh(a2, b, c, d, x2[i + 1], 4, -1530992060);
    d = md5hh(d, a2, b, c, x2[i + 4], 11, 1272893353);
    c = md5hh(c, d, a2, b, x2[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a2, x2[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b, c, d, x2[i + 13], 4, 681279174);
    d = md5hh(d, a2, b, c, x2[i], 11, -358537222);
    c = md5hh(c, d, a2, b, x2[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a2, x2[i + 6], 23, 76029189);
    a2 = md5hh(a2, b, c, d, x2[i + 9], 4, -640364487);
    d = md5hh(d, a2, b, c, x2[i + 12], 11, -421815835);
    c = md5hh(c, d, a2, b, x2[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a2, x2[i + 2], 23, -995338651);
    a2 = md5ii(a2, b, c, d, x2[i], 6, -198630844);
    d = md5ii(d, a2, b, c, x2[i + 7], 10, 1126891415);
    c = md5ii(c, d, a2, b, x2[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a2, x2[i + 5], 21, -57434055);
    a2 = md5ii(a2, b, c, d, x2[i + 12], 6, 1700485571);
    d = md5ii(d, a2, b, c, x2[i + 3], 10, -1894986606);
    c = md5ii(c, d, a2, b, x2[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a2, x2[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b, c, d, x2[i + 8], 6, 1873313359);
    d = md5ii(d, a2, b, c, x2[i + 15], 10, -30611744);
    c = md5ii(c, d, a2, b, x2[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a2, x2[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b, c, d, x2[i + 4], 6, -145523070);
    d = md5ii(d, a2, b, c, x2[i + 11], 10, -1120210379);
    c = md5ii(c, d, a2, b, x2[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a2, x2[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a2, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x2, y) {
  var lsw = (x2 & 65535) + (y & 65535);
  var msw = (x2 >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b, x2, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t)), s), b);
}
function md5ff(a2, b, c, d, x2, s, t) {
  return md5cmn(b & c | ~b & d, a2, b, x2, s, t);
}
function md5gg(a2, b, c, d, x2, s, t) {
  return md5cmn(b & d | c & ~d, a2, b, x2, s, t);
}
function md5hh(a2, b, c, d, x2, s, t) {
  return md5cmn(b ^ c ^ d, a2, b, x2, s, t);
}
function md5ii(a2, b, c, d, x2, s, t) {
  return md5cmn(c ^ (b | ~d), a2, b, x2, s, t);
}
var md5_default = md5;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x2, y, z2) {
  switch (s) {
    case 0:
      return x2 & y ^ ~x2 & z2;
    case 1:
      return x2 ^ y ^ z2;
    case 2:
      return x2 & y ^ x2 & z2 ^ y & z2;
    case 3:
      return x2 ^ y ^ z2;
  }
}
function ROTL(x2, n) {
  return x2 << n | x2 >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M2 = new Array(N);
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i2 * 64 + j2 * 4] << 24 | bytes[_i2 * 64 + j2 * 4 + 1] << 16 | bytes[_i2 * 64 + j2 * 4 + 2] << 8 | bytes[_i2 * 64 + j2 * 4 + 3];
    }
    M2[_i2] = arr;
  }
  M2[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N - 1][14] = Math.floor(M2[N - 1][14]);
  M2[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N; ++_i22) {
    var W2 = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W2[t] = M2[_i22][t];
    }
    for (var _t2 = 16; _t2 < 80; ++_t2) {
      W2[_t2] = ROTL(W2[_t2 - 3] ^ W2[_t2 - 8] ^ W2[_t2 - 14] ^ W2[_t2 - 16], 1);
    }
    var a2 = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s = Math.floor(_t22 / 20);
      var T = ROTL(a2, 5) + f(s, b, c, d) + e + K[s] + W2[_t22] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@dytesdk/web-core/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/bowser/src/constants.js
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  "Pale Moon": "pale_moon",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  pale_moon: "Pale Moon",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv",
  bot: "bot"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/bowser/src/utils.js
var Utils = class _Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] !== 10) return void 0;
    switch (v[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v = version.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] === 1 && v[1] < 5) return void 0;
    if (v[0] === 1 && v[1] < 6) return "Cupcake";
    if (v[0] === 1 && v[1] >= 6) return "Donut";
    if (v[0] === 2 && v[1] < 2) return "Eclair";
    if (v[0] === 2 && v[1] === 2) return "Froyo";
    if (v[0] === 2 && v[1] > 2) return "Gingerbread";
    if (v[0] === 3) return "Honeycomb";
    if (v[0] === 4 && v[1] < 1) return "Ice Cream Sandwich";
    if (v[0] === 4 && v[1] < 4) return "Jelly Bean";
    if (v[0] === 4 && v[1] >= 4) return "KitKat";
    if (v[0] === 5) return "Lollipop";
    if (v[0] === 6) return "Marshmallow";
    if (v[0] === 7) return "Nougat";
    if (v[0] === 8) return "Oreo";
    if (v[0] === 9) return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = _Utils.getVersionPrecision(versionA);
    const versionBPrecision = _Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = _Utils.map([versionA, versionB], (version) => {
      const delta = precision - _Utils.getVersionPrecision(version);
      const _version = version + new Array(delta + 1).join(".0");
      return _Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator(arr[i]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i;
    let l;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l = arr.length; i < l; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l = assigners.length; i < l; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get browser name for a short version/alias
   *
   * @example
   *   getBrowserTypeByAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/PaleMoon/i],
    describe(ua) {
      const browser = {
        name: "Pale Moon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/bowser/src/parser-os.js
var parser_os_default = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version) {
        result.version = version;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version);
      const os2 = {
        name: OS_MAP.MacOS,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version);
      const os2 = {
        name: OS_MAP.Android,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os2 = {
        name: OS_MAP.WebOS
      };
      if (version && version.length) {
        os2.version = version;
      }
      return os2;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
];

// node_modules/bowser/src/parser-platforms.js
var parser_platforms_default = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: PLATFORMS_MAP.bot,
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Nokia */
  {
    test: [/Nokia/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, ua);
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nokia"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/bowser/src/parser-engines.js
var parser_engines_default = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  }
];

// node_modules/bowser/src/parser.js
var Parser = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA2, skipParsing = false) {
    if (UA2 === void 0 || UA2 === null || UA2 === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA2;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (Array.isArray(_browser.test)) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os2 = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (Array.isArray(_os.test)) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os2) {
      this.parsedResult.os = os2.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (Array.isArray(_platform.test)) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (Array.isArray(_engine.test)) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param {string} browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0];
    let comparableVersion = version;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version[0] === ">" || version[0] === "<") {
      comparableVersion = version.substr(1);
      if (version[1] === "=") {
        isLoose = true;
        comparableVersion = version.substr(2);
      } else {
        expectedResults = [];
      }
      if (version[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version[0] === "=") {
      comparableVersion = version.substr(1);
    } else if (version[0] === "~") {
      isLoose = true;
      comparableVersion = version.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  /**
   * Check if the OS name equals the passed string
   * @param {string} osName The string to compare with the OS name
   * @returns {boolean}
   */
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  /**
   * Check if the platform type equals the passed string
   * @param {string} platformType The string to compare with the platform type
   * @returns {boolean}
   */
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  /**
   * Check if the engine name equals the passed string
   * @param {string} engineName The string to compare with the engine name
   * @returns {boolean}
   */
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/bowser/src/bowser.js
var Bowser = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA2, skipParsing = false) {
    if (typeof UA2 !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA2, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA2) {
    return new parser_default(UA2).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
function typeofJsonValue(value) {
  let t = typeof value;
  if (t == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es2 = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es2 -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es2 -= 1;
  let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0; i < base64Str.length; i++) {
    b = decTable[base64Str.charCodeAt(i)];
    if (b === void 0) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p = 0;
  for (let i = 0; i < bytes.length; i++) {
    b = bytes[i];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p | b >> 4];
        p = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is2(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is2(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf2) => uf2.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is2 = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi2, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi2 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi2 & 7) << 4;
  const hasMoreBits = !(hi2 >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi2 >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi2 >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv2 = new DataView(new ArrayBuffer(8));
  const ok2 = globalThis.BigInt !== void 0 && typeof dv2.getBigInt64 === "function" && typeof dv2.getBigUint64 === "function" && typeof dv2.setBigInt64 === "function" && typeof dv2.setBigUint64 === "function";
  BI = ok2 ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv2
  } : void 0;
}
detectBi();
function assertBi(bi2) {
  if (!bi2)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi2) {
    this.lo = lo | 0;
    this.hi = hi2 | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi2] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi2);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi2] = int64fromString(value);
          if (minus) {
            if (hi2 > HALF_2_PWR_32 || hi2 == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi2 >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi2);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi2 = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi2 += 1;
    return new _PbLong(lo, hi2);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n = this.negate();
      return "-" + int64toString(n.lo, n.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t;
        while ((t = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi2] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi2 & 1) << 31) ^ s;
    hi2 = hi2 >>> 1 ^ s;
    return new PbLong(lo, hi2);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi2] = this.varint64();
    return lo !== 0 || hi2 !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi2 = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi2, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb2 = [];
  for (let i = 0; i < snakeCase.length; i++) {
    let next = snakeCase.charAt(i);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb2.push(next);
      capNext = true;
    } else if (capNext) {
      sb2.push(next.toUpperCase());
      capNext = false;
    } else if (i == 0) {
      sb2.push(next.toLowerCase());
    } else {
      sb2.push(next);
    }
  }
  return sb2.join("");
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a2, _b2, _c2, _d2;
  field.localName = (_a2 = field.localName) !== null && _a2 !== void 0 ? _a2 : lowerCamelCase(field.name);
  field.jsonName = (_b2 = field.jsonName) !== null && _b2 !== void 0 ? _b2 : lowerCamelCase(field.name);
  field.repeat = (_c2 = field.repeat) !== null && _c2 !== void 0 ? _c2 : RepeatType.NO;
  field.opt = (_d2 = field.opt) !== null && _d2 !== void 0 ? _d2 : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k2) => !data.known.includes(k2)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name of data.oneofs) {
      const group = message[name];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f2) => f2.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.isAssignable(arg[i], depth - 1))
          return false;
    } else {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!type.is(arg[i], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i = 0; i < arg.length && i < depth; i++)
        if (!this.scalar(arg[i], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map, type, depth) {
    let keys = Object.keys(map);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k2) => parseInt(k2)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            if (jsonValue === null)
              continue;
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue === null)
              continue;
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e;
    try {
      switch (type) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        // bool:
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        // string:
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e2) {
            e2 = "invalid UTF8";
            break;
          }
          return json;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error) {
      e = error.message;
    }
    this.assert(false, fieldName + (e ? " - " + e : ""), json);
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var ReflectionJsonWriter = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            const val = this.scalar(field.T, value[i], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i = 0; i < value.length; i++) {
            assert(value[i] === void 0 || typeof value[i] == "number");
            const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i = 0; i < value.length; i++) {
            const val = this.message(messageType, value[i], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed2 = emitDefaultValues || optional;
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assertUInt32(value);
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed2 ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        if (value === "")
          return ed2 ? "" : void 0;
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        if (value === false)
          return ed2 ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed2)
          return void 0;
        return ulong.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed2)
          return void 0;
        return long.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed2 ? "" : void 0;
        return base64encode(value);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u2 = options.readUnknownField;
        if (u2 == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L2 = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e = reader.uint32() + reader.pos;
              while (reader.pos < e)
                arr.push(this.scalar(reader, T, L2));
            } else
              arr.push(this.scalar(reader, T, L2));
          } else
            target[localName] = this.scalar(reader, T, L2);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var ReflectionBinaryWriter = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a2, b) => a2.no - b.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i = 0; i < value.length; i++)
      writer[method](value[i]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t = WireType.Varint;
    let m2;
    let i = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m2 = "int32";
        break;
      case ScalarType.STRING:
        d = i || !value.length;
        t = WireType.LengthDelimited;
        m2 = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m2 = "bool";
        break;
      case ScalarType.UINT32:
        m2 = "uint32";
        break;
      case ScalarType.DOUBLE:
        t = WireType.Bit64;
        m2 = "double";
        break;
      case ScalarType.FLOAT:
        t = WireType.Bit32;
        m2 = "float";
        break;
      case ScalarType.INT64:
        d = i || PbLong.from(value).isZero();
        m2 = "int64";
        break;
      case ScalarType.UINT64:
        d = i || PbULong.from(value).isZero();
        m2 = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i || PbULong.from(value).isZero();
        t = WireType.Bit64;
        m2 = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i || !value.byteLength;
        t = WireType.LengthDelimited;
        m2 = "bytes";
        break;
      case ScalarType.FIXED32:
        t = WireType.Bit32;
        m2 = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t = WireType.Bit32;
        m2 = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i || PbLong.from(value).isZero();
        t = WireType.Bit64;
        m2 = "sfixed64";
        break;
      case ScalarType.SINT32:
        m2 = "sint32";
        break;
      case ScalarType.SINT64:
        d = i || PbLong.from(value).isZero();
        m2 = "sint64";
        break;
    }
    return [t, m2, i || d];
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name] = 0;
          break;
        case "map":
          msg[name] = {};
          break;
      }
  }
  return msg;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name];
        continue;
      }
    } else {
      fieldValue = input[name];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = fieldValue[i];
        else
          output[name] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i = 0; i < fieldValue.length; i++)
            output[name][i] = T.create(fieldValue[i]);
        else if (output[name] === void 0)
          output[name] = T.create(fieldValue);
        else
          T.mergePartial(output[name], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k2 of Object.keys(fieldValue))
              output[name][k2] = T2.create(fieldValue[k2]);
            break;
        }
        break;
    }
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
function reflectionEquals(info, a2, b) {
  if (a2 === b)
    return true;
  if (!a2 || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type, a2, b) {
  if (a2 === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba2 = a2;
  let bb2 = b;
  if (ba2.length !== bb2.length)
    return false;
  for (let i = 0; i < ba2.length; i++)
    if (ba2[i] != bb2[i])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!primitiveEq(type, a2[i], b[i]))
      return false;
  return true;
}
function repeatedMsgEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!type.equals(a2[i], b[i]))
      return false;
  return true;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
var MessageType = class {
  constructor(name, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    messageTypeDescriptor.value = this;
    this.messagePrototype = Object.create(null, baseDescriptors);
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy = this.create();
    reflectionMergePartial(this, copy, message);
    return copy;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a2, b) {
    return reflectionEquals(this, a2, b);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a2;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};

// node_modules/worker-timers/build/es2019/module.js
var module_exports = {};
__export(module_exports, {
  clearInterval: () => clearInterval2,
  clearTimeout: () => clearTimeout2,
  setInterval: () => setInterval2,
  setTimeout: () => setTimeout2
});

// node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js
var createAddUniqueNumber = (generateUniqueNumber2) => {
  return (set) => {
    const number = generateUniqueNumber2(set);
    set.add(number);
    return number;
  };
};

// node_modules/fast-unique-numbers/build/es2019/factories/cache.js
var createCache = (lastNumberWeakMap) => {
  return (collection, nextNumber) => {
    lastNumberWeakMap.set(collection, nextNumber);
    return nextNumber;
  };
};

// node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
var createGenerateUniqueNumber = (cache2, lastNumberWeakMap) => {
  return (collection) => {
    const lastNumber = lastNumberWeakMap.get(collection);
    let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
    if (!collection.has(nextNumber)) {
      return cache2(collection, nextNumber);
    }
    if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
      while (collection.has(nextNumber)) {
        nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
      }
      return cache2(collection, nextNumber);
    }
    if (collection.size > MAX_SAFE_INTEGER) {
      throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
    }
    while (collection.has(nextNumber)) {
      nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
    }
    return cache2(collection, nextNumber);
  };
};

// node_modules/fast-unique-numbers/build/es2019/module.js
var LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
var cache = createCache(LAST_NUMBER_WEAK_MAP);
var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);

// node_modules/worker-timers-broker/build/es2019/guards/call-notification.js
var isCallNotification = (message) => {
  return message.method !== void 0 && message.method === "call";
};

// node_modules/worker-timers-broker/build/es2019/guards/clear-response.js
var isClearResponse = (message) => {
  return message.error === null && typeof message.id === "number";
};

// node_modules/worker-timers-broker/build/es2019/module.js
var load = (url) => {
  const scheduledIntervalFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const unrespondedRequests = /* @__PURE__ */ new Map();
  const worker2 = new Worker(url);
  worker2.addEventListener("message", ({ data }) => {
    if (isCallNotification(data)) {
      const { params: { timerId, timerType } } = data;
      if (timerType === "interval") {
        const idOrFunc = scheduledIntervalFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      } else if (timerType === "timeout") {
        const idOrFunc = scheduledTimeoutFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
          scheduledTimeoutFunctions.delete(timerId);
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      }
    } else if (isClearResponse(data)) {
      const { id: id2 } = data;
      const timerIdAndTimerType = unrespondedRequests.get(id2);
      if (timerIdAndTimerType === void 0) {
        throw new Error("The timer is in an undefined state.");
      }
      const { timerId, timerType } = timerIdAndTimerType;
      unrespondedRequests.delete(id2);
      if (timerType === "interval") {
        scheduledIntervalFunctions.delete(timerId);
      } else {
        scheduledTimeoutFunctions.delete(timerId);
      }
    } else {
      const { error: { message } } = data;
      throw new Error(message);
    }
  });
  const clearInterval3 = (timerId) => {
    const id2 = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id2, { timerId, timerType: "interval" });
    scheduledIntervalFunctions.set(timerId, id2);
    worker2.postMessage({
      id: id2,
      method: "clear",
      params: { timerId, timerType: "interval" }
    });
  };
  const clearTimeout3 = (timerId) => {
    const id2 = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id2, { timerId, timerType: "timeout" });
    scheduledTimeoutFunctions.set(timerId, id2);
    worker2.postMessage({
      id: id2,
      method: "clear",
      params: { timerId, timerType: "timeout" }
    });
  };
  const setInterval3 = (func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledIntervalFunctions);
    scheduledIntervalFunctions.set(timerId, () => {
      func();
      if (typeof scheduledIntervalFunctions.get(timerId) === "function") {
        worker2.postMessage({
          id: null,
          method: "set",
          params: {
            delay,
            now: performance.now(),
            timerId,
            timerType: "interval"
          }
        });
      }
    });
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "interval"
      }
    });
    return timerId;
  };
  const setTimeout3 = (func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledTimeoutFunctions);
    scheduledTimeoutFunctions.set(timerId, func);
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "timeout"
      }
    });
    return timerId;
  };
  return {
    clearInterval: clearInterval3,
    clearTimeout: clearTimeout3,
    setInterval: setInterval3,
    setTimeout: setTimeout3
  };
};

// node_modules/worker-timers/build/es2019/factories/load-or-return-broker.js
var createLoadOrReturnBroker = (loadBroker, worker2) => {
  let broker = null;
  return () => {
    if (broker !== null) {
      return broker;
    }
    const blob = new Blob([worker2], { type: "application/javascript; charset=utf-8" });
    const url = URL.createObjectURL(blob);
    broker = loadBroker(url);
    setTimeout(() => URL.revokeObjectURL(url));
    return broker;
  };
};

// node_modules/worker-timers/build/es2019/worker/worker.js
var worker = `(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`;

// node_modules/worker-timers/build/es2019/module.js
var loadOrReturnBroker = createLoadOrReturnBroker(load, worker);
var clearInterval2 = (timerId) => loadOrReturnBroker().clearInterval(timerId);
var clearTimeout2 = (timerId) => loadOrReturnBroker().clearTimeout(timerId);
var setInterval2 = (func, delay) => loadOrReturnBroker().setInterval(func, delay);
var setTimeout2 = (func, delay) => loadOrReturnBroker().setTimeout(func, delay);

// node_modules/@dytesdk/web-core/dist/index.es.js
var cs = __toESM(require_lib());
var QS = Object.defineProperty;
var XS = Object.defineProperties;
var ZS = Object.getOwnPropertyDescriptors;
var ed = Object.getOwnPropertySymbols;
var ev = Object.getPrototypeOf;
var Xh = Object.prototype.hasOwnProperty;
var Zh = Object.prototype.propertyIsEnumerable;
var tv = Reflect.get;
var ep = Math.pow;
var iu = (s, t, e) => t in s ? QS(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var D = (s, t) => {
  for (var e in t || (t = {}))
    Xh.call(t, e) && iu(s, e, t[e]);
  if (ed)
    for (var e of ed(t))
      Zh.call(t, e) && iu(s, e, t[e]);
  return s;
};
var B = (s, t) => XS(s, ZS(t));
var ho = (s, t) => {
  var e = {};
  for (var r in s)
    Xh.call(s, r) && t.indexOf(r) < 0 && (e[r] = s[r]);
  if (s != null && ed)
    for (var r of ed(s))
      t.indexOf(r) < 0 && Zh.call(s, r) && (e[r] = s[r]);
  return e;
};
var h = (s, t, e) => (iu(s, typeof t != "symbol" ? t + "" : t, e), e);
var au = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var a = (s, t, e) => (au(s, t, "read from private field"), e ? e.call(s) : t.get(s));
var g = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
};
var m = (s, t, e, r) => (au(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e);
var L = (s, t, e) => (au(s, t, "access private method"), e);
var tp = (s, t, e) => tv(ev(s), e, t);
var u = (s, t, e) => new Promise((r, i) => {
  var n = (d) => {
    try {
      c(e.next(d));
    } catch (l) {
      i(l);
    }
  }, o = (d) => {
    try {
      c(e.throw(d));
    } catch (l) {
      i(l);
    }
  }, c = (d) => d.done ? r(d.value) : Promise.resolve(d.value).then(n, o);
  c((e = e.apply(s, t)).next());
});
function rv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
Array.prototype.at || Object.assign(Array.prototype, { at: rv });
function iv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
String.prototype.at || Object.assign(String.prototype, { at: iv });
var av = (s) => {
  !navigator.isReactNative && typeof window != "undefined" && (window.addEventListener("error", (t) => {
    var e;
    !((e = t.filename) != null && e.includes("localhost")) && t.lineno !== 0 && s.error(
      "window::error",
      {
        error: t.error
      },
      true
    );
  }), window.addEventListener(
    "unhandledrejection",
    (t) => {
      var e, r, i, n, o, c, d, l;
      s.error(
        "window::unhandledrejection",
        {
          error: t == null ? void 0 : t.reason,
          /**
                             * NOTE(ravindra-dyte):
                             * Network calls fail a lot for clients,
                             *	tracking more info to see where
                             *	*/
          networkCall: {
            url: (r = (e = t == null ? void 0 : t.reason) == null ? void 0 : e.config) == null ? void 0 : r.url,
            baseURL: (n = (i = t == null ? void 0 : t.reason) == null ? void 0 : i.config) == null ? void 0 : n.baseURL,
            method: (c = (o = t == null ? void 0 : t.reason) == null ? void 0 : o.config) == null ? void 0 : c.method,
            status: (d = t == null ? void 0 : t.reason) == null ? void 0 : d.status,
            statusText: (l = t == null ? void 0 : t.reason) == null ? void 0 : l.statusText
          }
        },
        true
      );
    }
  ), window.addEventListener("offline", () => {
    s.info("window::offline");
  }), window.addEventListener("online", () => {
    s.info("window::online");
  }));
};
var Vo = "chrome";
var zg = "opera";
var Yg = "firefox";
var Qg = "iexplorer";
var Xg = "safari";
var Zg = "nwjs";
var em = "electron";
var tm = "react-native";
var Sh = "unknown";
var wd = {
  Chrome: Vo,
  Chromium: Vo,
  Opera: zg,
  Firefox: Yg,
  "Internet Explorer": Qg,
  Safari: Xg
};
function nv() {
  const { userAgent: s } = navigator, t = {
    name: Sh,
    version: void 0
  };
  if (s.match(/Chrome/) && !s.match(/Edge/))
    if (s.match(/Edg(A?)/)) {
      const e = s.match(/Chrome\/([\d.]+)/)[1];
      Number.parseInt(e, 10) > 72 && (t.name = Vo, t.version = e);
    } else
      t.name = Vo, t.version = s.match(/Chrome\/([\d.]+)/)[1];
  return t;
}
function ov() {
  const { userAgent: s } = navigator;
  if (s.match(/Electron/)) {
    const t = s.match(/Electron\/([\d.]+)/)[1];
    return {
      name: em,
      version: t
    };
  }
  return null;
}
function cv() {
  const { userAgent: s } = navigator;
  if (s.match(/JitsiMeetNW/)) {
    const t = s.match(/JitsiMeetNW\/([\d.]+)/)[1];
    return {
      name: Zg,
      version: t
    };
  }
}
function dv() {
  const s = navigator.userAgent.match(
    /\b(react[ \t_-]*native)(?:\/(\S+))?/i
  );
  let t;
  if (s || navigator.product === "ReactNative")
    return s && s.length > 2 && (s[1], t = s[2]), t || (t = "unknown"), {
      name: tm,
      version: t
    };
}
function lv(s) {
  let t;
  const e = [dv, ov, cv];
  for (let i = 0; i < e.length; i += 1)
    if (t = e[i](), t)
      return t;
  const r = s.getBrowserName();
  return r in wd ? {
    name: wd[r],
    version: s.getBrowserVersion()
  } : (t = nv(), t || {
    name: Sh,
    version: void 0
  });
}
var uv = class {
  constructor() {
    h(this, "_bowser");
    h(this, "_name");
    h(this, "_version");
    h(this, "getDeviceInfo", () => ({
      isMobile: this.isMobile(),
      browserName: this._bowser.getBrowserName(),
      osName: this._bowser.getOSName(),
      browserVersion: this._bowser.getBrowserVersion(),
      osVersionName: this._bowser.getOSVersion(),
      engineName: this._bowser.getEngineName()
    }));
  }
  /**
   * Creates new BrowserDetection instance.
   *
   * @param {Object} [browserInfo] - Information about the browser.
   * @param {string} browserInfo.name - The name of the browser.
   * @param {string} browserInfo.version - The version of the browser.
   */
  init(t) {
    let e, r;
    if (this._bowser = bowser_default.getParser(navigator.userAgent), typeof t == "undefined") {
      const i = lv(this._bowser);
      e = i.name, r = i.version;
    } else
      t.name in wd ? (e = wd[t.name], r = t.version) : (e = Sh, r = void 0);
    this._name = e, this._version = r;
  }
  /**
   * Gets current browser name.
   * @returns {string}
   */
  getName() {
    return this._name;
  }
  /**
   * Checks if current browser is Chrome.
   * @returns {boolean}
   */
  isChrome() {
    return this._name === Vo;
  }
  /**
   * Checks if current browser is Opera.
   * @returns {boolean}
   */
  isOpera() {
    return this._name === zg;
  }
  /**
   * Checks if current browser is Firefox.
   * @returns {boolean}
   */
  isFirefox() {
    return this._name === Yg;
  }
  /**
   * Checks if current browser is Internet Explorer.
   * @returns {boolean}
   */
  isIExplorer() {
    return this._name === Qg;
  }
  /**
   * Checks if current browser is Safari.
   * @returns {boolean}
   */
  isSafari() {
    return this._name === Xg;
  }
  /**
   * Checks if current environment is NWJS.
   * @returns {boolean}
   */
  isNWJS() {
    return this._name === Zg;
  }
  /**
   * Checks if current environment is Electron.
   * @returns {boolean}
   */
  isElectron() {
    return this._name === em;
  }
  /**
   * Checks if current environment is React Native.
   * @returns {boolean}
   */
  isReactNative() {
    return this._name === tm || navigator.isReactNative === true;
  }
  /**
   * Returns the version of the current browser.
   * @returns {string}
   */
  getVersion() {
    return this._version;
  }
  isMobile() {
    return this._bowser.getPlatformType() === "mobile";
  }
  /**
   * Check if the parsed browser matches the passed condition.
   *
   * @param {Object} checkTree - It's one or two layered object, which can include a
   * platform or an OS on the first layer and should have browsers specs on the
   * bottom layer.
   * Eg. { chrome: '>71.1.0' }
   *		 { windows: { chrome: '<70.2' } }
   * @returns {boolean | undefined} - Returns true if the browser satisfies the set
   * conditions, false if not and undefined when the browser is not defined in the
   * checktree object or when the current browser's version is unknown.
   * @private
   */
  _checkCondition(t) {
    if (this._version)
      return this._bowser.satisfies(t);
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * greater than the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   */
  isVersionGreaterThan(t) {
    return this._checkCondition({ [this._name]: `>${t}` });
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * lower than the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   */
  isVersionLessThan(t) {
    return this._checkCondition({ [this._name]: `<${t}` });
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * equal to the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   * A loose-equality operator is used here so that it matches the sub-versions as well.
   */
  isVersionEqualTo(t) {
    return this._checkCondition({ [this._name]: `~${t}` });
  }
};
var hv = class extends uv {
  /**
   * Tells whether or not the <tt>MediaStream/tt> is removed from
   * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn
   * off the camera device).
   * @return {boolean} <tt>true</tt> if the current browser supports this
   * strategy or <tt>false</tt> otherwise.
   */
  doesVideoMuteByStreamRemove() {
    return this.isChromiumBased() || this.isWebKitBased();
  }
  /**
   * Check whether or not the current browser support peer to peer connections
   * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>
   * otherwise.
   */
  supportsP2P() {
    return !this.usesUnifiedPlan();
  }
  /**
   * Checks if the current browser is Chromium based, that is, it's either
   * Chrome / Chromium or uses it as its engine, but doesn't identify as
   * Chrome.
   *
   * This includes the following browsers:
   * - Chrome and Chromium
   * - Other browsers which use the Chrome engine, but are detected as Chrome,
   *	 such as Brave and Vivaldi
   * - Browsers which are NOT Chrome but use it as their engine, and have
   *	 custom detection code: Opera, Electron and NW.JS
   */
  isChromiumBased() {
    return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera();
  }
  /**
   * Checks if the current browser is WebKit based. It's either
   * Safari or uses WebKit as its engine.
   *
   * This includes Chrome and Firefox on iOS
   *
   * @returns {boolean}
   */
  isWebKitBased() {
    return this._bowser.isEngine("webkit") && typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getUserMedia != "undefined" && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1;
  }
  /**
   * Checks if the current browser is supported.
   *
   * @returns {boolean} true if the browser is supported, false otherwise.
   */
  isSupported() {
    return typeof RTCPeerConnection != "undefined";
  }
  /**
   * Returns whether or not the current environment needs a user interaction
   * with the page before any unmute can occur.
   *
   * @returns {boolean}
   */
  isUserInteractionRequiredForUnmute() {
    return this.isFirefox() && this.isVersionLessThan("68");
  }
  /**
   * Checks if the current browser triggers 'onmute'/'onunmute' events when
   * user's connection is interrupted and the video stops playback.
   * @returns {*|boolean} 'true' if the event is supported or 'false'
   * otherwise.
   */
  supportsVideoMuteOnConnInterrupted() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the current browser reports upload and download bandwidth
   * statistics.
   * @return {boolean}
   */
  supportsBandwidthStatistics() {
    return !this.isFirefox() && !this.isWebKitBased();
  }
  /**
   * Checks if the current browser supports setting codec preferences on the transceiver.
   * @returns {boolean}
   */
  supportsCodecPreferences() {
    return this.usesUnifiedPlan() && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(window.RTCRtpTransceiver.prototype).indexOf(
      "setCodecPreferences"
    ) > -1 && Object.keys(RTCRtpSender.prototype).indexOf("getCapabilities") > -1 && !this.isWebKitBased();
  }
  /**
   * Checks if the current browser support the device change event.
   * @return {boolean}
   */
  // eslint-disable-next-line class-methods-use-this
  supportsDeviceChangeEvent() {
    return navigator.mediaDevices && typeof navigator.mediaDevices.ondevicechange != "undefined" && typeof navigator.mediaDevices.addEventListener != "undefined";
  }
  /**
   * Checks if the current browser supports RTT statistics for srflx local
   * candidates through the legacy getStats() API.
   */
  supportsLocalCandidateRttStatistics() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the current browser supports the Long Tasks API that lets us observe
   * performance measurement events and be notified of tasks that take longer than
   * 50ms to execute on the main thread.
   */
  supportsPerformanceObserver() {
    return typeof window.PerformanceObserver != "undefined" && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1;
  }
  /**
   * Checks if the current browser supports audio level stats on the receivers.
   */
  supportsReceiverStats() {
    return typeof window.RTCRtpReceiver != "undefined" && Object.keys(RTCRtpReceiver.prototype).indexOf(
      "getSynchronizationSources"
    ) > -1;
  }
  /**
   * Checks if the current browser reports round trip time statistics for
   * the ICE candidate pair.
   * @return {boolean}
   */
  supportsRTTStatistics() {
    return !this.isFirefox();
  }
  /**
   * Checks if the browser uses plan B.
   *
   * @returns {boolean}
   */
  usesPlanB() {
    return !this.usesUnifiedPlan();
  }
  /**
   * Checks if the browser uses SDP munging for turning on simulcast.
   *
   * @returns {boolean}
   */
  usesSdpMungingForSimulcast() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the browser uses unified plan.
   *
   * @returns {boolean}
   */
  usesUnifiedPlan() {
    return !!(this.isFirefox() || this.isWebKitBased());
  }
  /**
   * Returns whether or not the current browser should be using the new
   * getUserMedia flow, which utilizes the adapter shim. This method should
   * be temporary and used while migrating all browsers to use adapter and
   * the new getUserMedia.
   *
   * @returns {boolean}
   */
  usesNewGumFlow() {
    return !!(this.isChromiumBased() || this.isFirefox() || this.isWebKitBased());
  }
  /**
   * Checks if the browser uses webrtc-adapter. All browsers using the new
   * getUserMedia flow.
   *
   * @returns {boolean}
   */
  usesAdapter() {
    return this.usesNewGumFlow();
  }
  /**
   * Checks if the browser uses RIDs/MIDs for siganling the simulcast streams
   * to the bridge instead of the ssrcs.
   */
  usesRidsForSimulcast() {
    return false;
  }
  /**
   * Checks if the browser supports getDisplayMedia.
   * @returns {boolean} {@code true} if the browser supports getDisplayMedia.
   */
  supportsGetDisplayMedia() {
    return typeof navigator.getDisplayMedia != "undefined" || typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getDisplayMedia != "undefined";
  }
  /**
   * Checks if the browser supports insertable streams, needed for E2EE.
   * @returns {boolean} {@code true} if the browser supports insertable streams.
   */
  supportsInsertableStreams() {
    if (!(typeof window.RTCRtpSender != "undefined" && (window.RTCRtpSender.prototype.createEncodedStreams || window.RTCRtpSender.prototype.createEncodedVideoStreams)))
      return false;
    const t = new ReadableStream();
    try {
      return window.postMessage(t, "*", [t]), true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Whether the browser supports the RED format for audio.
   */
  supportsAudioRed() {
    return Boolean(
      window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      ) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      )
    );
  }
  /**
   * Checks if the browser supports the "sdpSemantics" configuration option.
   * https://webrtc.org/web-apis/chrome/unified-plan/
   *
   * @returns {boolean}
   */
  supportsSdpSemantics() {
    return this.isChromiumBased();
  }
  /**
   * Returns the version of a Chromium based browser.
   *
   * @returns {Number}
   */
  _getChromiumBasedVersion() {
    if (this.isChromiumBased()) {
      if (this.isNWJS())
        return Number.parseInt(process.versions.chromium, 10);
      const t = navigator.userAgent;
      if (t.match(/Chrome/))
        return Number.parseInt(t.match(/Chrome\/([\d.]+)/)[1], 10);
    }
    return -1;
  }
  isIOSMobile() {
    return this.isMobile && this._bowser.getOSName() === "iOS";
  }
};
var Te = new hv();
var ut = {};
var pv = {
  get exports() {
    return ut;
  },
  set exports(s) {
    ut = s;
  }
};
var La = typeof Reflect == "object" ? Reflect : null;
var sp = La && typeof La.apply == "function" ? La.apply : function(t, e, r) {
  return Function.prototype.apply.call(t, e, r);
};
var hd;
La && typeof La.ownKeys == "function" ? hd = La.ownKeys : Object.getOwnPropertySymbols ? hd = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : hd = function(t) {
  return Object.getOwnPropertyNames(t);
};
function gv(s) {
  console && console.warn && console.warn(s);
}
var sm = Number.isNaN || function(t) {
  return t !== t;
};
function ce() {
  ce.init.call(this);
}
pv.exports = ce;
ut.once = vv;
ce.EventEmitter = ce;
ce.prototype._events = void 0;
ce.prototype._eventsCount = 0;
ce.prototype._maxListeners = void 0;
var rp = 10;
function xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(ce, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return rp;
  },
  set: function(s) {
    if (typeof s != "number" || s < 0 || sm(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    rp = s;
  }
});
ce.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
ce.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || sm(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function rm(s) {
  return s._maxListeners === void 0 ? ce.defaultMaxListeners : s._maxListeners;
}
ce.prototype.getMaxListeners = function() {
  return rm(this);
};
ce.prototype.emit = function(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e.push(arguments[r]);
  var i = t === "error", n = this._events;
  if (n !== void 0)
    i = i && n.error === void 0;
  else if (!i)
    return false;
  if (i) {
    var o;
    if (e.length > 0 && (o = e[0]), o instanceof Error)
      throw o;
    var c = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw c.context = o, c;
  }
  var d = n[t];
  if (d === void 0)
    return false;
  if (typeof d == "function")
    sp(d, this, e);
  else
    for (var l = d.length, p = cm(d, l), r = 0; r < l; ++r)
      sp(p[r], this, e);
  return true;
};
function im(s, t, e, r) {
  var i, n, o;
  if (xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = rm(s), i > 0 && o.length > i && !o.warned) {
    o.warned = true;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, gv(c);
  }
  return s;
}
ce.prototype.addListener = function(t, e) {
  return im(this, t, e, false);
};
ce.prototype.on = ce.prototype.addListener;
ce.prototype.prependListener = function(t, e) {
  return im(this, t, e, true);
};
function mv() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function am(s, t, e) {
  var r = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i = mv.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
ce.prototype.once = function(t, e) {
  return xl(e), this.on(t, am(this, t, e)), this;
};
ce.prototype.prependOnceListener = function(t, e) {
  return xl(e), this.prependListener(t, am(this, t, e)), this;
};
ce.prototype.removeListener = function(t, e) {
  var r, i, n, o, c;
  if (xl(e), i = this._events, i === void 0)
    return this;
  if (r = i[t], r === void 0)
    return this;
  if (r === e || r.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e));
  else if (typeof r != "function") {
    for (n = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === e || r[o].listener === e) {
        c = r[o].listener, n = o;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? r.shift() : fv(r, n), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, c || e);
  }
  return this;
};
ce.prototype.off = ce.prototype.removeListener;
ce.prototype.removeAllListeners = function(t) {
  var e, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var n = Object.keys(r), o;
    for (i = 0; i < n.length; ++i)
      o = n[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = r[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function nm(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? Sv(i) : cm(i, i.length);
}
ce.prototype.listeners = function(t) {
  return nm(this, t, true);
};
ce.prototype.rawListeners = function(t) {
  return nm(this, t, false);
};
ce.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : om.call(s, t);
};
ce.prototype.listenerCount = om;
function om(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
ce.prototype.eventNames = function() {
  return this._eventsCount > 0 ? hd(this._events) : [];
};
function cm(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
function fv(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function Sv(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function vv(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    dm(s, t, n, { once: true }), t !== "error" && yv(s, i, { once: true });
  });
}
function yv(s, t, e) {
  typeof s.on == "function" && dm(s, "error", t, e);
}
function dm(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var z;
(function(s) {
  s[s.MAJOR_EVENT = 0] = "MAJOR_EVENT", s[s.MINOR_EVENT = 1] = "MINOR_EVENT";
})(z || (z = {}));
var O;
(function(s) {
  s.PRECALL_TEST_BEGIN = "precall_begin", s.PRECALL_TEST_COMPLETE = "precall_end", s.CALL_JOIN_BEGIN = "call_join", s.NET_QUALITY_TEST_BEGIN = "net_quality_test_begin", s.NET_QUALITY_TEST_END = "net_quality_test_end", s.WEBSOCKET_CONNECTED = "websocket_connected", s.TRANSPORT_CONNECTED = "transport_connected", s.AUDIO_ON = "audio_on", s.AUDIO_OFF = "audio_off", s.VIDEO_ON = "video_on", s.VIDEO_OFF = "video_off", s.PARTICIPANT_ROLE = "participant_role", s.PING_STAT = "ping_stat", s.DISCONNECT = "disconnect", s.RECONNECT_ATTEMPT = "reconnect_attempt", s.SCREENSHARE_START_REQUESTED = "screenshare_start_requested", s.SCREENSHARE_STARTED = "screenshare_started", s.SCREENSHARE_STOPPED = "screenshare_stopped", s.TAB_CHANGE = "tab_change", s.BROWSER_BACKGROUNDED = "browser_backgrounded", s.BROWSER_FOREGROUNDED = "browser_foregrounded", s.DOMINANT_SPEAKER = "dominant_speaker", s.AUDIO_DEVICES_UPDATES = "audio_devices_updates", s.VIDEO_DEVICES_UPDATES = "video_devices_updates", s.SPEAKER_DEVICES_UPDATES = "speaker_devices_updates", s.SELECTED_MICROHPONE_UPDATE = "selected_microphone_update", s.SELECTED_CAMERA_UPDATE = "selected_camera_update", s.SELECTED_SPEAKER_UPDATE = "selected_speaker_update", s.EXPECTED_VIDEO_RESOLUTION = "expected_video_resolution", s.EXPECTED_SCREENSHARE_RESOLUTION = "expected_screenshare_resolution", s.MEDIA_PERMISSION = "media_permission", s.LEGACY_SWITCH = "legacy_switch", s.AUDIO_PLAY_FAILED = "audio_play_failed", s.VIDEO_PLAY_FAILED = "video_play_failed", s.AUDIO_TRACK_MUTED = "audio_track_muted", s.VIDEO_TRACK_MUTED = "video_track_muted", s.IVS_PLAYER_REBUFFERING = "ivs_player_rebuffering", s.IVS_PLAYER_AUDIO_BLOCKED = "ivs_player_audio_blocked", s.IVS_PLAYER_PLAYBACK_BLOCKED = "ivs_player_playback_blocked", s.IVS_PLAYER_ERROR = "ivs_player_error", s.IVS_PLAYER_RECOVERABLE_ERROR = "ivs_player_recoverable_error", s.IVS_PLAYER_WORKER_ERROR = "ivs_player_worker_error", s.IVS_PLAYER_NETWORK_UNAVAILABLE = "ivs_player_network_unavailable", s.LIVESTREAM_LATENCY = "livestream_latency", s.IVS_PLAYER_ANALYTICS_EVENT = "ivs_player_analytics_event", s.IVS_PLAYER_PLAYBACK_RATE_CHANGED = "ivs_player_playback_rate_changed", s.IVS_PLAYER_QUALITY_CHANGED = "ivs_player_quality_changed", s.IVS_PLAYER_INITIALIZED = "ivs_player_initialized";
})(O || (O = {}));
var Tv = /* @__PURE__ */ new Map([
  [O.PRECALL_TEST_BEGIN, z.MINOR_EVENT],
  [O.PRECALL_TEST_COMPLETE, z.MINOR_EVENT],
  [O.CALL_JOIN_BEGIN, z.MAJOR_EVENT],
  [O.NET_QUALITY_TEST_BEGIN, z.MINOR_EVENT],
  [O.NET_QUALITY_TEST_END, z.MINOR_EVENT],
  [O.WEBSOCKET_CONNECTED, z.MINOR_EVENT],
  [O.TRANSPORT_CONNECTED, z.MAJOR_EVENT],
  [O.AUDIO_ON, z.MINOR_EVENT],
  [O.AUDIO_OFF, z.MINOR_EVENT],
  [O.VIDEO_ON, z.MINOR_EVENT],
  [O.VIDEO_OFF, z.MINOR_EVENT],
  [O.PARTICIPANT_ROLE, z.MINOR_EVENT],
  [O.PING_STAT, z.MAJOR_EVENT],
  [O.DISCONNECT, z.MAJOR_EVENT],
  [O.RECONNECT_ATTEMPT, z.MAJOR_EVENT],
  [O.SCREENSHARE_START_REQUESTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STARTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STOPPED, z.MINOR_EVENT],
  [O.TAB_CHANGE, z.MINOR_EVENT],
  [O.BROWSER_BACKGROUNDED, z.MINOR_EVENT],
  [O.BROWSER_FOREGROUNDED, z.MINOR_EVENT],
  [O.DOMINANT_SPEAKER, z.MINOR_EVENT],
  [O.AUDIO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.VIDEO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SPEAKER_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SELECTED_MICROHPONE_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_CAMERA_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_SPEAKER_UPDATE, z.MINOR_EVENT],
  [O.MEDIA_PERMISSION, z.MINOR_EVENT],
  [O.LEGACY_SWITCH, z.MINOR_EVENT],
  [O.AUDIO_PLAY_FAILED, z.MINOR_EVENT],
  [O.VIDEO_PLAY_FAILED, z.MINOR_EVENT],
  [O.AUDIO_TRACK_MUTED, z.MINOR_EVENT],
  [O.VIDEO_TRACK_MUTED, z.MINOR_EVENT],
  // IVS Player Events
  [O.IVS_PLAYER_REBUFFERING, z.MAJOR_EVENT],
  [O.IVS_PLAYER_AUDIO_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_RECOVERABLE_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_WORKER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_NETWORK_UNAVAILABLE, z.MAJOR_EVENT],
  // We are keeping live latency as major, so that it
  // acts as a ping alternative for livestream viewer
  [O.LIVESTREAM_LATENCY, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ANALYTICS_EVENT, z.MINOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_RATE_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_QUALITY_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_INITIALIZED, z.MINOR_EVENT],
  [O.EXPECTED_VIDEO_RESOLUTION, z.MINOR_EVENT],
  [O.EXPECTED_SCREENSHARE_RESOLUTION, z.MINOR_EVENT]
]);
var Ev = class {
  constructor() {
    h(this, "events");
    this.events = [];
  }
  add(t) {
    this.events.push(t);
  }
  flush() {
    return {
      entries: this.events.splice(0, 25)
    };
  }
};
var _v = class extends ut {
  constructor({ logger: e, peerId: r, apiHostnames: i }) {
    super();
    h(this, "logger");
    h(this, "peerId");
    h(this, "eventStore");
    h(this, "apiEndpoint");
    this.logger = e, this.peerId = r, this.apiEndpoint = `https://${i.daCollector}/api/v1/message`, this.eventStore = new Ev();
  }
  sendEventsChunkToServer(e) {
    return u(this, null, function* () {
      var i;
      const r = {
        payload: e,
        peerId: this.peerId
      };
      try {
        return yield fetch(this.apiEndpoint, {
          method: "POST",
          body: JSON.stringify(r)
        }), true;
      } catch (n) {
        return this.logger.error("callStats::sendEventsChunkToServer::catch", { error: n }), (i = e.entries) == null || i.forEach((o) => {
          this.eventStore.add(o);
        }), false;
      }
    });
  }
  callEvent(e) {
    e.timestamp = /* @__PURE__ */ new Date(), this.eventStore.add(e), this.emit(e.event, e.metaData), Tv.get(e.event) === z.MAJOR_EVENT && this.flush();
  }
  flush() {
    return u(this, null, function* () {
      var r;
      const e = this.eventStore.flush();
      return (r = e == null ? void 0 : e.entries) != null && r.length ? (yield this.sendEventsChunkToServer(e), true) : false;
    });
  }
};
var ip;
(function(s) {
  s.CHROMIUM = "chromum", s.FIREFOX = "firefox", s.SAFARI = "safari";
})(ip || (ip = {}));
var bo = {
  DEVEL: "devel",
  PREPROD: "preprod",
  PROD: "prod"
};
var Jt;
(function(s) {
  s.AUDIO = "AUDIO", s.VIDEO = "VIDEO", s.SPEAKER = "SPEAKER", s.SCREENSHARE = "SCREENSHARE";
})(Jt || (Jt = {}));
var ap;
(function(s) {
  s[s.INIT = 0] = "INIT", s[s.ACCEPTED = 1] = "ACCEPTED", s[s.DENIED = 2] = "DENIED", s[s.SYS_DENIED = 3] = "SYS_DENIED", s[s.FAILED = 4] = "FAILED", s[s.NOTFOUND = 5] = "NOTFOUND", s[s.NOT_APPLICABLE = 6] = "NOT_APPLICABLE";
})(ap || (ap = {}));
function Zr(s) {
  return s ? s.split(".").slice(0, 2).concat(["0", "0"]).join(".") : "";
}
function bd({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
function kd({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
var lm = 240;
var um = 720;
var hm = 8;
var pm = 3;
var Ul = 10;
var $l = 0.02;
var Fl = 0.03;
function fr({ stat: s, weight: t, rangeMin: e, rangeMax: r, rangeRankingDirection: i }) {
  return s == null ? t : e === r ? i === "UP" ? s <= e ? t : 0 : s >= r ? t : 0 : i === "UP" ? (1 - Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e)) * t : i === "DOWN" ? Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e) * t : t;
}
function gm({ isLowQualityVideo: s, isVideoStuck: t, isVideoLagging: e, jitterQuality: r, packetsLostQuality: i }) {
  const n = 0.8 * ((s ? 0.85 : 1) * (e ? 0.7 : 1) * (t ? 0.5 : 1)) + 0.2 * (r * i);
  return Math.round((n + Number.EPSILON) * 100) / 100;
}
function mm({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
function fm({ packetsLost: s, packetsSent: t, jitter: e }) {
  const i = fr({
    stat: mm({
      packetsLost: s,
      packetsSent: t
    }),
    weight: 0.7,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), o = fr({
    stat: e,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return i + o;
}
function Pv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
function Cv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
function Rv({ framesEncoded: s }) {
  return s === 0;
}
function Sm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsSent: r, jitter: i, isScreenShare: n, framesEncoded: o }) {
  const c = fr({
    stat: mm({
      packetsLost: e,
      packetsSent: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = Pv({
    frameWidth: s,
    isScreenShare: n
  }), p = Cv({
    framesPerSecond: t,
    isScreenShare: n
  }), f2 = Rv({
    framesEncoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f2,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
function vm({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
function ym({ concealmentEvents: s, packetsLost: t, packetsReceived: e, jitter: r }) {
  const n = fr({
    stat: s,
    weight: 0.2,
    rangeMin: 0,
    rangeMax: 3,
    rangeRankingDirection: "UP"
  }), o = 0.5, c = fr({
    stat: vm({
      packetsLost: t,
      packetsReceived: e
    }),
    weight: o,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), l = fr({
    stat: r,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return n + c + l;
}
function wv({ framesDecoded: s }) {
  return s === 0;
}
function bv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
function kv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
function Tm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsReceived: r, jitter: i, isScreenShare: n, framesDecoded: o }) {
  const c = fr({
    stat: vm({
      packetsLost: e,
      packetsReceived: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = kv({
    frameWidth: s,
    isScreenShare: n
  }), p = bv({
    framesPerSecond: t,
    isScreenShare: n
  }), f2 = wv({
    framesDecoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f2,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
var Sr = class _Sr {
  constructor(t) {
    h(this, "pc1");
    h(this, "pc2");
    h(this, "constrainVideoBitrateKbps");
    h(this, "constrainOfferToRemoveVideoFec", false);
    h(this, "iceCandidateFilter");
    const e = new RTCPeerConnection(t), r = new RTCPeerConnection(t);
    this.pc1 = e, this.pc2 = r, this.iceCandidateFilter = _Sr.noFilter, this.pc1.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc2)), this.pc2.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc1));
  }
  static parseCandidate(t) {
    const e = "candidate:", r = t.indexOf(e) + e.length, i = t.substr(r).split(" ");
    return {
      type: i[7],
      protocol: i[2],
      address: i[4]
    };
  }
  static isNotHostCandidate(t) {
    return t.type !== "host";
  }
  static isHost(t) {
    return t.type === "host";
  }
  static isRelay(t) {
    return t.type === "relay";
  }
  static isReflexive(t) {
    return t.type === "srflx";
  }
  static noFilter(t) {
    return true;
  }
  onIceCandidate(t, e) {
    if (e.candidate) {
      const r = _Sr.parseCandidate(e.candidate.candidate);
      this.iceCandidateFilter(r) && t.addIceCandidate(e.candidate);
    }
  }
  setIceCandidateFilter(t) {
    this.iceCandidateFilter = t;
  }
  // Constraint max video bitrate by modifying the SDP when creating an answer.
  constrainVideoBitrate(t) {
    this.constrainVideoBitrateKbps = t;
  }
  // Remove video FEC if available on the offer.
  disableVideoFec() {
    this.constrainOfferToRemoveVideoFec = true;
  }
  gotOffer(t) {
    this.constrainOfferToRemoveVideoFec && (t.sdp = t.sdp.replace(/(m=video 1 [^\r]+)(116 117)(\r\n)/g, `$1\r
`), t.sdp = t.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=fmtp:98 apt=116\r\n/g, "")), this.pc1.setLocalDescription(t), this.pc2.setRemoteDescription(t), this.pc2.createAnswer().then(this.gotAnswer.bind(this), this.reportFatal.bind(this));
  }
  gotAnswer(t) {
    this.constrainVideoBitrateKbps && (t.sdp = t.sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r
b=AS:${this.constrainVideoBitrateKbps}\r
`)), this.pc2.setLocalDescription(t), this.pc1.setRemoteDescription(t);
  }
  establishConnection() {
    this.pc1.createOffer().then(this.gotOffer.bind(this), this.reportFatal.bind(this));
  }
  // eslint-disable-next-line class-methods-use-this
  reportFatal(t) {
    console.error("Error:", t);
  }
  getRoundTripTime() {
    return u(this, null, function* () {
      const [t, e] = yield Promise.all([this.pc1.getStats(), this.pc2.getStats()]);
      let r, i;
      if (t.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === true && n.bytesSent > 0 && (r = n);
      }), e.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === true && n.bytesReceived > 0 && (i = n);
      }), r && i)
        try {
          if (r.currentRoundTripTime && i.currentRoundTripTime)
            return {
              rtt: r.currentRoundTripTime,
              backendRTT: i.currentRoundTripTime
            };
          const n = (i.lastPacketReceivedTimestamp - r.lastPacketSentTimestamp) / 1e3;
          return {
            rtt: n,
            backendRTT: n
          };
        } catch (n) {
          return;
        }
    });
  }
  close() {
    this.pc1.close(), this.pc2.close();
  }
};
var Em = class extends ut {
  constructor(e) {
    super();
    h(this, "call");
    h(this, "timeOut");
    this.call = new Sr(e);
  }
  start(e = 1e4) {
    this.call.establishConnection(), this.timeOut = setTimeout(this.testFailed.bind(this), e);
  }
  testComplete(e) {
    clearTimeout(this.timeOut), this.call.close(), this.emit("done", e);
  }
  testFailed(e) {
    this.call.close(), this.emit("failed", e);
  }
};
var Iv = 8;
var Av = 1 / 1e3;
var Mv = class extends Em {
  constructor(e) {
    super(e);
    h(this, "senderChannel");
    h(this, "recieveChannel");
    h(this, "startTime");
    h(this, "lastBitrateMeasureTime");
    h(this, "sentPayloadBytes", 0);
    h(this, "recievedPayloadBytes", 0);
    h(this, "lastReceivedPayloadBytes", 0);
    h(this, "stopSending", false);
    h(this, "testProgress", 0);
    h(this, "samplePacket", "");
    h(this, "finalBitrateSum", 0);
    h(this, "bitRateSampels", 0);
    h(this, "maxNumberOfPacketsToSend", 0);
    h(this, "bytesToKeepBuffered", 0);
    h(this, "testDurationSeconds", 5);
    this.call.setIceCandidateFilter(Sr.isNotHostCandidate), this.senderChannel = this.call.pc1.createDataChannel(null);
    for (let r = 0; r < 1024 * 256; r += 1)
      this.samplePacket += "h";
    this.maxNumberOfPacketsToSend = 1, this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend, this.testDurationSeconds = 4, this.senderChannel.addEventListener("open", this.sendingStep.bind(this)), this.call.pc2.addEventListener("datachannel", this.onRecieverChannel.bind(this));
  }
  sendingStep() {
    const e = /* @__PURE__ */ new Date();
    this.startTime || (this.startTime = e, this.lastBitrateMeasureTime = e);
    for (let i = 0; i !== this.maxNumberOfPacketsToSend && !(this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered); i += 1) {
      this.sentPayloadBytes += this.samplePacket.length;
      try {
        this.senderChannel.send(this.samplePacket);
      } catch (n) {
      }
    }
    const r = e.getTime() - this.startTime.getTime();
    r >= 1e3 * this.testDurationSeconds ? (this.stopSending = true, this.testProgress = 100) : (this.testProgress = r / (10 * this.testDurationSeconds), setTimeout(this.sendingStep.bind(this), 1));
  }
  onMessageRecieved(e) {
    this.recievedPayloadBytes += e.data.length;
    const r = /* @__PURE__ */ new Date(), i = r.getTime() - this.lastBitrateMeasureTime.getTime();
    if (i >= 1e3) {
      const o = (this.recievedPayloadBytes - this.lastReceivedPayloadBytes) * Iv / (i / 1e3);
      this.finalBitrateSum += o, this.bitRateSampels += 1, this.lastReceivedPayloadBytes = this.recievedPayloadBytes, this.lastBitrateMeasureTime = r;
    }
    if (this.stopSending && this.sentPayloadBytes === this.recievedPayloadBytes) {
      const n = this.finalBitrateSum / this.bitRateSampels;
      this.testComplete({
        throughput: Math.round(n * Av)
      });
    }
  }
  testComplete(e) {
    this.call.getRoundTripTime().then(({ rtt: r, backendRTT: i }) => super.testComplete({
      RTT: r,
      backendRTT: i,
      throughput: e.throughput
    }));
  }
  onRecieverChannel(e) {
    this.recieveChannel = e.channel, this.recieveChannel.addEventListener("message", this.onMessageRecieved.bind(this));
  }
};
var vh = class extends Em {
  constructor(e, r = Sr.noFilter) {
    super(e);
    h(this, "ch1");
    h(this, "ch2");
    this.call.setIceCandidateFilter(r);
    const i = this.call.pc1.createDataChannel(null);
    this.ch1 = i, i.addEventListener("open", () => {
      i.send("hello");
    }), i.addEventListener("message", this.onCh1Recieve.bind(this)), this.call.pc2.addEventListener("datachannel", this.dataChannelHandler.bind(this));
  }
  onCh1Recieve(e) {
    e.data !== "world" ? this.hangup("Invalid data transmitted.") : this.testComplete({
      connectivity: true
    });
  }
  onCh2Recieve(e) {
    if (e.data !== "hello")
      this.hangup("Invalid data transmitted.");
    else
      try {
        this.ch2.send("world");
      } catch (r) {
      }
  }
  dataChannelHandler(e) {
    const r = e.channel;
    this.ch2 = r, r.addEventListener("message", this.onCh2Recieve.bind(this));
  }
  hangup(e) {
    this.testFailed(e);
  }
};
var Dv = class extends vh {
  constructor(t) {
    super(t, Sr.isHost);
  }
};
var Ov = class extends vh {
  constructor(t) {
    super(t, Sr.isRelay);
  }
};
var Nv = class extends vh {
  constructor(t) {
    super(t, Sr.isReflexive);
  }
};
var Vv = class {
  constructor() {
    h(this, "ipInformation", null);
  }
  getIPDetails(i) {
    return u(this, arguments, function* ({ peerId: t, apiHostnames: e, logger: r }) {
      var n, o, c;
      if (!this.ipInformation) {
        try {
          const d = `https://${e.location}`, p = yield (yield fetch(d)).json();
          if (((n = p.loc) == null ? void 0 : n.length) > 5)
            return this.ipInformation = p, (o = this.ipInformation) != null && o.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip)), p;
          throw Error("Insufficient data");
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using location service", { error: d });
        }
        try {
          const d = yield fetch(`https://${e.locationLegacy}/?token=3c493932b0624c&peerId=${t}`, {
            method: "POST"
          });
          this.ipInformation = yield d.json(), (c = this.ipInformation) != null && c.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip));
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using legacy location service", { error: d });
        }
      }
      return this.ipInformation;
    });
  }
  resetCache() {
    this.ipInformation = null;
  }
};
var yh = new Vv();
var np = [
  {
    urls: "turn:turn.dyte.in:443?transport=tcp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  },
  {
    urls: "turn:turn.dyte.in:3478?transport=udp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  }
];
function op(s) {
  const [t, e] = s.split(",");
  return {
    coords: {
      latitude: Number(t),
      longitude: Number(e)
    }
  };
}
var _m = class {
  constructor() {
    h(this, "transport");
    h(this, "candidatePair");
    h(this, "outboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "inboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "outboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "inboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "remoteInboundRtp", /* @__PURE__ */ new Map());
    h(this, "producerStreamMap", /* @__PURE__ */ new Map());
    h(this, "consumerStreamMap", /* @__PURE__ */ new Map());
    h(this, "staleProducerStreamMap", false);
    h(this, "staleConsumerStreamMap", false);
  }
};
var Pm = class extends ut {
  constructor() {
    super();
    h(this, "observer");
    h(this, "outboundProducerMap", /* @__PURE__ */ new Map());
    h(this, "inboundConsumerMap", /* @__PURE__ */ new Map());
    h(this, "consumerPeerIdMap", /* @__PURE__ */ new Map());
    h(this, "pausedConsumerMap", /* @__PURE__ */ new Map());
    h(this, "pausedProducerMap", /* @__PURE__ */ new Map());
    h(this, "overallProducingTransportsStatsMap", {});
    h(this, "overallConsumingTransportsStatsMap", {});
    h(this, "overallConsumersStatsMap", {});
    h(this, "overallProducersStatsMap", {});
    h(this, "videoProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "videoConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "consumerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "consumerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "freezedProducingTransportIds", /* @__PURE__ */ new Set());
    h(this, "freezedConsumingTransportIds", /* @__PURE__ */ new Set());
    h(this, "screenShareProducers", /* @__PURE__ */ new Set());
    h(this, "screenShareConsumers", /* @__PURE__ */ new Set());
    h(this, "ipDetails");
    h(this, "callStatsInstance");
    this.observer = new ut();
  }
  registerProducer(e) {
    return u(this, null, function* () {
      yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
    });
  }
  pauseProducer(e) {
    this.pausedProducerMap.set(e, {
      lastReportCalculated: false
    });
  }
  resumeProducer(e) {
    this.pausedProducerMap.delete(e);
  }
  processInboundConsumerVideoStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalVideoPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "pause", e))) : (r.totalVideoPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedVideo.has(e) && (this.consumerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "resume", e))));
  }
  processInboundConsumerAudioStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalAudioPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "pause", e))) : (r.totalAudioPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedAudio.has(e) && (this.consumerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "resume", e))));
  }
  processOutboundProducerVideoStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalVideoPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "pause", e))) : (r.totalVideoPacketsSent = i.packetsSent, this.producerIdsWithFreezedVideo.has(e) && (this.producerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "resume", e))));
  }
  processOutboundProducerAudioStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalAudioPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "pause", e))) : (r.totalAudioPacketsSent = i.packetsSent, this.producerIdsWithFreezedAudio.has(e) && (this.producerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "resume", e))));
  }
  processProducingTransportStats(e, r, i) {
    var p;
    const n = ((p = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : p.currentUserMediaStates) || {}, { audio: o, video: c, screen: d } = n, l = o || c || d;
    r.totalPacketsSent === i.packetsSent ? (this.freezedProducingTransportIds.add(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "pause", e))) : (r.totalPacketsSent = i.packetsSent, this.freezedProducingTransportIds.has(e) && (this.freezedProducingTransportIds.delete(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "resume", e))));
  }
  processConsumingTransportStats(e, r, i) {
    var c, d;
    const o = !!Array.from(((d = (c = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : c.consumerSharedMediaStatesMap) == null ? void 0 : d.values()) || []).reduce((l, p) => l || p.audio || p.video || p.screen, false);
    r.totalPacketsReceived === i.packetsSent ? (this.freezedConsumingTransportIds.add(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "pause", e))) : (r.totalPacketsReceived = i.packetsSent, this.freezedConsumingTransportIds.has(e) && (this.freezedConsumingTransportIds.delete(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "resume", e))));
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
    });
  }
  pauseConsumer(e) {
    this.pausedConsumerMap.set(e, {
      lastReportCalculated: false
    });
  }
  resumeConsumer(e) {
    this.pausedConsumerMap.delete(e);
  }
  generateProducerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getProducerStatsFromReport(this.parseRTCReport(i, ["outbound-rtp", "remote-inbound-rtp"], false, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "outbound-rtp": {
            this.outboundProducerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  generateConsumerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getConsumerStatsFromReport(this.parseRTCReport(i, ["inbound-rtp"], false, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  deregisterProducer(e) {
    this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  // eslint-disable-next-line class-methods-use-this
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  // eslint-disable-next-line class-methods-use-this
  getWorkingSimulcastVideoStats(e) {
    return e.find((i) => {
      const n = i.framesEncoded > 0, o = i.packetsSent > 0, c = i.frameWidth && i.frameHeight;
      return n && o && !!c;
    }) || e[e.length - 1];
  }
  parseRTCReport(e, r = [], i = false, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f2 = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f2.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === true || I.selected === true) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            // @ts-ignore
            dtlsState: y.dtlsState,
            // @ts-ignore
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: true
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = true;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped,
                framesPerSecond: b.framesPerSecond,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                // temp sending target bitrate in total encode time
                // to avoid the delay with making the backend changes
                totalEncodeTime: b.targetBitrate,
                totalPacketSendDelay: b.totalPacketSendDelay,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: true
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = true;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped,
                framesPerSecond: V.framesPerSecond,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f2.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      // candidateStats: result.candidatePair,
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateProducerStreamMap(i, true));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  getConsumersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateConsumerStreamMap(i, true));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getTransportReport(e) {
    return u(this, null, function* () {
      return e.getStats();
    });
  }
  getProcessedStats(e, r, i) {
    return u(this, null, function* () {
      const n = yield this.getTransportReport(e), o = { producing: i, consuming: r, id: e.id }, c = n, d = this.parseRTCReport(c, ["transport", "candidate-pair", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "local-candidate", "remote-candidate"], false, void 0, o);
      if (!d)
        return;
      const l = {
        stats: d.transport,
        transportId: e.id,
        consuming: r,
        producing: i
      }, p = d.staleProducerStreamMap ? void 0 : this.getProducerStatsFromReport(d), f2 = d.staleConsumerStreamMap ? void 0 : this.getConsumerStatsFromReport(d);
      return {
        transportReport: l,
        producerReport: p,
        consumerReport: f2
      };
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        var o, c;
        r.push({
          producerId: n,
          videoStats: i.outboundVideoRtpId.map((d) => e.outboundVideoRtp.get(d)),
          audioStats: i.outboundAudioRtpId.map((d) => e.outboundAudioRtp.get(d)),
          appData: ((c = (o = this.callStatsInstance.producers) == null ? void 0 : o.get(n)) == null ? void 0 : c.appData) || null
        });
      });
    } catch (i) {
      this.callStatsInstance.logger.error("callStats::measurements::getProducerStatsFromReport", {
        error: { reason: i.reason, message: i.message }
      });
    }
    return r;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(n);
        r.push({
          consumerId: n,
          peerId: o,
          producerId: c,
          appData: d,
          videoStats: i.inboundVideoRtpId.map((l) => e.inboundVideoRtp.get(l)),
          audioStats: i.inboundAudioRtpId.map((l) => e.inboundAudioRtp.get(l))
        });
      });
    } catch (i) {
      console.error("getConsumersReport: ", i, e);
    }
    return r;
  }
  // eslint-disable-next-line class-methods-use-this
  getUserLocation() {
    return u(this, null, function* () {
      return new Promise((e, r) => {
        try {
          navigator.geolocation ? navigator.geolocation.getCurrentPosition((i) => {
            e(i);
          }) : r();
        } catch (i) {
          r(i);
        }
      });
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getConnectivity(e) {
    return u(this, null, function* () {
      try {
        const r = {
          iceServers: e || np
        }, i = new Promise((p, f2) => {
          try {
            const S = new Dv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f2(S);
          }
        }), n = new Promise((p, f2) => {
          try {
            const S = new Ov(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f2(S);
          }
        }), o = new Promise((p, f2) => {
          try {
            const S = new Nv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: false });
            }), S.start(2e3);
          } catch (S) {
            f2(S);
          }
        }), [c, d, l] = yield Promise.all([i, n, o]);
        return {
          host: c == null ? void 0 : c.connectivity,
          relay: d == null ? void 0 : d.connectivity,
          reflexive: l == null ? void 0 : l.connectivity
        };
      } catch (r) {
        return {
          host: false,
          relay: false,
          reflexive: false
        };
      }
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getThroughput(e) {
    return u(this, null, function* () {
      try {
        const i = yield new Promise((n, o) => {
          try {
            const c = {
              iceServers: e || np
            }, d = new Mv(c);
            d.addListener("done", n), d.addListener("failed", o), d.start(1e4);
          } catch (c) {
            o(c);
          }
        });
        return {
          throughput: i.throughput,
          fractionalLoss: 0,
          RTT: i.RTT,
          jitter: 0,
          backendRTT: i.backendRTT
        };
      } catch (r) {
        return;
      }
    });
  }
  getIPDetails() {
    return u(this, null, function* () {
      var e, r;
      try {
        return this.ipDetails || (this.ipDetails = yield yh.getIPDetails({
          peerId: (e = this.callStatsInstance) == null ? void 0 : e.peerId,
          apiHostnames: (r = this.callStatsInstance) == null ? void 0 : r.apiHostnames,
          logger: this.callStatsInstance.logger
        })), this.ipDetails;
      } catch (i) {
        return;
      }
    });
  }
  getNetworkQuality(e) {
    return u(this, null, function* () {
      const [r, i] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e)
      ]);
      return {
        connectivity: r,
        throughput: i == null ? void 0 : i.throughput,
        fractionalLoss: i == null ? void 0 : i.fractionalLoss,
        RTT: i == null ? void 0 : i.RTT,
        jitter: i == null ? void 0 : i.jitter,
        backendRTT: i == null ? void 0 : i.backendRTT
      };
    });
  }
  getNetworkInfo(e, r = false) {
    return u(this, null, function* () {
      var c, d;
      if (r) {
        const l = yield this.getIPDetails();
        return {
          ipDetails: l,
          effectiveNetworkType: (c = navigator.connection) == null ? void 0 : c.effectiveType,
          location: l != null && l.loc ? op(l == null ? void 0 : l.loc) : void 0
          // userLocation,
        };
      }
      const [i, n, o] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e),
        this.getIPDetails()
      ]);
      return {
        ipDetails: o,
        effectiveNetworkType: (d = navigator.connection) == null ? void 0 : d.effectiveType,
        location: o != null && o.loc ? op(o == null ? void 0 : o.loc) : void 0,
        turnConnectivity: i ? i.host || i.relay || i.reflexive : false,
        connectivity: i,
        throughput: n == null ? void 0 : n.throughput,
        fractionalLoss: n == null ? void 0 : n.fractionalLoss,
        RTT: n == null ? void 0 : n.RTT,
        jitter: n == null ? void 0 : n.jitter,
        backendRTT: n == null ? void 0 : n.backendRTT
      };
    });
  }
};
var Lv = class extends Pm {
};
var Cm = class extends Pm {
  constructor() {
    super(...arguments);
    h(this, "producerMap", /* @__PURE__ */ new Map());
    h(this, "consumerMap", /* @__PURE__ */ new Map());
  }
  registerProducer(e) {
    return u(this, null, function* () {
      this.producerMap.set(e.id, e), yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
    });
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      this.consumerMap.set(e.id, e), yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
    });
  }
  generateConsumerStreamMap(e, r = false) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = this.parseRTCReport(i, ["inbound-rtp"], false, e.id), o = [...n.consumerStreamMap.values()][0], c = r ? this.getConsumerStatsFromParsedConsumerStats(n, o, e.id) : void 0;
      for (const d of i.values())
        switch (d.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(d.id, e.id);
            break;
          }
        }
      return c;
    });
  }
  deregisterProducer(e) {
    this.producerMap.delete(e.id), this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.consumerMap.delete(e.id), this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  // eslint-disable-next-line class-methods-use-this
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  parseRTCReport(e, r = [], i = false, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f2 = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f2.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === true || I.selected === true) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            dtlsState: y.dtlsState,
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: true
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = true;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped ? b.framesDropped : b.droppedFrames,
                framesPerSecond: b.framesPerSecond ? b.framesPerSecond : b.framerateMean,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                totalEncodeTime: b.totalEncodeTime,
                totalPacketSendDelay: b.totalEncodeTime,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === true)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: true
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = true;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped ? V.framesDropped : V.droppedFrames,
                framesPerSecond: V.framesPerSecond ? V.framesPerSecond : V.framerateMean,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f2.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.bytesReceived = d.candidatePair.bytesReceived, d.transport.bytesSent = d.candidatePair.bytesSent, d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      // candidateStats: result.candidatePair,
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        const o = this.producerMap.get(n), c = o.track.getSettings(), d = i.outboundVideoRtpId.map((p) => {
          const f2 = e.outboundVideoRtp.get(p);
          return f2.frameHeight || (f2.frameHeight = c.height, f2.frameWidth = c.width, f2.framesPerSecond = c.frameRate), f2;
        }), l = {
          producerId: n,
          appData: o.appData,
          videoStats: d,
          audioStats: i.outboundAudioRtpId.map((p) => e.outboundAudioRtp.get(p))
        };
        r.push(l);
      });
    } catch (i) {
      console.error("getProducersReport: ", i, e);
    }
    return r;
  }
  getConsumerStatsFromParsedConsumerStats(e, r, i) {
    let n;
    try {
      const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(i), l = r == null ? void 0 : r.inboundVideoRtpId.map((p) => {
        const S = this.consumerMap.get(i).track.getSettings(), T = e.inboundVideoRtp.get(p);
        return T.frameHeight || (T.frameHeight = S.height, T.frameWidth = S.width, T.framesPerSecond = S.frameRate), T;
      });
      n = {
        consumerId: i,
        peerId: o,
        producerId: c,
        appData: d,
        videoStats: l,
        audioStats: r == null ? void 0 : r.inboundAudioRtpId.map((p) => e.inboundAudioRtp.get(p))
      };
    } catch (o) {
      console.error("getConsumerStatsFromParsedConsumerStats: ", o, e);
    }
    return n;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        r.push(this.getConsumerStatsFromParsedConsumerStats(e, i, n));
      });
    } catch (i) {
      console.error("getConsumerStatsFromReport: ", i, e);
    }
    return r;
  }
};
var xv = class extends Cm {
};
function Id(s, t, e, r) {
  if (s != null && s.logger && s.logger.error("Callstats::handleError", { error: r }), typeof e == "function" && r instanceof t)
    e.call(null, r, s);
  else
    throw r;
}
function cp(s, t, e) {
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        Id(this, t, e, o);
      }) : n;
    } catch (n) {
      Id(this, t, e, n);
    }
    return null;
  }, s;
}
var Z = (s, t) => (e, r, i) => {
  const n = i.value;
  return i.value = function(...o) {
    try {
      const c = n.apply(this, o);
      return c && c instanceof Promise ? c.catch((d) => {
        Id(this, s, t, d);
      }) : c;
    } catch (c) {
      Id(this, s, t, c);
    }
    return null;
  }, i;
};
var Uv = (s, t) => (e, r, i) => {
  if (i)
    return cp(i, s, t);
  for (const n of Reflect.ownKeys(e.prototype).filter((o) => o !== "constructor")) {
    const o = Object.getOwnPropertyDescriptor(e.prototype, n);
    o.value instanceof Function && Object.defineProperty(e.prototype, n, cp(o, s, t));
  }
};
var Y = globalThis && globalThis.__decorate || function(s, t, e, r) {
  var i = arguments.length, n = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(s, t, e, r);
  else
    for (var c = s.length - 1; c >= 0; c--)
      (o = s[c]) && (n = (i < 3 ? o(n) : i > 3 ? o(t, e, n) : o(t, e)) || n);
  return i > 3 && n && Object.defineProperty(t, e, n), n;
};
var Q = console;
var J = class extends ut {
  constructor(e = "https://api.testingv3.dyte.in", r = "Blink", i = bo.PROD, n, o, c, d) {
    super();
    h(this, "observer");
    h(this, "eventHandler");
    h(this, "measurements");
    h(this, "producingTransport");
    h(this, "consumingTransport");
    h(this, "producers", /* @__PURE__ */ new Map());
    h(this, "consumers", /* @__PURE__ */ new Map());
    h(this, "iceServers");
    h(this, "connectionInfoPromise");
    h(this, "pingStatsTimeout");
    h(this, "logger");
    h(this, "env");
    h(this, "apiHostnames");
    h(this, "peerId");
    h(this, "consumerSharedMediaStatesMap", /* @__PURE__ */ new Map());
    h(this, "currentUserMediaStates", {});
    switch (this.env = i, this.apiHostnames = d, this.logger = o, this.peerId = c, this.eventHandler = new _v({ logger: o, peerId: c, apiHostnames: d }), this.logger.debug("callStats::engineName: ", { engineName: r }), r) {
      case "Blink":
        this.measurements = new Lv();
        break;
      case "Gecko":
        this.measurements = new Cm();
        break;
      case "WebKit":
        this.measurements = new xv();
        break;
      default:
        throw Error(`Unknown engineName! ${r}`);
    }
    this.measurements.callStatsInstance = this, this.registerProducer = this.registerProducer.bind(this), this.registerConsumer = this.registerConsumer.bind(this), this.observer = new ut(), this.measurements.observer.on("consumer_score", (l) => {
      o.debug(`callStats::consumer_score ${[...l.entries()]}`), this.eventHandler.emit("consumer_score", l);
    }), this.measurements.observer.on("producer_score", (l) => {
      o.debug(`callStats::producer_score ${[...l.entries()]}`), this.eventHandler.emit("producer_score", l);
    });
  }
  registerIceServers(e) {
    this.iceServers = e;
  }
  registerConsumer(e) {
    var r;
    this.consumerSharedMediaStatesMap.has(e.id) || this.consumerSharedMediaStatesMap.set(e.id, {}), this.consumers.set(e.id, e), this.measurements.registerConsumer(e), this.logger.debug("callStats::registerConsumer", { consumerId: e.id, consumerkind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterConsumer.bind(this, e));
  }
  registerProducer(e) {
    var r;
    this.producers.set(e.id, e), this.measurements.registerProducer(e), this.logger.debug("callStats::registerProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterProducer.bind(this, e));
  }
  sendConsumerSharedMediaStateEvent(e, r) {
    this.consumerSharedMediaStatesMap.has(e) || this.consumerSharedMediaStatesMap.set(e, {});
    const i = this.consumerSharedMediaStatesMap.get(e);
    this.consumerSharedMediaStatesMap.set(e, Object.assign(i, r));
  }
  registerProducingTransport(e) {
    var i;
    this.producingTransport = e, e.on("close", this.disconnectProducingTransport.bind(this, e)), e.on("disconnect", this.disconnectProducingTransport.bind(this, e)), Array.from(
      // eslint-disable-next-line no-underscore-dangle
      ((i = e._producers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerProducer(n);
    }), e.on("newproducer", this.registerProducer);
  }
  registerConsumingTransport(e) {
    var i;
    this.consumingTransport = e, e.on("close", this.disconnectConsumingTransport.bind(this, e)), e.on("disconnect", this.disconnectConsumingTransport.bind(this, e)), Array.from(
      // eslint-disable-next-line no-underscore-dangle
      ((i = e._consumers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerConsumer(n);
    }), e.on("newconsumer", this.registerConsumer);
  }
  deRegisterConsumer(e) {
    this.consumers.delete(e.id);
  }
  deRegisterProducer(e) {
    var r;
    this.producers.delete(e.id), this.logger.debug("callStats::deRegisterProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) });
  }
  disconnectConsumingTransport() {
    this.consumingTransport = void 0;
  }
  disconnectProducingTransport() {
    this.producingTransport = void 0;
  }
  callEvent(e) {
    this.eventHandler.callEvent(e);
  }
  sendPreCallTestBeginEvent(e = false, r) {
    this.connectionInfoPromise = this.measurements.getNetworkInfo(this.iceServers, e), this.eventHandler.callEvent({
      event: O.PRECALL_TEST_BEGIN,
      timestamp: r
    }), this.connectionInfoPromise && this.connectionInfoPromise.then((i) => {
      this.eventHandler.callEvent({
        event: O.PRECALL_TEST_COMPLETE,
        metaData: {
          connectionInfo: i
        },
        timestamp: r
      });
    });
  }
  sendScreenShareToggleEvent(e, r = null, i) {
    this.currentUserMediaStates.screen = e, this.eventHandler.callEvent({
      event: e ? O.SCREENSHARE_STARTED : O.SCREENSHARE_STOPPED,
      metaData: {
        ssrc: r
      },
      timestamp: i
    });
  }
  sendScreenShareRequestedEvent(e) {
    this.eventHandler.callEvent({
      event: O.SCREENSHARE_START_REQUESTED,
      timestamp: e
    });
  }
  sendActiveSpeakerEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.DOMINANT_SPEAKER,
      metaData: {
        peerId: e
      },
      timestamp: r
    });
  }
  devices(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_DEVICES_UPDATES || e === Jt.VIDEO && O.VIDEO_DEVICES_UPDATES || e === Jt.SPEAKER && O.SPEAKER_DEVICES_UPDATES,
      metaData: {
        deviceList: r
      },
      timestamp: i
    });
  }
  selectedDevice(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.SELECTED_MICROHPONE_UPDATE || e === Jt.VIDEO && O.SELECTED_CAMERA_UPDATE || e === Jt.SPEAKER && O.SELECTED_SPEAKER_UPDATE,
      metaData: {
        device: r
      },
      timestamp: i
    });
  }
  mediaPermission(e, r, i) {
    this.eventHandler.callEvent({
      event: O.MEDIA_PERMISSION,
      metaData: {
        deviceType: e,
        permission: r
      },
      timestamp: i
    });
  }
  mediaPlaybackFailed(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_PLAY_FAILED || e === Jt.VIDEO && O.VIDEO_PLAY_FAILED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  mediaTrackMuted(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_TRACK_MUTED || e === Jt.VIDEO && O.VIDEO_TRACK_MUTED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  tabChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.TAB_CHANGE,
      metaData: { isMeetingsTabActive: e },
      timestamp: r
    });
  }
  browserBackgrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_BACKGROUNDED,
      timestamp: e
    });
  }
  browserForegrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_FOREGROUNDED,
      timestamp: e
    });
  }
  legacySwitch(e, r) {
    this.eventHandler.callEvent({
      event: O.LEGACY_SWITCH,
      metadata: { on: e },
      timestamp: r
    });
  }
  getPreCallTestResults() {
    return u(this, null, function* () {
      return this.connectionInfoPromise;
    });
  }
  sendCallJoinBeginEvent(e, r) {
    e = B(D({}, e), {
      meetingEnv: this.env
    }), e.deviceInfo = B(D({}, e.deviceInfo), {
      userAgent: navigator.userAgent,
      cpus: navigator.hardwareConcurrency,
      memory: navigator.deviceMemory
    }), this.eventHandler.callEvent({
      event: O.CALL_JOIN_BEGIN,
      metaData: {
        peerMetaData: e
      },
      timestamp: r
    });
  }
  sendNetworkQualityTestBeginEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.NET_QUALITY_TEST_BEGIN,
      timestamp: r
    }), new Promise((n, o) => u(this, null, function* () {
      const c = [];
      try {
        for (const d of e)
          try {
            if (d.iceServers && d.iceServers.length > 0) {
              const l = yield this.measurements.getNetworkQuality(d.iceServers);
              c.push(B(D({}, d), {
                networkResults: l
              }));
            }
          } catch (l) {
            console.warn("Error handling ", l);
          }
        n({
          regionData: c
        });
      } catch (d) {
        console.warn("Error in callstats, ", d), o(d);
      }
    })).then((n) => {
      this.eventHandler.callEvent({
        event: O.NET_QUALITY_TEST_END,
        timestamp: r,
        metaData: n
      });
    });
  }
  sendWebSocketConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.WEBSOCKET_CONNECTED,
      timestamp: e
    });
  }
  sendTransportConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.TRANSPORT_CONNECTED,
      timestamp: e
    });
  }
  sendAudioToggleEvent(e, r) {
    this.currentUserMediaStates.audio = e;
    let i;
    e ? i = O.AUDIO_ON : i = O.AUDIO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendVideoToggleEvent(e, r) {
    this.currentUserMediaStates.video = e;
    let i;
    e ? i = O.VIDEO_ON : i = O.VIDEO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendParticipantRoleToggleEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.PARTICIPANT_ROLE,
      timestamp: r,
      metaData: e
    });
  }
  startPingStats(e = 7e3) {
    this.sendPingStatsEvent(false, /* @__PURE__ */ new Date()), this.pingStatsTimeout = setInterval(this.sendPingStatsEvent.bind(this), e);
  }
  stopPingStats() {
    clearInterval(this.pingStatsTimeout);
  }
  sendPingStatsEvent(e = true, r) {
    return u(this, null, function* () {
      let i, n;
      if (this.producingTransport && (i = yield this.measurements.getProcessedStats(this.producingTransport, false, true), !i || !(i != null && i.producerReport))) {
        this.logger.debug("callStats::sendPingStatsEvent::staleProducingTransport", { disclaimer: "Stale producer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getProducersReport([...this.producers.values()]);
        i && c ? i.producerReport = c : (i = yield this.measurements.getProcessedStats(this.producingTransport, false, true), (!i || !(i != null && i.producerReport)) && this.logger.debug("callStats::sendPingStatsEvent::noProducingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      if (this.consumingTransport && (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), !n || !n.consumerReport)) {
        this.logger.debug("callStats::sendPingStatsEvent::staleConsumingTransport", { disclaimer: "Stale consumer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getConsumersReport([...this.consumers.values()]);
        n && c ? n.consumerReport = c : (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), (!n || !n.consumerReport) && this.logger.debug("callStats::sendPingStatsEvent::noConsumingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      const o = {
        producingTransportStats: i ? i == null ? void 0 : i.transportReport : void 0,
        consumingTransportStats: n ? n == null ? void 0 : n.transportReport : void 0,
        producerStats: [].concat((i == null ? void 0 : i.producerReport) || []).concat((n == null ? void 0 : n.producerReport) || []),
        consumerStats: [].concat((n == null ? void 0 : n.consumerReport) || []).concat((i == null ? void 0 : i.consumerReport) || [])
      };
      if (e && o.producerStats.length === 0 && o.consumerStats.length === 0) {
        yield this.eventHandler.flush();
        return;
      }
      this.eventHandler.callEvent({
        event: O.PING_STAT,
        metaData: o,
        timestamp: r
      });
    });
  }
  sendIVSPlayerRebufferEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_REBUFFERING,
      timestamp: e
    });
  }
  sendIVSPlayerAudioBlockEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_AUDIO_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerPlaybackBlockedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerNetworkUnavailableEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_NETWORK_UNAVAILABLE,
      timestamp: e
    });
  }
  sendIVSPlayerInitializedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_INITIALIZED,
      timestamp: e
    });
  }
  sendIVSPlayerWorkerErrorEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_WORKER_ERROR,
      timestamp: e
    });
  }
  sendIVSPlayerErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerRecoverableErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_RECOVERABLE_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerAnalyticsEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ANALYTICS_EVENT,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerPlaybackRateChangedEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_RATE_CHANGED,
      timestamp: r,
      metaData: {
        updatedPlaybackRate: e
      }
    });
  }
  sendIVSPlayerQualityChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_QUALITY_CHANGED,
      timestamp: r,
      metaData: e
    });
  }
  sendPlayerLiveLatency(e, r) {
    this.eventHandler.callEvent({
      event: O.LIVESTREAM_LATENCY,
      timestamp: r,
      metaData: {
        latency: e
      }
    });
  }
  sendDisconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.DISCONNECT,
      timestamp: e
    });
  }
  sendReconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.RECONNECT_ATTEMPT,
      timestamp: e
    });
  }
  expectedVideoResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_VIDEO_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
  expectedScreenshareResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_SCREENSHARE_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
};
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerIceServers", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendConsumerSharedMediaStateEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPreCallTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareRequestedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendActiveSpeakerEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "devices", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "selectedDevice", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPermission", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPlaybackFailed", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaTrackMuted", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "tabChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserBackgrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserForegrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "legacySwitch", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "getPreCallTestResults", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendCallJoinBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendNetworkQualityTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendWebSocketConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendTransportConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendAudioToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendVideoToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendParticipantRoleToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "startPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "stopPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPingStatsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRebufferEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAudioBlockEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackBlockedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerNetworkUnavailableEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerInitializedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerWorkerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRecoverableErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAnalyticsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackRateChangedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerQualityChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPlayerLiveLatency", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendDisconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendReconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedVideoResolution", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedScreenshareResolution", null);
J = Y([
  Uv(TypeError, (s, t) => Q.error(t, s))
], J);
var $v = J;
var Rm = class extends ut {
  constructor() {
    super(...arguments);
    h(this, "stats");
    h(this, "peerId");
    h(this, "backend");
    h(this, "iceServers");
    h(this, "initialized", false);
    h(this, "stalled", false);
    h(this, "ipInformation");
    h(this, "logger");
  }
  initialize(f2) {
    return u(this, arguments, function* ({ peerId: e, engineName: r, env: i = bo.PROD, iceServers: n, apiBase: o = "https://api.cluster.dyte.in", flags: c, logger: d = console, apiHostnames: l, skipConnectivityChecks: p = false }) {
      var S, T, _;
      try {
        this.peerId = e, this.logger = d, this.ipInformation = yield yh.getIPDetails({ peerId: e, apiHostnames: l, logger: d }), this.backend = new $v(o, r, i, c, d, e, l), this.iceServers = n, (S = this.backend) == null || S.registerIceServers(this.iceServers), this.initialized = true, (_ = (T = this.backend) == null ? void 0 : T.eventHandler) == null || _.emit("initialized", this.ipInformation), this.emit("initialized", this.ipInformation), this.startPreCallTest(p);
      } catch (P) {
        this.logger.error("callStats::CallStatsIntegration: ", { error: P }), this.stallCallStats();
      }
    });
  }
  configureSendTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerProducingTransport(e);
    });
  }
  configureRecvTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerConsumingTransport(e);
    });
  }
  candidateRegionalNetworkQualityTest(e) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i;
        try {
          (i = this.backend) == null || i.sendNetworkQualityTestBeginEvent(e, r);
        } catch (n) {
          this.logger.error("callStats::sendNetworkQualityTestBeginEvent", { error: { reason: n.reason } });
        }
      });
    });
  }
  roomJoined(e) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i, n;
        (i = this.backend) == null || i.sendCallJoinBeginEvent(e, r), this.backend, (n = this.backend) == null || n.startPingStats();
      });
    });
  }
  audioOff() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(false, e);
    });
  }
  audioOn() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(true, e);
    });
  }
  videoOff() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(false, e);
    });
  }
  videoOn() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(true, e);
    });
  }
  callEnded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r, i;
      (r = this.backend) == null || r.stopPingStats(), (i = this.backend) == null || i.sendDisconnectEvent(e);
    });
  }
  screenShareStart(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(true, e, r);
    });
  }
  consumerSharedMediaState(e, r) {
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendConsumerSharedMediaStateEvent(e, r);
    });
  }
  screenShareStop(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(false, e, r);
    });
  }
  screenShareRequested() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendScreenShareRequestedEvent(e);
    });
  }
  activeSpeaker(e) {
    if (e !== this.peerId)
      return;
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendActiveSpeakerEvent(e, r);
    });
  }
  devices(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.devices(e, r, i);
    });
  }
  selectedDevice(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.selectedDevice(e, r, i);
    });
  }
  mediaPermission(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.mediaPermission(e, r, i);
    });
  }
  mediaPlaybackFailed(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaPlaybackFailed(e, r);
    });
  }
  mediaTrackMuted(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaTrackMuted(e, r);
    });
  }
  tabChanged(e = false) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.tabChanged(e, r);
    });
  }
  browserBackgrounded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserBackgrounded(e);
    });
  }
  browserForegrounded() {
    const e = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserForegrounded(e);
    });
  }
  legacySwitch(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.legacySwitch(e, r);
    });
  }
  startPreCallTest(e = false) {
    return u(this, null, function* () {
      const r = /* @__PURE__ */ new Date();
      this.onSafeInitialization(() => {
        var i;
        (i = this.backend) == null || i.sendPreCallTestBeginEvent(e, r);
      });
    });
  }
  onPreCallTestResults(e) {
    return this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.once("precall_end", e);
    }), e;
  }
  onReceivingConsumerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_audio_status", e);
    });
  }
  onReceivingConsumerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_video_status", e);
    });
  }
  onReceivingProducerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_audio_status", e);
    });
  }
  onReceivingProducerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_video_status", e);
    });
  }
  onReceivingProducingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producing_transport_status", e);
    });
  }
  onReceivingConsumingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consuming_transport_status", e);
    });
  }
  onProducerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_score", e);
    });
  }
  onConsumerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_score", e);
    });
  }
  onSafeInitialization(e) {
    if (this.initialized)
      e(this.ipInformation, false);
    else if (!this.stalled) {
      const r = (i) => {
        e(i, true);
      };
      return this.once("initialized", r), r;
    }
    return () => {
    };
  }
  removeInitializationListener(e) {
    this.removeListener("initialized", e);
  }
  stallCallStats() {
    this.stalled = true, this.removeAllListeners("initialized");
  }
  ivsPlayerEvent(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n, o, c, d, l, p, f2, S, T, _, P;
      switch (e) {
        case "PlayerRebuffering":
          (n = this.backend) == null || n.sendIVSPlayerRebufferEvent(i);
          break;
        case "PlayerAudioBlocked":
          (o = this.backend) == null || o.sendIVSPlayerAudioBlockEvent(i);
          break;
        case "PlayerPlaybackBlocked":
          (c = this.backend) == null || c.sendIVSPlayerPlaybackBlockedEvent(i);
          break;
        case "PlayerNetworkUnavailable":
          (d = this.backend) == null || d.sendIVSPlayerNetworkUnavailableEvent(i);
          break;
        case "PlayerInitialized":
          (l = this.backend) == null || l.sendIVSPlayerInitializedEvent(i);
          break;
        case "PlayerWorkerError":
          (p = this.backend) == null || p.sendIVSPlayerWorkerErrorEvent(i);
          break;
        case "PlayerError":
          (f2 = this.backend) == null || f2.sendIVSPlayerErrorEvent(r, i);
          break;
        case "PlayerRecoverableError":
          (S = this.backend) == null || S.sendIVSPlayerRecoverableErrorEvent(r, i);
          break;
        case "PlayerAnalyticsEvent":
          (T = this.backend) == null || T.sendIVSPlayerAnalyticsEvent(r, i);
          break;
        case "PlayerPlaybackRateChanged":
          (_ = this.backend) == null || _.sendIVSPlayerPlaybackRateChangedEvent(r, i);
          break;
        case "PlayerQualityChanged":
          (P = this.backend) == null || P.sendIVSPlayerQualityChanged(r, i);
          break;
      }
    });
  }
  livestreamLatency(e) {
    const r = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendPlayerLiveLatency(e, r);
    });
  }
  expectedVideoResolution(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedVideoResolution(e, r, i);
    });
  }
  expectedScreenshareResolution(e, r) {
    const i = /* @__PURE__ */ new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedScreenshareResolution(e, r, i);
    });
  }
};
var Fv = new Rm();
Fv.setMaxListeners(30);
function Hv() {
  this.__data__ = [], this.size = 0;
}
function qc(s, t) {
  return s === t || s !== s && t !== t;
}
function Hl(s, t) {
  for (var e = s.length; e--; )
    if (qc(s[e][0], t))
      return e;
  return -1;
}
var Bv = Array.prototype;
var qv = Bv.splice;
function jv(s) {
  var t = this.__data__, e = Hl(t, s);
  if (e < 0)
    return false;
  var r = t.length - 1;
  return e == r ? t.pop() : qv.call(t, e, 1), --this.size, true;
}
function Gv(s) {
  var t = this.__data__, e = Hl(t, s);
  return e < 0 ? void 0 : t[e][1];
}
function Wv(s) {
  return Hl(this.__data__, s) > -1;
}
function Jv(s, t) {
  var e = this.__data__, r = Hl(e, s);
  return r < 0 ? (++this.size, e.push([s, t])) : e[r][1] = t, this;
}
function Tr(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
Tr.prototype.clear = Hv;
Tr.prototype.delete = jv;
Tr.prototype.get = Gv;
Tr.prototype.has = Wv;
Tr.prototype.set = Jv;
function Kv() {
  this.__data__ = new Tr(), this.size = 0;
}
function zv(s) {
  var t = this.__data__, e = t.delete(s);
  return this.size = t.size, e;
}
function Yv(s) {
  return this.__data__.get(s);
}
function Qv(s) {
  return this.__data__.has(s);
}
var Xv = typeof global == "object" && global && global.Object === Object && global;
var wm = Xv;
var Zv = typeof self == "object" && self && self.Object === Object && self;
var ey = wm || Zv || Function("return this")();
var Cs = ey;
var ty = Cs.Symbol;
var ti = ty;
var bm = Object.prototype;
var sy = bm.hasOwnProperty;
var ry = bm.toString;
var go = ti ? ti.toStringTag : void 0;
function iy(s) {
  var t = sy.call(s, go), e = s[go];
  try {
    s[go] = void 0;
    var r = true;
  } catch (n) {
  }
  var i = ry.call(s);
  return r && (t ? s[go] = e : delete s[go]), i;
}
var ay = Object.prototype;
var ny = ay.toString;
function oy(s) {
  return ny.call(s);
}
var cy = "[object Null]";
var dy = "[object Undefined]";
var dp = ti ? ti.toStringTag : void 0;
function ma(s) {
  return s == null ? s === void 0 ? dy : cy : dp && dp in Object(s) ? iy(s) : oy(s);
}
function Ps(s) {
  var t = typeof s;
  return s != null && (t == "object" || t == "function");
}
var ly = "[object AsyncFunction]";
var uy = "[object Function]";
var hy = "[object GeneratorFunction]";
var py = "[object Proxy]";
function Th(s) {
  if (!Ps(s))
    return false;
  var t = ma(s);
  return t == uy || t == hy || t == ly || t == py;
}
var gy = Cs["__core-js_shared__"];
var nu = gy;
var lp = (function() {
  var s = /[^.]+$/.exec(nu && nu.keys && nu.keys.IE_PROTO || "");
  return s ? "Symbol(src)_1." + s : "";
})();
function my(s) {
  return !!lp && lp in s;
}
var fy = Function.prototype;
var Sy = fy.toString;
function fa(s) {
  if (s != null) {
    try {
      return Sy.call(s);
    } catch (t) {
    }
    try {
      return s + "";
    } catch (t) {
    }
  }
  return "";
}
var vy = /[\\^$.*+?()[\]{}|]/g;
var yy = /^\[object .+?Constructor\]$/;
var Ty = Function.prototype;
var Ey = Object.prototype;
var _y = Ty.toString;
var Py = Ey.hasOwnProperty;
var Cy = RegExp(
  "^" + _y.call(Py).replace(vy, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ry(s) {
  if (!Ps(s) || my(s))
    return false;
  var t = Th(s) ? Cy : yy;
  return t.test(fa(s));
}
function wy(s, t) {
  return s == null ? void 0 : s[t];
}
function Sa(s, t) {
  var e = wy(s, t);
  return Ry(e) ? e : void 0;
}
var by = Sa(Cs, "Map");
var Lo = by;
var ky = Sa(Object, "create");
var xo = ky;
function Iy() {
  this.__data__ = xo ? xo(null) : {}, this.size = 0;
}
function Ay(s) {
  var t = this.has(s) && delete this.__data__[s];
  return this.size -= t ? 1 : 0, t;
}
var My = "__lodash_hash_undefined__";
var Dy = Object.prototype;
var Oy = Dy.hasOwnProperty;
function Ny(s) {
  var t = this.__data__;
  if (xo) {
    var e = t[s];
    return e === My ? void 0 : e;
  }
  return Oy.call(t, s) ? t[s] : void 0;
}
var Vy = Object.prototype;
var Ly = Vy.hasOwnProperty;
function xy(s) {
  var t = this.__data__;
  return xo ? t[s] !== void 0 : Ly.call(t, s);
}
var Uy = "__lodash_hash_undefined__";
function $y(s, t) {
  var e = this.__data__;
  return this.size += this.has(s) ? 0 : 1, e[s] = xo && t === void 0 ? Uy : t, this;
}
function ha(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
ha.prototype.clear = Iy;
ha.prototype.delete = Ay;
ha.prototype.get = Ny;
ha.prototype.has = xy;
ha.prototype.set = $y;
function Fy() {
  this.size = 0, this.__data__ = {
    hash: new ha(),
    map: new (Lo || Tr)(),
    string: new ha()
  };
}
function Hy(s) {
  var t = typeof s;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? s !== "__proto__" : s === null;
}
function Bl(s, t) {
  var e = s.__data__;
  return Hy(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function By(s) {
  var t = Bl(this, s).delete(s);
  return this.size -= t ? 1 : 0, t;
}
function qy(s) {
  return Bl(this, s).get(s);
}
function jy(s) {
  return Bl(this, s).has(s);
}
function Gy(s, t) {
  var e = Bl(this, s), r = e.size;
  return e.set(s, t), this.size += e.size == r ? 0 : 1, this;
}
function va(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
va.prototype.clear = Fy;
va.prototype.delete = By;
va.prototype.get = qy;
va.prototype.has = jy;
va.prototype.set = Gy;
var Wy = 200;
function Jy(s, t) {
  var e = this.__data__;
  if (e instanceof Tr) {
    var r = e.__data__;
    if (!Lo || r.length < Wy - 1)
      return r.push([s, t]), this.size = ++e.size, this;
    e = this.__data__ = new va(r);
  }
  return e.set(s, t), this.size = e.size, this;
}
function Us(s) {
  var t = this.__data__ = new Tr(s);
  this.size = t.size;
}
Us.prototype.clear = Kv;
Us.prototype.delete = zv;
Us.prototype.get = Yv;
Us.prototype.has = Qv;
Us.prototype.set = Jy;
function Ky(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r && t(s[e], e, s) !== false; )
    ;
  return s;
}
var zy = (function() {
  try {
    var s = Sa(Object, "defineProperty");
    return s({}, "", {}), s;
  } catch (t) {
  }
})();
var Ad = zy;
function Eh(s, t, e) {
  t == "__proto__" && Ad ? Ad(s, t, {
    configurable: true,
    enumerable: true,
    value: e,
    writable: true
  }) : s[t] = e;
}
var Yy = Object.prototype;
var Qy = Yy.hasOwnProperty;
function km(s, t, e) {
  var r = s[t];
  (!(Qy.call(s, t) && qc(r, e)) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
function jc(s, t, e, r) {
  var i = !e;
  e || (e = {});
  for (var n = -1, o = t.length; ++n < o; ) {
    var c = t[n], d = r ? r(e[c], s[c], c, e, s) : void 0;
    d === void 0 && (d = s[c]), i ? Eh(e, c, d) : km(e, c, d);
  }
  return e;
}
function Xy(s, t) {
  for (var e = -1, r = Array(s); ++e < s; )
    r[e] = t(e);
  return r;
}
function $s(s) {
  return s != null && typeof s == "object";
}
var Zy = "[object Arguments]";
function up(s) {
  return $s(s) && ma(s) == Zy;
}
var Im = Object.prototype;
var eT = Im.hasOwnProperty;
var tT = Im.propertyIsEnumerable;
var sT = up(/* @__PURE__ */ (function() {
  return arguments;
})()) ? up : function(s) {
  return $s(s) && eT.call(s, "callee") && !tT.call(s, "callee");
};
var Md = sT;
var rT = Array.isArray;
var si = rT;
function iT() {
  return false;
}
var Am = typeof exports == "object" && exports && !exports.nodeType && exports;
var hp = Am && typeof module == "object" && module && !module.nodeType && module;
var aT = hp && hp.exports === Am;
var pp = aT ? Cs.Buffer : void 0;
var nT = pp ? pp.isBuffer : void 0;
var oT = nT || iT;
var Bn = oT;
var cT = 9007199254740991;
var dT = /^(?:0|[1-9]\d*)$/;
function Mm(s, t) {
  var e = typeof s;
  return t = t == null ? cT : t, !!t && (e == "number" || e != "symbol" && dT.test(s)) && s > -1 && s % 1 == 0 && s < t;
}
var lT = 9007199254740991;
function Dm(s) {
  return typeof s == "number" && s > -1 && s % 1 == 0 && s <= lT;
}
var uT = "[object Arguments]";
var hT = "[object Array]";
var pT = "[object Boolean]";
var gT = "[object Date]";
var mT = "[object Error]";
var fT = "[object Function]";
var ST = "[object Map]";
var vT = "[object Number]";
var yT = "[object Object]";
var TT = "[object RegExp]";
var ET = "[object Set]";
var _T = "[object String]";
var PT = "[object WeakMap]";
var CT = "[object ArrayBuffer]";
var RT = "[object DataView]";
var wT = "[object Float32Array]";
var bT = "[object Float64Array]";
var kT = "[object Int8Array]";
var IT = "[object Int16Array]";
var AT = "[object Int32Array]";
var MT = "[object Uint8Array]";
var DT = "[object Uint8ClampedArray]";
var OT = "[object Uint16Array]";
var NT = "[object Uint32Array]";
var ye = {};
ye[wT] = ye[bT] = ye[kT] = ye[IT] = ye[AT] = ye[MT] = ye[DT] = ye[OT] = ye[NT] = true;
ye[uT] = ye[hT] = ye[CT] = ye[pT] = ye[RT] = ye[gT] = ye[mT] = ye[fT] = ye[ST] = ye[vT] = ye[yT] = ye[TT] = ye[ET] = ye[_T] = ye[PT] = false;
function VT(s) {
  return $s(s) && Dm(s.length) && !!ye[ma(s)];
}
function _h(s) {
  return function(t) {
    return s(t);
  };
}
var Om = typeof exports == "object" && exports && !exports.nodeType && exports;
var ko = Om && typeof module == "object" && module && !module.nodeType && module;
var LT = ko && ko.exports === Om;
var ou = LT && wm.process;
var xT = (function() {
  try {
    var s = ko && ko.require && ko.require("util").types;
    return s || ou && ou.binding && ou.binding("util");
  } catch (t) {
  }
})();
var qn = xT;
var gp = qn && qn.isTypedArray;
var UT = gp ? _h(gp) : VT;
var ql = UT;
var $T = Object.prototype;
var FT = $T.hasOwnProperty;
function Nm(s, t) {
  var e = si(s), r = !e && Md(s), i = !e && !r && Bn(s), n = !e && !r && !i && ql(s), o = e || r || i || n, c = o ? Xy(s.length, String) : [], d = c.length;
  for (var l in s)
    (t || FT.call(s, l)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    n && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    Mm(l, d))) && c.push(l);
  return c;
}
var HT = Object.prototype;
function jl(s) {
  var t = s && s.constructor, e = typeof t == "function" && t.prototype || HT;
  return s === e;
}
function Vm(s, t) {
  return function(e) {
    return s(t(e));
  };
}
var BT = Vm(Object.keys, Object);
var qT = BT;
var jT = Object.prototype;
var GT = jT.hasOwnProperty;
function Lm(s) {
  if (!jl(s))
    return qT(s);
  var t = [];
  for (var e in Object(s))
    GT.call(s, e) && e != "constructor" && t.push(e);
  return t;
}
function Gc(s) {
  return s != null && Dm(s.length) && !Th(s);
}
function Ph(s) {
  return Gc(s) ? Nm(s) : Lm(s);
}
function WT(s, t) {
  return s && jc(t, Ph(t), s);
}
function JT(s) {
  var t = [];
  if (s != null)
    for (var e in Object(s))
      t.push(e);
  return t;
}
var KT = Object.prototype;
var zT = KT.hasOwnProperty;
function YT(s) {
  if (!Ps(s))
    return JT(s);
  var t = jl(s), e = [];
  for (var r in s)
    r == "constructor" && (t || !zT.call(s, r)) || e.push(r);
  return e;
}
function Wc(s) {
  return Gc(s) ? Nm(s, true) : YT(s);
}
function QT(s, t) {
  return s && jc(t, Wc(t), s);
}
var xm = typeof exports == "object" && exports && !exports.nodeType && exports;
var mp = xm && typeof module == "object" && module && !module.nodeType && module;
var XT = mp && mp.exports === xm;
var fp = XT ? Cs.Buffer : void 0;
var Sp = fp ? fp.allocUnsafe : void 0;
function Um(s, t) {
  if (t)
    return s.slice();
  var e = s.length, r = Sp ? Sp(e) : new s.constructor(e);
  return s.copy(r), r;
}
function $m(s, t) {
  var e = -1, r = s.length;
  for (t || (t = Array(r)); ++e < r; )
    t[e] = s[e];
  return t;
}
function ZT(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length, i = 0, n = []; ++e < r; ) {
    var o = s[e];
    t(o, e, s) && (n[i++] = o);
  }
  return n;
}
function Fm() {
  return [];
}
var eE = Object.prototype;
var tE = eE.propertyIsEnumerable;
var vp = Object.getOwnPropertySymbols;
var sE = vp ? function(s) {
  return s == null ? [] : (s = Object(s), ZT(vp(s), function(t) {
    return tE.call(s, t);
  }));
} : Fm;
var Ch = sE;
function rE(s, t) {
  return jc(s, Ch(s), t);
}
function Hm(s, t) {
  for (var e = -1, r = t.length, i = s.length; ++e < r; )
    s[i + e] = t[e];
  return s;
}
var iE = Vm(Object.getPrototypeOf, Object);
var Rh = iE;
var aE = Object.getOwnPropertySymbols;
var nE = aE ? function(s) {
  for (var t = []; s; )
    Hm(t, Ch(s)), s = Rh(s);
  return t;
} : Fm;
var Bm = nE;
function oE(s, t) {
  return jc(s, Bm(s), t);
}
function qm(s, t, e) {
  var r = t(s);
  return si(s) ? r : Hm(r, e(s));
}
function Eu(s) {
  return qm(s, Ph, Ch);
}
function cE(s) {
  return qm(s, Wc, Bm);
}
var dE = Sa(Cs, "DataView");
var _u = dE;
var lE = Sa(Cs, "Promise");
var Pu = lE;
var uE = Sa(Cs, "Set");
var Cu = uE;
var hE = Sa(Cs, "WeakMap");
var Ru = hE;
var yp = "[object Map]";
var pE = "[object Object]";
var Tp = "[object Promise]";
var Ep = "[object Set]";
var _p = "[object WeakMap]";
var Pp = "[object DataView]";
var gE = fa(_u);
var mE = fa(Lo);
var fE = fa(Pu);
var SE = fa(Cu);
var vE = fa(Ru);
var oi = ma;
(_u && oi(new _u(new ArrayBuffer(1))) != Pp || Lo && oi(new Lo()) != yp || Pu && oi(Pu.resolve()) != Tp || Cu && oi(new Cu()) != Ep || Ru && oi(new Ru()) != _p) && (oi = function(s) {
  var t = ma(s), e = t == pE ? s.constructor : void 0, r = e ? fa(e) : "";
  if (r)
    switch (r) {
      case gE:
        return Pp;
      case mE:
        return yp;
      case fE:
        return Tp;
      case SE:
        return Ep;
      case vE:
        return _p;
    }
  return t;
});
var jn = oi;
var yE = Object.prototype;
var TE = yE.hasOwnProperty;
function EE(s) {
  var t = s.length, e = new s.constructor(t);
  return t && typeof s[0] == "string" && TE.call(s, "index") && (e.index = s.index, e.input = s.input), e;
}
var _E = Cs.Uint8Array;
var Dd = _E;
function wh(s) {
  var t = new s.constructor(s.byteLength);
  return new Dd(t).set(new Dd(s)), t;
}
function PE(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.byteLength);
}
var CE = /\w*$/;
function RE(s) {
  var t = new s.constructor(s.source, CE.exec(s));
  return t.lastIndex = s.lastIndex, t;
}
var Cp = ti ? ti.prototype : void 0;
var Rp = Cp ? Cp.valueOf : void 0;
function wE(s) {
  return Rp ? Object(Rp.call(s)) : {};
}
function jm(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.length);
}
var bE = "[object Boolean]";
var kE = "[object Date]";
var IE = "[object Map]";
var AE = "[object Number]";
var ME = "[object RegExp]";
var DE = "[object Set]";
var OE = "[object String]";
var NE = "[object Symbol]";
var VE = "[object ArrayBuffer]";
var LE = "[object DataView]";
var xE = "[object Float32Array]";
var UE = "[object Float64Array]";
var $E = "[object Int8Array]";
var FE = "[object Int16Array]";
var HE = "[object Int32Array]";
var BE = "[object Uint8Array]";
var qE = "[object Uint8ClampedArray]";
var jE = "[object Uint16Array]";
var GE = "[object Uint32Array]";
function WE(s, t, e) {
  var r = s.constructor;
  switch (t) {
    case VE:
      return wh(s);
    case bE:
    case kE:
      return new r(+s);
    case LE:
      return PE(s, e);
    case xE:
    case UE:
    case $E:
    case FE:
    case HE:
    case BE:
    case qE:
    case jE:
    case GE:
      return jm(s, e);
    case IE:
      return new r();
    case AE:
    case OE:
      return new r(s);
    case ME:
      return RE(s);
    case DE:
      return new r();
    case NE:
      return wE(s);
  }
}
var wp = Object.create;
var JE = /* @__PURE__ */ (function() {
  function s() {
  }
  return function(t) {
    if (!Ps(t))
      return {};
    if (wp)
      return wp(t);
    s.prototype = t;
    var e = new s();
    return s.prototype = void 0, e;
  };
})();
var KE = JE;
function Gm(s) {
  return typeof s.constructor == "function" && !jl(s) ? KE(Rh(s)) : {};
}
var zE = "[object Map]";
function YE(s) {
  return $s(s) && jn(s) == zE;
}
var bp = qn && qn.isMap;
var QE = bp ? _h(bp) : YE;
var XE = QE;
var ZE = "[object Set]";
function e_(s) {
  return $s(s) && jn(s) == ZE;
}
var kp = qn && qn.isSet;
var t_ = kp ? _h(kp) : e_;
var s_ = t_;
var r_ = 1;
var i_ = 2;
var a_ = 4;
var Wm = "[object Arguments]";
var n_ = "[object Array]";
var o_ = "[object Boolean]";
var c_ = "[object Date]";
var d_ = "[object Error]";
var Jm = "[object Function]";
var l_ = "[object GeneratorFunction]";
var u_ = "[object Map]";
var h_ = "[object Number]";
var Km = "[object Object]";
var p_ = "[object RegExp]";
var g_ = "[object Set]";
var m_ = "[object String]";
var f_ = "[object Symbol]";
var S_ = "[object WeakMap]";
var v_ = "[object ArrayBuffer]";
var y_ = "[object DataView]";
var T_ = "[object Float32Array]";
var E_ = "[object Float64Array]";
var __ = "[object Int8Array]";
var P_ = "[object Int16Array]";
var C_ = "[object Int32Array]";
var R_ = "[object Uint8Array]";
var w_ = "[object Uint8ClampedArray]";
var b_ = "[object Uint16Array]";
var k_ = "[object Uint32Array]";
var fe = {};
fe[Wm] = fe[n_] = fe[v_] = fe[y_] = fe[o_] = fe[c_] = fe[T_] = fe[E_] = fe[__] = fe[P_] = fe[C_] = fe[u_] = fe[h_] = fe[Km] = fe[p_] = fe[g_] = fe[m_] = fe[f_] = fe[R_] = fe[w_] = fe[b_] = fe[k_] = true;
fe[d_] = fe[Jm] = fe[S_] = false;
function pd(s, t, e, r, i, n) {
  var o, c = t & r_, d = t & i_, l = t & a_;
  if (e && (o = i ? e(s, r, i, n) : e(s)), o !== void 0)
    return o;
  if (!Ps(s))
    return s;
  var p = si(s);
  if (p) {
    if (o = EE(s), !c)
      return $m(s, o);
  } else {
    var f2 = jn(s), S = f2 == Jm || f2 == l_;
    if (Bn(s))
      return Um(s, c);
    if (f2 == Km || f2 == Wm || S && !i) {
      if (o = d || S ? {} : Gm(s), !c)
        return d ? oE(s, QT(o, s)) : rE(s, WT(o, s));
    } else {
      if (!fe[f2])
        return i ? s : {};
      o = WE(s, f2, c);
    }
  }
  n || (n = new Us());
  var T = n.get(s);
  if (T)
    return T;
  n.set(s, o), s_(s) ? s.forEach(function(w) {
    o.add(pd(w, t, e, w, s, n));
  }) : XE(s) && s.forEach(function(w, A) {
    o.set(A, pd(w, t, e, A, s, n));
  });
  var _ = l ? d ? cE : Eu : d ? Wc : Ph, P = p ? void 0 : _(s);
  return Ky(P || s, function(w, A) {
    P && (A = w, w = s[A]), km(o, A, pd(w, t, e, A, s, n));
  }), o;
}
var I_ = 1;
var A_ = 4;
function bh(s) {
  return pd(s, I_ | A_);
}
var M_ = "[object Symbol]";
function D_(s) {
  return typeof s == "symbol" || $s(s) && ma(s) == M_;
}
var O_ = Object.defineProperty;
var N_ = (s, t) => {
  for (var e in t)
    O_(s, e, { get: t[e], enumerable: true });
};
var V_ = {};
N_(V_, {
  permissions: () => L_,
  theme: () => x_
});
var Mt = ((s) => (s.GroupCall = "GROUP_CALL", s.Webinar = "WEBINAR", s.AudioRoom = "AUDIO_ROOM", s.Livestream = "LIVESTREAM", s.Chat = "CHAT", s))(Mt || {});
var j = ((s) => (s.Allowed = "ALLOWED", s.NotAllowed = "NOT_ALLOWED", s.CanRequest = "CAN_REQUEST", s))(j || {});
var L_ = {
  view_type: "GROUP_CALL",
  accept_waiting_requests: false,
  accept_present_requests: false,
  request_produce: false,
  can_allow_participant_audio: false,
  can_allow_participant_screensharing: false,
  can_allow_participant_video: false,
  can_spotlight: false,
  request_kick_participant: false,
  kick_participant: false,
  pin_participant: false,
  can_edit_display_name: false,
  can_record: false,
  can_livestream: false,
  can_present: true,
  waiting_room_type: "SKIP_ON_ACCEPT",
  recorder_type: "NONE",
  plugins: {
    can_close: true,
    can_start: true
  },
  polls: {
    can_create: true,
    can_vote: true,
    can_view: true
  },
  produce: {
    video: {
      allow: true,
      quality: "vga",
      frame_rate: 24
    },
    audio: true,
    screenshare: {
      allow: true,
      quality: "hd",
      frame_rate: 5
    }
  },
  chat: {
    public: {
      can_send: true,
      text: true,
      files: true
    },
    private: {
      can_send: false,
      can_receive: false,
      text: false,
      files: false
    }
  },
  connected_meetings: {
    can_alter_connected_meetings: false,
    can_switch_connected_meetings: false,
    can_switch_to_parent_meeting: false
  },
  reactions: false,
  hidden_participant: false,
  is_recorder: false,
  show_participant_list: true,
  can_change_participant_role: false,
  can_change_theme: false,
  max_screenshare_count: 1
};
var x_ = {
  setup_screen: {
    is_enabled: true
  },
  alone_here: {
    is_enabled: true
  },
  waiting_room: {
    is_enabled: false,
    enable_preview: true
  },
  control_bar: {
    is_enabled: true,
    elements: {
      plugins: true,
      screenshare: true,
      invite: true,
      participants: true,
      chat: true,
      reactions: false,
      polls: true,
      fullscreen: true,
      layout: true
    }
  },
  header: {
    is_enabled: true,
    elements: {
      timer: true,
      title: true,
      participant_count: true,
      change_layout: true
    }
  },
  pip_mode: true,
  auto_tune: true,
  grid: {
    multi: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    single: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    defaultView: "multi"
  },
  controls: {
    pip_toggle: false
  }
};
var zm = "hXgU8Wc8pwuGNq9ms5q9Hh";
var wg;
typeof process != "undefined" && (wg = process == null ? void 0 : process.env) != null && wg.FLAGSMITH_ENVIRONMENT_KEY && (zm = process.env.FLAGSMITH_ENVIRONMENT_KEY);
function U_(s = []) {
  const t = {};
  return s.forEach((e) => {
    t[e.feature.name] = {
      enabled: e.enabled,
      value: e.feature_state_value
    };
  }), t;
}
var Ym = class {
  constructor(s = zm) {
    h(this, "flags", {});
    h(this, "environmentKey", null);
    this.environmentKey = s;
  }
  identifyAndFetchFlagsWithRetry(c) {
    return u(this, arguments, function* ({
      primaryEndpoint: s,
      secondaryEndpoint: t,
      forceEvaluate: e,
      timeout: r,
      uniqueIdentifier: i,
      traitsObj: n,
      logger: o
    }) {
      const d = JSON.parse(JSON.stringify(n)), l = Object.entries(d).map((f2) => ({
        trait_key: f2[0],
        trait_value: f2[1]
      })), p = [s, t, t];
      for (const f2 of p)
        try {
          const S = new AbortController(), T = setTimeout(() => S.abort(), r), _ = "_" + (Math.random() + 1).toString(36).substring(2), P = yield fetch(`https://${f2}/api/v1/identities/`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Environment-Key": this.environmentKey
            },
            body: JSON.stringify({
              identifier: i + (e ? _ : ""),
              traits: l
            }),
            signal: S.signal
            // Handles the timeout
          });
          if (clearTimeout(T), !P.ok)
            throw new Error(`Request failed with status ${P.status}`);
          const w = yield P.json();
          return U_(w.flags || []);
        } catch (S) {
          o.error("Flagsmith identify failed!!", { error: S, url: f2 });
        }
      return {};
    });
  }
  identify(o) {
    return u(this, arguments, function* (s, t = {}, e = false, r = 5e3, i = "edge.api.flagsmith.com", n = console) {
      return this.flags = yield this.identifyAndFetchFlagsWithRetry({
        traitsObj: t,
        uniqueIdentifier: s,
        forceEvaluate: e,
        timeout: r,
        primaryEndpoint: i,
        secondaryEndpoint: "edge.api.flagsmith.com",
        logger: n
      }), this.flags;
    });
  }
  getValue(s) {
    return this.flags && this.flags[s] && this.flags[s].value;
  }
  hasFeature(s) {
    return this.flags && this.flags[s] && this.flags[s].enabled;
  }
  getAllFlags() {
    return this.flags;
  }
};
var $_ = new Ym();
function F_(s) {
  return new Ym(s);
}
var Qm = [-2, -1, 0, 1, 2];
var H_ = [0, 1, 2, 3, 4];
function B_(s) {
  s = s.trim();
  let t = "0", e = "0", r = "0";
  return s.length == 4 ? (t = "0x" + s[1] + s[1], e = "0x" + s[2] + s[2], r = "0x" + s[3] + s[3]) : s.length > 6 && (t = "0x" + s[1] + s[2], e = "0x" + s[3] + s[4], r = "0x" + s[5] + s[6]), [+t, +e, +r];
}
var q_ = (s, t, e) => {
  let r, i, n;
  if (t == 0)
    r = i = n = e;
  else {
    const o = (l, p, f2) => (f2 < 0 && (f2 += 1), f2 > 1 && (f2 -= 1), f2 < 0.16666666666666666 ? l + (p - l) * 6 * f2 : f2 < 0.5 ? p : f2 < 0.6666666666666666 ? l + (p - l) * (0.6666666666666666 - f2) * 6 : l), c = e < 0.5 ? e * (1 + t) : e + t - e * t, d = 2 * e - c;
    r = o(d, c, s + 1 / 3), i = o(d, c, s), n = o(d, c, s - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(i * 255), Math.round(n * 255)];
};
var j_ = (s, t, e) => {
  s /= 255, t /= 255, e /= 255;
  const r = Math.max(s, t, e), i = Math.min(s, t, e);
  let n, o;
  const c = (r + i) / 2;
  if (r == i)
    n = o = 0;
  else {
    const d = r - i;
    switch (o = c > 0.5 ? d / (2 - r - i) : d / (r + i), r) {
      case s:
        n = (t - e) / d + (t < e ? 6 : 0);
        break;
      case t:
        n = (e - s) / d + 2;
        break;
      case e:
        n = (s - t) / d + 4;
        break;
    }
    n /= 6;
  }
  return [n, o, c];
};
var G_ = (s, t, e) => {
  const r = (i) => i.toString(16).padStart(2, "0");
  return `#${r(s)}${r(t)}${r(e)}`;
};
var Xm = (s, t = Qm, e = 0.4) => {
  const r = [], [i, n, o] = B_(s), [c, d, l] = j_(i, n, o), p = Math.round(l * 100);
  p > 70 ? e = 0.8 : p > 60 ? e = 0.9 : p < 10 ? e = 0.075 : p < 42 && (e = 0.3);
  const f2 = t.findIndex((w) => w === 0);
  if (f2 === -1)
    throw new Error("Invalid reducer provided, it must contain atleast one zero");
  const S = 5 - f2, T = f2 + 1, _ = (100 - p) / S, P = p / T;
  for (const w of t) {
    let A;
    w < 0 ? A = p + w * P * e : w > 0 ? A = p + w * _ * e : A = p;
    const [N, H, $] = q_(c, d, A / 100);
    r.push(G_(N, H, $));
  }
  return r;
};
var Ip = {
  dark: {
    background: {
      1e3: "#252525",
      900: "#2F2F2F",
      800: "#323232",
      700: "#3E3E3E",
      600: "#4A4A4A"
    },
    text: "#F5F5F5",
    "video-bg": "#1C1C1C"
  },
  light: {
    background: {
      1e3: "#FFFFFF",
      900: "#F5F5F5",
      800: "#EBEBEB",
      700: "#E0E0E0",
      600: "#D6D6D6"
    },
    text: "#111111",
    "text-on-brand": "#ffffff",
    "video-bg": "#DADADA"
  }
};
var W_ = (s) => {
  const [t, e, r, i, n] = Xm(s, Qm);
  return { 300: t, 400: e, 500: r, 600: i, 700: n };
};
var J_ = (s) => {
  if (s === "#FFFFFF")
    return Ip.light.background;
  if (s === "#000000")
    return Ip.dark.background;
  const [t, e, r, i, n] = Xm(s, H_);
  return { 1e3: t, 900: e, 800: r, 700: i, 600: n };
};
var K_ = {
  border_radius: "rounded",
  border_width: "thin",
  spacing_base: 4,
  theme: "dark",
  colors: {
    brand: W_("#2160FD"),
    background: J_("#141414"),
    danger: "#FF2D2D",
    text: "#EEEEEE",
    text_on_brand: "#EEEEEE",
    success: "#62A504",
    video_bg: "#191919",
    warning: "#FFCD07"
  }
};
function Zm() {
  return bh(K_);
}
var z_ = {
  permissions: {
    // webinar
    can_accept_production_requests: false,
    can_edit_display_name: true,
    accept_waiting_requests: false,
    disable_participant_audio: false,
    disable_participant_screensharing: false,
    disable_participant_video: false,
    can_spotlight: false,
    kick_participant: false,
    pin_participant: false,
    can_record: false,
    can_livestream: false,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: true,
      can_start: true,
      can_edit_config: false,
      config: {}
    },
    polls: {
      can_create: true,
      can_vote: true,
      can_view: true
    },
    media: {
      video: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
        /* Allowed */
      },
      audio: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      screenshare: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
        /* Allowed */
      }
    },
    chat: {
      public: {
        can_send: true,
        text: true,
        files: true
      },
      private: {
        can_send: false,
        can_receive: false,
        text: false,
        files: false
      },
      channel: {
        // Make sure these are the same in default to ensure consistency in developer portal
        can_create: "ALL",
        can_delete: "ALL",
        can_update: "ALL",
        // end same
        can_read_all: false
      },
      message: {
        // Make sure these are the same in default to ensure consistency in developer portal
        can_delete: "ALL",
        can_edit: "ALL",
        // end same
        delete_cutoff_time_seconds: 0,
        edit_cutoff_time_seconds: 0
      }
    },
    hidden_participant: false,
    is_recorder: false,
    recorder_type: "NONE",
    show_participant_list: true,
    transcription_enabled: false,
    can_change_participant_permissions: false,
    connected_meetings: {
      can_alter_connected_meetings: false,
      can_switch_connected_meetings: false,
      can_switch_to_parent_meeting: false
    },
    stage_enabled: false,
    stage_access: void 0,
    accept_stage_requests: false
  },
  ui: {
    oldTheme: {
      setup_screen: {
        is_enabled: false
      },
      alone_here: {
        is_enabled: false
      },
      waiting_room: {
        is_enabled: false,
        enable_preview: true
      },
      control_bar: {
        is_enabled: true,
        elements: {
          plugins: true,
          screenshare: true,
          invite: false,
          participants: true,
          chat: true,
          reactions: false,
          polls: true,
          fullscreen: true,
          layout: true
        }
      },
      header: {
        is_enabled: true,
        elements: {
          timer: true,
          title: true,
          participant_count: true,
          change_layout: true
        }
      },
      pip_mode: true,
      auto_tune: true,
      colors: {
        primary: "#2160FD",
        secondary: "#1A1A1A",
        text: "#EEEEEE",
        background: "#1A1A1A",
        textPrimary: "#EEEEEE",
        videoBackground: "#1A1A1A"
      },
      dimensions: {
        mode: "fillParent"
      },
      grid: {
        multi: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        single: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        defaultView: "MULTI"
      },
      controls: {
        pip_toggle: false
      },
      plugins: []
    },
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: false,
        enable_high_bitrate: false
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "hybrid"
};
function Y_() {
  return bh(z_);
}
var Q_ = {
  permissions: {
    // webinar
    can_accept_production_requests: false,
    can_edit_display_name: true,
    accept_waiting_requests: false,
    disable_participant_audio: false,
    disable_participant_screensharing: false,
    disable_participant_video: false,
    can_spotlight: false,
    kick_participant: false,
    pin_participant: false,
    can_record: false,
    can_livestream: false,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: true,
      can_start: true,
      can_edit_config: false,
      config: {}
    },
    polls: {
      can_create: true,
      can_vote: true,
      can_view: true
    },
    media: {
      video: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      audio: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      screenshare: {
        can_produce: "ALLOWED"
        /* Allowed */
      }
    },
    chat: {
      public: {
        can_send: true,
        text: true,
        files: true
      },
      private: {
        can_send: false,
        can_receive: false,
        text: false,
        files: false
      }
    },
    hidden_participant: false,
    is_recorder: false,
    recorder_type: "NONE",
    show_participant_list: true,
    transcription_enabled: false,
    can_change_participant_permissions: false,
    connected_meetings: {
      can_alter_connected_meetings: false,
      can_switch_connected_meetings: false,
      can_switch_to_parent_meeting: false
    },
    stage_enabled: false,
    stage_access: void 0,
    accept_stage_requests: false
  },
  ui: {
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: false,
        enable_high_bitrate: false
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "2.0.0"
};
function kh() {
  return bh(Q_);
}
var $o;
var ef = class {
  constructor() {
    g(this, $o, void 0);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    var t;
    return (t = a(this, $o)) == null ? void 0 : t.getValue("telemetry");
  }
  init(t) {
    m(this, $o, t);
  }
  info(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "info",
      t,
      e,
      r
    );
  }
  error(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "error",
      t,
      e,
      r
    );
  }
  debug(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "debug",
      t,
      e,
      r
    );
  }
  log(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "log",
      t,
      e,
      r
    );
  }
  warn(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "warn",
      t,
      e,
      r
    );
  }
};
$o = /* @__PURE__ */ new WeakMap();
var js;
var Gs;
var zh = class extends ut.EventEmitter {
  constructor(e) {
    super();
    g(this, js, void 0);
    g(this, Gs, void 0);
    h(this, "asyncPromiseTimeout");
    h(this, "logger");
    this.logger = e, m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), this.asyncPromiseTimeout = 8e3;
  }
  emitAsync(e, ...r) {
    return u(this, null, function* () {
      a(this, js).set(e, []);
      const i = a(this, Gs).get(e).map(
        () => new Promise((n) => {
          a(this, js).get(e).push(n);
        })
      );
      tp(zh.prototype, this, "emit").call(this, e, ...r), yield Promise.race([
        Promise.all(i),
        new Promise(
          (n, o) => setTimeout(
            () => o(new Error(`emitAsync failed to resolve for event ${e}.`)),
            this.asyncPromiseTimeout
          )
        )
      ]), a(this, js).delete(e);
    });
  }
  onAsync(e, r) {
    const i = a(this, js), n = (...o) => u(this, null, function* () {
      var d;
      try {
        yield r(...o);
      } catch (l) {
        this.logger.error("[onAsync]", { error: l });
      }
      const c = (d = i.get(e)) == null ? void 0 : d.shift();
      c == null || c();
    });
    return a(this, Gs).get(e) || a(this, Gs).set(e, []), a(this, Gs).get(e).push(n), super.on(e, n);
  }
  /**
   * removes all attached listeners
   */
  reset() {
    m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), super.removeAllListeners();
  }
};
var wu = zh;
js = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap();
var X_ = /\s/;
function Z_(s) {
  for (var t = s.length; t-- && X_.test(s.charAt(t)); )
    ;
  return t;
}
var eP = /^\s+/;
function tP(s) {
  return s && s.slice(0, Z_(s) + 1).replace(eP, "");
}
var Ap = 0 / 0;
var sP = /^[-+]0x[0-9a-f]+$/i;
var rP = /^0b[01]+$/i;
var iP = /^0o[0-7]+$/i;
var aP = parseInt;
function Mp(s) {
  if (typeof s == "number")
    return s;
  if (D_(s))
    return Ap;
  if (Ps(s)) {
    var t = typeof s.valueOf == "function" ? s.valueOf() : s;
    s = Ps(t) ? t + "" : t;
  }
  if (typeof s != "string")
    return s === 0 ? s : +s;
  s = tP(s);
  var e = rP.test(s);
  return e || iP.test(s) ? aP(s.slice(2), e ? 2 : 8) : sP.test(s) ? Ap : +s;
}
function tf(s) {
  return s;
}
function nP(s, t, e) {
  switch (e.length) {
    case 0:
      return s.call(t);
    case 1:
      return s.call(t, e[0]);
    case 2:
      return s.call(t, e[0], e[1]);
    case 3:
      return s.call(t, e[0], e[1], e[2]);
  }
  return s.apply(t, e);
}
var oP = 800;
var cP = 16;
var dP = Date.now;
function lP(s) {
  var t = 0, e = 0;
  return function() {
    var r = dP(), i = cP - (r - e);
    if (e = r, i > 0) {
      if (++t >= oP)
        return arguments[0];
    } else
      t = 0;
    return s.apply(void 0, arguments);
  };
}
function uP(s) {
  return function() {
    return s;
  };
}
var hP = Ad ? function(s, t) {
  return Ad(s, "toString", {
    configurable: true,
    enumerable: false,
    value: uP(t),
    writable: true
  });
} : tf;
var pP = hP;
var gP = lP(pP);
var mP = gP;
var Dp = Math.max;
function fP(s, t, e) {
  return t = Dp(t === void 0 ? s.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, n = Dp(r.length - t, 0), o = Array(n); ++i < n; )
      o[i] = r[t + i];
    i = -1;
    for (var c = Array(t + 1); ++i < t; )
      c[i] = r[i];
    return c[t] = e(o), nP(s, this, c);
  };
}
function SP(s, t) {
  return mP(fP(s, t, tf), s + "");
}
function vP(s, t, e) {
  if (!Ps(e))
    return false;
  var r = typeof t;
  return (r == "number" ? Gc(e) && Mm(t, e.length) : r == "string" && t in e) ? qc(e[t], s) : false;
}
function yP(s) {
  return SP(function(t, e) {
    var r = -1, i = e.length, n = i > 1 ? e[i - 1] : void 0, o = i > 2 ? e[2] : void 0;
    for (n = s.length > 3 && typeof n == "function" ? (i--, n) : void 0, o && vP(e[0], e[1], o) && (n = i < 3 ? void 0 : n, i = 1), t = Object(t); ++r < i; ) {
      var c = e[r];
      c && s(t, c, r, n);
    }
    return t;
  });
}
var TP = "[object Object]";
var EP = Function.prototype;
var _P = Object.prototype;
var sf = EP.toString;
var PP = _P.hasOwnProperty;
var CP = sf.call(Object);
function RP(s) {
  if (!$s(s) || ma(s) != TP)
    return false;
  var t = Rh(s);
  if (t === null)
    return true;
  var e = PP.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e instanceof e && sf.call(e) == CP;
}
var wP = "__lodash_hash_undefined__";
function bP(s) {
  return this.__data__.set(s, wP), this;
}
function kP(s) {
  return this.__data__.has(s);
}
function Od(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.__data__ = new va(); ++t < e; )
    this.add(s[t]);
}
Od.prototype.add = Od.prototype.push = bP;
Od.prototype.has = kP;
function IP(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r; )
    if (t(s[e], e, s))
      return true;
  return false;
}
function AP(s, t) {
  return s.has(t);
}
var MP = 1;
var DP = 2;
function rf(s, t, e, r, i, n) {
  var o = e & MP, c = s.length, d = t.length;
  if (c != d && !(o && d > c))
    return false;
  var l = n.get(s), p = n.get(t);
  if (l && p)
    return l == t && p == s;
  var f2 = -1, S = true, T = e & DP ? new Od() : void 0;
  for (n.set(s, t), n.set(t, s); ++f2 < c; ) {
    var _ = s[f2], P = t[f2];
    if (r)
      var w = o ? r(P, _, f2, t, s, n) : r(_, P, f2, s, t, n);
    if (w !== void 0) {
      if (w)
        continue;
      S = false;
      break;
    }
    if (T) {
      if (!IP(t, function(A, N) {
        if (!AP(T, N) && (_ === A || i(_, A, e, r, n)))
          return T.push(N);
      })) {
        S = false;
        break;
      }
    } else if (!(_ === P || i(_, P, e, r, n))) {
      S = false;
      break;
    }
  }
  return n.delete(s), n.delete(t), S;
}
function OP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r, i) {
    e[++t] = [i, r];
  }), e;
}
function NP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r) {
    e[++t] = r;
  }), e;
}
var VP = 1;
var LP = 2;
var xP = "[object Boolean]";
var UP = "[object Date]";
var $P = "[object Error]";
var FP = "[object Map]";
var HP = "[object Number]";
var BP = "[object RegExp]";
var qP = "[object Set]";
var jP = "[object String]";
var GP = "[object Symbol]";
var WP = "[object ArrayBuffer]";
var JP = "[object DataView]";
var Op = ti ? ti.prototype : void 0;
var cu = Op ? Op.valueOf : void 0;
function KP(s, t, e, r, i, n, o) {
  switch (e) {
    case JP:
      if (s.byteLength != t.byteLength || s.byteOffset != t.byteOffset)
        return false;
      s = s.buffer, t = t.buffer;
    case WP:
      return !(s.byteLength != t.byteLength || !n(new Dd(s), new Dd(t)));
    case xP:
    case UP:
    case HP:
      return qc(+s, +t);
    case $P:
      return s.name == t.name && s.message == t.message;
    case BP:
    case jP:
      return s == t + "";
    case FP:
      var c = OP;
    case qP:
      var d = r & VP;
      if (c || (c = NP), s.size != t.size && !d)
        return false;
      var l = o.get(s);
      if (l)
        return l == t;
      r |= LP, o.set(s, t);
      var p = rf(c(s), c(t), r, i, n, o);
      return o.delete(s), p;
    case GP:
      if (cu)
        return cu.call(s) == cu.call(t);
  }
  return false;
}
var zP = 1;
var YP = Object.prototype;
var QP = YP.hasOwnProperty;
function XP(s, t, e, r, i, n) {
  var o = e & zP, c = Eu(s), d = c.length, l = Eu(t), p = l.length;
  if (d != p && !o)
    return false;
  for (var f2 = d; f2--; ) {
    var S = c[f2];
    if (!(o ? S in t : QP.call(t, S)))
      return false;
  }
  var T = n.get(s), _ = n.get(t);
  if (T && _)
    return T == t && _ == s;
  var P = true;
  n.set(s, t), n.set(t, s);
  for (var w = o; ++f2 < d; ) {
    S = c[f2];
    var A = s[S], N = t[S];
    if (r)
      var H = o ? r(N, A, S, t, s, n) : r(A, N, S, s, t, n);
    if (!(H === void 0 ? A === N || i(A, N, e, r, n) : H)) {
      P = false;
      break;
    }
    w || (w = S == "constructor");
  }
  if (P && !w) {
    var $ = s.constructor, F = t.constructor;
    $ != F && "constructor" in s && "constructor" in t && !(typeof $ == "function" && $ instanceof $ && typeof F == "function" && F instanceof F) && (P = false);
  }
  return n.delete(s), n.delete(t), P;
}
var ZP = 1;
var Np = "[object Arguments]";
var Vp = "[object Array]";
var td = "[object Object]";
var eC = Object.prototype;
var Lp = eC.hasOwnProperty;
function tC(s, t, e, r, i, n) {
  var o = si(s), c = si(t), d = o ? Vp : jn(s), l = c ? Vp : jn(t);
  d = d == Np ? td : d, l = l == Np ? td : l;
  var p = d == td, f2 = l == td, S = d == l;
  if (S && Bn(s)) {
    if (!Bn(t))
      return false;
    o = true, p = false;
  }
  if (S && !p)
    return n || (n = new Us()), o || ql(s) ? rf(s, t, e, r, i, n) : KP(s, t, d, e, r, i, n);
  if (!(e & ZP)) {
    var T = p && Lp.call(s, "__wrapped__"), _ = f2 && Lp.call(t, "__wrapped__");
    if (T || _) {
      var P = T ? s.value() : s, w = _ ? t.value() : t;
      return n || (n = new Us()), i(P, w, e, r, n);
    }
  }
  return S ? (n || (n = new Us()), XP(s, t, e, r, i, n)) : false;
}
function af(s, t, e, r, i) {
  return s === t ? true : s == null || t == null || !$s(s) && !$s(t) ? s !== s && t !== t : tC(s, t, e, r, af, i);
}
function sC(s) {
  return function(t, e, r) {
    for (var i = -1, n = Object(t), o = r(t), c = o.length; c--; ) {
      var d = o[s ? c : ++i];
      if (e(n[d], d, n) === false)
        break;
    }
    return t;
  };
}
var rC = sC();
var iC = rC;
var aC = function() {
  return Cs.Date.now();
};
var du = aC;
var nC = "Expected a function";
var oC = Math.max;
var cC = Math.min;
function Ih(s, t, e) {
  var r, i, n, o, c, d, l = 0, p = false, f2 = false, S = true;
  if (typeof s != "function")
    throw new TypeError(nC);
  t = Mp(t) || 0, Ps(e) && (p = !!e.leading, f2 = "maxWait" in e, n = f2 ? oC(Mp(e.maxWait) || 0, t) : n, S = "trailing" in e ? !!e.trailing : S);
  function T(K) {
    var re = r, Je = i;
    return r = i = void 0, l = K, o = s.apply(Je, re), o;
  }
  function _(K) {
    return l = K, c = setTimeout(A, t), p ? T(K) : o;
  }
  function P(K) {
    var re = K - d, Je = K - l, ks = t - re;
    return f2 ? cC(ks, n - Je) : ks;
  }
  function w(K) {
    var re = K - d, Je = K - l;
    return d === void 0 || re >= t || re < 0 || f2 && Je >= n;
  }
  function A() {
    var K = du();
    if (w(K))
      return N(K);
    c = setTimeout(A, P(K));
  }
  function N(K) {
    return c = void 0, S && r ? T(K) : (r = i = void 0, o);
  }
  function H() {
    c !== void 0 && clearTimeout(c), l = 0, r = d = i = c = void 0;
  }
  function $() {
    return c === void 0 ? o : N(du());
  }
  function F() {
    var K = du(), re = w(K);
    if (r = arguments, i = this, d = K, re) {
      if (c === void 0)
        return _(d);
      if (f2)
        return clearTimeout(c), c = setTimeout(A, t), T(d);
    }
    return c === void 0 && (c = setTimeout(A, t)), o;
  }
  return F.cancel = H, F.flush = $, F;
}
function bu(s, t, e) {
  (e !== void 0 && !qc(s[t], e) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
function dC(s) {
  return $s(s) && Gc(s);
}
function ku(s, t) {
  if (!(t === "constructor" && typeof s[t] == "function") && t != "__proto__")
    return s[t];
}
function lC(s) {
  return jc(s, Wc(s));
}
function uC(s, t, e, r, i, n, o) {
  var c = ku(s, e), d = ku(t, e), l = o.get(d);
  if (l) {
    bu(s, e, l);
    return;
  }
  var p = n ? n(c, d, e + "", s, t, o) : void 0, f2 = p === void 0;
  if (f2) {
    var S = si(d), T = !S && Bn(d), _ = !S && !T && ql(d);
    p = d, S || T || _ ? si(c) ? p = c : dC(c) ? p = $m(c) : T ? (f2 = false, p = Um(d, true)) : _ ? (f2 = false, p = jm(d, true)) : p = [] : RP(d) || Md(d) ? (p = c, Md(c) ? p = lC(c) : (!Ps(c) || Th(c)) && (p = Gm(d))) : f2 = false;
  }
  f2 && (o.set(d, p), i(p, d, r, n, o), o.delete(d)), bu(s, e, p);
}
function nf(s, t, e, r, i) {
  s !== t && iC(t, function(n, o) {
    if (i || (i = new Us()), Ps(n))
      uC(s, t, o, e, nf, r, i);
    else {
      var c = r ? r(ku(s, o), n, o + "", s, t, i) : void 0;
      c === void 0 && (c = n), bu(s, o, c);
    }
  }, Wc);
}
var hC = "[object Map]";
var pC = "[object Set]";
var gC = Object.prototype;
var mC = gC.hasOwnProperty;
function fC(s) {
  if (s == null)
    return true;
  if (Gc(s) && (si(s) || typeof s == "string" || typeof s.splice == "function" || Bn(s) || ql(s) || Md(s)))
    return !s.length;
  var t = jn(s);
  if (t == hC || t == pC)
    return !s.size;
  if (jl(s))
    return !Lm(s).length;
  for (var e in s)
    if (mC.call(s, e))
      return false;
  return true;
}
function SC(s, t) {
  return af(s, t);
}
var vC = yP(function(s, t, e) {
  nf(s, t, e);
});
var br = vC;
var Iu = ((s) => (s.PARTICIPANT = "PARTICIPANT", s.PEER = "PEER", s.CLIENT = "CLIENT", s))(Iu || {});
var X = {
  PROPAGATE_KICK_ALL: "propagate_kick_across_rooms",
  REFRESH_ID_ON_DISCONNECTION: "refresh_id_on_disconnection",
  SIMULCAST: "simulcast",
  CHAT_SOCKET_SERVER: "chat_socket_server",
  POLL_SOCKET_SERVER: "poll_socket_server",
  PLUGIN_SOCKET_SERVER: "plugin_socket_server",
  NR_OTEL_WEB: "nr_otel_web",
  ICE_RESTART_ON_FAILED_STATE: "ice_restart_on_failed_state",
  ICE_RESTART_ON_DISCONNECTED_STATE: "ice_restart_on_disconnected_state",
  ENABLE_ICE_STATE_LOGGING: "enable_ice_state_logging",
  SUPPRESS_PEER_MUTE_UNMUTE_EMITS: "web_core_suppress_peer_mute_unmute_emits",
  SKIP_OTEL_TRACES: "skip_otel_traces",
  USE_USERIDS_IN_CHAT: "use_userids_in_chat",
  CUSTOM_PING_PONG: "custom_ping_pong",
  // NOTE(itzmanish) below flags is added by me
  ENABLE_HIVE_SIMULCAST: "enable_hive_simulcast",
  ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_hive_transport_reconnection_on_ice_failed",
  ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY: "enable_hive_fail_recovery",
  ENABLE_HIVE_INFINITE_RETRIES: "enable_hive_infinite_retries",
  HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "hive_transport_force_relay_on_ice_failed",
  ENABLE_HIVE_CONSUME_OVER_DC: "enable_hive_consume_over_dc",
  // ==========================================
  // NOTE(ravindra-dyte) replicating hive flags for CF, need to remove if not needed
  ENABLE_CF_SIMULCAST: "enable_cf_simulcast",
  ENABLE_CF_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_cf_transport_reconnection_on_ice_failed",
  ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY: "enable_cf_fail_recovery",
  ENABLE_CF_INFINITE_RETRIES: "enable_cf_infinite_retries",
  CF_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "cf_transport_force_relay_on_ice_failed",
  // ==========================================
  BYPASS_LOG_EXCLUSION_LIST: "bypass_log_exclusion_list",
  LOG_LEVEL: "log_level",
  V1_PLUGINS: "v1_plugins",
  SCREENSHARE_DTX: "screenshare_dtx",
  SCREENSHARE_PRIORITY: "screenshare_priority",
  SCREENSHARE_MIN_BITRATE: "screenshare_minbitrate",
  SCREENSHARE_SIMULCAST: "screenshare_simulcast",
  DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE: "disable_webcam_layers_on_screenshare",
  SCREENSHARE_FORCE_GOOG_CONFERENCE: "screenshare_force_goog_conference",
  LIVESTREAM: "feat_livestream",
  FETCH_RETRY: "fetch_retry",
  DISABLE_WEBCAM_SIMULCAST: "webcore_disable_webcam_simulcast",
  OVERRIDE_WEBCAM_SIMULCAST: "override_webcam_simulcast",
  SOCKET_POLLING: "socket_polling",
  FEAT_PAGINATED_CHAT: "feat_paginated_chat",
  VAL_MIN_FRAMERATE: "val_min_framerate",
  SCREEENSHARE_ERR_HACK: "screenshare_err_hack",
  SCREEENSHARE_CONSTRAINTS_RETRY: "screenshare_constraints_retry",
  TROUBLESHOOTING: "feat_troubleshooting",
  VIDEO_CONSTRAINTS: "video_constraints",
  SCREENSHARE_CONSTRAINTS: "screenshare_constraints",
  FEAT_CHAT_SDK: "feat_chat_sdk",
  FEAT_CHAT_SDK_SEARCH: "chat_search",
  OBS_QUALITY: "obs_quality",
  ALLOW_SAFARI_MEDIA_MIDDLEWARES: "allow_safari_media_middlewares",
  DYNAMIC_VIDEO_QUALITY: "dynamic_video_quality",
  EXP_RESHARE: "exp_reshare",
  LEAVE_STAGE_ON_END: "leave_stage_on_end",
  SKIP_SETTING_IN_USE_DEVICE: "skip_setting_in_use_device",
  PRECALL_BANDWIDTH_TEST: "precall_bandwidth_test",
  CONSUMER_BIND_NO_RETRY: "consumer_bind_no_retry",
  DEBUG_SOCKET_JOIN: "debug_socket_join",
  FORCE_RELAY: "force_relay",
  FORCE_VIDEO_CODEC: "force_video_codec",
  USE_EXPERIMENTAL_SFU_HANDLER: "use_experimental_sfu_handler",
  TRACK_HINT: "track_hint",
  OVERRIDE_HIVE_SIMULCAST_DYNAMIC: "override_hive_simulcast_dynamic",
  PRECREATE_PRODUCERS: "precreate_producers",
  DISABLE_OPUS_DTX_CF: "disable_opus_dtx_cf",
  ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS: "enable_audio_activity_debug_logs",
  NEW_SYNC_CONSUMERS: "new_sync_consumers"
};
function gd(s) {
  const t = {};
  return typeof (s == null ? void 0 : s.code) == "number" && (t.code = s.code), typeof (s == null ? void 0 : s.code) == "string" && (t.code = s.code.substring(0, 100)), typeof (s == null ? void 0 : s.name) == "string" && (t.name = s.name.substring(0, 500)), typeof (s == null ? void 0 : s.message) == "string" && (t.message = s.message.substring(0, 500)), typeof (s == null ? void 0 : s.reason) == "string" && (t.reason = s.reason.substring(0, 500)), typeof (s == null ? void 0 : s.stack) == "string" && (t.stack = s.stack.substring(0, 500)), t;
}
function yC(s) {
  var r, i, n, o;
  const t = typeof navigator != "undefined" && !navigator.isReactNative && typeof window != "undefined" && ((r = window.location.host) == null ? void 0 : r.includes("devel")) && ((i = window.location.host) == null ? void 0 : i.includes("dyte.io")), e = !!((o = (n = s == null ? void 0 : s.getValue("modules")) == null ? void 0 : n.devTools) != null && o.logs);
  return t || e;
}
function TC(s, t) {
  var e;
  if (s != null && s.getValue("flagsmith").hasFeature(X.LOG_LEVEL)) {
    let r = ((e = s.getValue("flagsmith").getValue(X.LOG_LEVEL)) == null ? void 0 : e.toString()) || "all";
    if (r = r.toLowerCase().trim(), r === "off")
      return false;
    if (r !== "all") {
      const i = ["debug", "log", "info", "warn", "error"], n = i.indexOf(
        t
      ), o = i.indexOf(r);
      if (n < o)
        return false;
    }
  }
  return true;
}
function of(s, t, e = {}) {
  return Object.getOwnPropertyNames(s).forEach((r) => {
    var n;
    if ([null, void 0, NaN].includes(s[r]) || t && (((n = t.match(/\./g)) == null ? void 0 : n.length) || 0) >= 10)
      return;
    const i = t ? `${t}.${r}` : r;
    typeof s[r] == "object" ? of(s[r], i, e) : ["number", "string", "boolean"].includes(typeof s[r]) && (e[i] = s[r]);
  }), e;
}
function xp(s, t, e = {}, r = "") {
  const i = {};
  try {
    const n = JSON.stringify(e), o = JSON.parse(n), c = of(
      o,
      r
    ), d = JSON.stringify(c);
    return JSON.parse(d);
  } catch (n) {
    const o = gd(n);
    i[`${r}.error.message`] = o.message || "", i[`${r}.error.stack`] = o.stack || "", i[`${r}.error.reason`] = o.reason || "", i[`${r}.error.source`] = "safelyFlattenObjForOpenTelemetry";
  }
  return i;
}
var EC = {
  audio: true,
  video: true,
  screenshareAudio: true,
  screenshareVideo: true
};
var mo = {
  baseURL: "http://localhost:5000",
  createdAt: "2021-08-05T10:49:56.602Z",
  description: "Develop plugins locally",
  id: "09259e3b-7be8-46f6-9801-106bf1866e1c",
  name: "Localhost Dev",
  organizationId: "4ad15a19-80e2-4105-bf43-48039fd2963e",
  picture: "https://dyte-uploads.s3.ap-south-1.amazonaws.com/dyte.png",
  private: false,
  published: true,
  staggered: false,
  tags: ["#localhost", "#dev"],
  type: "self_hosted",
  updatedAt: "2021-08-05T10:50:07.681Z"
};
var _C = {
  pip: true,
  poll: true,
  chat: true,
  stage: true,
  theme: true,
  plugin: true,
  tracing: true,
  internals: true,
  recording: true,
  livestream: true,
  participant: true,
  connectedMeetings: true,
  devTools: {
    logs: false
  }
};
function Gn(s, t) {
  const e = s.getValue("overrides");
  return e && e[t] ? e[t] : false;
}
function PC({ baseURI: s }) {
  return s.includes("preprod.dyte") || s.includes("preprod.realtime") ? bo.PREPROD : s.includes("devel.dyte") || s.includes("devel.realtime") ? bo.DEVEL : bo.PROD;
}
function da({ servicePrefix: s, baseURI: t }) {
  return `${s}.${t}`;
}
function cf(s) {
  const t = s.getValue("baseURI");
  return {
    location: da({
      servicePrefix: "location",
      baseURI: t
    }),
    locationLegacy: da({
      servicePrefix: "location-legacy",
      baseURI: t
    }),
    daCollector: da({
      servicePrefix: "da-collector",
      /**
       * FIXME(ravindra-dyte): Need to port da-collector to CF.
       * For now, using dyte one.
       * Remove the replace logic once realtime da-collector is up.
       * * */
      baseURI: t.replace("realtime.cloudflare.com", "dyte.io")
    })
  };
}
var CC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>';
var RC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 12.02c0 1.06.2 2.1.6 3.08l.6 1.42c.22.55.64 1.01 1.17 1.29.27.14.56.21.86.21h2.55c.77 0 1.49-.41 1.87-1.08.5-.87 1.02-1.7 1.72-2.43l1.32-1.39c.44-.46.97-.84 1.49-1.23l.59-.45a.6.6 0 0 0 .23-.47c0-.75-.54-1.57-1.22-1.79a3.34 3.34 0 0 0-2.78.29V4.5a1.5 1.5 0 0 0-2.05-1.4 1.5 1.5 0 0 0-2.9 0A1.5 1.5 0 0 0 6 4.5v.09A1.5 1.5 0 0 0 4 6v6.02ZM8 4.5v4a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0v5a.5.5 0 0 0 1 0v-4a.5.5 0 0 1 1 0v6a.5.5 0 0 0 .85.37h.01c.22-.22.44-.44.72-.58.7-.35 2.22-.57 2.4.5l-.53.4c-.52.4-1.04.78-1.48 1.24l-1.33 1.38c-.75.79-1.31 1.7-1.85 2.63-.21.36-.6.58-1.01.58H7.23a.87.87 0 0 1-.4-.1 1.55 1.55 0 0 1-.71-.78l-.59-1.42a7.09 7.09 0 0 1-.53-2.7V6a.5.5 0 0 1 1 0v3.5a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0Z" fill="currentColor"></path></svg>';
var sd = (s) => {
  if (!s)
    return;
  if (!s.startsWith("<svg"))
    return new Promise((n) => {
      n(s);
    });
  const e = new Blob([s], { type: "image/svg+xml" }), r = new Image(), i = window.URL.createObjectURL(e);
  return new Promise((n, o) => {
    r.onload = () => {
      n(r), window.URL.revokeObjectURL(i);
    }, r.onerror = () => {
      o(), window.URL.revokeObjectURL(i);
    }, r.src = i;
  });
};
var Yh = class {
  constructor() {
    h(this, "logsCache", []);
    h(this, "logsProcessorTimer");
    h(this, "tracingEnabled", true);
    h(this, "initialized", false);
    h(this, "logsProcessingInterval", 7e3);
    h(this, "logExclusionList", [
      "message",
      "websocket/message",
      "roomMessage",
      "websocket/room-message",
      "websocket/room-legacy-mode",
      "chatMessage",
      "websocket/new-chat-message",
      "websocket/no-active-speaker",
      "websocket/selected-peers",
      "websocket/active-speaker",
      "ping",
      "websocket/new-consumer",
      "websocket/producer-score",
      "websocket/consumer-score",
      "websocket/plugin-event",
      "websocket/plugin-data",
      "websocket/plugin-internal-data"
    ]);
    h(this, "meetingMetadata", {});
  }
  get logsEndpoint() {
    const t = mr.getContext(this.meetingMetadata.peerId);
    return `https://${da({
      servicePrefix: "api-silos",
      baseURI: t.getValue("baseURI")
    })}/otel/logs`;
  }
  resetPeerId(t) {
    this.meetingMetadata.peerId = t;
  }
  init(t, e, r) {
    this.tracingEnabled = true, this.initialized = false, this.logsCache = [];
    const i = t.getValue("peerId");
    this.meetingMetadata = e, this.tracingEnabled = r, this.meetingMetadata.peerId = i, this.meetingMetadata.sdkVersion = t.getValue("sdkVersion");
    const { RNDeviceInfoImpl: n } = navigator;
    this.meetingMetadata.deviceInfo = navigator.isReactNative ? n == null ? void 0 : n.getDeviceInfo() : Te.getDeviceInfo(), this.meetingMetadata.visitedUrl = !navigator.isReactNative && typeof window != "undefined" && window.location.href, this.logsProcessorTimer = setInterval(
      this.processCachedLogs.bind(this),
      this.logsProcessingInterval
    ), r && (this.initialized = true);
  }
  static trace(t, e = void 0) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var S;
        const l = this == null ? void 0 : this.telemetry;
        if (!l || !l.initialized || navigator.isReactNative || !l.tracingEnabled || (S = mr.getContext(l.meetingMetadata.peerId)) != null && S.getValue("flagsmith").hasFeature(X.SKIP_OTEL_TRACES))
          return o.apply(this, d);
        l.addLogInCurrentSpan("info", t, e);
        const p = performance.now(), f2 = o.apply(this, d);
        return Promise.resolve(f2).then(() => {
          const T = performance.now();
          T - p > 10 && l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p,
            country: Yh.location.country
          });
        }).catch(() => {
          const T = performance.now();
          l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p
          });
        }), f2;
      }, n;
    };
  }
  injectContext(t) {
    var i;
    const e = v4_default().replace(/-/g, "").substring(0, 16), r = (i = this.meetingMetadata.peerId) == null ? void 0 : i.replace(/-/g, "");
    t.TRACEPARENT = `00-${r}-${e}-01`;
  }
  /**
   * Adds event into the current span or the main span.
   * Event(or this method) is not a replacement for a log.
   * Tip :: Heavy objects should be logged.
   * Tip :: Light objects with `to the point` info should be added as events.
   * @param eventSeverity severity of the passed event to create better dashboards
   * @param eventName name of event in format
   *	fileName::functionName::eventName or functionName::eventName or whatever seems fit
   * @param metadata pass any information which makes sense for analytics or debugging
   * @param noCache optionally pass if log can be cached in FE or it has to be sent instantly
   * @returns nothing
   */
  addLogInCurrentSpan(t, e, r = {}, i = false) {
    r != null && r.error && Object.assign(r, { error: gd(r.error) });
    const n = mr.getContext(this.meetingMetadata.peerId);
    if (yC(n) && (fC(r) ? console[t]("DyteInternalLogs:: ", t, e) : console[t](
      "DyteInternalLogs:: ",
      t,
      e,
      r
    )), !!TC(n, t))
      try {
        const c = xp(
          n,
          e,
          r,
          "metadata"
        ), d = /* @__PURE__ */ new Date(), l = B(D({
          message: e,
          level: t
        }, c), {
          loggedAt: d.toISOString(),
          loggedAtTzOffset: d.getTimezoneOffset()
        });
        i ? this.sendOtelLogsToNewRelic([l]) : this.logsCache.push(l);
      } catch (c) {
        this.addLogInCurrentSpan(
          "error",
          "opentelemetry::addLogInCurrentSpan_failed",
          {
            error: gd(c)
          }
        );
      }
  }
  sendOtelLogsToNewRelic(t) {
    const e = mr.getContext(this.meetingMetadata.peerId);
    fetch(this.logsEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        meetingMetadata: xp(
          e,
          "sendOtelLogsToNewRelic",
          this.meetingMetadata,
          "meetingMetadata"
        ),
        serviceName: e.getValue("sdkName"),
        logs: t
      })
    }).catch((r) => {
      this.addLogInCurrentSpan(
        "error",
        "opentelemetry::sendOtelLogToNewRelic_failed",
        {
          error: gd(r)
        }
      ), this.logsCache.push(...t);
    });
  }
  processCachedLogs() {
    const t = this.logsCache.splice(0, 25);
    t != null && t.length && this.sendOtelLogsToNewRelic(t);
  }
  destruct() {
    clearInterval(this.logsProcessorTimer), this.processCachedLogs();
  }
};
var E = Yh;
h(E, "location", {
  country: void 0
});
function wC(s) {
  const t = D({}, s), e = /* @__PURE__ */ new Map(), r = (l, p) => (e.has(l) || e.set(l, /* @__PURE__ */ new Set()), e.get(l).add(p), () => {
    var f2;
    return (f2 = e.get(l)) == null ? void 0 : f2.delete(p);
  }), i = (l, p) => {
    var f2;
    (f2 = e.get(l)) == null || f2.delete(p);
  }, n = (l) => {
    var p;
    (p = e.get(l)) == null || p.forEach((f2) => {
      try {
        f2(t[l]);
      } catch (S) {
      }
    });
  };
  return {
    subscribe: r,
    unsubscribe: i,
    notify: n,
    setValue: (l, p, f2 = true) => {
      t[l] = p, f2 && n(l);
    },
    getValue: (l) => t[l],
    getAllValues: () => t
  };
}
var bC = class {
  constructor() {
    h(this, "contexts", /* @__PURE__ */ new Map());
    h(this, "mostRecentPeerId", null);
  }
  createContext(t, e) {
    if (this.contexts.has(t))
      return this.contexts.get(t);
    const r = new E(), i = new ef();
    this.contexts.set(t, wC(e)), this.contexts.get(t).setValue("peerSessionStore", new wu(i));
    const n = new Rm();
    return n.setMaxListeners(50), this.contexts.get(t).setValue("logger", i), this.contexts.get(t).setValue("telemetry", r), this.contexts.get(t).setValue("callstats", n), this.contexts.get(t).setValue("flagsmith", F_()), this.mostRecentPeerId = t, this.contexts.get(t);
  }
  /**
   * NOTE(ishita1805): Used to remap the context
   * when we regnerate a peerId during reconnection.
   */
  remapContext(t, e) {
    const r = e.getValue("peerId");
    r !== t && (e.setValue("peerId", t), this.mostRecentPeerId = t, this.contexts.set(t, e), this.contexts.delete(r));
  }
  getContext(t) {
    return this.contexts.get(t);
  }
  /**
   * @deprecated
   * This is currently done as a hack to expose the current peer Id.
   * However this would not work in future, if we want to support multiple ongoing meetings per page
   * This hack works for now, because a lot more components will fail, before this,
   * if someone decides to initialize multiple meetings on the same page.
   */
  getMostRecentPeerId() {
    return this.mostRecentPeerId;
  }
};
var mr = new bC();
var kC = {
  "00": "DyteClient",
  "01": "Controller",
  "02": "RoomNodeClient",
  "03": "HiveNodeClient",
  "04": "SocketService",
  "05": "Chat",
  "06": "Plugin",
  "07": "Polls",
  "08": "Meta",
  "09": "Preset",
  10: "Recording",
  11: "Self",
  12: "Participant",
  13: "Spotlight",
  14: "Remote Request",
  15: "Webinar",
  16: "LocalMediaHandler",
  17: "End-End Encryption",
  18: "AI",
  19: "Livestream",
  20: "Stage"
};
var md = {
  "0000": "Internal exception.",
  "0001": "Failed to initialize.",
  "0002": "Failed to join room.",
  "0003": "Failed to leave room.",
  "0004": "Invalid auth token",
  "0010": "Browser not supported",
  "0011": "HTTP Network Error",
  "0012": "Websocket Network Error",
  "0013": "Rate Limited",
  "0100": "Internal exception",
  "0101": "Permission denied",
  "0102": "Prerequisite module missing",
  "0200": "Internal exception.",
  "0300": "Internal exception",
  "0400": "Internal exception",
  "0404": "Missing prerequisites to establish a websocket connection",
  "0500": "Internal exception",
  "0501": "Permission denied.",
  "0502": "Invalid message body.",
  "0503": "Text Message is too large",
  "0504": "Message not found by the given id",
  "0505": "Action not permitted without joining room",
  "0506": "Message search is disabled",
  "0510": "Invalid channel name.",
  "0600": "Internal exception",
  "0601": "Permission denied.",
  "0602": "Auth token not set for plugin",
  "0603": "Iframe was not provided",
  "0700": "Internal exception",
  "0705": "Action not permitted without joining room",
  "0800": "Internal exception",
  "0801": "Permission denied",
  "0900": "Internal exception",
  "0904": "Could not load preset",
  1e3: "Internal exception",
  1001: "Permission denied",
  1004: "Could not find specified recording",
  1005: "Action not permitted in given recording state",
  1100: "Internal exception",
  1101: "Permission denied",
  1102: "Unsupported",
  1103: "Name cannot be empty",
  1104: "No device selected while calling meeting.self.setDevice",
  1105: "Action not permitted without joining room",
  1106: "Can't set currently used device",
  1200: "Internal exception",
  1201: "Permission denied",
  1202: "Invalid page number was requested",
  1203: "Invalid participant count per page was requested",
  1204: "No participants exists with the given UserIds",
  1205: "Action not permitted without joining room",
  1206: "Manual Subscription Mode was not ACTIVATED",
  1207: "Invalid view mode",
  1208: "Manual Subscription not enabled for organization",
  1209: "Broadcast message type must be a non-empty string",
  1300: "Internal exception",
  1400: "Internal exception",
  1402: "No existing remote requests",
  1403: "No peer exists with given id",
  1500: "Internal exception",
  1600: "Internal exception",
  1601: "Failed to get audio track",
  1602: "Failed to get video track",
  1603: "Incorrect device",
  1604: "Failed to change device",
  1605: "Failed to get audio & video track",
  1606: "No audio input devices are available",
  1607: "No video input devices are available",
  1608: "No audio output devices (speakers) are available",
  1609: "Failed to fetch list of media devices",
  1610: "No media track exists",
  1611: "Failed to unmute track",
  1612: "Failed to get screenshare tracks",
  1701: "Crypto error",
  // 18xx is for AI
  1800: "Internal exception",
  1801: "Can't fetch transcript file",
  // 19xx for livestream
  1900: "Internal exception",
  1901: "Permission denied.",
  1902: "Livestream that has not yet started, can't be stopped",
  2e3: "Internal exception",
  2001: "Permission denied",
  2002: "Unsupported",
  2003: "Stage is disabled",
  2004: "Method not implemented",
  2005: "Action not permitted without joining room",
  2006: "Action not permitted in current stage status",
  9900: "Internal exception"
};
Object.keys(md).forEach((s) => {
  md[s] = `{${kC[s.slice(0, 2)]}} ${md[s]}`;
});
var R = class extends Error {
  constructor(e, r, i = void 0, n = false) {
    super(e);
    h(this, "code");
    this.code = r, this.name = "DyteError", this.message = `[ERR${this.code}]: ${md[this.code]}
${this.message}`;
    try {
      let o = n && !!i;
      r && r.endsWith("00") && i && (o = true), o && i.error("DyteError", {
        error: { message: this.message, name: this.name, code: r }
      });
      const c = mr.getContext(mr.getMostRecentPeerId());
      if (c) {
        const d = c.getValue("onError");
        try {
          d(this);
        } catch (l) {
        }
      }
      typeof window != "undefined" && window.dispatchEvent(new CustomEvent("dyteError", {
        detail: this
      }));
    } catch (o) {
    }
  }
};
function rd(s, t, e, r) {
  if (r instanceof R)
    throw r;
  if (r instanceof t) {
    const i = new R(r.message, e);
    throw i.stack = r.stack, i;
  } else
    throw r;
}
function Up(s, t, e) {
  if (!s.value) {
    const i = s.get, n = s.set;
    return i && (s.get = function() {
      try {
        return i.apply(this);
      } catch (o) {
        rd(this, t, e, o);
      }
    }), n && (s.set = function(o) {
      try {
        return n.apply(this, [o]);
      } catch (c) {
        rd(this, t, e, c);
      }
    }), s;
  }
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        rd(this, t, e, o);
      }) : n;
    } catch (n) {
      rd(this, t, e, n);
    }
  }, s;
}
function IC(s, t) {
  return (e, r, i) => {
    if (i)
      return Up(i, s, t);
    for (const n of Reflect.ownKeys(e.prototype).filter(
      (o) => o !== "constructor"
    )) {
      const o = Object.getOwnPropertyDescriptor(
        e.prototype,
        n
      );
      (o.value instanceof Function || o.get instanceof Function || o.set instanceof Function) && Object.defineProperty(
        e.prototype,
        n,
        Up(o, s, t)
      );
    }
  };
}
var ht = (s) => IC(Error, s);
function AC(s) {
  let t = 0, e, r;
  if (!s)
    return t;
  for (e = 0; e < s.length; e += 1)
    r = s.charCodeAt(e), t = (t << 5) - t + r, t |= 0;
  return Math.abs(t) % 100 + 1;
}
function MC() {
  Te.isElectron() && window.dyteElectronGetDisplayMediaSource && (navigator.mediaDevices.getDisplayMedia = () => u(this, null, function* () {
    const s = yield window.dyteElectronGetDisplayMediaSource(
      {
        types: ["window", "screen"]
      }
    );
    let t = [];
    if (s && (Array.isArray(s) ? t = s : t = [s]), !(t != null && t.length))
      throw new Error("Couldn't find any media source for screen share.");
    let e = t.find(
      (n) => {
        var o;
        return (o = n.id) == null ? void 0 : o.includes("screen");
      }
    );
    e = e != null ? e : t[0];
    const r = {
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: e.id
        }
      }
    };
    return yield navigator.mediaDevices.getUserMedia(
      r
    );
  }));
}
var k = ((s) => (s.NEW_PRODUCER = "NEW_PRODUCER", s.PRODUCER_TRACK_ENDED = "PRODUCER_TRACK_ENDED", s.ROOM_NODE_CONNECTION_ERROR = "ROOM_NODE_CONNECTION_ERROR", s.SOCKET_SERVICE_ROOM_JOINED = "SOCKET_SERVICE_ROOM_JOINED", s.SOCKET_SERVICE_RECONNECTED = "SOCKET_SERVICE_RECONNECTED", s.SOCKET_SERVICE_DISCONNECTED = "SOCKET_SERVICE_DISCONNECTED", s.SOCKET_SERVICE_FAILED = "SOCKET_SERVICE_FAILED", s.SOCKET_STATE_UPDATE = "SOCKET_STATE_UPDATE", s.ROOM_NODE_RECONNECTED = "ROOM_NODE_RECONNECTED", s.ROOM_NODE_DISCONNECTED = "ROOM_NODE_DISCONNECTED", s.ROOM_NODE_FAILED = "ROOM_NODE_FAILED", s.TRANSPORT_STATE_UPDATE = "TRANSPORT_STATE_UPDATE", s.PRODUCER_SCORE_UPDATE = "PRODUCER_SCORE_UPDATE", s.CONSUMER_SCORE_UPDATE = "CONSUMER_SCORE_UPDATE", s.PRODUCER_STATUS_UPDATE = "PRODUCER_STATUS_UPDATE", s.CONSUMER_STATUS_UPDATE = "CONSUMER_STATUS_UPDATE", s.LOW_PRODUCER_SCORE = "LOW_PRODUCER_SCORE", s.LOW_CONSUMER_SCORE = "LOW_CONSUMER_SCORE", s.MEDIA_PERMISSION_ERROR = "MEDIA_PERMISSION_ERROR", s.MEDIA_PERMISSION_UPDATE = "MEDIA_PERMISSION_UPDATE", s.WAITLISTED = "WAIT_LISTED", s.MESSAGE = "websocket/message", s.ROOM_MESSAGE = "websocket/room-message", s.PEER_JOINED_INTERNAL = "peer/joined-internal", s.PEER_CLOSED = "websocket/peer-closed", s.CONSUMER_CLOSED = "websocket/consumer-closed", s.CONSUMER_PAUSED = "websocket/consumer-paused", s.CONSUMER_RESUMED = "websocket/consumer-resumed", s.PRODUCER_CLOSED = "websocket/producer-closed", s.NEW_CONSUMER = "websocket/new-consumer", s.PRODUCER_SCORE = "websocket/producer-score", s.CONSUMER_SCORE = "websocket/consumer-score", s.PRODUCER_TOGGLE = "hive/producer-toggle", s.CONSUMER_TOGGLE = "hive/consumer-toggle", s.SELECTED_PEERS_DIFF = "hive/selected-peers-diff", s.UPDATE_ACTIVE = "media/update-active", s.RESET_PRODUCER_STATE = "hive/reset-producer-state", s.CF_TRANSPORT_STATE_CHANGED = "cf/transport-state-changed", s.CF_ROOM_REJOINING = "cf/room-rejoining", s.CF_ROOM_REJOIN_FAILED = "cf/room-rejoining-failed", s.CF_ROOM_REJOINED = "cf/room-rejoined", s.CF_TRANPSORT_RECONNECTING = "cf/transport-reconnecting", s.ROOM_STATE = "sockethub/room-state", s.PEER_DISPLAY_NAME_CHANGED = "hive/display-name-changed", s.GET_STAGE_REQUESTS = "GET_STAGE_REQUESTS", s.UPDATE_STAGE_REQUESTS = "UPDATE_STAGE_REQUESTS", s.KICK_PEER = "KICK_PEER", s.UPDATE_PEER_STAGE_STATUS = "UPDATE_PEER_STAGE_STATUS", s.JOIN_MEDIA_ROOM = "JOIN_MEDIA_ROOM", s.LEAVE_MEDIA_ROOM = "LEAVE_MEDIA_ROOM", s.PIP_HANGUP = "PIP_HANGUP", s.E2EE_ACTIVE_PRODUCER = "E2EE_ACTIVE_PRODUCER", s.E2EE_INACTIVE_PRODUCER = "E2EE_INACTIVE_PRODUCER", s.E2EE_ACTIVE_CONSUMER = "E2EE_ACTIVE_CONSUMER", s.E2EE_INACTIVE_CONSUMER = "E2EE_INACTIVE_CONSUMER", s.SOCKET_PEERS = "SOCKET_PEERS", s.UPDATE_PERMISSIONS = "UPDATE_PERMISSIONS", s.MAX_SPATIAL_LAYER_CHANGE = "MAX_SPATIAL_LAYER_CHANGE", s.MUTE_SELF = "MUTE_SELF", s.MUTE_SELF_VIDEO = "MUTE_SELF_VIDEO", s))(k || {});
var Jn = class extends ut.EventEmitter {
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
};
var qt = class extends ut.EventEmitter {
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
};
function DC(s, t = 2) {
  return s.replace(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/g, "").trim().split(/\s+/).slice(0, t).map((i) => i.charAt(0)).join("").toUpperCase();
}
var $p = 1080;
var Fp = 1920;
var OC = (s, t, e, r, i, n) => {
  let o = 0.5, c = 0.5;
  const d = i, l = n, p = Math.min(e / d, r / l);
  let f2 = d * p, S = l * p, T, _, P, w, A = 1;
  return f2 < e && (A = e / f2), Math.abs(A - 1) < 1e-14 && S < r && (A = r / S), f2 *= A, S *= A, P = d / (f2 / e), w = l / (S / r), T = (d - P) * o, _ = (l - w) * c, T < 0 && (T = 0), _ < 0 && (_ = 0), P > d && (P = d), w > l && (w = l), [T, _, P, w, s, t, e, r];
};
var Kt;
var Si;
var rt;
var zt;
var be;
var ds;
var Ws;
var mt;
var Oe;
var Fa;
var Ha;
var Js;
var Ba;
var Qh = class extends qt {
  constructor(e, r, i, n) {
    const o = e.getValue("logger");
    super(o);
    g(this, Kt, void 0);
    g(this, Si, void 0);
    g(this, rt, void 0);
    g(this, zt, void 0);
    g(this, be, {
      height: $p,
      width: Fp
    });
    g(this, ds, {
      brand: "#2160FD",
      background: "#141414",
      text: "#000000",
      videoBackground: "#191919",
      textOnBrand: "#EEEEEE"
    });
    g(this, Ws, void 0);
    g(this, mt, {});
    g(this, Oe, void 0);
    g(this, Fa, void 0);
    g(this, Ha, void 0);
    g(this, Js, void 0);
    g(this, Ba, false);
    h(this, "cleanupEventListeners", () => {
      a(this, Si).unsubscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).removeListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).removeListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).removeListener("roomLeft", () => this.disable());
    });
    h(this, "enablePipMediaControls", () => {
      this.mountAudioEvents(), this.mountVideoEvents();
    });
    h(this, "onSelfVideoUpdateListener", ({ videoEnabled: e2 }) => {
      this.updateMediaSession("CAMERA", e2);
    });
    h(this, "onSelfAudioUpdateListener", ({ audioEnabled: e2 }) => {
      this.updateMediaSession("MIC", e2);
    });
    h(this, "handlePipMediaControls", (e2) => {
      e2 === "ON_STAGE" ? this.enablePipMediaControls() : this.unmountEvents();
    });
    h(this, "eventCallback", (e2) => {
      e2 === "CAMERA" && (a(this, Oe).videoEnabled ? a(this, Oe).disableVideo() : a(this, Oe).enableVideo(), this.emit("cameraToggled")), e2 === "MIC" && (a(this, Oe).audioEnabled ? a(this, Oe).disableAudio() : a(this, Oe).enableAudio(), this.emit("micToggled")), e2 === "END" && (a(this, Si).getValue("peerSessionStore").emit(k.PIP_HANGUP), this.cleanupEventListeners(), this.emit("hangup"), this.cleanup());
    });
    h(this, "unmountEvents", () => {
      navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("togglemicrophone", void 0), navigator.mediaSession.setActionHandler("togglecamera", void 0));
    });
    h(this, "animate", () => {
      if (!this.isActive && a(this, Js) === "active") {
        this.disable(true);
        return;
      }
      a(this, mt) !== void 0 && this.paintCanvas(), a(this, Ws) !== void 0 && m(this, Ws, requestAnimationFrame(() => this.animate()));
    });
    h(this, "disable", (e2 = false) => {
      m(this, Js, "idle"), this.cleanupEventListeners(), cancelAnimationFrame(a(this, Ws)), e2 !== true && document.body.removeChild(a(this, rt)), m(this, Ws, void 0), document.pictureInPictureElement && document.exitPictureInPicture();
    });
    m(this, Si, e), m(this, Js, "idle"), m(this, Oe, r), m(this, ds, {
      brand: r.config.designTokens.colors.brand[500],
      background: r.config.designTokens.colors.background[1e3],
      text: r.config.designTokens.colors.text,
      videoBackground: r.config.designTokens.colors.videoBg,
      textOnBrand: r.config.designTokens.colors.textOnBrand
    }), i && this.setupIcon("pin", i), n && this.setupIcon("handRaise", n);
  }
  static _init(e, r) {
    return u(this, null, function* () {
      let i, n;
      try {
        i = yield sd(CC), n = yield sd(RC);
      } catch (o) {
      }
      return new Qh(e, r, i, n);
    });
  }
  setupIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, r);
          break;
        case "pin":
          m(this, Fa, r);
          break;
      }
    });
  }
  overrideIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, yield sd(r));
          break;
        case "pin":
          m(this, Fa, yield sd(r));
          break;
      }
    });
  }
  constructImage(e) {
    const r = new Image(), i = new Blob([e], { type: "image/svg+xml" }), n = window.URL.createObjectURL(i);
    return new Promise((o) => {
      r.onload = () => {
        o(r), window.URL.revokeObjectURL(n);
      }, r.src = n;
    });
  }
  createVideoContainer() {
    m(this, rt, document.createElement("div")), a(this, rt).style.width = "0.1px", a(this, rt).style.height = "0.1px", a(this, rt).style.overflow = "hidden", a(this, rt).style.position = "absolute", a(this, rt).style.bottom = "0", a(this, rt).style.right = "0", a(this, rt).style.opacity = "0", a(this, rt).appendChild(a(this, zt));
  }
  setupEventListeners() {
    a(this, Si).subscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).addListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).addListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).addListener("roomLeft", () => this.disable());
  }
  createCanvas() {
    const e = document.createElement("canvas");
    e.height = a(this, be).height, e.width = a(this, be).width, m(this, Kt, e);
  }
  setupMediaSessionEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("hangup", () => {
      this.eventCallback("END");
    }), this.mountAudioEvents(), this.mountVideoEvents());
  }
  mountAudioEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setMicrophoneActive === void 0 || a(this, Oe).permissions.canProduceAudio && navigator.mediaSession.setActionHandler("togglemicrophone", () => {
      this.eventCallback("MIC");
    });
  }
  mountVideoEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || a(this, Oe).permissions.canProduceVideo && navigator.mediaSession.setActionHandler("togglecamera", () => {
      this.eventCallback("CAMERA");
    });
  }
  getSources() {
    const r = Object.values(a(this, mt)).reduce(
      (i, n) => (i[n.pinned ? "pinned" : "regular"].push(n), i),
      { pinned: [], regular: [] }
    );
    return [...r.pinned, ...r.regular];
  }
  drawEmptyTile(e, r, i, n) {
    if (a(this, Kt) === void 0)
      return;
    const o = a(this, Kt).getContext("2d"), c = a(this, Kt).width, d = 0, l = 0, p = r - d * 2, f2 = i - d * 2, S = Math.floor(c / p), T = Math.floor(e / S), P = e % S * (p + d) + d, w = T * (f2 + d) + d, { displayText: A, image: N } = n != null ? n : {};
    o.fillStyle = A || N ? a(this, ds).videoBackground : a(this, ds).background, o.strokeStyle = a(this, ds).brand, o.beginPath(), o.moveTo(P + l, w), o.arcTo(P + p, w, P + p, w + l, l), o.arcTo(
      P + p,
      w + f2,
      P + p - l,
      w + f2,
      l
    ), o.arcTo(P, w + f2, P, w + f2 - l, l), o.arcTo(P, w, P + l, w, l), o.closePath(), o.fill(), o.stroke();
    const H = p / 6, $ = p / 2 + P, F = f2 / 2 + w;
    o.save(), (A || N) && (o.beginPath(), o.arc($, F, H, 0, Math.PI * 2), o.fillStyle = a(this, ds).brand, o.fill(), N ? (o.clip(), o.drawImage(
      N,
      $ - H,
      F - H,
      H * 2,
      H * 2
    ), o.restore()) : A && (o.fillStyle = a(this, ds).textOnBrand, o.font = `${H / 2}px sans-serif`, o.textAlign = "center", o.textBaseline = "middle", o.fillText(A, $, F)), this.drawIcons(n, P, w, Math.max(p, f2)));
  }
  drawIcons(e, r, i, n) {
    const o = Math.min(Math.max(n * 0.15, 100), 200), c = o * 0.2, d = o * 0.2;
    let l = r + c;
    const p = i + c, f2 = (S) => {
      const T = a(this, Kt).getContext("2d");
      T.save(), T.fillStyle = a(this, ds).background, T.beginPath(), T.moveTo(l + d, p), T.arcTo(l + o, p, l + o, p + d, d), T.arcTo(
        l + o,
        p + o,
        l + o - d,
        p + o,
        d
      ), T.arcTo(l, p + o, l, p + o - d, d), T.arcTo(l, p, l + d, p, d), T.closePath(), T.fill(), typeof S == "string" ? (T.font = `${o / 1.5}px sans-serif`, T.fillStyle = a(this, ds).text, T.textAlign = "center", T.textBaseline = "top", T.fillText(S, o / 2 + l, p + c)) : T.drawImage(
        S,
        l + c,
        p + c,
        o - c * 2,
        o - c * 2
      ), l += o + c, T.restore();
    };
    e.pinned && f2(a(this, Fa)), e.handRaised && f2(a(this, Ha));
  }
  drawTile(e, r, i) {
    var l, p;
    if (a(this, Kt) === void 0)
      return;
    const n = a(this, Kt).getContext("2d"), o = this.getSources();
    let c = 0, d = 0;
    for (; c < a(this, be).height - 5; ) {
      let f2 = 0;
      for (; f2 < a(this, be).width - 5 && d < i; ) {
        if ((l = o[d]) != null && l.enabled) {
          const S = o[d].element, [T, _, P, w, A, N, H, $] = OC(
            f2,
            c,
            e,
            r,
            S.videoWidth,
            S.videoHeight
          );
          ((p = S == null ? void 0 : S.classList) == null ? void 0 : p.contains("mirror")) ? (n.save(), n.scale(-1, 1), n.drawImage(S, T, _, P, w, -1 * A, N, -1 * H, $), n.restore()) : n.drawImage(S, T, _, P, w, A, N, H, $), this.drawIcons(o[d], A, N, Math.max(H, $));
        } else
          this.drawEmptyTile(d, e, r, o[d]);
        d += 1, f2 += e;
      }
      c += r;
    }
  }
  calcGridElemSize(e) {
    switch (e) {
      case 0:
      case 1:
        return [a(this, be).width, a(this, be).height];
      case 2:
        return [Math.floor(a(this, be).width / 2), a(this, be).height];
      case 3:
      case 4:
        return [Math.floor(a(this, be).width / 2), Math.floor(a(this, be).height / 2)];
      case 5:
      case 6:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
      case 7:
      case 8:
      case 9:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 3)];
      default:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
    }
  }
  paintCanvas() {
    let e = this.getSources().length;
    e !== 1 && (e = e % 2 > 0 ? e + 1 : e);
    const [r, i] = this.calcGridElemSize(e);
    this.drawTile(r, i, e);
  }
  isSupported() {
    var e;
    return !!window.chrome && document.pictureInPictureEnabled && ((e = a(this, Oe).config) == null ? void 0 : e.viewType) !== "LIVESTREAM";
  }
  get isActive() {
    return document.pictureInPictureElement !== null;
  }
  cleanup() {
    if (m(this, Ba, false), this.isSupported() && document.exitPictureInPicture !== void 0 && document.pictureInPictureElement !== null && document.exitPictureInPicture(), a(this, rt))
      try {
        document.body.removeChild(a(this, rt));
      } catch (e) {
      }
    this.removeAllSources(), m(this, Kt, void 0), m(this, zt, void 0), m(this, Ws, void 0);
  }
  /**
  	 * Initialize PiP and prepare sources
  	 */
  init({ height: e, width: r } = {}) {
    if (!this.isSupported())
      throw this.logger.error("DytePip.unsupported"), new Error("Picture-in-picture is not available in this environment");
    if (a(this, Ba))
      return;
    m(this, Ba, true), this.createCanvas(), this.setupMediaSessionEvents();
    const i = document.createElement("video");
    m(this, be, {
      height: e != null ? e : $p,
      width: r != null ? r : Fp
    }), i.height = a(this, be).height, i.width = a(this, be).width, i.autoplay = true, i.muted = true, i.srcObject = a(this, Kt).captureStream(24), m(this, zt, i), a(this, zt).onloadedmetadata = () => {
      try {
        this.emit("pipStarted"), a(this, zt).onleavepictureinpicture = () => {
          this.emit("pipEnded");
        };
      } catch (n) {
        this.emit("pipEnded");
      }
    }, this.createVideoContainer(), this.paintCanvas();
  }
  updateMediaSession(e, r) {
    navigator.mediaSession !== void 0 && (e === "CAMERA" && navigator.mediaSession.setCameraActive !== void 0 && navigator.mediaSession.setCameraActive(r), e === "MIC" && navigator.mediaSession.setMicrophoneActive !== void 0 && navigator.mediaSession.setMicrophoneActive(r));
  }
  enableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = true);
  }
  disableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = false);
  }
  generateAvatar(e, r) {
    return u(this, null, function* () {
      if (!r)
        return;
      const i = new Image();
      try {
        const n = yield (yield fetch(r)).blob(), o = window.URL.createObjectURL(n);
        i.onload = () => {
          this.updateSource(e, { image: i }), window.URL.revokeObjectURL(o);
        }, i.src = o;
      } catch (n) {
        this.logger.error("DytePip::GenerateAvatar", {
          error: n
        });
      }
    });
  }
  /**
   * Add a video source from the participant grid
   * @param {string} id id for the source (ex. participant id)
   * @param {HTMLVideoElement} element HTMLVideoElement for the video source
   * @param {boolean} enabled if source is enabled
   * @param {?string} [displayText] two character display text
   */
  addSource(e, r, i, n = false, o = void 0, c = void 0, d = false) {
    this.logger.debug("DytePIP::AddSource", {
      pip: {
        id: e,
        handRaised: d
      }
    }), a(this, mt)[e] = {
      id: e,
      element: r,
      enabled: i,
      pinned: n,
      displayText: o ? DC(o) : void 0,
      imageUrl: c,
      handRaised: d
    }, c && this.generateAvatar(e, c);
  }
  /** Update a video source */
  updateSource(e, r) {
    this.logger.info("DytePIP::UpdateSource", {
      pip: {
        id: e,
        handRaised: r.handRaised
      }
    });
    const i = a(this, mt)[e];
    i && (a(this, mt)[e] = D(D({}, i), r));
  }
  /**
  	 * Remove the video source for the participant
  	 * @param id id for the source (ex. participant id)
  	 */
  removeSource(e) {
    delete a(this, mt)[e];
  }
  /**
  	 * Remove the pinned source
  	 * @param id id for the source (ex. participant id)
  	 */
  removePinnedSource() {
    Object.values(a(this, mt)).forEach((r) => {
      r.pinned && this.removeSource(r.id);
    });
  }
  /**
  	 * Remove all sources
  	 */
  removeAllSources() {
    m(this, mt, {});
  }
  /**
  	 * Enable PiP
  	 */
  enable() {
    m(this, Js, "activating"), this.setupEventListeners(), this.updateMediaSession("CAMERA", a(this, Oe).videoEnabled), this.updateMediaSession("MIC", a(this, Oe).audioEnabled), document.body.appendChild(a(this, rt)), m(this, Ws, requestAnimationFrame(() => this.animate())), a(this, zt).onloadedmetadata = () => {
      a(this, zt).requestPictureInPicture().then(() => {
        m(this, Js, "active");
      });
    }, a(this, zt).readyState === 4 && a(this, zt).requestPictureInPicture().then(() => {
      m(this, Js, "active");
    });
  }
};
var Au = Qh;
Kt = /* @__PURE__ */ new WeakMap(), Si = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), zt = /* @__PURE__ */ new WeakMap(), be = /* @__PURE__ */ new WeakMap(), ds = /* @__PURE__ */ new WeakMap(), Ws = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), Oe = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), Js = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap();
var vr;
(function(s) {
  s[s.PUBLISHER = 0] = "PUBLISHER", s[s.SUBSCRIBER = 1] = "SUBSCRIBER";
})(vr || (vr = {}));
var xs;
(function(s) {
  s[s.AUDIO = 0] = "AUDIO", s[s.VIDEO = 1] = "VIDEO";
})(xs || (xs = {}));
var NC = class extends MessageType {
  constructor() {
    super("media.Codec", [
      {
        no: 1,
        name: "channels",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "clock_rate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "mime_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "sdp_fmtp_line",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "payload_type",
        kind: "scalar",
        opt: true,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
};
var df = new NC();
var VC = class extends MessageType {
  constructor() {
    super("media.HeaderExtension", [
      {
        no: 1,
        name: "direction",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "uri",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var LC = new VC();
var xC = class extends MessageType {
  constructor() {
    super("media.Fingerprint", [
      {
        no: 1,
        name: "algorithm",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new xC();
var UC = class extends MessageType {
  constructor() {
    super("media.SessionDescription", [
      { no: 1, name: "target", kind: "enum", T: () => ["media.Target", vr] },
      {
        no: 2,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Rs = new UC();
var $C = class extends MessageType {
  constructor() {
    super("media.ProducerPayload", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "msid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var FC = new $C();
var HC = class extends MessageType {
  constructor() {
    super("media.CreateTransportRequest", [
      {
        no: 1,
        name: "consuming",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "force_tcp",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "description", kind: "message", T: () => Rs },
      {
        no: 4,
        name: "private_ice",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 5, name: "producers", kind: "message", repeat: 1, T: () => FC }
    ]);
  }
};
var BC = new HC();
var qC = class extends MessageType {
  constructor() {
    super("media.AudioActivityRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "energy",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "silent",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var jC = new qC();
var GC = class extends MessageType {
  constructor() {
    super("media.CreateTransportResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "transcription_enabled",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var lf = new GC();
var WC = class extends MessageType {
  constructor() {
    super("media.RenegotiateRequest", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
var JC = new WC();
var KC = class extends MessageType {
  constructor() {
    super("media.RenegotiateResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
new KC();
var zC = class extends MessageType {
  constructor() {
    super("media.NestedScore", [
      {
        no: 1,
        name: "encoding_idx",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "rid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "ssrc",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
};
var YC = new zC();
var QC = class extends MessageType {
  constructor() {
    super("media.ProducerTrack", [
      {
        no: 1,
        name: "track_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "stream_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var XC = new QC();
var ZC = class extends MessageType {
  constructor() {
    super("media.ProducerEntry", [
      {
        no: 1,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new ZC();
var eR = class extends MessageType {
  constructor() {
    super("media.ConsumerEntry", [
      {
        no: 1,
        name: "consuming_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new eR();
var tR = class extends MessageType {
  constructor() {
    super("media.ProducerState", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "kind", kind: "enum", T: () => ["media.ProducerKind", xs] },
      {
        no: 3,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "codec", kind: "message", T: () => df }
    ]);
  }
};
var Jc = new tR();
var sR = class extends MessageType {
  constructor() {
    super("media.ConsumerState", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc },
      { no: 3, name: "producer_track", kind: "message", T: () => XC },
      {
        no: 4,
        name: "error_code",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var rR = new sR();
var iR = class extends MessageType {
  constructor() {
    super("media.ProducerIdToConsumerMap", [
      { no: 1, name: "map", kind: "map", K: 9, V: { kind: "message", T: () => rR } }
    ]);
  }
};
var uf = new iR();
var aR = class extends MessageType {
  constructor() {
    super("media.PeerRtpCapabilitites", [
      { no: 1, name: "sender", kind: "message", T: () => Bp },
      { no: 2, name: "receiver", kind: "message", T: () => Bp }
    ]);
  }
};
var hf = new aR();
var nR = class extends MessageType {
  constructor() {
    super("media.RtpCapability", [
      { no: 1, name: "codecs", kind: "message", repeat: 1, T: () => df },
      { no: 2, name: "header_extensions", kind: "message", repeat: 1, T: () => LC }
    ]);
  }
};
var Hp = new nR();
var oR = class extends MessageType {
  constructor() {
    super("media.RtpCapabilitites", [
      { no: 1, name: "audio", kind: "message", T: () => Hp },
      { no: 2, name: "video", kind: "message", T: () => Hp }
    ]);
  }
};
var Bp = new oR();
var cR = class extends MessageType {
  constructor() {
    super("media.PreferredCodec", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var dR = new cR();
var lR = class extends MessageType {
  constructor() {
    super("media.Simulcast", [
      {
        no: 1,
        name: "preferred_rid",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "priority_ordering",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "rid_not_available",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var pf = new lR();
var uR = class extends MessageType {
  constructor() {
    super("media.edge.GeoLocation", [
      {
        no: 1,
        name: "latitude",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 2,
        name: "longitude",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 3,
        name: "region",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var hR = new uR();
var pR = class extends MessageType {
  constructor() {
    super("media.edge.PeerJoinRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "prejoined",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "user_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "organization_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "location", kind: "message", T: () => hR },
      { no: 9, name: "capabilities", kind: "message", T: () => hf }
    ]);
  }
};
var gR = new pR();
var mR = class extends MessageType {
  constructor() {
    super("media.edge.PeerJoinCompleteRequest", []);
  }
};
var fR = new mR();
var SR = class extends MessageType {
  constructor() {
    super("media.edge.PeerLeaveRequest", [
      {
        no: 1,
        name: "close_room",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var vR = new SR();
var yR = class extends MessageType {
  constructor() {
    super("media.edge.ConsumeMultipleProducerRequest", [
      {
        no: 1,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new yR();
var TR = class extends MessageType {
  constructor() {
    super("media.edge.ConsumePeerRequest", [
      {
        no: 1,
        name: "producing_peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "producer_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "preferred_codec", kind: "message", T: () => dR },
      {
        no: 5,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "simulcast", kind: "message", T: () => pf }
    ]);
  }
};
var ER = new TR();
var _R = class extends MessageType {
  constructor() {
    super("media.edge.ConsumePeersRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => ER },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var PR = new _R();
var CR = class extends MessageType {
  constructor() {
    super("media.edge.UpdateConsumerSimulcastConfigRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "simulcast", kind: "message", T: () => pf },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "mid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var RR = new CR();
var wR = class extends MessageType {
  constructor() {
    super("media.edge.UpdateConsumersSimulcastConfigRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => RR },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var bR = new wR();
var kR = class extends MessageType {
  constructor() {
    super("media.edge.ProducerCreateRequest", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "description", kind: "message", T: () => Rs },
      {
        no: 5,
        name: "msid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "app_data",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var IR = new kR();
var AR = class extends MessageType {
  constructor() {
    super("media.edge.SelectedPeersRequest", []);
  }
};
new AR();
var MR = class extends MessageType {
  constructor() {
    super("media.edge.GlobalPeerPinningRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var DR = new MR();
var OR = class extends MessageType {
  constructor() {
    super("media.edge.ProducerToggleRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var id = new OR();
var NR = class extends MessageType {
  constructor() {
    super("media.edge.ConsumerToggleRequest", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new NR();
var VR = class extends MessageType {
  constructor() {
    super("media.edge.ProducerCloseRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var LR = new VR();
var xR = class extends MessageType {
  constructor() {
    super("media.edge.ConsumerCloseRequest", [
      {
        no: 1,
        name: "consumer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var UR = new xR();
var $R = class extends MessageType {
  constructor() {
    super("media.edge.KickPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new $R();
var FR = class extends MessageType {
  constructor() {
    super("media.edge.KickAllPeersRequest", [
      {
        no: 1,
        name: "propagate_kick_across_rooms",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var gf = new FR();
var HR = class extends MessageType {
  constructor() {
    super("media.edge.PeerDisplayNameEditRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var BR = new HR();
var qR = class extends MessageType {
  constructor() {
    super("media.edge.HostMediaControlForPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "scree_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var jR = new qR();
var GR = class extends MessageType {
  constructor() {
    super("media.edge.HostMediaControlForAllPeerRequest", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var WR = new GR();
var JR = class extends MessageType {
  constructor() {
    super("media.edge.GetRoomStateResponse", [
      {
        no: 1,
        name: "display_title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "locked_mode",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "current_peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "is_recording",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "recorder_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "pinned_peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var KR = new JR();
var zR = class extends MessageType {
  constructor() {
    super("media.edge.ErrorResponse", [
      {
        no: 1,
        name: "error_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "event_id",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var YR = new zR();
var QR = class extends MessageType {
  constructor() {
    super("media.edge.EmptyResponse", []);
  }
};
new QR();
var XR = class extends MessageType {
  constructor() {
    super("media.edge.RoomParticipants", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_states", kind: "message", repeat: 1, T: () => Jc },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "user_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "capabilities", kind: "message", T: () => hf }
    ]);
  }
};
var mf = new XR();
var ZR = class extends MessageType {
  constructor() {
    super("media.edge.SelectedPeersResponse", [
      {
        no: 1,
        name: "audio_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "compulsory_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Mu = new ZR();
var ew = class extends MessageType {
  constructor() {
    super("media.edge.SelectedPeersDiffEntry", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "priority",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var tw = new ew();
var sw = class extends MessageType {
  constructor() {
    super("media.edge.SelectedPeersDiffResponse", [
      { no: 1, name: "entries", kind: "message", repeat: 1, T: () => tw }
    ]);
  }
};
var qp = new sw();
var rw = class extends MessageType {
  constructor() {
    super("media.edge.PeerJoinResponse", []);
  }
};
new rw();
var iw = class extends MessageType {
  constructor() {
    super("media.edge.PeerJoinCompleteResponse", [
      { no: 1, name: "room_state", kind: "message", T: () => KR },
      { no: 2, name: "participants", kind: "message", repeat: 1, T: () => mf },
      { no: 3, name: "selected_peers", kind: "message", T: () => Mu },
      {
        no: 4,
        name: "max_preferred_streams",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var Du = new iw();
var aw = class extends MessageType {
  constructor() {
    super("media.edge.PeerLeaveResponse", [
      {
        no: 1,
        name: "closed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var nw = new aw();
var ow = class extends MessageType {
  constructor() {
    super("media.edge.ConsumeMultipleProducerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: () => uf }
    ]);
  }
};
new ow();
var cw = class extends MessageType {
  constructor() {
    super("media.edge.ConsumePeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: () => uf },
      { no: 3, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
var dw = new cw();
var lw = class extends MessageType {
  constructor() {
    super("media.edge.ProducerCreateResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
var uw = new lw();
var hw = class extends MessageType {
  constructor() {
    super("media.edge.ProducerScoreResponse", [
      {
        no: 1,
        name: "responseid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "score", kind: "message", T: () => YC }
    ]);
  }
};
new hw();
var pw = class extends MessageType {
  constructor() {
    super("media.edge.ActiveSpeakerResponse", [
      {
        no: 1,
        name: "responsepeer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "volume",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
new pw();
var gw = class extends MessageType {
  constructor() {
    super("media.edge.NoActiveSpeakerResponse", []);
  }
};
new gw();
var mw = class extends MessageType {
  constructor() {
    super("media.edge.ProducerToggleResponse", []);
  }
};
new mw();
var fw = class extends MessageType {
  constructor() {
    super("media.edge.ConsumerToggleResponse", []);
  }
};
new fw();
var Sw = class extends MessageType {
  constructor() {
    super("media.edge.ProducerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
var vw = new Sw();
var yw = class extends MessageType {
  constructor() {
    super("media.edge.ConsumerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: () => Rs }
    ]);
  }
};
var Tw = new yw();
var Ew = class extends MessageType {
  constructor() {
    super("media.edge.GlobalPeerPinningResponse", []);
  }
};
new Ew();
var _w = class extends MessageType {
  constructor() {
    super("media.edge.KickPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new _w();
var Pw = class extends MessageType {
  constructor() {
    super("media.edge.KickAllPeersResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new Pw();
var Cw = class extends MessageType {
  constructor() {
    super("media.edge.HostMediaControlForPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Rw = new Cw();
var ww = class extends MessageType {
  constructor() {
    super("media.edge.HostMediaControlForAllPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var bw = new ww();
var kw = class extends MessageType {
  constructor() {
    super("media.edge.PeerDisplayNameEditResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Iw = new kw();
var Aw = class extends MessageType {
  constructor() {
    super("media.edge.PeerJoinBroadcastResponse", [
      { no: 1, name: "participant", kind: "message", T: () => mf }
    ]);
  }
};
var jp = new Aw();
var Mw = class extends MessageType {
  constructor() {
    super("media.edge.TrackSubscriptionKind", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Gp = new Mw();
var Dw = class extends MessageType {
  constructor() {
    super("media.edge.TrackSubscription", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "webcam", kind: "message", T: () => Gp },
      { no: 3, name: "screenshare", kind: "message", T: () => Gp }
    ]);
  }
};
var Ow = new Dw();
var Nw = class extends MessageType {
  constructor() {
    super("media.edge.PeerProducingTransportCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transport_details", kind: "message", T: () => lf },
      { no: 3, name: "track_subscriptions", kind: "message", repeat: 1, T: () => Ow }
    ]);
  }
};
new Nw();
var Vw = class extends MessageType {
  constructor() {
    super("media.edge.PeerProducerCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc }
    ]);
  }
};
var Lw = new Vw();
var xw = class extends MessageType {
  constructor() {
    super("media.edge.PeerProducerToggleBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc },
      {
        no: 3,
        name: "initiator_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Wp = new xw();
var Uw = class extends MessageType {
  constructor() {
    super("media.edge.PeerProducerCloseBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc }
    ]);
  }
};
var $w = new Uw();
var Fw = class extends MessageType {
  constructor() {
    super("media.edge.PeerLeaveBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Ou = new Fw();
var Hw = class extends MessageType {
  constructor() {
    super("media.edge.GlobalPeerPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Jp = new Hw();
var Bw = class extends MessageType {
  constructor() {
    super("media.edge.GlobalPeerUnPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new Bw();
var qw = class extends MessageType {
  constructor() {
    super("media.edge.RecordingStartedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new qw();
var jw = class extends MessageType {
  constructor() {
    super("media.edge.RecordingStoppedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new jw();
var Gw = class extends MessageType {
  constructor() {
    super("media.edge.PeerDisplayNameEditBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new Gw();
var Ww = class extends MessageType {
  constructor() {
    super("media.edge.PeerPingRequestBroadcastResponse", [
      {
        no: 1,
        name: "password",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new Ww();
var Jw = class extends MessageType {
  constructor() {
    super("media.edge.MediaRoomTerminationBroadcastResponse", [
      {
        no: 1,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new Jw();
var Kw = class extends MessageType {
  constructor() {
    super("socket.ai.MeetingTranscript", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "transcript",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_partial",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var lu = new Kw();
var zw = class extends MessageType {
  constructor() {
    super("socket.api.BaseSocketHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new zw();
var Yw = class extends MessageType {
  constructor() {
    super("socket.api.ErrorMessage", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Qw = new Yw();
var la;
(function(s) {
  s[s.BROWSER = 0] = "BROWSER", s[s.TRACK = 1] = "TRACK", s[s.COMPOSITE = 2] = "COMPOSITE";
})(la || (la = {}));
var pr;
(function(s) {
  s[s.UNSPECIFIED = 0] = "UNSPECIFIED", s[s.ON_STAGE = 1] = "ON_STAGE", s[s.APPROVED_STAGE = 2] = "APPROVED_STAGE", s[s.REQUESTED_STAGE = 3] = "REQUESTED_STAGE", s[s.OFF_STAGE = 4] = "OFF_STAGE";
})(pr || (pr = {}));
var Nu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.RECORDER = 1] = "RECORDER", s[s.LIVESTREAMER = 2] = "LIVESTREAMER";
})(Nu || (Nu = {}));
var Vu;
(function(s) {
  s[s.PEERS = 0] = "PEERS", s[s.ROOMS = 1] = "ROOMS";
})(Vu || (Vu = {}));
var Nd;
(function(s) {
  s[s.HIVE = 0] = "HIVE", s[s.CHAT = 1] = "CHAT", s[s.PING = 2] = "PING";
})(Nd || (Nd = {}));
var Xw = class extends MessageType {
  constructor() {
    super("socket.room.PeerFlags", [
      {
        no: 1,
        name: "preset_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "recorder_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "hidden_participant",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Zw = new Xw();
var eb = class extends MessageType {
  constructor() {
    super("socket.room.Peer", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "stage_type", kind: "enum", opt: true, T: () => ["socket.room.StageType", pr, "STAGE_TYPE_"] },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "waitlisted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 9, name: "flags", kind: "message", T: () => Zw }
    ]);
  }
};
var Gl = new eb();
var tb = class extends MessageType {
  constructor() {
    super("socket.room.PeerInfoResponse", [
      { no: 1, name: "peer", kind: "message", T: () => Gl }
    ]);
  }
};
var Ca = new tb();
var sb = class extends MessageType {
  constructor() {
    super("socket.room.PeerStatusUpdate", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "stage_type", kind: "enum", opt: true, T: () => ["socket.room.StageType", pr, "STAGE_TYPE_"] }
    ]);
  }
};
var Kp = new sb();
var rb = class extends MessageType {
  constructor() {
    super("socket.room.RoomPeersInfoRequest", [
      {
        no: 1,
        name: "seach_query",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "offset",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var ib = new rb();
var ab = class extends MessageType {
  constructor() {
    super("socket.room.RoomPeersInfoResponse", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Gl }
    ]);
  }
};
var uu = new ab();
var nb = class extends MessageType {
  constructor() {
    super("socket.room.RoomPeerCountResponse", [
      {
        no: 1,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
};
var zp = new nb();
var ob = class extends MessageType {
  constructor() {
    super("socket.room.Room", [
      {
        no: 1,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      { no: 5, name: "active_recordings", kind: "message", repeat: 1, T: () => db },
      {
        no: 6,
        name: "room_uuid",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ff = new ob();
var cb = class extends MessageType {
  constructor() {
    super("socket.room.ActiveRecording", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", la] },
      {
        no: 3,
        name: "recording_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var db = new cb();
var lb = class extends MessageType {
  constructor() {
    super("socket.room.RoomInfoResponse", [
      { no: 1, name: "room", kind: "message", T: () => ff }
    ]);
  }
};
var Yp = new lb();
var ub = class extends MessageType {
  constructor() {
    super("socket.room.GetPeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Sf = new ub();
var hb = class extends MessageType {
  constructor() {
    super("socket.room.UpdatePeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new hb();
var pb = class extends MessageType {
  constructor() {
    super("socket.room.JoinRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: () => Gl },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "organization_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "use_hive",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 7, name: "capabilities", kind: "enum", repeat: 1, T: () => ["socket.room.Capabilities", Nd, "CAPABILITIES_"] },
      {
        no: 8,
        name: "timestamp",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
};
var gb = new pb();
var mb = class extends MessageType {
  constructor() {
    super("socket.room.LeaveRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: () => Gl },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
};
var fb = new mb();
var Sb = class extends MessageType {
  constructor() {
    super("socket.room.UpdateRoomInfoRequest", [
      { no: 1, name: "room", kind: "message", T: () => ff }
    ]);
  }
};
new Sb();
var vb = class extends MessageType {
  constructor() {
    super("socket.room.GetConnectedRoomsDumpRequest", []);
  }
};
new vb();
var yb = class extends MessageType {
  constructor() {
    super("socket.room.ServiceError", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "code",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Ah = new yb();
var Tb = class extends MessageType {
  constructor() {
    super("socket.room.ConnectedMeetingPeer", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Eb = new Tb();
var _b = class extends MessageType {
  constructor() {
    super("socket.room.ConnectedMeetingDump", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: () => Eb }
    ]);
  }
};
var Qp = new _b();
var Pb = class extends MessageType {
  constructor() {
    super("socket.room.GetConnectedRoomsDumpResponse", [
      { no: 1, name: "parent_meeting", kind: "message", T: () => Qp },
      { no: 2, name: "meetings", kind: "message", repeat: 1, T: () => Qp }
    ]);
  }
};
var Cb = new Pb();
var Rb = class extends MessageType {
  constructor() {
    super("socket.room.CreateRoomRequestPayload", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var wb = new Rb();
var bb = class extends MessageType {
  constructor() {
    super("socket.room.CreateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => wb }
    ]);
  }
};
var kb = new bb();
var Ib = class extends MessageType {
  constructor() {
    super("socket.room.CreateRoomResponsePayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "error", kind: "message", T: () => Ah }
    ]);
  }
};
var Ab = new Ib();
var Mb = class extends MessageType {
  constructor() {
    super("socket.room.CreateConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Ab }
    ]);
  }
};
var Xp = new Mb();
var Db = class extends MessageType {
  constructor() {
    super("socket.room.UpdateRoomRequestPayload", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Ob = new Db();
var Nb = class extends MessageType {
  constructor() {
    super("socket.room.UpdateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Ob }
    ]);
  }
};
new Nb();
var Vb = class extends MessageType {
  constructor() {
    super("socket.room.DisableRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Lb = new Vb();
var xb = class extends MessageType {
  constructor() {
    super("socket.room.DisableConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Lb }
    ]);
  }
};
var Ub = new xb();
var $b = class extends MessageType {
  constructor() {
    super("socket.room.DisableConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Bb }
    ]);
  }
};
var Fb = new $b();
var Hb = class extends MessageType {
  constructor() {
    super("socket.room.DisableConnectedRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "status",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "title",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "error", kind: "message", T: () => Ah }
    ]);
  }
};
var Bb = new Hb();
var qb = class extends MessageType {
  constructor() {
    super("socket.room.MovePeerPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "preset_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var jb = new qb();
var Gb = class extends MessageType {
  constructor() {
    super("socket.room.MovePeersBetweenRoomsRequest", [
      {
        no: 1,
        name: "source_meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "destination_meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: () => jb }
    ]);
  }
};
var Wb = new Gb();
var Jb = class extends MessageType {
  constructor() {
    super("socket.room.MovedPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "error", kind: "message", T: () => Ah }
    ]);
  }
};
var vf = new Jb();
var Kb = class extends MessageType {
  constructor() {
    super("socket.room.MovePeersBetweenRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => vf }
    ]);
  }
};
new Kb();
var zb = class extends MessageType {
  constructor() {
    super("socket.room.TransferPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "auth_token",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Yb = new zb();
var Qb = class extends MessageType {
  constructor() {
    super("socket.room.GetAllAddedParticipantsResponse", [
      { no: 1, name: "participants", kind: "message", repeat: 1, T: () => ek }
    ]);
  }
};
var Xb = new Qb();
var Zb = class extends MessageType {
  constructor() {
    super("socket.room.AddedParticipant", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ek = new Zb();
var tk = class extends MessageType {
  constructor() {
    super("socket.room.RemoveParticipantsRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var yf = new tk();
var sk = class extends MessageType {
  constructor() {
    super("socket.room.BroadcastMessage", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 4,
        name: "ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "broadcast_type", kind: "enum", opt: true, T: () => ["socket.room.BroadcastType", Vu, "BROADCAST_TYPE_"] }
    ]);
  }
};
var fo = new sk();
var rk = class extends MessageType {
  constructor() {
    super("socket.room.AcceptWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ik = new rk();
var ak = class extends MessageType {
  constructor() {
    super("socket.room.DenyWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var nk = new ak();
var ok = class extends MessageType {
  constructor() {
    super("socket.room.WaitingRoomRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "preset_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ck = new ok();
var dk = class extends MessageType {
  constructor() {
    super("socket.room.GetWaitingRoomRequests", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => ck }
    ]);
  }
};
var Zp = new dk();
var lk = class extends MessageType {
  constructor() {
    super("socket.room.GetRoomStageStateResponse", [
      {
        no: 1,
        name: "on_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "approved_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "requested_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var eg = new lk();
var Lu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SKIP = 1] = "SKIP", s[s.ON_PRIVILEGED_USER_ENTRY = 2] = "ON_PRIVILEGED_USER_ENTRY", s[s.SKIP_ON_ACCEPT = 3] = "SKIP_ON_ACCEPT";
})(Lu || (Lu = {}));
var Qr;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.ALLOWED = 1] = "ALLOWED", s[s.NOT_ALLOWED = 2] = "NOT_ALLOWED", s[s.CAN_REQUEST = 3] = "CAN_REQUEST";
})(Qr || (Qr = {}));
var uk = class extends MessageType {
  constructor() {
    super("socket.preset.PollsPermissionUpdate", [
      {
        no: 1,
        name: "can_create",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_vote",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "can_view",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var hk = new uk();
var pk = class extends MessageType {
  constructor() {
    super("socket.preset.PluginsPermissionsUpdate", [
      {
        no: 1,
        name: "can_close",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_start",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var gk = new pk();
var mk = class extends MessageType {
  constructor() {
    super("socket.preset.PublicChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "files",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var fk = new mk();
var Sk = class extends MessageType {
  constructor() {
    super("socket.preset.PrivateChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_receive",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "text",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "files",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var vk = new Sk();
var yk = class extends MessageType {
  constructor() {
    super("socket.preset.ChatPermissionUpdate", [
      { no: 1, name: "public", kind: "message", T: () => fk },
      { no: 2, name: "private", kind: "message", T: () => vk }
    ]);
  }
};
var Tk = new yk();
var Ek = class extends MessageType {
  constructor() {
    super("socket.preset.ConnectedMeetingPermissionUpdate", [
      {
        no: 1,
        name: "can_alter_connected_meetings",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_switch_to_parent_meeting",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "can_switch_connected_meetings",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var _k = new Ek();
var Pk = class extends MessageType {
  constructor() {
    super("socket.preset.StreamPermission", [
      { no: 1, name: "can_produce", kind: "enum", opt: true, T: () => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"] },
      { no: 2, name: "can_consume", kind: "enum", opt: true, T: () => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"] }
    ]);
  }
};
var hu = new Pk();
var Ck = class extends MessageType {
  constructor() {
    super("socket.preset.MediaPermissionUpdate", [
      { no: 1, name: "video", kind: "message", T: () => hu },
      { no: 2, name: "audio", kind: "message", T: () => hu },
      { no: 3, name: "screenshare", kind: "message", T: () => hu }
    ]);
  }
};
var Rk = new Ck();
var wk = class extends MessageType {
  constructor() {
    super("socket.preset.PresetUpdates", [
      { no: 1, name: "polls", kind: "message", T: () => hk },
      { no: 2, name: "plugins", kind: "message", T: () => gk },
      { no: 3, name: "chat", kind: "message", T: () => Tk },
      {
        no: 4,
        name: "accept_waiting_requests",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "can_accept_production_requests",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "can_edit_display_name",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "can_record",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "can_livestream",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "can_spotlight",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "disable_participant_audio",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "disable_participant_screensharing",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 12,
        name: "disable_participant_video",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "kick_participant",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "pin_participant",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "transcription_enabled",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 16, name: "waiting_room_type", kind: "enum", opt: true, T: () => ["socket.preset.WaitingRoomType", Lu, "WAITING_ROOM_TYPE_"] },
      {
        no: 17,
        name: "is_recorder",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 18, name: "recorder_type", kind: "enum", opt: true, T: () => ["socket.room.RecorderType", Nu, "RECORDER_TYPE_"] },
      {
        no: 19,
        name: "hidden_participant",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 20,
        name: "show_participant_list",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 21,
        name: "can_change_participant_permissions",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 22, name: "connected_meetings", kind: "message", T: () => _k },
      { no: 23, name: "media", kind: "message", T: () => Rk }
    ]);
  }
};
var Mh = new wk();
var bk = class extends MessageType {
  constructor() {
    super("socket.preset.ReadPeersPresetRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var kk = new bk();
var Ik = class extends MessageType {
  constructor() {
    super("socket.preset.PeerPreset", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "preset",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var Ak = new Ik();
var Mk = class extends MessageType {
  constructor() {
    super("socket.preset.ReadPeersPresetResponse", [
      { no: 1, name: "peer_presets", kind: "message", repeat: 1, T: () => Ak }
    ]);
  }
};
var Dk = new Mk();
var Ok = class extends MessageType {
  constructor() {
    super("socket.preset.UpdatePeerPreset", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
};
var Tf = new Ok();
var Nk = class extends MessageType {
  constructor() {
    super("socket.preset.UpdatePeersPresetRequest", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Tf }
    ]);
  }
};
var Vk = new Nk();
var Lk = class extends MessageType {
  constructor() {
    super("socket.preset.UpdatePeersPresetResponse", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Tf }
    ]);
  }
};
var tg = new Lk();
var xk = class extends MessageType {
  constructor() {
    super("socket.preset.PeerUserIDMap", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Uk = new xk();
var $k = class extends MessageType {
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetRequest", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Uk },
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
};
new $k();
var Fk = class extends MessageType {
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetResponse", [
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
};
new Fk();
var Hk = class extends MessageType {
  constructor() {
    super("socket.chat.ChatMessage", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "is_edited",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 12,
        name: "created_at_ms",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 13,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "channel_index",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ya = new Hk();
var Bk = class extends MessageType {
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var qk = new Bk();
var jk = class extends MessageType {
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => ya },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Gk = new jk();
var Wk = class extends MessageType {
  constructor() {
    super("socket.chat.GetChatMessagesResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => ya }
    ]);
  }
};
var Ef = new Wk();
var Jk = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToRoomRequest", [
      {
        no: 1,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Kk = new Jk();
var zk = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToRoomResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
};
var pu = new zk();
var Yk = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToPeersRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Qk = new Yk();
var Xk = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToPeersResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
};
var gu = new Xk();
var Zk = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToChannelRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var eI = new Zk();
var tI = class extends MessageType {
  constructor() {
    super("socket.chat.SendChatMessageToChannelResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
};
new tI();
var sI = class extends MessageType {
  constructor() {
    super("socket.chat.EditChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        opt: true,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "pinned",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var rI = new sI();
var iI = class extends MessageType {
  constructor() {
    super("socket.chat.PinChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var aI = new iI();
var nI = class extends MessageType {
  constructor() {
    super("socket.chat.PinChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ad = new nI();
var oI = class extends MessageType {
  constructor() {
    super("socket.chat.EditChatMessageResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
};
var nd = new oI();
var cI = class extends MessageType {
  constructor() {
    super("socket.chat.DeleteChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var dI = new cI();
var lI = class extends MessageType {
  constructor() {
    super("socket.chat.DeleteChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var od = new lI();
var uI = class extends MessageType {
  constructor() {
    super("socket.chat.SearchChatMessagesRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "search_term",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var hI = new uI();
var pI = class extends MessageType {
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "channel_index",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var gI = new pI();
var mI = class extends MessageType {
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadResponse", [
      {
        no: 1,
        name: "channel_index",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var fI = new mI();
var SI = class extends MessageType {
  constructor() {
    super("socket.chat.CreateChatChannelRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var vI = new SI();
var yI = class extends MessageType {
  constructor() {
    super("socket.chat.UpdateChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "visibility",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "is_direct_message",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var TI = new yI();
var EI = class extends MessageType {
  constructor() {
    super("socket.chat.CreateChatChannelResponse", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
new EI();
var _I = class extends MessageType {
  constructor() {
    super("socket.chat.GetChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var PI = new _I();
var CI = class extends MessageType {
  constructor() {
    super("socket.chat.LatestMessageAndUnreadCount", [
      { no: 1, name: "message", kind: "message", T: () => ya },
      {
        no: 2,
        name: "unread_count",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
};
var RI = new CI();
var wI = class extends MessageType {
  constructor() {
    super("socket.chat.ChatChannel", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 6, name: "latest_message_and_unread_count", kind: "message", T: () => RI },
      {
        no: 7,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var bI = new wI();
var kI = class extends MessageType {
  constructor() {
    super("socket.chat.GetChatChannelResponse", [
      { no: 1, name: "chat_channels", kind: "message", repeat: 1, T: () => bI }
    ]);
  }
};
var Hs = new kI();
var II = class extends MessageType {
  constructor() {
    super("socket.chat.ChannelMember", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var AI = new II();
var MI = class extends MessageType {
  constructor() {
    super("socket.chat.GetChatChannelMembersResponse", [
      { no: 1, name: "channel_members", kind: "message", repeat: 1, T: () => AI }
    ]);
  }
};
var DI = new MI();
var OI = class extends MessageType {
  constructor() {
    super("socket.plugin.AddPluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var NI = new OI();
var VI = class extends MessageType {
  constructor() {
    super("socket.plugin.RemovePluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var LI = new VI();
var xI = class extends MessageType {
  constructor() {
    super("socket.plugin.EnablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var UI = new xI();
var $I = class extends MessageType {
  constructor() {
    super("socket.plugin.DisablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var FI = new $I();
var HI = class extends MessageType {
  constructor() {
    super("socket.plugin.EnablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var BI2 = new HI();
var qI = class extends MessageType {
  constructor() {
    super("socket.plugin.DisablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var jI = new qI();
var GI = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginEventToRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var WI = new GI();
var JI = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginEventToPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var KI = new JI();
var zI = class extends MessageType {
  constructor() {
    super("socket.plugin.StoreKeys", [
      {
        no: 1,
        name: "store_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var Dh = new zI();
var YI = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreInsertKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "insert_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
};
var sg = new YI();
var QI = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreGetKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "get_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
};
var XI = new QI();
var ZI = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreDeleteKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "delete_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
};
var eA = new ZI();
var tA = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreDeleteRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var sA = new tA();
var rA = class extends MessageType {
  constructor() {
    super("socket.plugin.EnablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "enabled_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var xu = new rA();
var iA = class extends MessageType {
  constructor() {
    super("socket.plugin.EnablePluginsResponse", [
      { no: 1, name: "plugins", kind: "message", repeat: 1, T: () => xu }
    ]);
  }
};
var aA = new iA();
var nA = class extends MessageType {
  constructor() {
    super("socket.plugin.DisablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "disabled_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var rg = new nA();
var oA = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreItem", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "store_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var cA = new oA();
var dA = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginStoreResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "store_items", kind: "message", repeat: 1, T: () => cA }
    ]);
  }
};
var ig = new dA();
var lA = class extends MessageType {
  constructor() {
    super("socket.plugin.PluginEventResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var ag = new lA();
var uA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.LiveStreamingEvent", [
      {
        no: 1,
        name: "livestream_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "playback_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "org_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "room_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "manual_ingest",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var ng = new uA();
var hA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.GetStagePeersResponse", [
      {
        no: 1,
        name: "stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var og = new hA();
var pA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.StageRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var gA = new pA();
var mA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.GetStageRequestsResponse", [
      { no: 1, name: "stage_requests", kind: "message", repeat: 1, T: () => gA }
    ]);
  }
};
var mu = new mA();
var fA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.GrantStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var SA = new fA();
var vA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.DenyStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var yA = new vA();
var TA = class extends MessageType {
  constructor() {
    super("socket.livestreaming.LeaveStageRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var cg = new TA();
var EA = class extends MessageType {
  constructor() {
    super("socket.polls.Poll", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "created_by_user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "question",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "options", kind: "message", repeat: 1, T: () => PA },
      {
        no: 6,
        name: "hide_votes",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "anonymous",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "votes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var _f = new EA();
var _A = class extends MessageType {
  constructor() {
    super("socket.polls.PollOption", [
      {
        no: 1,
        name: "text",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        opt: true,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      { no: 3, name: "votes", kind: "message", repeat: 1, T: () => RA }
    ]);
  }
};
var PA = new _A();
var CA = class extends MessageType {
  constructor() {
    super("socket.polls.PollVote", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var RA = new CA();
var wA = class extends MessageType {
  constructor() {
    super("socket.polls.NewPollRequest", [
      {
        no: 1,
        name: "question",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "options",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "anonymous",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "hide_votes",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "created_by",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "created_by_user_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var bA = new wA();
var kA = class extends MessageType {
  constructor() {
    super("socket.polls.VotePollRequest", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "index",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
};
var IA = new kA();
var AA = class extends MessageType {
  constructor() {
    super("socket.polls.UpdatePollResponse", [
      { no: 1, name: "poll", kind: "message", T: () => _f }
    ]);
  }
};
var fu = new AA();
var MA = class extends MessageType {
  constructor() {
    super("socket.polls.GetPollsResponse", [
      { no: 1, name: "polls", kind: "message", repeat: 1, T: () => _f }
    ]);
  }
};
var DA = new MA();
var OA = class extends MessageType {
  constructor() {
    super("socket.recording.RecordingEvent", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", la] }
    ]);
  }
};
var dg = new OA();
var NA = class extends MessageType {
  constructor() {
    super("google.protobuf.Timestamp", [
      {
        no: 1,
        name: "seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "nanos",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  /**
   * Creates a new `Timestamp` for the current time.
   */
  now() {
    const t = this.create(), e = Date.now();
    return t.seconds = PbLong.from(Math.floor(e / 1e3)).toBigInt(), t.nanos = e % 1e3 * 1e6, t;
  }
  /**
   * Converts a `Timestamp` to a JavaScript Date.
   */
  toDate(t) {
    return new Date(PbLong.from(t.seconds).toNumber() * 1e3 + Math.ceil(t.nanos / 1e6));
  }
  /**
   * Converts a JavaScript Date to a `Timestamp`.
   */
  fromDate(t) {
    const e = this.create(), r = t.getTime();
    return e.seconds = PbLong.from(Math.floor(r / 1e3)).toBigInt(), e.nanos = r % 1e3 * 1e6, e;
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonWrite(t, e) {
    let r = PbLong.from(t.seconds).toNumber() * 1e3;
    if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (t.nanos < 0)
      throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
    let i = "Z";
    if (t.nanos > 0) {
      let n = (t.nanos + 1e9).toString().substring(1);
      n.substring(3) === "000000" ? i = "." + n.substring(0, 3) + "Z" : n.substring(6) === "000" ? i = "." + n.substring(0, 6) + "Z" : i = "." + n + "Z";
    }
    return new Date(r).toISOString().replace(".000Z", i);
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonRead(t, e, r) {
    if (typeof t != "string")
      throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(t) + ".");
    let i = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!i)
      throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
    let n = Date.parse(i[1] + "-" + i[2] + "-" + i[3] + "T" + i[4] + ":" + i[5] + ":" + i[6] + (i[8] ? i[8] : "Z"));
    if (Number.isNaN(n))
      throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
    if (n < Date.parse("0001-01-01T00:00:00Z") || n > Date.parse("9999-12-31T23:59:59Z"))
      throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    return r || (r = this.create()), r.seconds = PbLong.from(n / 1e3).toBigInt(), r.nanos = 0, i[7] && (r.nanos = parseInt("1" + i[7] + "0".repeat(9 - i[7].length)) - 1e9), r;
  }
};
new NA();
var VA = class extends MessageType {
  constructor() {
    super("common.BaseHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "room_object_id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "preset",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "use_start_session",
        kind: "scalar",
        opt: true,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Uu = new VA();
var LA = class extends MessageType {
  constructor() {
    super("common.BulkedHubMessage", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => Uu }
    ]);
  }
};
new LA();
var xA = class extends MessageType {
  constructor() {
    super("common.CFWorkersResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 1, T: () => Uu },
      { no: 2, name: "broadcast_responses", kind: "message", repeat: 1, T: () => Uu }
    ]);
  }
};
new xA();
var UA = 0;
var $A = 1;
var FA = 2;
var HA = 3;
var BA = 4;
var qA = 5;
var jA = {
  getPeerInfo: 0,
  updatePeerInfo: 1,
  getRoomPeersInfo: 2,
  joinRoom: 3,
  leaveRoom: 4,
  getRoomInfo: 5,
  updateRoomInfo: 6,
  closeRoom: 7,
  startedLivestream: 8,
  stoppedLivestream: 9,
  erroredLivestream: 10,
  getStagePeers: 11,
  getStageRequests: 12,
  requestStageAccess: 13,
  cancelStageRequest: 14,
  grantStageAccess: 15,
  denyStageAccess: 16,
  roomPeerCount: 17,
  joinStage: 18,
  leaveStage: 19,
  // getConnectedRoomsDump returns entire dump for a breakout rooms meeting
  // This details which peer is in which meeting currently, and which is the parent meeting
  getConnectedRoomsDump: 20,
  // createConnectedRooms to create breakout rooms
  createConnectedRooms: 21,
  // deleteConnectedRooms to delete breakout rooms
  deleteConnectedRooms: 22,
  // move peers between breakout rooms
  movePeers: 23,
  // transfer peer to new room
  transferPeer: 24,
  // message sent by socket service to inform client of a participant joining a breakout room
  movedPeer: 25,
  // message sent by socket service to inform client of updates in connected rooms
  connectedRoomsUpdated: 26,
  // message sent by socket service to inform client of deletion in connected rooms
  connectedRoomsDeleted: 27,
  // get all participants that have been added to the meeting irrespective of their live status
  getAllAddedParticipants: 28,
  // broadcast api
  broadcastMessage: 29,
  kick: 30,
  kickAll: 31,
  transcript: 32,
  // waitlist events
  getWaitingRoomRequests: 33,
  acceptWaitingRoomRequests: 34,
  waitingRoomRequestAccepted: 35,
  denyWaitingRoomRequests: 36,
  waitingRoomRequestDenied: 37,
  peerStageStatusUpdate: 38,
  broadcastToEntity: 39,
  recordingStarted: 40,
  recordingStopped: 41,
  recordingPaused: 42,
  getRoomStageState: 43,
  livestreamingInvoked: 44
};
var GA = {
  getMessages: 0,
  sendMessageToRoom: 1,
  sendMessageToPeers: 2,
  editMessage: 3,
  deleteMessage: 4,
  getPaginatedMessages: 5,
  sendMessageToChannel: 6,
  searchChannelMessages: 7,
  getAllChatChannels: 8,
  markChannelIndexAsRead: 9,
  pinMessage: 10
};
var WA = {
  getPlugins: 0,
  addPlugin: 1,
  enablePluginForRoom: 2,
  disablePluginForPeers: 3,
  enablePluginForPeers: 4,
  disablePluginForRoom: 5,
  removePlugin: 6,
  customPluginEventToRoom: 7,
  customPluginEventToPeers: 8,
  storeInsertKeys: 9,
  storeGetKeys: 10,
  storeDeleteKeys: 11,
  storeDelete: 12
};
var JA = {
  createPoll: 0,
  getPolls: 1,
  votePoll: 2,
  updatePoll: 3
};
var Pf = {
  unknown: 0,
  createWebRTCTransport: 1,
  produce: 2,
  consume: 3,
  toggleProducer: 4,
  toggleConsumer: 5,
  closeProducer: 6,
  closeConsumer: 7,
  updateConsumersSimulcastConfig: 8,
  // adding some buffers for new media events.
  joinRoom: 16,
  leaveRoom: 17,
  selectedPeer: 18,
  globalPinPeer: 19,
  selfJoinComplete: 20,
  // some additional buffer for broadcast events.
  peerJoinedBroadcast: 25,
  peerLeaveBroadcast: 26,
  peerProducerCreateBroadcast: 27,
  peerProducerToggleBroadcast: 28,
  peerProducerCloseBroadcast: 29,
  globalPeerPinBroadcast: 30,
  recordingStartedBroadcast: 31,
  recordingStoppedBroadcast: 32,
  peerDisplayNameEditBroadcast: 33,
  mediaRoomTerminationBroadcastResponse: 36,
  selectedPeerDiff: 40,
  renegotiateSessionDescription: 50,
  errorResponse: 60,
  kickPeer: 90,
  kickAll: 91,
  changeDisplayName: 92,
  hostControlPeer: 93,
  hostControlAllPeers: 94,
  // only for CF
  audioActivity: 100
};
var KA = {
  createChatChannel: 0,
  getChatChannel: 1,
  deprecatedGetAllChatChannels: 2,
  getChannelMembers: 3,
  updateChatChannel: 4
};
var zA = {
  getUserPresets: 0,
  updateUserPreset: 1
};
function Kn(s, t) {
  return Object.keys(t).reduce((e, r) => (e[r] = (s << 16) + t[r], e), {});
}
function Cf(s, t) {
  return Object.keys(s).reduce((e, r) => (e[r] = t | s[r], e), {});
}
var x = Kn(UA, jA);
var Re = Kn($A, GA);
var W = Kn(
  FA,
  WA
);
var qs = Kn(HA, JA);
var pi = Kn(
  BA,
  KA
);
var is = Cf(Pf, 16777216);
var Ts = Cf(Pf, 50331648);
var fd = Kn(
  qA,
  zA
);
var YA = Object.defineProperty;
var QA = Object.getOwnPropertyDescriptor;
var Oh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? QA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && YA(t, e, i), i;
};
var Mr;
var qa;
var bg;
var $u = (bg = class {
  constructor(s, t) {
    g(this, Mr, void 0);
    g(this, qa, void 0);
    m(this, Mr, t), m(this, qa, s);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, qa).getValue("telemetry");
  }
  /**
   * @private access
   * Not for external use
   */
  get logger() {
    return a(this, qa).getValue("logger");
  }
  createChannel(s, t, e, r = "public", i = false) {
    return u(this, null, function* () {
      const n = {
        displayName: s,
        targetUserIds: t,
        displayPictureUrl: e,
        visibility: r,
        isDirectMessage: i
      };
      i && (n.visibility = "private");
      const o = yield a(this, Mr).sendMessagePromise(
        pi.createChatChannel,
        vI.toBinary(n)
      ), c = Hs.fromBinary(
        o.payload
      ).chatChannels;
      return $u.formatChannel(c[0]);
    });
  }
  updateChannel(s, t) {
    return u(this, null, function* () {
      const e = yield a(this, Mr).sendMessagePromise(
        pi.updateChatChannel,
        TI.toBinary({
          chatChannelId: s,
          targetUserIds: t.memberIds,
          displayName: t.displayName,
          displayPictureUrl: t.displayPictureUrl,
          visibility: t.visibility
        })
      ), r = Hs.fromBinary(
        e.payload
      ).chatChannels;
      return $u.formatChannel(r[0]);
    });
  }
  static formatChannel(s) {
    var r;
    const { latestMessageAndUnreadCount: t } = s, e = B(D({}, s), {
      id: s.chatChannelId,
      memberIds: s.targetUserIds,
      unreadCount: (r = t == null ? void 0 : t.unreadCount) != null ? r : 0
    });
    return t != null && t.message && (e.latestMessage = Es.formatSocketServiceMessage(
      t.message
    )), delete e.chatChannelId, delete e.targetUserIds, delete e.latestMessageAndUnreadCount, e;
  }
  getChannelMembers(s) {
    return u(this, null, function* () {
      try {
        const t = yield a(this, Mr).sendMessagePromise(
          pi.getChannelMembers,
          PI.toBinary({ chatChannelId: s })
        );
        return DI.fromBinary(t.payload).channelMembers.map((i) => {
          var n = i, { id: e } = n, r = ho(n, ["id"]);
          return B(D({}, r), { userId: e });
        });
      } catch (t) {
        return [];
      }
    });
  }
  on(s, t) {
    let e, r;
    switch (s) {
      case pi.createChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
      case pi.updateChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
    }
    if (!e) {
      this.logger.warn(
        `ChatChannelSocketHandler::Event ${s} is not recognized`
      );
      return;
    }
    a(this, Mr).on(s, ({ payload: i }) => {
      let n = r;
      try {
        n = e(i);
      } catch (o) {
        this.logger.error("ChatChannelSocketHandler::on::binary_decode_error", {
          error: o
        });
      }
      return t(n);
    });
  }
}, Mr = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), bg);
var pa = $u;
Oh([
  E.trace("ChatChannelHandler.createChannel")
], pa.prototype, "createChannel", 1);
Oh([
  E.trace("ChatChannelHandler.updateChannel")
], pa.prototype, "updateChannel", 1);
Oh([
  E.trace("ChatChannelHandler.getChannelMembers")
], pa.prototype, "getChannelMembers", 1);
var XA = Object.defineProperty;
var ZA = Object.getOwnPropertyDescriptor;
var ws = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? ZA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && XA(t, e, i), i;
};
var _t = ((s) => (s[s.TEXT = 0] = "TEXT", s[s.IMAGE = 1] = "IMAGE", s[s.FILE = 2] = "FILE", s[s.CUSTOM = 3] = "CUSTOM", s))(_t || {});
var it;
var ja;
var as = class {
  constructor(t, e) {
    g(this, it, void 0);
    g(this, ja, void 0);
    m(this, it, e), m(this, ja, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ja).getValue("telemetry");
  }
  /**
   * @private access
   * Not available for external use
   */
  get logger() {
    return a(this, ja).getValue("logger");
  }
  getChatMessages() {
    return a(this, it).sendMessagePromise(Re.getMessages);
  }
  getChatMessagesPaginated(t, e, r, i = 0, n = "") {
    return u(this, null, function* () {
      const o = {
        timeStamp: t,
        size: e,
        from: i,
        reversed: r,
        channelId: n
      }, c = yield a(this, it).sendMessagePromise(
        Re.getPaginatedMessages,
        qk.toBinary(o)
      );
      return c.payload ? Gk.fromBinary(
        c.payload
      ) : {
        messages: [],
        next: false
      };
    });
  }
  sendMessageToRoom(t, e) {
    const r = {
      payloadType: e,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToRoom,
      Kk.toBinary(r)
    );
  }
  sendMessageToPeers(t, e, r) {
    const i = {
      payloadType: e,
      peerIds: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToPeers,
      Qk.toBinary(i)
    );
  }
  sendMessageToChannel(t, e, r) {
    const i = {
      payloadType: e,
      channelId: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToChannel,
      eI.toBinary(i)
    );
  }
  sendMessage(t, e, r, i) {
    if (i && this.sendMessageToChannel(t, e, i), r && r.length > 0) {
      this.sendMessageToPeers(t, e, r);
      return;
    }
    this.sendMessageToRoom(t, e);
  }
  editMessage(t, e, r, i, n) {
    return u(this, null, function* () {
      const o = {
        chatId: t,
        payloadType: r,
        payload: e
      };
      i && (o.channelId = i), n !== void 0 && (o.pinned = n);
      const c = yield a(this, it).sendMessagePromise(
        Re.editMessage,
        rI.toBinary(o)
      );
      return nd.fromBinary(c.payload).message;
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t
      };
      e && (r.channelId = e);
      const i = yield a(this, it).sendMessagePromise(
        Re.deleteMessage,
        dI.toBinary(r)
      ), n = od.fromBinary(i.payload);
      return D({
        id: n.chatId
      }, n.channelId ? { channelId: n.channelId } : {});
    });
  }
  searchMessages(t, e) {
    return u(this, null, function* () {
      var i, n, o;
      const r = {
        searchTerm: t,
        timeStamp: (i = e.timestamp) != null ? i : Date.now(),
        size: (n = e.size) != null ? n : 75,
        from: 0,
        reversed: (o = e.reversed) != null ? o : true
      };
      e.channelId && (r.channelId = e.channelId);
      try {
        const c = yield a(this, it).sendMessagePromise(
          Re.searchChannelMessages,
          hI.toBinary(r)
        );
        return Ef.fromBinary(c.payload).messages;
      } catch (c) {
        return [];
      }
    });
  }
  getAllChannels() {
    return u(this, null, function* () {
      try {
        const t = yield a(this, it).sendMessagePromise(
          Re.getAllChatChannels
        );
        return Hs.fromBinary(t.payload).chatChannels.map(pa.formatChannel);
      } catch (t) {
        return [];
      }
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      const r = yield a(this, it).sendMessagePromise(
        Re.markChannelIndexAsRead,
        gI.toBinary({
          channelId: t,
          userId: e.userId,
          channelIndex: e.channelIndex
        })
      );
      return fI.fromBinary(r.payload).channelIndex;
    });
  }
  setPinState(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t.id,
        pinned: e,
        channelId: t.channelId
      }, i = yield a(this, it).sendMessagePromise(
        Re.pinMessage,
        aI.toBinary(r)
      );
      return ad.fromBinary(i.payload);
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case Re.sendMessageToRoom: {
        r = pu.fromBinary.bind(
          pu
        ), i = pu.create();
        break;
      }
      case Re.sendMessageToPeers: {
        r = gu.fromBinary.bind(
          gu
        ), i = gu.create();
        break;
      }
      case Re.editMessage: {
        r = nd.fromBinary.bind(
          nd
        ), i = nd.create();
        break;
      }
      case Re.pinMessage: {
        r = ad.fromBinary.bind(
          ad
        ), i = ad.create();
        break;
      }
      case Re.deleteMessage: {
        r = od.fromBinary.bind(
          od
        ), i = od.create();
        break;
      }
    }
    if (!r) {
      this.logger.warn(`ChatSocketHandler::Event ${t} is not recognized`);
      return;
    }
    a(this, it).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
};
it = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap();
ws([
  E.trace("SocketService.getChatMessages")
], as.prototype, "getChatMessages", 1);
ws([
  E.trace("SocketService.getChatMessagesPaginated")
], as.prototype, "getChatMessagesPaginated", 1);
ws([
  E.trace("SocketService.sendMessageToRoom")
], as.prototype, "sendMessageToRoom", 1);
ws([
  E.trace("SocketService.sendMessageToPeers")
], as.prototype, "sendMessageToPeers", 1);
ws([
  E.trace("SocketService.sendMessageToChannel")
], as.prototype, "sendMessageToChannel", 1);
ws([
  E.trace("SocketService.sendMessage")
], as.prototype, "sendMessage", 1);
ws([
  E.trace("SocketService.editMessage")
], as.prototype, "editMessage", 1);
ws([
  E.trace("SocketService.deleteMessage")
], as.prototype, "deleteMessage", 1);
ws([
  E.trace("SocketService.searchMessages")
], as.prototype, "searchMessages", 1);
ws([
  E.trace("SocketService.getAllChannels")
], as.prototype, "getAllChannels", 1);
ws([
  E.trace("SocketService.markLastReadMessage")
], as.prototype, "markLastReadMessage", 1);
function eM(s) {
  return s.replace(
    /([-_]\w)/g,
    (t) => t[1].toUpperCase()
  );
}
function _s(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => _s(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = validate_default(e) ? e : eM(e);
    t[r] = _s(s[e]);
  }), t;
}
function tM(s) {
  return s.replace(
    /[A-Z]/g,
    (t) => `_${t.toLowerCase()}`
  );
}
function Rf(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => Rf(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = validate_default(e) ? e : tM(e);
    t[r] = s[e];
  }), t;
}
function Vd(s, t = {}) {
  return s == null ? {} : (Object.getOwnPropertyNames(s).forEach((e) => {
    if (typeof s[e] != "function") {
      if (typeof s[e] == "object") {
        Vd(s[e], t[e] = {});
        return;
      }
      t[e] = s[e];
    }
  }), t);
}
var lg = class {
  constructor(t) {
    h(this, "defaults");
    this.defaults = {
      baseURL: t.baseURL,
      headers: { common: {} },
      timeout: t.timeout,
      retry: t.retry,
      retryDelay: t.retryDelay
    };
  }
  buildURL(t, e) {
    const { baseURL: r } = this.defaults, i = t.startsWith("http") ? t : `${r}${t.startsWith("/") ? t : `/${t}`}`;
    if (e) {
      const n = new URLSearchParams();
      return Object.entries(e).forEach(([o, c]) => {
        n.append(o, c);
      }), `${i}${i.includes("?") ? "&" : "?"}${n.toString()}`;
    }
    return i;
  }
  request(t) {
    return u(this, null, function* () {
      var f2;
      const e = ((f2 = t.method) == null ? void 0 : f2.toUpperCase()) || "GET", r = this.buildURL(t.url || "", t.params), i = D(D({}, this.defaults.headers.common), t.headers);
      e !== "GET" && e !== "HEAD" && t.data && !i["Content-Type"] && (i["Content-Type"] = "application/json");
      const o = i["Content-Type"] === "application/json" ? JSON.stringify(t.data) : t.data, c = {
        method: e,
        headers: i,
        body: e !== "GET" && e !== "HEAD" && t.data ? o : void 0
      }, d = t.timeout || this.defaults.timeout, l = t.retry !== void 0 ? t.retry : this.defaults.retry, p = t.retryDelay || this.defaults.retryDelay;
      try {
        const S = new AbortController(), T = setTimeout(() => S.abort(), d);
        c.signal = S.signal;
        const _ = yield fetch(r, c);
        clearTimeout(T);
        let P = null;
        const w = _.headers.get("content-type");
        w && w.includes("application/json") ? P = yield _.json() : P = yield _.text();
        const A = {};
        _.headers.forEach((H, $) => {
          A[$] = H;
        });
        const N = {
          data: P,
          status: _.status,
          statusText: _.statusText,
          headers: A,
          config: t
        };
        if (!_.ok)
          throw N;
        return N;
      } catch (S) {
        if (S instanceof Error && l > 0)
          return yield new Promise((T) => setTimeout(T, p)), this.defaults.baseURL === "https://api.dyte.io" ? this.defaults.baseURL = "https://api.cluster.dyte.in" : this.defaults.baseURL === "https://api.cluster.dyte.in" && (this.defaults.baseURL = "https://api.dyte.io"), this.request(B(D({}, t), {
            retry: l - 1
          }));
        throw S;
      }
    });
  }
  get(r) {
    return u(this, arguments, function* (t, e = {}) {
      return this.request(B(D({}, e), {
        method: "GET",
        url: t
      }));
    });
  }
  post(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "POST",
        url: t,
        data: e
      }));
    });
  }
  put(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "PUT",
        url: t,
        data: e
      }));
    });
  }
};
var sM = 3;
var rM = 30;
var iM = 8e3;
var aM = class {
  constructor(t, e) {
    h(this, "ipInfo");
    h(this, "fetchClient");
    h(this, "requests");
    h(this, "roomName");
    h(this, "roomUUID");
    h(this, "authToken");
    h(this, "organizationId");
    h(this, "iceServers");
    h(this, "pluginInformation");
    h(this, "userDetails");
    h(this, "roomDetails");
    h(this, "context");
    this.context = t;
    const {
      timeout: r = iM,
      retry: i = sM,
      retryDelay: n = rM,
      baseURL: o = "https://api.dyte.io",
      authToken: c,
      cachedUserDetails: d
    } = e || {};
    this.iceServers = d == null ? void 0 : d.iceServers, this.pluginInformation = d == null ? void 0 : d.pluginInformation, this.userDetails = d == null ? void 0 : d.userDetails, this.roomDetails = d == null ? void 0 : d.roomDetails, this.requests = new lg({
      baseURL: o,
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.fetchClient = new lg({
      baseURL: "",
      // Empty baseURL for direct fetch calls
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.setAuthToken(c, { bearer: true });
    const l = this.requests.request.bind(this.requests);
    this.requests.request = (p) => u(this, null, function* () {
      var S, T, _, P, w;
      const f2 = t.getValue("telemetry");
      try {
        f2.injectContext(this.requests.defaults.headers.common);
        const A = yield l(p);
        return p.url !== f2.logsEndpoint && this.logger.debug("xhr::fetch", {
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: p.baseURL || this.requests.defaults.baseURL,
            url: p.url,
            method: p.method
          }
        }), A;
      } catch (A) {
        throw A ? (((S = A.config) == null ? void 0 : S.url) !== f2.logsEndpoint && this.logger.error("xhr::fetch", {
          error: A,
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: ((T = A.config) == null ? void 0 : T.baseURL) || this.requests.defaults.baseURL,
            url: (_ = A.config) == null ? void 0 : _.url,
            retries: (P = A.config) == null ? void 0 : P.retry,
            method: (w = A.config) == null ? void 0 : w.method,
            isOnline: navigator.onLine ? "online" : "offline"
          }
        }), new R(A.message || "Network request failed", "0011")) : new R("Unknown network error occurred", "0011");
      }
    });
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  setAuthToken(t, e) {
    const { bearer: r } = e || {};
    this.authToken = t, this.requests.defaults.headers.common.Authorization = r ? `Bearer ${t}` : t;
  }
  setHeader(t, e) {
    this.requests.defaults.headers.common[t] = e;
  }
  setRoomName(t) {
    this.roomName = t;
  }
  setRoomUUID(t) {
    this.roomUUID = t;
  }
  setOrganizationId(t) {
    this.organizationId = t;
  }
};
var nM = Object.defineProperty;
var oM = Object.getOwnPropertyDescriptor;
var ns = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? oM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && nM(t, e, i), i;
};
var jt = class extends aM {
  constructor(e, r) {
    super(e, r);
    h(this, "telemetry");
    this.telemetry = e.getValue("telemetry"), this.setHeader("x-dyte-web-core-version", e.getValue("sdkVersion"));
  }
  getIPDetails() {
    return u(this, null, function* () {
      var r;
      const { peerId: e } = this;
      try {
        const i = yield yh.getIPDetails({
          peerId: e,
          apiHostnames: cf(this.context),
          logger: ef
        });
        if (this.logger.log("ipInfo", { ipInfo: i }), ((r = i == null ? void 0 : i.loc) == null ? void 0 : r.length) > 5)
          return i;
        throw Error("Insufficient data");
      } catch (i) {
        this.logger.warn(
          "ApiClient.getRoomNodeLinkAndTitleV1 Failed to get ip details",
          { error: { name: i.name, message: i.message } }
        );
        return;
      }
    });
  }
  getICEServers() {
    return u(this, null, function* () {
      if (this.iceServers)
        return this.iceServers;
      const { success: e, iceServers: r } = (yield this.requests.get("/iceservers")).data;
      if (e)
        return (r == null ? void 0 : r.length) > 0 && (this.iceServers = r), r;
    });
  }
  getPlugins() {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f2;
      if (this.pluginInformation)
        return this.pluginInformation;
      const { plugins: e } = (yield this.requests.get("/v2/plugins/user")).data.data, r = ((o = (n = this.context.getValue("flagsmith").getValue(X.V1_PLUGINS)) == null ? void 0 : n.toString()) == null ? void 0 : o.split(",")) || [], i = e.reduce(
        (S, T) => (S[r.includes(T.id) ? "v1" : "v2"].push(B(D({}, T), { name: T.name.replace("v2", "") })), S),
        { v1: [], v2: [] }
      );
      return (l = (d = (c = this.context.getValue("modules")) == null ? void 0 : c.devTools) == null ? void 0 : d.plugins) != null && l.length && ((f2 = (p = this.context.getValue("modules")) == null ? void 0 : p.devTools) == null || f2.plugins.forEach((S) => {
        var _, P, w;
        const T = B(D({}, mo), {
          tags: [...mo.tags],
          baseUrl: `http://localhost:${S.port}`,
          name: S.name,
          picture: (_ = S.picture) != null ? _ : mo.picture,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          id: S.id,
          organizationId: this.organizationId,
          description: (P = S.description) != null ? P : mo.description,
          staggered: (w = S.staggered) != null ? w : mo.staggered
        });
        i.v2.push(T);
      })), i.v2;
    });
  }
  getPluginDetails(e) {
    return u(this, null, function* () {
      const { plugin: r } = (yield this.requests.get(`/v2/plugins/view/${e}`)).data.data;
      return r;
    });
  }
  getPluginConfig(e) {
    return u(this, null, function* () {
      return (yield this.fetchClient.get(`${e}/dyte-config.json`)).data;
    });
  }
  authorizePlugin(e) {
    return u(this, null, function* () {
      const r = {
        peerId: this.peerId
      }, { token: i } = (yield this.requests.post(`/v2/plugins/authorize/${e}`, r)).data.data;
      return i;
    });
  }
  getPresignedUrls(e, r) {
    return u(this, null, function* () {
      const i = Gn(this.context, "chat_upload_expiry"), n = {
        roomUUID: this.roomUUID,
        filename: e,
        expiry: typeof i == "number" ? i : void 0
      };
      this.context.getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK) && (n.viewType = r);
      const { getLocation: o, putLocation: c } = (yield this.requests.post("/v1/meetings/genPreSignedUploadUrl", n)).data.data;
      return {
        getLocation: o,
        putLocation: c
      };
    });
  }
  uploadFile(e, r) {
    return u(this, null, function* () {
      if (navigator.isReactNative && "uri" in e)
        try {
          yield fetch(r, {
            method: "PUT",
            headers: {
              "Content-Type": "application/octet-stream"
            },
            body: {
              uri: e.uri,
              name: e.name
            }
          });
        } catch (i) {
          this.logger.error(`sendFileMessage::${i}`);
        }
      else
        yield this.fetchClient.put(r, e, {
          headers: {
            "Content-Type": e.type
          }
        });
    });
  }
  // eslint-disable-next-line class-methods-use-this
  startLivestreaming(r) {
    return u(this, arguments, function* ({
      manualIngestion: e
    }) {
      const i = _s(
        yield this.requests.post(
          `/v2/meetings/${this.context.getValue("meetingId")}/livestreams`,
          {
            manual_ingest: !!e
          }
        )
      ).data.data;
      return {
        playbackUrl: i.playbackUrl,
        status: i.status,
        manualIngest: i.manualIngest,
        ingestionCredentials: i.streamKey ? {
          ingestionServer: i.ingestServer,
          streamKey: i.streamKey
        } : null
      };
    });
  }
  // eslint-disable-next-line class-methods-use-this
  stopLivestreaming() {
    return u(this, null, function* () {
      return this.requests.post(
        `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream/stop`
      );
    });
  }
  getActiveLivestream() {
    return u(this, null, function* () {
      const e = _s(
        (yield this.requests.get(
          `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream`
        )).data.data
      );
      return {
        playbackUrl: e.playbackUrl,
        status: e.status,
        manualIngest: e.manualIngest,
        ingestionCredentials: e.streamKey ? {
          ingestionServer: e.ingestServer,
          streamKey: e.streamKey
        } : null
      };
    });
  }
  getUserDetails() {
    return u(this, null, function* () {
      if (this.userDetails)
        return this.userDetails;
      const e = (yield this.requests.get("v2/internals/participant-details")).data.data;
      return _s(e);
    });
  }
  startRecording(e, r) {
    return u(this, null, function* () {
      return (yield this.requests.post("/v2/recordings", B(D({}, Rf(e)), {
        meeting_id: this.context.getValue("meetingId"),
        allow_multiple_recordings: !!r
      }))).data.data.id;
    });
  }
  updateRecording(e, r) {
    return u(this, null, function* () {
      return this.requests.put(`v2/recordings/${e}`, {
        action: r
      });
    });
  }
  getActiveRecording() {
    return u(this, null, function* () {
      const { status: e, id: r } = (yield this.requests.get(
        `v2/recordings/active-recording/${this.context.getValue("meetingId")}`
      )).data.data;
      return { status: e, id: r };
    });
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      const { transcript_download_url: e } = (yield this.requests.get(
        `v2/meetings/${this.context.getValue("meetingId")}/active-transcript`
      )).data.data;
      try {
        return { transcript: (yield this.fetchClient.get(e)).data };
      } catch (r) {
        throw new R("Cant fetch transcript s3 url", "1801");
      }
    });
  }
  getRoomNodeData() {
    return u(this, null, function* () {
      const e = yield this.getIPDetails();
      if (this.ipInfo = e, this.roomDetails)
        return this.roomDetails;
      const {
        roomNodeLink: r,
        title: i,
        useHiveMedia: n,
        sfu: o
      } = _s(
        (yield this.requests.post("v2/internals/rooms", {
          ip_information: e
        })).data.data
      );
      return {
        roomNodeUrl: r,
        meetingTitle: i,
        useHiveMedia: n != null ? n : false,
        sfu: o
      };
    });
  }
};
ns([
  E.trace("APIClient.getIPDetails")
], jt.prototype, "getIPDetails", 1);
ns([
  E.trace("APIClient.getICEServers")
], jt.prototype, "getICEServers", 1);
ns([
  E.trace("APIClient.getPlugins")
], jt.prototype, "getPlugins", 1);
ns([
  E.trace("APIClient.startLivestreaming")
], jt.prototype, "startLivestreaming", 1);
ns([
  E.trace("APIClient.stopLivestreaming")
], jt.prototype, "stopLivestreaming", 1);
ns([
  E.trace("APIClient.getActiveLivestream")
], jt.prototype, "getActiveLivestream", 1);
ns([
  E.trace("APIClient.getUserDetails")
], jt.prototype, "getUserDetails", 1);
ns([
  E.trace("APIClient.startRecording")
], jt.prototype, "startRecording", 1);
ns([
  E.trace("APIClient.stopRecording")
], jt.prototype, "updateRecording", 1);
ns([
  E.trace("APIClient.getActiveRecording")
], jt.prototype, "getActiveRecording", 1);
ns([
  E.trace("APIClient.getActiveTranscript")
], jt.prototype, "getActiveTranscript", 1);
ns([
  E.trace("APIClient.getRoomNodeData")
], jt.prototype, "getRoomNodeData", 1);
var Fu;
function cM(s, t) {
  return Fu = new jt(s, t), Fu;
}
function lt() {
  return Fu;
}
function dM(s, t) {
  return `<blockquote>${t.replace(/<blockquote>[.\s\S]*<\/blockquote>\n\n/m, "")}</blockquote>

${s}`;
}
var zn = {
  maxInvocations: 5,
  period: 1
};
function Dt(s, t) {
  return function(e, r, i) {
    const n = i.value;
    let o = 0, c = Date.now();
    return i.value = function(...d) {
      const l = Date.now(), p = t ? this[t] : s;
      if (l - c > p.period * 1e3 && (c = l, o = 0), o >= p.maxInvocations)
        throw new R(`Method rate limit ${p.maxInvocations} invocations/${p.period}sec exceeded`, "0013");
      return o += 1, n.apply(this, d);
    }, i;
  };
}
var lM = Object.defineProperty;
var uM = Object.getOwnPropertyDescriptor;
var pt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? uM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && lM(t, e, i), i;
};
var hM = ["text", "image", "file", "custom", "poll"];
var Sd = { maxInvocations: 180, period: 60 };
var ee;
var vi;
var Fe;
var yi;
var Ti;
var jd;
var wf;
var Fo;
var Hu;
var kg;
var Qe = (kg = class extends qt {
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    g(this, jd);
    g(this, Fo);
    h(this, "messages");
    h(this, "channels", []);
    g(this, ee, void 0);
    g(this, vi, void 0);
    g(this, Fe, void 0);
    g(this, yi, void 0);
    g(this, Ti, void 0);
    h(this, "maxTextLimit", 2e3);
    m(this, Ti, t), m(this, Fe, e), m(this, yi, r), m(this, ee, i), m(this, vi, n), this.messages = [];
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ti).getValue("telemetry");
  }
  /**
  	Set the max character limit of a text message
  */
  setMaxTextLimit(t) {
    this.maxTextLimit = t;
  }
  sendMessageInternal(n, o, c) {
    return u(this, arguments, function* (t, e, r, i = {}) {
      switch (t.type) {
        case "text": {
          const d = i.replyTo && i.replyTo.type === "text" ? dM(t.message, i.replyTo.message) : t.message;
          yield this.sendTextMessageInternal(d, e, r);
          break;
        }
        case "image":
          yield this.sendImageMessageInternal(t.image, e, r);
          break;
        case "file":
          yield this.sendFileMessageInternal(t.file, e, r);
          break;
        default:
          this.logger.error("sendMessage::message_type_not_supported", {
            dyteChat: { messageType: t.type }
          });
          break;
      }
    });
  }
  sendTextMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (t.length > this.maxTextLimit)
        throw new R("Max character limit breached", "0503");
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.text))
          throw this.logger.error("sendTextMessage::private_chat_permission_denied"), new R("Could not send message to private chat.", "0501");
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.text))
        throw this.logger.error("sendTextMessage::public_chat_permission_denied"), new R("Could not send message to public chat.", "0501");
      if (!t)
        throw this.logger.error("sendTextMessage::message_can_not_be_empty"), new R("Message can not be empty.", "0502");
      if (r) {
        a(this, Fe).sendMessageToChannel(t, _t.TEXT, r);
        return;
      }
      let i = [];
      e && e.length > 0 && (e.push(a(this, ee).id), i = a(this, vi).joined.toArray().filter((f2) => e.includes(f2.id)).map((f2) => f2.userId), i.push(a(this, ee).userId)), a(this, Fe).sendMessage(
        t,
        _t.TEXT,
        e
      );
    });
  }
  sendImageMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files)) {
          this.logger.error("sendImageMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.files)) {
        this.logger.error("sendImageMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(t.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", { dyteChat: { imageType: t.type } });
        return;
      }
      try {
        const f2 = lt(), { getLocation: S, putLocation: T } = yield f2.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield f2.uploadFile(t, T), r) {
          a(this, Fe).sendMessageToChannel(
            S,
            _t.IMAGE,
            r
          );
          return;
        }
        let _ = [];
        e && e.length > 0 && (e.push(a(this, ee).id), _ = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), _.push(a(this, ee).userId)), a(this, Fe).sendMessage(
          S,
          _t.IMAGE,
          e
        );
      } catch (f2) {
        throw new R("Error sending image message.", "0500", this.logger);
      }
    });
  }
  sendFileMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (e && e.length > 0) {
        if (!((i = a(this, ee).permissions) != null && i.chatPrivate.canSend) || !((n = a(this, ee).permissions) != null && n.chatPrivate.files)) {
          this.logger.error("sendFileMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const p = lt(), { getLocation: f2, putLocation: S } = yield p.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield p.uploadFile(t, S), r) {
          a(this, Fe).sendMessageToChannel(
            JSON.stringify({
              link: f2,
              name: t.name,
              size: "size" in t ? t.size : 0
            }),
            _t.FILE,
            r
          );
          return;
        }
        let T = [];
        e && e.length > 0 && (e.push(a(this, ee).id), T = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), T.push(a(this, ee).userId));
        const _ = JSON.stringify({
          link: f2,
          name: t.name,
          size: "size" in t ? t.size : 0
        });
        a(this, Fe).sendMessage(
          _,
          _t.FILE,
          e
        );
      } catch (p) {
        throw new R("Error sending file message.", "0500", this.logger);
      }
    });
  }
  // eslint-disable-next-line class-methods-use-this
  get rateLimits() {
    return Sd;
  }
  // eslint-disable-next-line class-methods-use-this
  updateRateLimits(t, e) {
    Sd.maxInvocations = t, Sd.period = e;
  }
  sendTextMessage(t, e) {
    return u(this, null, function* () {
      return this.sendTextMessageInternal(t, e);
    });
  }
  sendCustomMessage(t, e) {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f2, S, T, _, P, w, A, N, H;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files) || !((c = a(this, ee).permissions) != null && c.chatPrivate.text)) {
          this.logger.error("sendCustomMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.canSend) || !((f2 = (p = a(this, ee).permissions) == null ? void 0 : p.chatPublic) != null && f2.files) || !((T = (S = a(this, ee).permissions) == null ? void 0 : S.chatPublic) != null && T.text)) {
        this.logger.error("sendCustomMessage::permission_denied");
        return;
      }
      const r = ($) => u(this, null, function* () {
        try {
          if (typeof $ == "string")
            return { link: $ };
          const F = lt(), { getLocation: K, putLocation: re } = yield F.getPresignedUrls(
            $.name,
            a(this, ee).config.viewType
          );
          return yield F.uploadFile($, re), {
            link: K,
            type: $.type,
            name: $.name,
            size: $.size
          };
        } catch (F) {
          throw new R("Error sending image message.", "0500", this.logger);
        }
      }), i = B(D({}, t), {
        files: yield Promise.all((P = (_ = t.files) != null ? _ : []) == null ? void 0 : P.map(($) => u(this, null, function* () {
          return r($);
        }))),
        images: yield Promise.all((A = (w = t.images) != null ? w : []) == null ? void 0 : A.map(($) => u(this, null, function* () {
          return r($);
        }))),
        videos: yield Promise.all((H = (N = t.videos) != null ? N : []) == null ? void 0 : H.map(($) => u(this, null, function* () {
          return r($);
        })))
      });
      a(this, Fe).sendMessage(
        JSON.stringify(i),
        _t.CUSTOM,
        e
      );
    });
  }
  sendImageMessage(t, e) {
    return u(this, null, function* () {
      return this.sendImageMessageInternal(t, e);
    });
  }
  sendFileMessage(t, e) {
    return u(this, null, function* () {
      return this.sendFileMessageInternal(t, e);
    });
  }
  sendMessage(t, e) {
    return u(this, null, function* () {
      return this.sendMessageInternal(t, e);
    });
  }
  editTextMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatMessage) == null ? void 0 : n.canEdit) === "NONE")
        throw new R("Not permitted to edit messages", "0501");
      if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.text)) {
        this.logger.error("editTextMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editTextMessage::message_can_not_be_empty");
        return;
      }
      a(this, Fe).editMessage(
        t,
        e,
        _t.TEXT,
        r
      );
    });
  }
  editImageMessage(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d;
      if (!((o = (n = a(this, ee).permissions) == null ? void 0 : n.chatPublic) != null && o.canSend) || !((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.files)) {
        this.logger.error("editImageMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(e.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", {
          dyteChat: { imageType: e.type }
        });
        return;
      }
      try {
        const l = lt(), { getLocation: p, putLocation: f2 } = yield l.getPresignedUrls(e.name, a(this, ee).config.viewType);
        yield l.uploadFile(e, f2), a(this, Fe).editMessage(
          t,
          p,
          _t.IMAGE,
          r
        );
      } catch (l) {
        throw new R("Error editing image message.", "0500", this.logger);
      }
    });
  }
  editFileMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c;
      if (!((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatPublic) != null && n.canSend) || !((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const d = lt(), { getLocation: l, putLocation: p } = yield d.getPresignedUrls(
          e.name,
          a(this, ee).config.viewType
        );
        yield d.uploadFile(e, p), a(this, Fe).editMessage(
          t,
          JSON.stringify({
            link: l,
            name: e.name,
            size: "size" in e ? e.size : 0
          }),
          _t.FILE,
          r
        );
      } catch (d) {
        throw new R("Error editing file message.", "0500", this.logger);
      }
    });
  }
  editMessage(t, e, r) {
    return u(this, null, function* () {
      switch (e.type) {
        case "text": {
          this.editTextMessage(t, e.message, r);
          break;
        }
        case "image": {
          this.editImageMessage(t, e.image, r);
          break;
        }
        case "file": {
          this.editFileMessage(t, e.file, r);
          break;
        }
        default: {
          this.logger.error("editMessage::message_type_not_supported", {
            dyteChat: { messageType: e.type }
          });
          break;
        }
      }
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      var r, i;
      if (((i = (r = a(this, ee).permissions) == null ? void 0 : r.chatMessage) == null ? void 0 : i.canDelete) === "NONE")
        throw new R("Not permitted to delete messages", "0501");
      a(this, Fe).deleteMessage(t, e);
    });
  }
  /**
   * Returns an array of messages sent by a specific userId.
   * @param userId The user id of the user that sent the message.
   */
  getMessagesByUser(t) {
    return this.messages.filter((e) => e.userId === t);
  }
  /**
   * Returns an array of 'text', 'image' or 'file' messages.
   * @param type 'text', 'image', or 'file'.
   */
  getMessagesByType(t) {
    return this.messages.filter((e) => e.type === t);
  }
  /**
   * Pins a chat message
   * @param id ID of the message to be pinned
   */
  pin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t pin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to pin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, true);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  /**
   * Unpins a chat message
   * @param id ID of the message to be unpinned
   */
  unpin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t unpin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to unpin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, false);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  /**
   * Gets chat messages in a paginated manner
   */
  getMessages(t, e, r, i = 0, n = void 0) {
    return u(this, null, function* () {
      const o = yield a(this, Fe).getChatMessagesPaginated(t, e, r, i, n);
      return {
        messages: o.messages.map(
          (c) => Es.formatSocketServiceMessage(c)
        ),
        next: o.next
      };
    });
  }
  createChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      var l;
      const o = (l = a(this, ee).permissions) == null ? void 0 : l.chatChannel;
      if (o) {
        if (o.canCreate === "NONE")
          throw new R("Not permitted to create channels", "0501");
        if (r.visibility === "public" && !(o.canCreate === "PUBLIC" || o.canCreate === "ALL"))
          throw new R("Not permitted to create public channels", "0501");
        if (r.visibility === "private" && !(o.canCreate === "PRIVATE" || o.canCreate === "ALL"))
          throw new R("Not permitted to create private channels", "0501");
      }
      if (!t || t.trim().length === 0)
        throw new R("channel name cannot be empty.", "0510");
      const c = [.../* @__PURE__ */ new Set([...e, a(this, ee).userId])];
      return yield a(this, yi).createChannel(
        t.trim(),
        c,
        r.displayPictureUrl,
        r.visibility,
        r.isDirectMessage
      );
    });
  }
  updateChannel(t, e) {
    var o, c, d, l, p;
    const r = this.channels.find((f2) => f2.id === t), i = (o = a(this, ee).permissions) == null ? void 0 : o.chatChannel;
    if (i) {
      if (i.canUpdate === "NONE")
        throw new R("Not permitted to update channels", "0501");
      if (r.visibility === "public" && !(i.canUpdate === "PUBLIC" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update public channels", "0501");
      if (r.visibility === "private" && !(i.canUpdate === "PRIVATE" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update private channels", "0501");
    }
    const n = {
      memberIds: (c = e.memberIds) != null ? c : r.memberIds,
      displayName: (d = e.displayName) != null ? d : r.displayName,
      displayPictureUrl: (l = e.displayPictureUrl) != null ? l : r.displayPictureUrl,
      visibility: (p = e.visibility) != null ? p : r.visibility
    };
    return a(this, yi).updateChannel(t, n);
  }
  sendMessageToChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.sendMessageInternal(t, null, e, r);
    });
  }
  getChannelMembers(t) {
    return u(this, null, function* () {
      return a(this, yi).getChannelMembers(t);
    });
  }
  searchMessages(r) {
    return u(this, arguments, function* (t, e = {}) {
      if (!a(this, Ti).getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK_SEARCH))
        throw new R("searchMessages is temporarily disabled!", "0506");
      return (yield a(this, Fe).searchMessages(t, e)).map(Es.formatSocketServiceMessage);
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      yield a(this, Fe).markLastReadMessage(t, e);
      const r = this.channels.find((i) => i.id === t);
      if (r) {
        const i = B(D({}, r), { unreadCount: 0 });
        this.channels = this.channels.map((n) => n.id === t ? i : n), this.emit("channelMessageUpdate", i);
      }
    });
  }
  /**
   * Returns an array of pinned messages.
   */
  get pinned() {
    return this.messages.filter((t) => t.pinned);
  }
}, ee = /* @__PURE__ */ new WeakMap(), vi = /* @__PURE__ */ new WeakMap(), Fe = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ new WeakMap(), Ti = /* @__PURE__ */ new WeakMap(), jd = /* @__PURE__ */ new WeakSet(), wf = function() {
  return a(this, Ti).getValue("connectionHandler");
}, Fo = /* @__PURE__ */ new WeakSet(), Hu = function() {
  return a(this, jd, wf).socketJoined === true;
}, kg);
pt([
  E.trace("DyteChat.sendTextMessage"),
  Dt(Sd)
], Qe.prototype, "sendTextMessage", 1);
pt([
  E.trace("DyteChat.sendImageMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendImageMessage", 1);
pt([
  E.trace("DyteChat.sendFileMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendFileMessage", 1);
pt([
  E.trace("DyteChat.sendMessage"),
  Dt({ maxInvocations: 180, period: 60 })
], Qe.prototype, "sendMessage", 1);
pt([
  E.trace("DyteChat.editTextMessage")
], Qe.prototype, "editTextMessage", 1);
pt([
  E.trace("DyteChat.editImageMessage")
], Qe.prototype, "editImageMessage", 1);
pt([
  E.trace("DyteChat.editFileMessage")
], Qe.prototype, "editFileMessage", 1);
pt([
  E.trace("DyteChat.editMessage")
], Qe.prototype, "editMessage", 1);
pt([
  E.trace("DyteChat.deleteMessage")
], Qe.prototype, "deleteMessage", 1);
pt([
  E.trace("DyteChat.createChannel")
], Qe.prototype, "createChannel", 1);
pt([
  E.trace("DyteChat.updateChannel")
], Qe.prototype, "updateChannel", 1);
pt([
  E.trace("DyteChat.sendMessageToChannel")
], Qe.prototype, "sendMessageToChannel", 1);
pt([
  E.trace("DyteChat.getChannelMembers")
], Qe.prototype, "getChannelMembers", 1);
pt([
  E.trace("DyteChat.searchMessages")
], Qe.prototype, "searchMessages", 1);
pt([
  E.trace("DyteChat.markLastReadMessage")
], Qe.prototype, "markLastReadMessage", 1);
Qe = pt([
  ht("0500")
], Qe);
var pM = Object.defineProperty;
var gM = Object.getOwnPropertyDescriptor;
var mM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? gM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && pM(t, e, i), i;
};
var Dr;
var Ig;
var ci = (Ig = class {
  constructor(s, t, e, r, i) {
    h(this, "chat");
    h(this, "chatSocketHandler");
    h(this, "chatChannelSocketHandler");
    h(this, "self");
    g(this, Dr, void 0);
    m(this, Dr, s), this.chatSocketHandler = t, this.chatChannelSocketHandler = e, this.chat = new Qe(
      s,
      t,
      e,
      r,
      i
    ), this.self = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Dr).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Dr).getValue("logger");
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      return new ci(
        s,
        t,
        e,
        r,
        i
      );
    });
  }
  static formatMessage(s) {
    return B(D({}, s), {
      time: new Date(s.time),
      type: hM[s.type]
    });
  }
  /**
   * @access private
   * This function formates the chat message coming from
   * socket service. This is not meant for external use.
   */
  static formatSocketServiceMessage(s) {
    const t = s.createdAt * 1e3, e = {
      displayName: s.displayName,
      id: s.chatId,
      time: t,
      timeMs: s.createdAtMs,
      type: s.payloadType,
      isEdited: s.isEdited,
      userId: s.userId,
      targetUserIds: s.targetUserIds,
      channelId: s.channelId,
      channelIndex: s.channelIndex,
      message: "",
      link: "",
      name: "",
      html: "",
      images: [],
      videos: [],
      files: [],
      size: 0,
      pinned: s.pinned
    };
    switch (e.type) {
      case _t.TEXT: {
        e.message = s.payload;
        break;
      }
      case _t.IMAGE: {
        e.link = s.payload;
        break;
      }
      case _t.FILE: {
        const { link: r, name: i, size: n } = JSON.parse(s.payload);
        e.link = r, e.name = i, e.size = n;
        break;
      }
      case _t.CUSTOM: {
        const {
          html: r,
          images: i,
          message: n,
          videos: o,
          files: c
        } = JSON.parse(s.payload);
        e.message = n, e.html = r, e.images = i, e.videos = o, e.files = c;
        break;
      }
    }
    return ci.formatMessage(e);
  }
  getChatMessages() {
    return u(this, null, function* () {
      if (this.self.config.viewType === "LIVESTREAM" || this.self.config.viewType === "CHAT" || a(this, Dr).getValue("flagsmith").hasFeature(X.FEAT_PAGINATED_CHAT))
        return;
      const s = yield this.chatSocketHandler.getChatMessages();
      if (!(s != null && s.payload))
        return;
      const t = Ef.fromBinary(
        s.payload
      ).messages;
      this.chat.messages = t.map(
        (e) => ci.formatSocketServiceMessage(e)
      );
    });
  }
  setupEvents() {
    a(this, Dr).getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => u(this, null, function* () {
        this.getChatMessages();
      })
    ), this.chatSocketHandler.on(
      Re.sendMessageToRoom,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (!t.channelId)
          this.chat.messages = [...this.chat.messages, t];
        else {
          const e = this.chat.channels.find((r) => r.id === t.channelId);
          e && (e.latestMessage = t, e.unreadCount += 1, this.chat.emit("channelMessageUpdate", e));
        }
        this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.sendMessageToPeers,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        this.chat.messages = [...this.chat.messages, t], this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.editMessage,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (t.channelId) {
          this.chat.emit("chatUpdate", {
            action: "edit",
            message: t,
            messages: this.chat.messages
          });
          return;
        }
        const e = this.chat.messages.findIndex((r) => r.id === t.id);
        e !== -1 && (this.chat.messages[e] = t, this.chat.emit("chatUpdate", {
          action: "edit",
          message: t,
          messages: this.chat.messages
        }));
      }
    ), this.chatSocketHandler.on(
      Re.deleteMessage,
      (s) => {
        if (s.channelId) {
          this.chat.emit("chatUpdate", {
            action: "delete",
            message: { id: s.chatId, channelId: s.channelId },
            messages: this.chat.messages
          });
          return;
        }
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const [e] = this.chat.messages.splice(t, 1);
        this.chat.emit("chatUpdate", {
          action: "delete",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.createChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels.push(e), this.chat.emit("channelCreate", e);
      }
    ), this.chatSocketHandler.on(
      Re.pinMessage,
      (s) => {
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const e = this.chat.messages[t];
        e.pinned = s.pinned, this.chat.messages[t] = e, this.chat.emit("chatUpdate", {
          action: "edit",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.updateChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels = this.chat.channels.map((r) => r.id === e.id ? e : r), this.chat.emit("channelUpdate", e);
      }
    );
  }
}, Dr = /* @__PURE__ */ new WeakMap(), Ig);
var Es = ci;
mM([
  E.trace("ChatController.setupEvents")
], Es.prototype, "setupEvents", 1);
var fM = Object.defineProperty;
var SM = Object.getOwnPropertyDescriptor;
var vM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? SM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && fM(t, e, i), i;
};
var Gd;
var bf;
var Wd;
var kf;
var Ga;
var Wa;
var Ho;
var Ag;
var Bu = (Ag = class extends qt {
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    g(this, Gd);
    g(this, Wd);
    h(this, "items");
    g(this, Ga, void 0);
    g(this, Wa, void 0);
    g(this, Ho, void 0);
    m(this, Ho, t), m(this, Ga, e), m(this, Wa, r), this.items = [];
  }
  /**
   * Creates a poll in the meeting.
   * @param question The question that is to be voted for.
   * @param options The options of the poll.
   * @param anonymous If true, the poll votes are anonymous.
   * @param hideVotes If true, the votes on the poll are hidden.
   */
  create(t, e, r = false, i = false) {
    return u(this, null, function* () {
      if (!a(this, Wd, kf))
        throw new R("Can't create polls without joining room", "0705");
      if (!a(this, Ga).permissions.polls.canCreate) {
        this.logger.error("DytePolls::create::permission_denied");
        return;
      }
      if (!t || !e) {
        this.logger.error("DytePolls::question_and_options_can_not_be_empty", {
          dytePolls: {
            hasQuestion: !!t,
            optionsLength: e == null ? void 0 : e.length
          }
        });
        return;
      }
      if (e.length < 2) {
        this.logger.error("DytePolls::there_must_be_at_least_two_options", {
          dytePolls: { hasQuestion: !!t, optionsLength: e.length }
        });
        return;
      }
      yield a(this, Wa).createPoll(
        t,
        e,
        r,
        i
      );
    });
  }
  /**
   * Casts a vote on an existing poll.
   * @param pollId The ID of the poll that is to be voted on.
   * @param index The index of the option.
   */
  vote(t, e) {
    return u(this, null, function* () {
      if (!a(this, Ga).permissions.polls.canVote) {
        this.logger.error("DytePolls::vote::permission_denied");
        return;
      }
      yield a(this, Wa).votePoll(t, e);
    });
  }
}, Gd = /* @__PURE__ */ new WeakSet(), bf = function() {
  return a(this, Ho).getValue("connectionHandler");
}, Wd = /* @__PURE__ */ new WeakSet(), kf = function() {
  var t;
  return ((t = a(this, Gd, bf)) == null ? void 0 : t.socketJoined) === true;
}, Ga = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), Ho = /* @__PURE__ */ new WeakMap(), Ag);
Bu = vM([
  ht("0700")
], Bu);
var yM = Object.defineProperty;
var TM = Object.getOwnPropertyDescriptor;
var EM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yM(t, e, i), i;
};
var Or;
var Ja;
var Ei;
var Mg;
var Ra = (Mg = class {
  constructor(s, t, e) {
    h(this, "polls");
    g(this, Or, void 0);
    g(this, Ja, void 0);
    g(this, Ei, void 0);
    this.polls = new Bu(s, t, e), m(this, Ja, t), m(this, Or, s), m(this, Ei, e), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Or).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Or).getValue("logger");
  }
  static init(s, t, e) {
    return u(this, null, function* () {
      return new Ra(s, t, e);
    });
  }
  canViewPolls() {
    return a(this, Ja).permissions.polls.canView;
  }
  setupEvents() {
    const s = {
      [qs.createPoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.updatePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.votePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      }
    }, t = () => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).on(r, s[r]);
      });
    }, e = () => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).removeListeners(r);
      });
    };
    a(this, Ja).permissions.on("permissionsUpdate", (r) => u(this, null, function* () {
      var i;
      r != null && r.polls && ((i = r == null ? void 0 : r.polls) != null && i.canView ? (yield this.getPolls(), t()) : (this.polls.items = [], e()));
    })), this.canViewPolls() && t();
  }
  updatePoll(s) {
    if (!this.canViewPolls())
      return;
    const t = this.polls.items.findIndex((e) => e.id === s.id);
    if (t > -1) {
      const e = JSON.stringify(this.polls.items[t]);
      this.polls.items[t] = s, e !== JSON.stringify(s) && this.polls.emit("pollsUpdate", {
        polls: this.polls.items,
        newPoll: false
      });
      return;
    }
    this.polls.items = [...this.polls.items, s], this.polls.emit("pollsUpdate", { polls: this.polls.items, newPoll: true });
  }
  getPolls() {
    return u(this, null, function* () {
      const s = yield a(this, Ei).getPolls();
      if (!(s != null && s.payload))
        return;
      const { polls: t } = DA.fromBinary(s.payload);
      this.polls.items = t.map(
        (e) => Ra.formatSocketServicePoll(e)
      );
    });
  }
  static formatSocketServicePoll(s) {
    const t = s.options.map((e) => ({
      count: e.count,
      text: e.text,
      votes: e.votes.map((r) => ({
        id: r.userId,
        name: r.name
      }))
    }));
    return {
      anonymous: s.anonymous,
      createdBy: s.createdBy,
      createdByUserId: s.createdByUserId,
      hideVotes: s.hideVotes,
      id: s.pollId,
      options: t,
      question: s.question,
      voted: s.votes
    };
  }
}, Or = /* @__PURE__ */ new WeakMap(), Ja = /* @__PURE__ */ new WeakMap(), Ei = /* @__PURE__ */ new WeakMap(), Mg);
var If = Ra;
EM([
  E.trace("PollController.setupEvents")
], If.prototype, "setupEvents", 1);
var _M = Object.defineProperty;
var PM = Object.getOwnPropertyDescriptor;
var CM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? PM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && _M(t, e, i), i;
};
var Af = ((s) => (s[s.User = 0] = "User", s[s.Meeting = 1] = "Meeting", s))(Af || {});
var Ka;
var Bo;
var ju;
var _i;
var qo;
var Dg;
var qu = (Dg = class extends qt {
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    g(this, Bo);
    h(this, "selfActiveTab");
    h(this, "broadcastTabChanges");
    g(this, Ka, void 0);
    g(this, _i, void 0);
    g(this, qo, void 0);
    h(this, "viewType");
    h(this, "meetingStartedTimestamp");
    h(this, "meetingTitle");
    h(this, "sessionId");
    m(this, Ka, t), m(this, _i, e), this.viewType = r, m(this, qo, i), this.meetingTitle = n, this.broadcastTabChanges = e.permissions.canSpotlight;
  }
  get socketState() {
    return a(this, Bo, ju).socketState;
  }
  get mediaState() {
    return a(this, Bo, ju).mediaState;
  }
  /**
   * The room name of the meeting.
   */
  get meetingId() {
    return a(this, Ka).getValue("meetingId");
  }
  /**
   * Sets current user as broadcasting tab changes
   * @param broadcastTabChanges
   */
  setBroadcastTabChanges(t) {
    if (!a(this, _i).permissions.canSpotlight)
      throw this.logger.error("DyteSpotlight::setSpotlighted::permission_denied"), new R("User does not have permission to toggle spotlight", "0801");
    this.broadcastTabChanges = t, this.emit("broadcastTabChangesUpdate", this.broadcastTabChanges), this.broadcastTabChanges && this.assertActiveTabToRoom();
  }
  /**
   * Sets current active tab for user
   * @param spotlightTab
   */
  setSelfActiveTab(t, e) {
    var r;
    this.logger.info("DyteSpotlight::setActiveTab", {
      spotlight: {
        currentTab: {
          id: t.id,
          type: t.type
        }
      }
    }), this.selfActiveTab = t, e === 0 && this.emit("selfTabUpdate", t), (r = a(this, _i).permissions) != null && r.canSpotlight && this.broadcastTabChanges && e === 0 && this.assertActiveTabToRoom();
  }
  assertActiveTabToRoom() {
    a(this, qo).broadcastMessage("spotlight", {
      userId: a(this, _i).userId,
      currentTab: this.selfActiveTab
    });
  }
}, Ka = /* @__PURE__ */ new WeakMap(), Bo = /* @__PURE__ */ new WeakSet(), ju = function() {
  return a(this, Ka).getValue("connectionHandler");
}, _i = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(), Dg);
qu = CM([
  ht("0800")
], qu);
function RM(s) {
  let t = "", e = [""];
  const r = [e];
  let i = 0, n = 0, o = true, c;
  for (c of s)
    c === '"' ? (o && c === t && (e[i] += c), o = !o) : c === "," && o ? c = e[++i] = "" : c === `
` && o ? (t === "\r" && (e[i] = e[i].slice(0, -1)), e = r[++n] = [c = ""], i = 0) : e[i] += c, t = c;
  return r;
}
var wM = Object.defineProperty;
var bM = Object.getOwnPropertyDescriptor;
var Mf = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? bM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && wM(t, e, i), i;
};
var jo;
var Og;
var ei = (Og = class extends qt {
  constructor(t) {
    const e = t.getValue("logger");
    super(e);
    h(this, "transcripts");
    g(this, jo, void 0);
    m(this, jo, t), this.transcripts = [];
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, jo).getValue("telemetry");
  }
  static init(t, e) {
    return u(this, null, function* () {
      const r = new ei(t), i = t.getValue("logger");
      try {
        e && r.getActiveTranscript();
      } catch (n) {
        i.error("Error fetching active transcriptions ", n);
      }
      return r;
    });
  }
  /**
  * Parse a single line transcript
  */
  static parseTranscript(t, e = false) {
    if (!t)
      return;
    const [[
      r,
      i,
      n,
      o,
      c,
      d
    ]] = RM(t);
    return {
      id: v4_default(),
      name: c,
      peerId: i,
      userId: n,
      customParticipantId: o,
      transcript: d,
      isPartialTranscript: e,
      date: new Date(parseInt(r, 10) * 1e3)
    };
  }
  /**
  * Parse a multi-line transcript
  */
  static parseTranscripts(t) {
    return t ? t.split(`
`).map((e) => ei.parseTranscript(e, false)).filter(Boolean) : [];
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      try {
        const t = lt(), { transcript: e } = yield t.getActiveTranscript();
        this.transcripts = ei.parseTranscripts(e);
      } catch (t) {
      }
    });
  }
  onTranscript(t) {
    return u(this, null, function* () {
      var r;
      const e = this.transcripts.filter(({ peerId: i }) => i === t.peerId);
      if ((r = e == null ? void 0 : e.at(-1)) != null && r.isPartialTranscript) {
        const i = e.at(-1);
        i.transcript = t.transcript, i.isPartialTranscript = t.isPartialTranscript, this.emit("transcript", i);
        return;
      }
      this.transcripts = [...this.transcripts, t], this.emit("transcript", t);
    });
  }
}, jo = /* @__PURE__ */ new WeakMap(), Og);
Mf([
  E.trace("DyteAi.getActiveTranscript")
], ei.prototype, "getActiveTranscript", 1);
ei = Mf([
  ht("0000")
], ei);
var kM = Object.defineProperty;
var IM = Object.getOwnPropertyDescriptor;
var AM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? IM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && kM(t, e, i), i;
};
var Nr;
var za;
var xt;
var Ng;
var Df = (Ng = class {
  constructor(s, t, e, r, i, n) {
    h(this, "meta");
    h(this, "ai");
    g(this, Nr, void 0);
    g(this, za, void 0);
    h(this, "aiSocketHandler");
    g(this, xt, void 0);
    m(this, xt, s), this.meta = new qu(
      s,
      t,
      t.config.viewType,
      e,
      n
    ), this.ai = r, m(this, Nr, t), m(this, za, e), this.aiSocketHandler = i, t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, xt).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, xt).getValue("logger");
  }
  /**
   *
   */
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = yield ei.init(s, t.permissions.transcriptionEnabled);
      return new Df(
        s,
        t,
        e,
        n,
        r,
        i
      );
    });
  }
  conditionallySetActiveTab(s) {
    var t;
    s != null && s.currentTab && ((t = this.meta.selfActiveTab) == null ? void 0 : t.id) !== s.currentTab.id && (this.meta.setSelfActiveTab(
      s.currentTab,
      Af.Meeting
    ), this.meta.emit(
      "activeTabUpdate",
      s.currentTab
    ));
  }
  setupEvents() {
    a(this, xt).getValue("peerSessionStore").on(
      k.TRANSPORT_STATE_UPDATE,
      (s) => {
        this.meta.emit("mediaConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.SOCKET_STATE_UPDATE,
      (s) => {
        this.meta.emit("socketConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(k.ROOM_STATE, ({ createdAt: s, roomUuid: t }) => {
      const e = this.meta.meetingStartedTimestamp;
      if (t && (this.meta.sessionId = t), s && !e) {
        const r = new Date(s * 1e3);
        this.meta.meetingStartedTimestamp = r, this.meta.emit("meetingStartTimeUpdate", {
          meetingStartedTimestamp: this.meta.meetingStartedTimestamp
        });
      }
    }), a(this, xt).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({ score: s }) => {
        s < 5 && this.meta.emit("poorConnection", { score: s });
      }
    ), a(this, Nr).permissions.canSpotlight && (this.logger.info("DyteMetaController::Asserting Spotlight"), this.meta.selfActiveTab && a(this, za).broadcastMessage("spotlight", {
      userId: a(this, Nr).userId,
      currentTab: this.meta.selfActiveTab
    })), a(this, xt).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (s) => u(this, null, function* () {
        a(this, Nr).permissions.canSpotlight && this.meta.selfActiveTab && a(this, za).broadcastToPeers("spotlight", [s.id], {
          userId: a(this, Nr).userId,
          currentTab: this.meta.selfActiveTab
        });
      })
    ), a(this, xt).getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), this.aiSocketHandler.on(x.transcript, (s) => {
      const {
        meetingId: t,
        transcript: e,
        isPartial: r
      } = s;
      let i;
      try {
        i = ei.parseTranscript(e, r);
      } catch (d) {
        this.logger.error(`Failed to parse transcript: ${e}`, d);
      }
      if (!i) {
        this.logger.warn("Received empty transcript data");
        return;
      }
      this.ai.onTranscript(i), this.meta.emit("transcript", i);
      const { peerId: n, name: o, transcript: c } = i;
      this.logger.debug(`${t} Received transcript for peer ${n} - ${o}: ${c}`);
    });
  }
}, Nr = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), xt = /* @__PURE__ */ new WeakMap(), Ng);
var Of = Df;
AM([
  E.trace("MetaController.setupEvents")
], Of.prototype, "setupEvents", 1);
var So = {};
var Er = {
  /**
   * Lock a method to prevent concurrency
   * @param config - configuration for the lock
   * @param config.methodName - config.methodName Name of method to expose in logs
   *	and to the user (if necessary).
   * @param config.lockName - Unique string to differentiate the method from others.
   * @param config.timeout - Release lock in given milliseconds if method doesn't get resolved.
   *
   *	Do not use common function names such as joinRoom as the lockName,
   *	instead use filename.functionname, if a suitable name couldn't be found.
   * @returns locked instance.
   *
   * It will throw error with name `UnsupportedConcurrentMethodExecution`,
   *	if lock couldn't be acquired.
   *
   * Note:
   *	Make sure that the methodName is explanatory on its own, if exposed to end users.
   * Eg: `meeting.joinRoom` is a much better choice than `joinRoom`.
   */
  executeWithLock({
    methodName: s,
    lockName: t,
    timeout: e
  }) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var _, P;
        const l = (P = (this == null ? void 0 : this.peerId) || ((_ = d[0]) == null ? void 0 : _.authToken)) != null ? P : "", p = `${t}-${l}`, f2 = this == null ? void 0 : this.logger;
        if (So[p]) {
          const w = new Error(
            `Unsupported concurrent calls on Dyte method: ${s}.`
          );
          throw w.name = "UnsupportedConcurrentMethodExecution", f2 == null || f2.error("DyteLocker::UnsupportedConcurrentMethodExecution", {
            error: {
              stack: w.stack
            },
            dyteLocker: {
              methodName: s,
              lockName: p
            }
          }), w;
        }
        So[p] = true;
        const S = setTimeout(
          () => delete So[p],
          e
        ), T = o.apply(this, d);
        return Promise.resolve(T).then(() => {
          delete So[p], clearTimeout(S);
        }).catch(() => {
          delete So[p], clearTimeout(S);
        }), T;
      }, n;
    };
  }
};
var MM = Object.defineProperty;
var DM = Object.getOwnPropertyDescriptor;
var Ta = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? DM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && MM(t, e, i), i;
};
var Yt;
var Jd;
var ae;
var Go;
var Is;
var Ke;
var Wo;
var Gu;
var Ya;
var vd;
var ii = class extends qt {
  constructor(e, r, i, n, o) {
    const c = e.getValue("logger");
    super(c);
    g(this, Wo);
    g(this, Ya);
    g(this, Yt, void 0);
    g(this, Jd, void 0);
    g(this, ae, void 0);
    g(this, Go, void 0);
    g(this, Is, void 0);
    g(this, Ke, void 0);
    m(this, Ke, e), m(this, Yt, n), m(this, Jd, o), m(this, ae, r), m(this, Go, i), m(this, Is, []), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ke).getValue("telemetry");
  }
  get status() {
    return a(this, Ke).getValue("stageStatus");
  }
  setupEvents() {
    const e = {
      /**
       * NOTE(ishita1805): Update stageRequests when socket sends them.
       */
      [k.GET_STAGE_REQUESTS]: (n) => u(this, null, function* () {
        m(this, Is, n);
      }),
      /**
       * NOTE(ishita1805): Update stageRequests when a peer
       * who has requested leaves/joins the meeting
       */
      [k.UPDATE_STAGE_REQUESTS]: (o) => u(this, [o], function* ({ add: n }) {
        const c = a(this, Is).length, { stageRequests: d } = this.getAccessRequests();
        (n || d.length > c) && this.emit("newStageRequest", { count: d.length }), this.emit("stageAccessRequestUpdate", d);
      })
    }, r = () => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").onAsync(
          n,
          o
        );
      });
    }, i = () => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").removeListener(
          n,
          o
        );
      });
    };
    a(this, ae).permissions.on("permissionsUpdate", (n) => {
      const { canAcceptProductionRequests: o } = n;
      o !== void 0 && (a(this, ae).permissions.acceptStageRequests ? (r(), a(this, Yt).getStageRequests()) : (i(), m(this, Is, []), this.emit("stageAccessRequestUpdate", a(this, Is))));
    }), a(this, ae).permissions.acceptStageRequests && r();
  }
  getAccessRequests() {
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::get_access_request::permission_denied"), new R("You do not have permission to perform this action", "2001");
    const e = a(this, Go).joined.toArray().filter(
      (r) => r.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((r) => ({
      displayName: r.name,
      userId: r.userId,
      peerId: r.id
    }));
    return m(this, Is, e), { stageRequests: a(this, Is) };
  }
  requestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (this.status !== "OFF_STAGE")
        throw new R(
          `Unable to request access you are currently ${this.status}`,
          "2006"
        );
      if (a(this, ae).permissions.stageAccess === j.Allowed) {
        L(this, Ya, vd).call(this, "ACCEPTED_TO_JOIN_STAGE");
        return;
      }
      a(this, Yt).requestAccess(), L(this, Ya, vd).call(this, "REQUESTED_TO_JOIN_STAGE");
    });
  }
  cancelRequestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      a(this, Yt).cancelRequestAccess(), L(this, Ya, vd).call(this, "OFF_STAGE");
    });
  }
  grantAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t grant for participant without joining room"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::grant_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).grantAccess(e);
  }
  denyAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t rejectRequestToJoinStage for participant without joining room",
        "2005"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::deny_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).denyAccess(e);
  }
  /**
   * Returns the peerId of the current user
   */
  get peerId() {
    return a(this, Ke).getValue("peerId");
  }
  join() {
    return u(this, null, function* () {
      const e = a(this, Ke).getValue("viewType");
      if (this.status === "ON_STAGE")
        throw new R("You are already on stage.", "2006");
      if (this.status !== "ACCEPTED_TO_JOIN_STAGE" || a(this, ae).permissions.stageAccess === j.NotAllowed)
        throw new R(`Unable to join stage you are currently ${this.status}`, "2006");
      if (a(this, Ke).setValue("stageStatus", "ON_STAGE", false), yield a(this, Yt).joinStage(), e === Mt.Livestream) {
        yield a(this, Ke).getValue("selfController").joinRoom();
        return;
      }
      a(this, Ke).notify("stageStatus"), a(this, ae).audioEnabled && a(this, Wo, Gu).shareMic(a(this, ae).audioTrack), a(this, ae).videoEnabled && a(this, Wo, Gu).shareWebcam(a(this, ae).videoTrack);
    });
  }
  leave() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!(this.status === "ON_STAGE" || this.status === "ACCEPTED_TO_JOIN_STAGE"))
        throw new R(`Unable to leave stage you are currently ${this.status}`, "2006");
      a(this, ae).setIsPinned(false), a(this, Ke).setValue("stageStatus", "OFF_STAGE", false), yield a(this, Yt).leaveStage(a(this, ae).userId);
      try {
        yield a(this, Ke).getValue("peerSessionStore").emitAsync(k.LEAVE_MEDIA_ROOM, "stageLeft");
      } catch (e) {
        this.logger.error("DyteStage::leave::emitAsync::failed", { error: e });
      }
      a(this, Ke).notify("stageStatus");
    });
  }
  /**
   * Method to kick a user off the stage
   *
   * `permissions.acceptStageRequests` privilege required
   */
  kick(e) {
    return u(this, null, function* () {
      if (!a(this, ae).roomJoined)
        throw new R(
          "Can`t kick participant without joining room",
          "2005"
        );
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!a(this, ae).permissions.acceptStageRequests)
        throw this.logger.error("DyteStage::kick::permission_denied"), new R("You do not have permissions for kick", "2001");
      return a(this, Yt).kick(e);
    });
  }
};
Yt = /* @__PURE__ */ new WeakMap(), Jd = /* @__PURE__ */ new WeakMap(), ae = /* @__PURE__ */ new WeakMap(), Go = /* @__PURE__ */ new WeakMap(), Is = /* @__PURE__ */ new WeakMap(), Ke = /* @__PURE__ */ new WeakMap(), Wo = /* @__PURE__ */ new WeakSet(), Gu = function() {
  return a(this, Ke).getValue("roomNodeClient");
}, Ya = /* @__PURE__ */ new WeakSet(), vd = function(e) {
  return u(this, null, function* () {
    this.status !== e && a(this, Ke).setValue("stageStatus", e);
  });
};
Ta([
  E.trace("DyteStage.getStageRequests")
], ii.prototype, "getAccessRequests", 1);
Ta([
  E.trace("DyteStage.requestAccess")
], ii.prototype, "requestAccess", 1);
Ta([
  E.trace("DyteStage.cancelRequestAccess")
], ii.prototype, "cancelRequestAccess", 1);
Ta([
  E.trace("DyteStage.grantAccess")
], ii.prototype, "grantAccess", 1);
Ta([
  E.trace("DyteStage.denyAccess")
], ii.prototype, "denyAccess", 1);
Ta([
  Er.executeWithLock({
    methodName: "joinStage",
    lockName: "DyteStage.join",
    timeout: 5e3
  }),
  E.trace("DyteStage.joinStage")
], ii.prototype, "join", 1);
Ta([
  E.trace("DyteStage.leaveStage")
], ii.prototype, "leave", 1);
function OM(s) {
  return !(s.viewType === "LIVESTREAM" || s.viewType === "CHAT");
}
function Nh(s) {
  switch (s) {
    case pr.UNSPECIFIED:
      return "OFF_STAGE";
    case pr.REQUESTED_STAGE:
      return "REQUESTED_TO_JOIN_STAGE";
    case pr.APPROVED_STAGE:
      return "ACCEPTED_TO_JOIN_STAGE";
    case pr.OFF_STAGE:
      return "OFF_STAGE";
    case pr.ON_STAGE:
      return "ON_STAGE";
    default:
      return "OFF_STAGE";
  }
}
var NM = Object.defineProperty;
var VM = Object.getOwnPropertyDescriptor;
var LM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? VM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && NM(t, e, i), i;
};
var Vr;
var Pi;
var Lr;
var Jo;
var ft;
var Nf = class {
  constructor(t, e, r, i, n) {
    h(this, "stage");
    g(this, Vr, void 0);
    g(this, Pi, void 0);
    g(this, Lr, void 0);
    g(this, Jo, 0);
    g(this, ft, void 0);
    m(this, ft, t), this.stage = new ii(
      t,
      i,
      n,
      e,
      r
    ), m(this, Lr, e), m(this, Vr, i), m(this, Pi, n), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ft).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, ft).getValue("logger");
  }
  setupEvents() {
    a(this, ft).subscribe("stageStatus", (t) => {
      this.stage.emit("stageStatusUpdate", t);
    }), a(this, Lr).on(x.grantStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestApproved"), this.setStageStatus("ACCEPTED_TO_JOIN_STAGE"));
    }), a(this, Lr).on(x.peerStageStatusUpdate, (t) => {
      t !== void 0 && (t.peerId === a(this, Vr).id ? this.selfStageStatusHandler(t) : this.peerStageStatusHandler(t));
    }), a(this, Lr).on(x.denyStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestRejected"), this.setStageStatus("OFF_STAGE"));
    }), a(this, Lr).on(
      x.getStageRequests,
      (t) => u(this, null, function* () {
        var r;
        if (a(this, Vr).permissions.stageAccess !== j.Allowed)
          return;
        const e = (r = t == null ? void 0 : t.stageRequests) != null ? r : [];
        yield a(this, ft).getValue("peerSessionStore").emitAsync(k.GET_STAGE_REQUESTS, e), a(this, Jo) < e.length && e.length > 0 && this.stage.emit("newStageRequest", { count: e.length }), m(this, Jo, e.length), this.stage.emit("stageAccessRequestUpdate", e);
      })
    );
  }
  getCurrentStageRequests() {
    return a(this, Pi).joined.toArray().filter(
      (e) => e.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((e) => ({
      displayName: e.name,
      userId: e.userId,
      peerId: e.id
    }));
  }
  setStageStatus(t) {
    return u(this, null, function* () {
      this.stage.status !== t && a(this, ft).setValue("stageStatus", t);
    });
  }
  /**
   * NOTE(ishita1805): Runs for cases like:
   * - Being kicked from stage
   * - Socket-Client inconsistency
   */
  selfStageStatusHandler(t) {
    const e = Nh(t.stageType), r = a(this, ft).getValue("stageStatus");
    if (r !== e)
      switch (t.stageType) {
        case 1:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.join();
          break;
        case 2:
        case 3:
          this.setStageStatus(r);
          break;
        case 0:
        case 4:
        default:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.leave();
          break;
      }
  }
  /**
   * NOTE(ishita1805): Source of truth for updating peer stage status
   */
  peerStageStatusHandler(t) {
    return u(this, null, function* () {
      const e = a(this, Pi).joined.get(t.peerId), r = a(this, Pi).viewMode === "ACTIVE_GRID";
      if (!e) {
        this.logger.warn("err::peerStageStatusUpdate: participant not found");
        return;
      }
      switch (t.stageType) {
        case 1:
          e.setStageStatus("ON_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
        case 2:
          e.setStageStatus("ACCEPTED_TO_JOIN_STAGE");
          break;
        case 3:
          e.setStageStatus("REQUESTED_TO_JOIN_STAGE");
          break;
        case 0:
        case 4:
        default:
          e.setStageStatus("OFF_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
      }
      a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_PEER_STAGE_STATUS, {
        id: e.id,
        status: e.stageStatus
      });
    });
  }
};
Vr = /* @__PURE__ */ new WeakMap(), Pi = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap();
LM([
  E.trace("DyteStage.setupEvents")
], Nf.prototype, "setupEvents", 1);
var xM = Object.defineProperty;
var UM = Object.getOwnPropertyDescriptor;
var Wl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? UM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && xM(t, e, i), i;
};
var Ie = {
  getPeer: 14,
  getPeers: 15,
  chatMessage: 16,
  getRoomName: 17,
  getDisplayTitle: 18,
  getPluginInitiator: 19,
  customPluginEventToParent: 20,
  peerJoined: 22,
  peerLeft: 23,
  sendData: 24,
  stageStatusUpdate: 25,
  peerStageStatusUpdate: 26
};
var at;
var Ut;
var Qa;
var Xa;
var Ks;
var Za;
var xr;
var en;
var Vg;
var Wn = (Vg = class extends Jn {
  constructor(t, {
    baseURL: e,
    createdAt: r,
    description: i,
    id: n,
    name: o,
    organizationId: c,
    picture: d,
    private: l,
    published: p,
    staggered: f2,
    tags: S,
    type: T,
    updatedAt: _
  }, P, w, A, N, H) {
    const $ = t.getValue("logger");
    super($);
    g(this, at, void 0);
    h(this, "baseURL");
    h(this, "createdAt");
    h(this, "description");
    h(this, "id");
    h(this, "name");
    g(this, Ut, void 0);
    g(this, Qa, void 0);
    g(this, Xa, void 0);
    h(this, "organizationId");
    h(this, "picture");
    h(this, "private");
    h(this, "published");
    h(this, "staggered");
    h(this, "tags");
    h(this, "type");
    h(this, "updatedAt");
    g(this, Ks, void 0);
    h(this, "config");
    g(this, Za, void 0);
    h(this, "active");
    h(this, "iframes");
    h(this, "enabledBy");
    g(this, xr, void 0);
    g(this, en, void 0);
    m(this, xr, t), this.baseURL = e, this.createdAt = new Date(r), this.description = i, this.id = n, this.name = o, m(this, Ut, w), this.organizationId = c, this.picture = d, this.private = l, this.published = p, this.staggered = f2, this.tags = S, this.type = T, this.updatedAt = new Date(_), this.active = false, this.iframes = /* @__PURE__ */ new Map(), m(this, at, P), m(this, Qa, A), m(this, Xa, N), this.enabledBy = "", m(this, en, H);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, xr).getValue("telemetry");
  }
  /**
   * @access private
   * This function forwards events to plugin. This is not meant for external use.
   * @param message Socket message forwarded to this plugin.
   */
  sendIframeEvent(t) {
    this.iframes.size && this.iframes.forEach((e) => {
      const { iframe: r } = e;
      r && (navigator.isReactNative ? r.postMessage(JSON.stringify(t)) : r.contentWindow.postMessage(t, "*"));
    });
  }
  handleIframeMessage(t) {
    return u(this, null, function* () {
      var o;
      if (!this.active)
        return;
      const e = t, { payload: r, uuid: i, type: n } = e;
      switch (n) {
        case W.customPluginEventToRoom: {
          a(this, at).customPluginEventToRoom(
            this.id,
            r,
            i
          );
          break;
        }
        case W.customPluginEventToPeers: {
          a(this, at).customPluginEventToPeers(
            this.id,
            r.peerIds,
            r,
            i
          );
          break;
        }
        case W.enablePluginForRoom: {
          a(this, at).enablePluginForRoom(this.id, i);
          break;
        }
        case W.enablePluginForPeers: {
          a(this, at).enablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.disablePluginForRoom: {
          a(this, at).disablePluginForRoom(this.id, i);
          break;
        }
        case W.disablePluginForPeers: {
          a(this, at).disablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.storeInsertKeys: {
          a(this, at).storeInsertKeys(
            this.id,
            r.store,
            r.insertKeys,
            i
          );
          break;
        }
        case W.storeGetKeys: {
          a(this, at).storeGetKeys(
            this.id,
            r.store,
            r.getKeys,
            i
          );
          break;
        }
        case W.storeDeleteKeys: {
          a(this, at).storeDeleteKeys(
            this.id,
            r.store,
            r.deleteKeys,
            i
          );
          break;
        }
        case W.storeDelete: {
          a(this, at).storeDelete(this.id, r.store, i);
          break;
        }
        case Ie.chatMessage: {
          const {
            messagePayload: c,
            peerIds: d
          } = r;
          if (!a(this, Xa)) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { error: "Chat is disabled for this room." }
            });
            return;
          }
          try {
            yield a(this, Xa).sendMessage(c, d), this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { success: true }
            });
          } catch (l) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: {
                error: l
              }
            });
          }
          break;
        }
        case Ie.getPeer: {
          let c;
          const { peerId: d } = r, l = B(D({}, a(this, Ut)), {
            id: a(this, Ut).id,
            isRecorder: (o = a(this, Ut).permissions) == null ? void 0 : o.isRecorder,
            isHidden: a(this, Ut).permissions.hiddenParticipant,
            stageStatus: a(this, Ut).stageStatus
          });
          d ? (c = a(this, Qa).joined.get(r.peerId), a(this, Ut).id === d && (c = l)) : c = l, this.sendIframeEvent({
            type: Ie.getPeer,
            payload: { peer: c && Vd(c) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPeers: {
          const c = a(this, Qa).joined.toArray().map((d) => Vd(d));
          this.sendIframeEvent({
            type: Ie.getPeers,
            payload: { peers: c },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPluginInitiator: {
          this.sendIframeEvent({
            type: Ie.getPluginInitiator,
            payload: { enabledBy: this.enabledBy },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getDisplayTitle: {
          this.sendIframeEvent({
            type: Ie.getDisplayTitle,
            payload: { displayTitle: a(this, en) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getRoomName: {
          this.sendIframeEvent({
            type: Ie.getRoomName,
            payload: { roomName: a(this, xr).getValue("meetingId") },
            uuid: e.uuid
          });
          break;
        }
        case Ie.customPluginEventToParent: {
          this.emit(e.payload.eventName, e.payload.data);
          break;
        }
      }
    });
  }
  sendData(t) {
    this.active && (this.logger.info("DytePlugin::SendData", {
      plugin: {
        id: this.id,
        name: this.name,
        data: {
          eventName: t.eventName
        }
      }
    }), this.sendIframeEvent({
      type: Ie.sendData,
      uuid: "",
      payload: t
    }));
  }
  /**
   * This method is used for cleaning up event listeners attached to an iframe. It must
   * be used before the iframe is removed from the DOM.
   * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
   */
  removePluginView(t = "default") {
    var i;
    const { iframe: e, listener: r } = (i = this.iframes.get(t)) != null ? i : {};
    (e || r) && (navigator.isReactNative ? e.props.onMessage = void 0 : window.removeEventListener("message", r), this.iframes.delete(t));
  }
  /**
   * This method adds the communcation layer between the plugin inside the iframe
   * and the core application (meeting object) in the main window.
   * @param iframe Iframe element to display this plugin.
   * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
   */
  addPluginView(t, e = "default") {
    var o;
    if (!a(this, Za))
      throw this.logger.error(
        "DytePlugin::addPluginView::no_auth_token_set_for_plugin"
      ), new R("No auth token set for plugin.", "0602");
    if (!t)
      throw this.logger.error("DytePlugin::addPluginView::iframe_was_not_provided"), new R("Iframe was not provided.", "0603");
    this.removePluginView(e);
    const r = t, i = new URL(this.baseURL), n = {
      auth: a(this, Za),
      parent: navigator.isReactNative ? this.baseURL : window.location.origin,
      backend: a(this, xr).getValue("apiBase"),
      pluginId: this.id,
      roomName: (o = a(this, xr).getValue("meetingId")) != null ? o : "",
      displayTitle: a(this, en)
    };
    if (Object.keys(n).forEach((c) => {
      i.searchParams.set(c, n[c]);
    }), r.src = i.href, r.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", r.title = e, navigator.isReactNative)
      r.props.onMessage = (c) => {
        this.handleIframeMessage(JSON.parse(c.nativeEvent.data));
      }, this.iframes.set(e, { iframe: r });
    else {
      const c = (d) => u(this, null, function* () {
        d.source === t.contentWindow && (yield this.handleIframeMessage(d.data));
      });
      window.addEventListener("message", c), this.iframes.set(e, { iframe: r, listener: c });
    }
  }
  setActive(t) {
    var e, r;
    if (this.active = t, t) {
      this.emit("stateUpdate", {
        active: this.active,
        pluginId: this.id,
        bind: this.addPluginView.bind(this),
        views: (e = this.config) == null ? void 0 : e.views
      });
      return;
    }
    this.active = false, this.emit("stateUpdate", {
      active: this.active,
      pluginId: this.id,
      views: (r = this.config) == null ? void 0 : r.views
    });
  }
  /**
   * @access private
   * Not for external use
   */
  // NOTE(roerohan): Enable this plugin for the current user.
  activateForSelf() {
    return u(this, null, function* () {
      const t = lt(), e = yield t.authorizePlugin(this.id);
      m(this, Za, e), m(this, Ks, /* @__PURE__ */ new Date());
      try {
        const r = yield t.getPluginConfig(this.baseURL);
        this.config = r;
      } catch (r) {
        this.logger.error("DytePlugin::activateForSelf", { error: r });
      }
      this.setActive(true), this.emit("enabled");
    });
  }
  /**
   * @access private
   * Not for external use
   */
  // NOTE(roerohan): Disable this plugin for the current user.
  deactivateForSelf() {
    Array.from(this.iframes.keys()).forEach((t) => {
      this.removePluginView(t);
    }), m(this, Ks, void 0), this.iframes.clear(), this.setActive(false), this.emit("closed");
  }
  /**
   * @deprecated
   */
  enable() {
    return u(this, null, function* () {
      return this.activateForSelf();
    });
  }
  /**
   * @deprecated
   */
  disable() {
    return this.deactivateForSelf();
  }
  activate() {
    return u(this, null, function* () {
      var t, e;
      this.active || (e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canStart && (a(this, at).addPlugin(this.id, this.staggered), m(this, Ks, /* @__PURE__ */ new Date()), this.logger.info("plugin::activated", {
        plugin: {
          id: this.id,
          enabledBy: this.enabledBy,
          name: this.name
        }
      }));
    });
  }
  deactivate() {
    return u(this, null, function* () {
      var t, e;
      this.active && (!((e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canClose) && this.enabledBy !== a(this, Ut).id || (a(this, at).removePlugin(this.id), this.logger.info("plugin::deactivated", {
        plugin: {
          id: this.id,
          name: this.name,
          duration: a(this, Ks) ? (/* @__PURE__ */ new Date()).getTime() - a(this, Ks).getTime() : 0
        }
      }), m(this, Ks, void 0)));
    });
  }
}, at = /* @__PURE__ */ new WeakMap(), Ut = /* @__PURE__ */ new WeakMap(), Qa = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), Ks = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), en = /* @__PURE__ */ new WeakMap(), Vg);
Wl([
  Dt({ maxInvocations: 5, period: 1 })
], Wn.prototype, "sendData", 1);
Wl([
  E.trace("DytePlugin.activatePlugin")
], Wn.prototype, "activate", 1);
Wl([
  E.trace("DytePlugin.deactivatePlugin")
], Wn.prototype, "deactivate", 1);
Wn = Wl([
  ht("0600")
], Wn);
var Ne;
var Ci;
var Vf = class extends Map {
  constructor(e, r = void 0) {
    const {
      onAddEvent: i,
      onDeleteEvent: n,
      onClearEvent: o
    } = e;
    super();
    g(this, Ne, void 0);
    g(this, Ci, void 0);
    h(this, "onAddEvent");
    h(this, "onDeleteEvent");
    h(this, "onClearEvent");
    m(this, Ne, new Jn(r)), this.onAddEvent = i, this.onDeleteEvent = n, this.onClearEvent = o, m(this, Ci, /* @__PURE__ */ new Map());
  }
  emit(e, ...r) {
    return a(this, Ne).emit(e, ...r);
  }
  on(e, r) {
    return a(this, Ne).on(e, r);
  }
  addListener(e, r) {
    return a(this, Ne).addListener(e, r);
  }
  off(e, r) {
    return a(this, Ne).off(e, r);
  }
  once(e, r) {
    return a(this, Ne).once(e, r);
  }
  prependListener(e, r) {
    return a(this, Ne).prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return a(this, Ne).prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return a(this, Ne).removeListener(e, r);
  }
  removeAllListeners(e) {
    return a(this, Ne).removeAllListeners(e);
  }
  listeners(e) {
    return a(this, Ne).listeners(e);
  }
  listenerCount(e) {
    return a(this, Ne).listenerCount(e);
  }
  getMaxListeners() {
    return a(this, Ne).getMaxListeners();
  }
  setMaxListeners(e) {
    return a(this, Ne).setMaxListeners(e);
  }
  eventNames() {
    return a(this, Ne).eventNames();
  }
  add(e, r = true) {
    return this.set(e.id, e, r);
  }
  set(e, r, i = true) {
    const n = super.set(e, r), o = (c, ...d) => {
      this.emit(c, r, ...d);
    };
    return a(this, Ci).set(e, o), r.on("*", o), i && a(this, Ne).emit(this.onAddEvent, r), n;
  }
  delete(e, r = true, i = false) {
    const n = this.get(e);
    if (!n)
      return false;
    n.removeListener("*", a(this, Ci).get(e));
    const o = super.delete(e);
    return i && n.removeAllListeners(), r && a(this, Ne).emit(this.onDeleteEvent, n), o;
  }
  clear(e = true, r = false) {
    this.forEach((n) => {
      n.removeListener("*", a(this, Ci).get(n.id)), r && n.removeAllListeners();
    });
    const i = super.clear();
    return e && a(this, Ne).emit(this.onClearEvent), i;
  }
  toArray() {
    return Array.from(this.values());
  }
};
Ne = /* @__PURE__ */ new WeakMap(), Ci = /* @__PURE__ */ new WeakMap();
var ug = class extends Vf {
  constructor(t) {
    super({
      onAddEvent: "pluginAdded",
      onDeleteEvent: "pluginDeleted"
    }, t);
  }
  add(t, e = true) {
    return super.add(t, e);
  }
  delete(t, e = true, r = false) {
    return super.delete(t, e, r);
  }
};
var $M = Object.defineProperty;
var FM = Object.getOwnPropertyDescriptor;
var HM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? FM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && $M(t, e, i), i;
};
var Wu = class {
  constructor(s) {
    h(this, "all");
    h(this, "active");
    this.all = new ug(s), this.active = new ug(s);
  }
};
Wu = HM([
  ht("0600")
], Wu);
var BM = Object.defineProperty;
var qM = Object.getOwnPropertyDescriptor;
var Jl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? qM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && BM(t, e, i), i;
};
var Qt;
var tn;
var ls;
var Lg;
var Lf = (Lg = class {
  constructor(s, t, e, r) {
    h(this, "plugins");
    g(this, Qt, void 0);
    g(this, tn, void 0);
    g(this, ls, void 0);
    m(this, Qt, t), m(this, tn, e), m(this, ls, s), this.plugins = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ls).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, ls).getValue("logger");
  }
  static init(s, t, e, r, i, n, o, c) {
    return u(this, null, function* () {
      const d = s.getValue("logger"), l = new Wu(d);
      return t.forEach((p) => {
        const f2 = new Wn(
          s,
          p,
          e,
          n,
          o,
          i,
          c
        );
        l.all.add(f2);
      }), new Lf(
        s,
        e,
        r,
        l
      );
    });
  }
  getRoomPlugins() {
    return u(this, null, function* () {
      var t;
      const { plugins: s } = yield a(this, Qt).getActivePlugins();
      (t = this.plugins.active) == null || t.toArray().forEach((e) => {
        this.disablePlugin({ id: e.id });
      }), yield Promise.all(
        s.map(
          (e) => this.enablePlugin({
            id: e.pluginId,
            enabledBy: e.enabledBy
          })
        )
      );
    });
  }
  enablePlugin(e) {
    return u(this, arguments, function* ({
      id: s,
      enabledBy: t
    }) {
      const r = this.plugins.all.get(s);
      r && (yield r.activateForSelf(), r.enabledBy = t);
    });
  }
  disablePlugin(t) {
    return u(this, arguments, function* ({ id: s }) {
      const e = this.plugins.all.get(s);
      e && e.deactivateForSelf();
    });
  }
  sendIframeEvent(s, t, e, r) {
    const i = this.plugins.all.get(t);
    i && i.sendIframeEvent({ type: s, uuid: e, payload: r });
  }
  broadcastIframeEvent(s, t) {
    this.plugins.active.forEach((e) => {
      this.sendIframeEvent(s, e.id, "", t);
    });
  }
  setupEvents() {
    this.plugins.all.on(
      "stateUpdate",
      ({ active: s, id: t }) => {
        if (s) {
          this.plugins.active.add(this.plugins.all.get(t));
          return;
        }
        this.plugins.active.delete(t);
      }
    ), a(this, ls).getValue("peerSessionStore").onAsync(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      yield this.getRoomPlugins(), this.logger.debug("[SOCKET_SERVICE_ROOM_JOINED] resolved request to fetch plugins.");
    })), a(this, Qt).on(
      W.addPlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active || (yield this.enablePlugin({ id: t, enabledBy: s.enabledBy }));
      })
    ), a(this, Qt).on(
      W.removePlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active && (yield this.disablePlugin({ id: t }));
      })
    ), [
      W.enablePluginForPeers,
      W.enablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            enabledBy: t.enabledBy
          });
        })
      );
    }), [
      W.disablePluginForPeers,
      W.disablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            disabledBy: t.disabledBy
          });
        })
      );
    }), [
      W.customPluginEventToPeers,
      W.customPluginEventToRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            data: JSON.parse(
              new TextDecoder().decode(t.pluginData)
            )
          });
        })
      );
    }), [
      W.storeInsertKeys,
      W.storeGetKeys,
      W.storeDeleteKeys
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          var i;
          const r = (i = t.storeItems) == null ? void 0 : i.map((n) => {
            var o;
            return {
              timestamp: n.timestamp,
              peerId: n.peerId,
              payload: JSON.parse(
                (o = n.payload) != null && o.length ? new TextDecoder().decode(n.payload) : "{}"
              ),
              key: n.storeKey
            };
          });
          this.sendIframeEvent(s, t.pluginId, e, {
            storeName: t.storeName,
            storeItems: r
          });
        })
      );
    }), a(this, Qt).on(
      W.storeDelete,
      (s, t) => u(this, null, function* () {
        this.sendIframeEvent(W.storeDelete, s.pluginId, t, {
          storeName: s.storeName
        });
      })
    ), a(this, tn).on(
      Re.sendMessageToPeers,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, tn).on(
      Re.sendMessageToRoom,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, ls).getValue("peerSessionStore").on(k.PEER_JOINED_INTERNAL, (s) => {
      const t = Vd(s);
      this.broadcastIframeEvent(Ie.peerJoined, t);
    }), a(this, ls).getValue("peerSessionStore").on(k.PEER_CLOSED, (s) => {
      this.broadcastIframeEvent(Ie.peerLeft, s);
    }), a(this, ls).getValue("peerSessionStore").on(k.UPDATE_PEER_STAGE_STATUS, (s) => {
      this.broadcastIframeEvent(Ie.peerStageStatusUpdate, s);
    }), a(this, ls).subscribe("stageStatus", (s) => {
      this.broadcastIframeEvent(Ie.stageStatusUpdate, s);
    });
  }
}, Qt = /* @__PURE__ */ new WeakMap(), tn = /* @__PURE__ */ new WeakMap(), ls = /* @__PURE__ */ new WeakMap(), Lg);
var Kc = Lf;
Jl([
  E.trace("PluginController.getRoomPlugins")
], Kc.prototype, "getRoomPlugins", 1);
Jl([
  E.trace("PluginController.enableForSelf")
], Kc.prototype, "enablePlugin", 1);
Jl([
  E.trace("PluginController.disableForSelf")
], Kc.prototype, "disablePlugin", 1);
Jl([
  E.trace("PluginController.setupEvents")
], Kc.prototype, "setupEvents", 1);
var Ko;
var jM = class {
  constructor(t) {
    h(this, "mediaJoined");
    h(this, "socketJoined");
    h(this, "socketJoinAttempted");
    h(this, "mediaJoinAttempted");
    h(this, "socketState");
    h(this, "mediaState");
    g(this, Ko, void 0);
    this.mediaJoined = false, this.socketJoined = false, this.socketJoinAttempted = false, this.mediaJoinAttempted = false, this.socketState = {
      state: void 0,
      reconnected: false,
      reconnectionAttempt: void 0
    }, this.mediaState = {
      recv: void 0,
      send: void 0
    }, m(this, Ko, t);
  }
  get joinAttempted() {
    return this.mediaJoinAttempted || this.socketJoinAttempted;
  }
  get roomJoined() {
    return this.mediaJoined && this.socketJoined;
  }
  updateSocketConnectionState(t, e) {
    let r;
    const { reconnected: i } = this.socketState;
    switch (t) {
      case "connected":
        r = {
          state: "connected",
          reconnected: i,
          reconnectionAttempt: void 0
        };
        break;
      case "disconnected":
        r = {
          state: "disconnected",
          reconnected: false,
          reconnectionAttempt: 0
        }, this.socketJoined = false;
        break;
      case "reconnected":
        r = {
          state: "connected",
          reconnected: true,
          reconnectionAttempt: void 0
        };
        break;
      case "reconnecting":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: 0
        };
        break;
      case "reconnectAttempt":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: e
        };
        break;
      case "failed":
        r = {
          state: "failed",
          reconnected: i,
          reconnectionAttempt: void 0
        }, this.socketJoined = false;
        break;
    }
    r && (a(this, Ko).getValue("peerSessionStore").emit(k.SOCKET_STATE_UPDATE, r), this.socketState = r);
  }
};
Ko = /* @__PURE__ */ new WeakMap();
var GM = Object.defineProperty;
var WM = Object.getOwnPropertyDescriptor;
var zc = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? WM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && GM(t, e, i), i;
};
var sn;
var rn;
var an;
var yd;
var xg;
var ga = (xg = class extends qt {
  constructor(t, e) {
    const r = t.getValue("logger");
    super(r);
    g(this, an);
    g(this, sn, void 0);
    g(this, rn, void 0);
    h(this, "recordingPeerIds", []);
    h(this, "recordings", []);
    m(this, rn, t), m(this, sn, e);
  }
  get recordingState() {
    return this.recordings.some((t) => t.state === "RECORDING") ? "RECORDING" : this.recordings.some((t) => t.state === "PAUSED") ? "PAUSED" : this.recordings.some((t) => t.state === "STARTING") ? "STARTING" : this.recordings.some((t) => t.state === "STOPPING") ? "STOPPING" : "IDLE";
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, rn).getValue("telemetry");
  }
  updateRecordings(t) {
    this.recordings = t, this.emit("recordingUpdate", this.recordingState);
  }
  start(t) {
    return u(this, null, function* () {
      if (!a(this, sn).permissions.canRecord)
        throw this.logger.error("DyteRecording::start::permission_denied"), new R("User does not have permission to start recording", "1001");
      if ((t == null ? void 0 : t.allowMultiple) !== true && (this.recordingState === "STARTING" || this.recordingState === "RECORDING" || this.recordingState === "STOPPING"))
        throw this.logger.error("DyteRecording::start::recording_in_progress", {
          recording: {
            state: this.recordingState
          }
        }), new R(
          `Cant start recording, recordingState irregular: ${this.recordingState}`,
          "1005"
        );
      try {
        const e = lt(), { recording: r = {} } = a(this, rn).getValue("defaults"), i = yield e.startRecording(r, t == null ? void 0 : t.allowMultiple);
        this.updateRecordings([...this.recordings, {
          id: i,
          state: "STARTING",
          type: "BROWSER"
        }]);
      } catch (e) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_start", {
          error: e
        }), new R("Error while starting recording", "1000", this.logger);
      }
    });
  }
  stop(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "stop", ["RECORDING", "PAUSED"], t);
    });
  }
  pause(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "pause", ["RECORDING"], t);
    });
  }
  resume(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "resume", ["PAUSED"], t);
    });
  }
}, sn = /* @__PURE__ */ new WeakMap(), rn = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakSet(), yd = function(t, e, r) {
  return u(this, null, function* () {
    if (!a(this, sn).permissions.canRecord)
      throw this.logger.error("DyteRecording::stop::permission_denied"), new R("User does not have permission to stop recording", "1001");
    let i = [];
    if (r !== void 0) {
      const n = this.recordings.find((o) => o.id === r);
      if (n === void 0)
        throw new R("Could not find the specified recording", "1004");
      if (e.includes(n.state)) {
        this.logger.error("DyteRecording::stop::recording_not_in_expected_state", {
          recording: {
            state: n.state
          }
        });
        return;
      }
      i.push(n);
    } else
      i = this.recordings.filter((n) => e.includes(n.state));
    i.forEach((n) => u(this, null, function* () {
      const o = n.state;
      t === "stop" && (n.state = "STOPPING", this.emit("recordingUpdate", "STOPPING"));
      try {
        yield lt().updateRecording(n.id, t);
      } catch (c) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_stop", {
          error: c
        }), n.state !== o && (n.state = o, this.emit("recordingUpdate", o)), new R("Error while stopping recording", "1000", this.logger);
      }
    }));
  });
}, xg);
zc([
  E.trace("DyteRecording.start")
], ga.prototype, "start", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "stop", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "pause", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "resume", 1);
ga = zc([
  ht("1000")
], ga);
var JM = Object.defineProperty;
var KM = Object.getOwnPropertyDescriptor;
var zM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JM(t, e, i), i;
};
var Ri;
var xf = class {
  constructor(t, e, r) {
    h(this, "recording");
    h(this, "room");
    g(this, Ri, void 0);
    m(this, Ri, t), this.recording = new ga(t, e), this.room = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ri).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ri).getValue("logger");
  }
  // eslint-disable-next-line class-methods-use-this
  getRecordingTypeFromProtoType(t) {
    let e;
    switch (t) {
      case la.BROWSER:
        e = "BROWSER";
        break;
      case la.COMPOSITE:
        e = "COMPOSITE";
        break;
      case la.TRACK:
        e = "TRACK";
        break;
      default:
        e = "BROWSER";
    }
    return e;
  }
  setupEvents() {
    a(this, Ri).getValue("peerSessionStore").on(k.ROOM_STATE, (t) => {
      t.activeRecordings.length !== 0 ? this.recording.updateRecordings(
        t.activeRecordings.map((e) => {
          const r = this.getRecordingTypeFromProtoType(e.recordingType);
          return { id: e.recordingId, state: e.recordingStatus, type: r };
        })
      ) : this.recording.recordings.length && this.recording.updateRecordings([]);
    }), this.room.on(x.recordingStarted, (t) => {
      let e = false;
      const r = [...this.recording.recordings];
      if (r.forEach((i) => {
        i.id === t.recordingId && (e = true, i.state = "RECORDING");
      }), e === false) {
        const i = this.getRecordingTypeFromProtoType(t.recordingType);
        r.push({
          id: t.recordingId,
          state: "RECORDING",
          type: i
        });
      }
      this.recording.updateRecordings(r);
    }), this.room.on(x.recordingPaused, (t) => {
      const e = [...this.recording.recordings];
      e.forEach((r) => {
        r.id === t.recordingId && (r.state = "PAUSED");
      }), this.recording.updateRecordings(e);
    }), this.room.on(x.recordingStopped, (t) => {
      const e = [...this.recording.recordings.filter((r) => r.id !== t.recordingId)];
      this.recording.updateRecordings(e);
    });
  }
};
Ri = /* @__PURE__ */ new WeakMap();
zM([
  E.trace("RecordingController.setupEvents")
], xf.prototype, "setupEvents", 1);
var wi;
var YM = class {
  constructor(t) {
    g(this, wi, void 0);
    m(this, wi, t);
  }
  hasFeature(t) {
    var e;
    return (e = a(this, wi).getValue("flagsmith").hasFeature(t)) != null ? e : false;
  }
  getFeatureValue(t) {
    return a(this, wi).getValue("flagsmith").getValue(t);
  }
  getAllFeatures() {
    return a(this, wi).getValue("flagsmith").getAllFlags();
  }
};
wi = /* @__PURE__ */ new WeakMap();
var Vh = class _Vh {
  constructor(t, e, r) {
    h(this, "logger");
    h(this, "features");
    h(this, "browserSpecs");
    h(this, "callStats");
    this.logger = t, this.features = e, this.browserSpecs = Te, this.callStats = r;
  }
  static init(t) {
    return new _Vh(t.getValue("logger"), new YM(t), t.getValue("callstats"));
  }
};
var Lh = class _Lh {
  constructor(t) {
    h(this, "internals");
    this.internals = t;
  }
  static init(t) {
    return u(this, null, function* () {
      const e = Vh.init(t);
      return new _Lh(e);
    });
  }
};
var QM = Object.defineProperty;
var XM = Object.getOwnPropertyDescriptor;
var Gt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QM(t, e, i), i;
};
var qe;
var ve;
var ge;
var zs;
var Xt;
var zo;
var ke;
var Ot = class extends Jn {
  constructor(e, r, i = Ju, n = true) {
    const o = e.getValue("logger");
    super(o);
    g(this, qe, void 0);
    g(this, ve, void 0);
    g(this, ge, void 0);
    g(this, zs, void 0);
    g(this, Xt, void 0);
    g(this, zo, void 0);
    g(this, ke, void 0);
    h(this, "audioUpdateInProgress");
    h(this, "videoUpdateInProgress");
    m(this, ke, e), this.audioUpdateInProgress = false, this.videoUpdateInProgress = false, m(this, qe, new Uf(e, r)), m(this, ve, new T0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, ge, new b0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, Xt, new C0(
      a(this, ke),
      a(this, qe)
    )), m(this, zs, new _0(
      a(this, qe)
    )), m(this, zo, n), a(this, ve).on("trackMuted", this.onAudioTrackMuted.bind(this)), a(this, ve).on(
      "trackChanged",
      this.onAudioTrackChanged.bind(this)
    ), a(this, ge).on(
      "trackChanged",
      this.onVideoTrackChanged.bind(this)
    ), a(this, ge).on("trackEnded", this.onVideoTrackEnded.bind(this)), a(this, Xt).on(
      "trackEnded",
      this.onScreenShareEnded.bind(this)
    ), this.onVisibilityChange = this.onVisibilityChange.bind(this), document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ke).getValue("telemetry");
  }
  set context(e) {
    m(this, ke, e);
  }
  // eslint-disable-next-line class-methods-use-this
  onVisibilityChange() {
    return u(this, null, function* () {
      a(this, ke).getValue("callstats").tabChanged(document.visibilityState === "visible"), document.visibilityState !== "visible" ? a(this, ke).getValue("callstats").browserBackgrounded() : (a(this, ke).getValue("callstats").browserForegrounded(), yield this.setupSpeaker());
    });
  }
  // eslint-disable-next-line class-methods-use-this
  repopulateAvailableDevices() {
    return u(this, null, function* () {
      return true;
    });
  }
  setupStreams(i) {
    return u(this, arguments, function* ({
      audio: e,
      video: r
    }) {
      var c;
      e ? a(this, ke).getValue("callstats").audioOn() : a(this, ke).getValue("callstats").audioOff(), r ? a(this, ke).getValue("callstats").videoOn() : a(this, ke).getValue("callstats").videoOff();
      let n, o;
      if (e && r)
        try {
          const d = yield a(this, qe).getAudioAndVideoTrack(
            a(this, ve).userSelectedDevice,
            a(this, ge).userSelectedDevice
          );
          n = d.audioTrack, o = d.videoTrack;
        } catch (d) {
          this.logger.error(
            "LocalMediaHandler::init::Failed to get audio video tracks",
            {
              error: d
            }
          );
        }
      if (!n && e)
        try {
          n = yield a(this, qe).getAudioTrack(
            false,
            a(this, ve).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get audio track", {
            error: d
          });
        }
      if (!o && r)
        try {
          o = yield a(this, qe).getVideoTrack(
            a(this, ge).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get video track", {
            error: d
          });
        }
      e && !n && a(this, ke).getValue("callstats").audioOff(), r && !o && a(this, ke).getValue("callstats").videoOff(), yield a(this, ve).setMediaTrack(n), yield a(this, ge).setMediaTrack(o);
      try {
        this.setupSpeaker();
      } catch (d) {
      }
      if (o) {
        const d = yield this.getDeviceById(o.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("VIDEO", d);
      }
      if (n) {
        const d = yield this.getDeviceById(n.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("AUDIO", d);
      }
      (c = a(this, zs).currentDevice) != null && c.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", a(this, zs).currentDevice), a(this, qe).onDeviceChange((d, l, p) => {
        this.onDeviceChange(l, p);
      });
    });
  }
  getCurrentDevices() {
    return {
      audio: a(this, ve).currentDevice,
      video: a(this, ge).currentDevice,
      speaker: a(this, zs).currentDevice
    };
  }
  get permissions() {
    return a(this, qe).permissions;
  }
  getAllDevices() {
    return a(this, qe).getAvailableDevices();
  }
  getDeviceById(e, r) {
    return a(this, qe).getDevice(e);
  }
  /**
   * Audio Input Handler
   */
  onAudioTrackMuted() {
    this.emit("AUDIO_TRACK_SILENT");
  }
  onAudioTrackChanged() {
    this.emit("AUDIO_TRACK_CHANGE");
  }
  get rawAudioTrack() {
    return a(this, ve).mediaTrack;
  }
  get audioTrack() {
    return a(this, ve).transformedMediaTrack;
  }
  get audioEnabled() {
    return a(this, ve).trackEnabled;
  }
  enableAudio(e) {
    return u(this, null, function* () {
      if (!this.audioUpdateInProgress) {
        this.audioUpdateInProgress = true;
        try {
          e ? yield a(this, ve).enableTrack(false, e) : yield a(this, ve).unmuteTrack();
        } catch (r) {
        } finally {
          this.audioUpdateInProgress = false;
        }
      }
    });
  }
  disableAudio() {
    a(this, ve).mediaTrack && !a(this, ve).isCustomTrack ? a(this, ve).muteTrack() : a(this, ve).disableTrack();
  }
  getAudioDevices(e) {
    return a(this, qe).getAudioInputDevices(e);
  }
  setAudioDevice(e) {
    return u(this, null, function* () {
      yield a(this, ve).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("AUDIO", e), this.emit("AUDIO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  /**
   * Audio Output Handler
   */
  setupSpeaker() {
    return u(this, null, function* () {
      const { speaker: e } = this.getCurrentDevices();
      yield a(this, zs).setupSpeaker();
      const { speaker: r } = this.getCurrentDevices();
      (e == null ? void 0 : e.deviceId) !== (r == null ? void 0 : r.deviceId) && r && this.emit("DEVICE_CHANGE", { device: r });
    });
  }
  setSpeakerDevice(e) {
    return u(this, null, function* () {
      yield a(this, zs).setupSpeaker(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", e), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  /**
   * Video Handler
   */
  onVideoTrackChanged() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  onVideoTrackEnded() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  get rawVideoTrack() {
    return a(this, ge).mediaTrack;
  }
  get videoTrack() {
    return a(this, ge).transformedMediaTrack;
  }
  get videoEnabled() {
    return a(this, ge).trackEnabled;
  }
  enableVideo(e) {
    return u(this, null, function* () {
      if (!this.videoUpdateInProgress) {
        this.videoUpdateInProgress = true;
        try {
          e ? yield a(this, ge).enableTrack(false, e) : yield a(this, ge).unmuteTrack();
        } catch (r) {
        } finally {
          this.videoUpdateInProgress = false;
        }
      }
    });
  }
  disableVideo() {
    a(this, ge).disableTrack();
  }
  getVideoDevices(e) {
    return a(this, qe).getVideoInputDevices(e);
  }
  setVideoDevice(e) {
    return u(this, null, function* () {
      yield a(this, ge).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("VIDEO", e), this.emit("VIDEO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  updateVideoConstraints(e) {
    return u(this, null, function* () {
      yield a(this, ge).updateConstraints(e);
    });
  }
  /**
   * Screen Share Handler
   */
  onScreenShareEnded() {
    this.emit("SCREENSHARE_ENDED");
  }
  get screenShareTracks() {
    return {
      audio: a(this, Xt).audioMediaTrack,
      video: a(this, Xt).videoMediaTrack
    };
  }
  get screenShareEnabled() {
    return a(this, Xt).trackEnabled;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield a(this, Xt).enableScreenShare();
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      a(this, Xt).disableScreenShare();
    });
  }
  updateScreenshareConstraints(e) {
    return u(this, null, function* () {
      yield a(this, Xt).updateConstraints(e);
    });
  }
  getSpeakerDevices(e) {
    return a(this, qe).getAudioOutputDevices(e);
  }
  /**
   * Middleware Utility
   */
  addAudioMiddleware(e) {
    return a(this, ve).addMiddleware(e);
  }
  removeAudioMiddleware(e) {
    return a(this, ve).removeMiddleware(e);
  }
  removeAllAudioMiddlewares() {
    return a(this, ve).removeAllMiddlewares();
  }
  addVideoMiddleware(e) {
    return a(this, ge).addMiddleware(e);
  }
  removeVideoMiddleware(e) {
    return a(this, ge).removeMiddleware(e);
  }
  removeAllVideoMiddlewares() {
    return a(this, ge).removeAllMiddlewares();
  }
  setVideoMiddlewareGlobalConfig(e) {
    return a(this, ge).setVideoMiddlewareGlobalConfig(e);
  }
  destruct() {
    a(this, ve).disableTrack(), a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker(), a(this, Xt).disableScreenShare(), a(this, qe).destruct();
  }
  onDeviceChange(e, r) {
    return u(this, null, function* () {
      var i, n;
      this.emit("DEVICE_LIST_UPDATED", e), !(r || !a(this, zo)) && ((i = e == null ? void 0 : e.added) == null || i.forEach((o) => u(this, null, function* () {
        var c;
        o && !Ju(o) && (o.kind === "audioinput" && ((c = this.audioTrack) == null ? void 0 : c.enabled) === true ? yield this.setAudioDevice(o) : o.kind === "audiooutput" && (yield this.setSpeakerDevice(o)));
      })), (n = e == null ? void 0 : e.removed) == null || n.forEach((o) => u(this, null, function* () {
        var c;
        if (o.kind === "audiooutput" && ((c = this.getCurrentDevices().speaker) == null ? void 0 : c.deviceId) === o.deviceId) {
          const d = (yield this.getSpeakerDevices()).find((l) => l.deviceId !== o.deviceId);
          d && (yield this.setSpeakerDevice(d));
        }
      })));
    });
  }
  /**
   * Backward Compatibility
   */
  removeAllTracks() {
    this.destruct();
  }
  /**
   * NOTE(ravindra-dyte):
   * Purpose of this function is to ensure a way to reset tracks.
   * Our EdTech clients also call getUserMedia for their own proctoring systems,
   * which can cause our tracks to be blank despite having enabled true.
   *
   * To ensure that they can cleanup our tracks and re-request tracks,
   *  we need to remove the existing tracks.
   */
  removeAudioTrack() {
    a(this, ve).disableTrack();
  }
  /**
   * NOTE(ravindra-dyte):
   * Purpose of this function is to ensure a way to reset tracks.
   * Our EdTech clients also call getUserMedia for their own proctoring systems,
   * which can cause our tracks to be blank despite having enabled true.
   *
   * To ensure that they can cleanup our tracks and re-request tracks,
   *  we need to remove the existing tracks.
   */
  removeVideoTrack() {
    a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker();
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      document.removeEventListener("visibilitychange", this.onVisibilityChange);
    });
  }
};
qe = /* @__PURE__ */ new WeakMap(), ve = /* @__PURE__ */ new WeakMap(), ge = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakMap(), zo = /* @__PURE__ */ new WeakMap(), ke = /* @__PURE__ */ new WeakMap();
Gt([
  E.trace("MediaHandler.setupStreams")
], Ot.prototype, "setupStreams", 1);
Gt([
  E.trace("MediaHandler.enableAudio")
], Ot.prototype, "enableAudio", 1);
Gt([
  E.trace("MediaHandler.disableAudio")
], Ot.prototype, "disableAudio", 1);
Gt([
  E.trace("MediaHandler.setAudioDevice")
], Ot.prototype, "setAudioDevice", 1);
Gt([
  E.trace("MediaHandler.enableVideo")
], Ot.prototype, "enableVideo", 1);
Gt([
  E.trace("MediaHandler.disableVideo")
], Ot.prototype, "disableVideo", 1);
Gt([
  E.trace("MediaHandler.setVideoDevice")
], Ot.prototype, "setVideoDevice", 1);
Gt([
  E.trace("MediaHandler.updateVideoConstraints")
], Ot.prototype, "updateVideoConstraints", 1);
Gt([
  E.trace("MediaHandler.enableScreenShare")
], Ot.prototype, "enableScreenShare", 1);
Gt([
  E.trace("MediaHandler.disableScreenShare")
], Ot.prototype, "disableScreenShare", 1);
Gt([
  E.trace("MediaHandler.updateScreenshareConstraints")
], Ot.prototype, "updateScreenshareConstraints", 1);
Gt([
  E.trace("MediaHandler.destruct")
], Ot.prototype, "destruct", 1);
Gt([
  E.trace("MediaHandler.onDeviceChange")
], Ot.prototype, "onDeviceChange", 1);
function cd(s, t, e) {
  switch (true) {
    case Te.isChromiumBased():
      switch (t) {
        case "NotAllowedError":
          return e.includes("by system") ? "SYSTEM_DENIED" : s === "screenshare" ? "CANCELED" : "DENIED";
        case "NotReadableError":
        default:
          return "COULD_NOT_START";
      }
    case Te.isSafari():
      switch (t) {
        case "NotAllowedError":
          return "DENIED";
        default:
          return "COULD_NOT_START";
      }
    case Te.isFirefox():
      switch (t) {
        case "NotFoundError":
        case "NotReadableError":
          return "SYSTEM_DENIED";
        case "NotAllowedError":
          return "DENIED";
        case "AbortError":
        default:
          return "COULD_NOT_START";
      }
    default:
      return "COULD_NOT_START";
  }
}
var ZM = [
  "virtual",
  "emulator",
  "krisp",
  "solstice conference",
  "teams",
  "loom",
  "zoom",
  "manycam",
  "blackhole",
  "displayport",
  "xsplit",
  // XSplit virtual camera
  "wirecast",
  // Wirecast virtual camera
  "vMix",
  // vMix virtual camera
  "elgato",
  // Elgato virtual camera
  "epiphan",
  // Epiphan virtual camera
  "voice changer",
  // Some voice changer software
  "voicemod",
  // Voicemod virtual audio device
  "morphvoxx"
  // MorphVOXX virtual audio device
];
function Ju(s) {
  var e, r;
  const t = (e = s.label) == null ? void 0 : e.toLowerCase();
  return ((r = Te._bowser) == null ? void 0 : r.getOSName()) === "macOS" && t.includes("iphone") ? true : ZM.some(
    (i) => t == null ? void 0 : t.includes(i)
  );
}
function e0(s, t, e) {
  return u(this, null, function* () {
    if (!(t != null && t.length))
      return e;
    const r = s.getValue("logger"), i = new AudioContext(), n = yield Promise.all(
      t == null ? void 0 : t.map((d) => d(i))
    ), o = i.createMediaStreamSource(
      new MediaStream([e])
    ), c = i.createMediaStreamDestination();
    try {
      let d = o;
      for (let l = 0; l < n.length; l += 1)
        d.connect(n[l]), d = n[l];
      d.connect(c);
    } catch (d) {
      return r.error("getTransformedAudioTrack::middleware_execution_failed", {
        error: d
      }), e;
    }
    return c.stream.getAudioTracks()[0];
  });
}
var bi;
var Yo;
var t0 = class {
  constructor(t) {
    g(this, bi, void 0);
    g(this, Yo, void 0);
    m(this, Yo, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Yo).getValue("logger");
  }
  terminateMiddlewareWebWorker() {
    if (a(this, bi))
      try {
        clearInterval2(a(this, bi)), m(this, bi, void 0);
      } catch (t) {
        this.logger.debug("WorkerTimers::terminateMiddlewareWebWorker::failed");
      }
  }
  getTransformedVideoTrack(t, e, r) {
    return u(this, null, function* () {
      if (!(t != null && t.length))
        return e;
      const i = document.createElement("canvas"), n = yield Promise.all(
        t == null ? void 0 : t.map((S) => S({
          canvas: i,
          WorkerTimers: module_exports
        }))
      );
      if (r.disablePerFrameCanvasRendering) {
        const T = i.captureStream().getVideoTracks()[0];
        return Object.defineProperty(T, "originalSettings", {
          value: e.getSettings()
        }), T;
      }
      const o = document.createElement("video"), c = new MediaStream();
      c.addTrack(e);
      const d = i.getContext("2d");
      o.srcObject = c, o.autoplay = true, this.terminateMiddlewareWebWorker();
      const l = () => u(this, null, function* () {
        if (e.enabled === false || e.readyState === "ended") {
          this.terminateMiddlewareWebWorker(), o.remove(), i.remove();
          return;
        }
        try {
          d.drawImage(o, 0, 0);
          for (let S = 0; S < n.length; S += 1)
            typeof n[S] == "function" && (yield n[S](
              i,
              d
            ));
        } catch (S) {
          this.logger.error(
            "getTransformedVideoTrack::middleware_execution_failed",
            { error: S }
          );
        }
      });
      try {
        o.play();
      } catch (S) {
      }
      o.addEventListener(
        "play",
        () => {
          i.width = o.width || e.getSettings().width, i.height = o.width || e.getSettings().height, m(this, bi, setInterval2(
            l,
            50
          ));
        },
        false
      );
      const f2 = i.captureStream().getVideoTracks()[0];
      return Object.defineProperty(f2, "originalSettings", {
        value: e.getSettings()
      }), f2;
    });
  }
};
bi = /* @__PURE__ */ new WeakMap(), Yo = /* @__PURE__ */ new WeakMap();
var hg = {
  gross: { width: { ideal: 192 }, height: { ideal: 144 } },
  qvga: { width: { ideal: 384 }, height: { ideal: 288 } },
  pvga: { width: { ideal: 480 }, height: { ideal: 360 } },
  vga: { width: { ideal: 640 }, height: { ideal: 480 } },
  hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
  hd_cropped: { width: { ideal: 900 }, height: { ideal: 720 } },
  fhd: { width: { ideal: 1920 }, height: { ideal: 1080 } }
};
var s0 = [
  [320, [
    {
      rid: "q",
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    }
  ]],
  [640, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 7e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1280, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 5e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 13e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1920, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 9e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 15e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]]
];
var r0 = (s, t) => {
  var c;
  const e = "getSettings" in t && t.getSettings().width || "getConstraints" in t && t.getConstraints().width || "originalSettings" in t && ((c = t.originalSettings) == null ? void 0 : c.width);
  let r = s0;
  s.getValue("flagsmith").hasFeature(X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC) && (r = JSON.parse(s.getValue("flagsmith").getValue(
    X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC
  )));
  const i = r.map(([d]) => d).sort((d, l) => d - l);
  let n = Number.MAX_VALUE, o = 0;
  return i.forEach((d, l) => {
    Math.abs(d - e) < n && (n = Math.abs(d - e), o = l);
  }), r[o][1];
};
var pe = ((s) => (s.WEBCAM = "webcam", s.WEBCAM_BACKUP = "webcam_backup", s.MIC = "mic", s.SCREENSHARE_VIDEO = "screenshare_video", s.SCREENSHARE_AUDIO = "screenshare_audio", s))(pe || {});
var i0 = Y_();
var Pa = _s(
  i0.config.media
);
function a0(s) {
  var e, r;
  const t = {};
  return s.audio && (t.audio = {
    enableStereo: (e = s.audio.enableStereo) != null ? e : false,
    enableHighBitrate: (r = s.audio.enableHighBitrate) != null ? r : false
  }), t.video = s.video.quality, t;
}
var ki;
var As;
var n0 = class {
  constructor(t, e) {
    g(this, ki, void 0);
    g(this, As, void 0);
    h(this, "getScreenShareConstraints", () => {
      var l, p, f2, S, T, _, P, w, A, N, H;
      const t2 = (l = a(this, ki)) == null ? void 0 : l.screenshare, e2 = (f2 = (p = t2 == null ? void 0 : t2.width) == null ? void 0 : p.max) != null ? f2 : 1920, r = (T = (S = t2 == null ? void 0 : t2.height) == null ? void 0 : S.max) != null ? T : 1080, i = (P = (_ = t2 == null ? void 0 : t2.frameRate) == null ? void 0 : _.max) != null ? P : 5;
      let n = (A = (w = t2 == null ? void 0 : t2.frameRate) == null ? void 0 : w.ideal) != null ? A : 5;
      const o = t2 == null ? void 0 : t2.displaySurface, c = t2 == null ? void 0 : t2.selfBrowserSurface;
      a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE) && (n = parseInt(
        (N = a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE)) == null ? void 0 : N.toString(),
        10
      ));
      let d = {
        width: { max: e2 },
        height: { max: r },
        frameRate: {
          ideal: n,
          max: i
        }
      };
      if (a(this, As).getValue("flagsmith").hasFeature(X.SCREENSHARE_CONSTRAINTS)) {
        const $ = (H = a(this, As).getValue("flagsmith").getValue(
          X.SCREENSHARE_CONSTRAINTS
        )) == null ? void 0 : H.toString();
        d = JSON.parse($);
      }
      return o !== void 0 && ["monitor", "browser", "window"].includes(o) && (d = B(D({}, d), { displaySurface: o })), c !== void 0 && (d = B(D({}, d), { selfBrowserSurface: c })), {
        audio: true,
        video: d
      };
    });
    h(this, "getAudioConstraints", (t2) => {
      var n, o, c, d, l, p, f2;
      const e2 = {}, r = (n = a(this, ki)) == null ? void 0 : n.audio, i = r != null && r.enableStereo ? 2 : 1;
      return Te.isFirefox() || Te.isWebKitBased() ? (e2.audio = {
        deviceId: t2,
        autoGainControl: (o = r == null ? void 0 : r.autoGainControl) != null ? o : true,
        echoCancellation: (c = r == null ? void 0 : r.echoCancellation) != null ? c : true,
        noiseSuppression: (d = r == null ? void 0 : r.noiseSupression) != null ? d : true,
        channelCount: i
      }, e2) : (e2.audio = {
        autoGainControl: (l = r == null ? void 0 : r.autoGainControl) != null ? l : true,
        echoCancellation: (p = r == null ? void 0 : r.echoCancellation) != null ? p : true,
        noiseSuppression: (f2 = r == null ? void 0 : r.noiseSupression) != null ? f2 : true,
        channelCount: i
      }, t2 && t2 !== "default" && (e2.audio.deviceId = { exact: t2 }), e2);
    });
    h(this, "getVideoConstraints", (t2) => {
      var n, o, c, d;
      const e2 = {}, r = (n = a(this, ki)) == null ? void 0 : n.video;
      let i = hg.vga;
      if (typeof r == "string" ? i = hg[r] : r !== void 0 && (i.height.ideal = r.height.ideal, i.width.ideal = r.width.ideal), i.frameRate = {
        ideal: (c = (o = i.frameRate) == null ? void 0 : o.ideal) != null ? c : 24
      }, Te.isChromiumBased() && (i.frameRate.max = 30), a(this, As).getValue("flagsmith").hasFeature(X.VIDEO_CONSTRAINTS)) {
        const l = (d = a(this, As).getValue("flagsmith").getValue(
          X.VIDEO_CONSTRAINTS
        )) == null ? void 0 : d.toString();
        i = JSON.parse(l);
      }
      return e2.video = i, typeof e2.video == "boolean" || (t2 ? e2.video.deviceId = { exact: t2 } : e2.video.facingMode = "user"), e2;
    });
    m(this, As, t), m(this, ki, e);
  }
  // eslint-disable-next-line class-methods-use-this
  getUpdatedVideoConstraints(t) {
    return t;
  }
};
ki = /* @__PURE__ */ new WeakMap(), As = /* @__PURE__ */ new WeakMap();
var Su = class extends Error {
  constructor(e, r, i) {
    super(r);
    h(this, "constraints");
    h(this, "name");
    this.name = e, this.constraints = i;
  }
};
var o0 = class {
  constructor() {
    h(this, "permissions");
    this.permissions = {
      audio: "NOT_REQUESTED",
      video: "NOT_REQUESTED",
      screenshare: "NOT_REQUESTED"
    };
  }
  getAudioInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audioinput");
    });
  }
  getVideoInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "videoinput");
    });
  }
  getAudioOutputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audiooutput");
    });
  }
};
var c0 = Object.defineProperty;
var d0 = Object.getOwnPropertyDescriptor;
var bs = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? d0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && c0(t, e, i), i;
};
var nn;
var Zt;
var Ve;
var Ug;
var Bt = (Ug = class extends o0 {
  constructor(t, e) {
    super();
    h(this, "availableDevices");
    g(this, nn, void 0);
    g(this, Zt, void 0);
    g(this, Ve, void 0);
    m(this, Ve, t), m(this, Zt, new n0(t, e)), m(this, nn, new AbortController()), this.availableDevices = [], this.getAvailableDevices();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ve).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ve).getValue("logger");
  }
  get constraintsBuilder() {
    return a(this, Zt);
  }
  destruct() {
    return u(this, null, function* () {
      var t;
      (t = a(this, nn)) == null || t.abort();
    });
  }
  handlePermissionErrors(t, e) {
    const r = cd(t, e.name, e.message);
    return this.permissions[t] = r, a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, {
      message: r,
      constraints: e.constraints,
      kind: t
    }), r;
  }
  getAudioAndVideoTrack(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: a(this, Zt).getAudioConstraints(t).audio,
        video: a(this, Zt).getVideoConstraints(e).video
      };
      try {
        this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
          constraints: JSON.stringify(r)
        });
        const i = yield navigator.mediaDevices.getUserMedia(
          r
        );
        this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
          constraints: JSON.stringify(r)
        });
        const n = i.getAudioTracks()[0];
        let o = i.getVideoTracks()[0];
        if (this.permissions.audio = "ACCEPTED", this.permissions.video = "ACCEPTED", a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY) && o.label.includes("OBS Virtual")) {
          const l = (yield this.getVideoInputDevices()).find((p) => p.label.includes("OBS Virtual"));
          o = yield this.getVideoTrack(l.deviceId);
        }
        return a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), { audioTrack: n, videoTrack: o };
      } catch (i) {
        throw this.logger.error("WebMediaInterface.getAudioAndVideoTrack", { error: i }), new R("Couldnt fetch audio and video track", "1605");
      }
    });
  }
  getAudioTrack(t, e) {
    return u(this, null, function* () {
      let r = yield this.getAudioInputDevices();
      if (r.length === 0)
        throw this.permissions.audio = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), new R("No audio devices available", "1606");
      const i = (n) => u(this, null, function* () {
        let o;
        try {
          r = r.filter((d) => d.deviceId !== n), o = a(this, Zt).getAudioConstraints(n), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(o)
          });
          const [c] = (yield navigator.mediaDevices.getUserMedia(o)).getAudioTracks();
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(o)
          }), c;
        } catch (c) {
          const d = cd(
            "audio",
            c.name,
            c.message
          ), l = new Su(c.name, c.message, o);
          if (d === "COULD_NOT_START") {
            const p = r.shift();
            if (!p)
              throw l;
            this.logger.info("getAudioTrack::gum_failed", {
              constraints: JSON.stringify(o),
              error: c
            });
            const f2 = a(this, Zt).getAudioConstraints(
              p.deviceId
            );
            return this.logger.info("getAudioTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(f2)
            }), i(p.deviceId);
          }
          throw l;
        }
      });
      try {
        const n = yield i(e);
        return n.enabled = !t, this.permissions.audio !== "ACCEPTED" && (this.permissions.audio = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        })), n;
      } catch (n) {
        throw n.constraints && this.handlePermissionErrors("audio", n), new R(n.message, "1601");
      }
    });
  }
  getVideoTrack(t) {
    return u(this, null, function* () {
      var c;
      const e = a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY), r = (c = yield this.getCurrentDeviceLabel(t)) == null ? void 0 : c.includes("OBS Virtual"), i = e && r, n = yield this.getVideoInputDevices();
      if (n.length === 0)
        throw this.permissions.video = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), new R("No video devices available", "1607");
      const o = (d) => u(this, null, function* () {
        try {
          let l = d;
          const { video: p } = l;
          i && typeof p != "boolean" && (l = {
            video: { deviceId: p.deviceId }
          }), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(l)
          });
          const [f2] = (yield navigator.mediaDevices.getUserMedia(l)).getVideoTracks();
          if (i && typeof p != "boolean" && typeof p.width == "object") {
            const { width: S, height: T } = f2.getSettings(), { ideal: _ } = p.width;
            f2.applyConstraints({
              width: { ideal: _ },
              height: { ideal: Math.floor(T * _ / S) },
              frameRate: p.frameRate
            });
          }
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(l)
          }), f2;
        } catch (l) {
          const p = cd(
            "video",
            l.name,
            l.message
          ), f2 = new Su(l.name, l.message, d);
          if (p === "COULD_NOT_START") {
            const S = n.shift();
            if (!S)
              throw f2;
            this.logger.info("getVideoTrack::gum_failed", {
              constraints: JSON.stringify(d),
              error: l
            });
            const T = a(this, Zt).getVideoConstraints(
              S.deviceId
            );
            return this.logger.info("getVideoTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(T)
            }), o({ video: T.video });
          }
          throw f2;
        }
      });
      try {
        const d = a(this, Zt).getVideoConstraints(t), l = yield o(d);
        return this.permissions.video !== "ACCEPTED" && (this.permissions.video = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        })), l;
      } catch (d) {
        throw d.constraints && this.handlePermissionErrors("video", d), new R(d.message, "1602");
      }
    });
  }
  getScreenShareTracks() {
    return u(this, null, function* () {
      const t = (e) => u(this, null, function* () {
        try {
          this.logger.info("getDisplayMediaWithoutTimeout::requesting_display_media", {
            constraints: JSON.stringify(e)
          }), a(this, Ve).getValue("callstats").screenShareRequested();
          const r = yield navigator.mediaDevices.getDisplayMedia(
            e
          );
          return this.logger.info("getDisplayMediaWithoutTimeout::received_display_media", {
            constraints: JSON.stringify(e)
          }), r;
        } catch (r) {
          const i = cd(
            "video",
            r.name,
            r.message
          ), n = new Su(r.name, r.message, e), o = { video: true };
          if (SC(e, o) || !a(this, Ve).getValue("flagsmith").hasFeature(X.SCREEENSHARE_CONSTRAINTS_RETRY))
            throw n;
          if (i === "COULD_NOT_START")
            return t(o);
          throw n;
        }
      });
      try {
        const e = a(this, Zt).getScreenShareConstraints(), r = yield t(e);
        return this.permissions.screenshare !== "ACCEPTED" && (this.permissions.screenshare = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.screenshare,
          kind: "screenshare"
        })), {
          audioTrack: r.getAudioTracks()[0],
          videoTrack: r.getVideoTracks()[0]
        };
      } catch (e) {
        throw e.constraints && this.handlePermissionErrors("screenshare", e), new R(e.message, "1612");
      }
    });
  }
  getCurrentDeviceLabel(t) {
    return u(this, null, function* () {
      const e = yield this.getDevice(t || "default");
      return e == null ? void 0 : e.label;
    });
  }
  getAvailableDevices() {
    return u(this, null, function* () {
      try {
        const t = yield navigator.mediaDevices.enumerateDevices();
        return this.availableDevices = t, t;
      } catch (t) {
        throw this.logger.error("enumerate_devices_failed", {
          error: t
        }), new R("Failed to get available devices", "1609");
      }
    });
  }
  getAvailableDevicesByKind(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter(
          ({ kind: e }) => t === e
        );
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get available devices by kind", "1609");
      }
    });
  }
  getDevice(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter((r) => r.deviceId === t)[0];
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get device", "1609");
      }
    });
  }
  onDeviceChange(t) {
    return u(this, null, function* () {
      Te.supportsDeviceChangeEvent() && navigator.mediaDevices.addEventListener(
        "devicechange",
        (e) => u(this, null, function* () {
          var l, p;
          const r = (f2) => `${f2.kind}-${f2.deviceId}-${f2.groupId}`, i = this.availableDevices, n = new Set(
            i.map((f2) => r(f2))
          ), o = yield this.getAvailableDevices(), c = new Set(
            o.map((f2) => r(f2))
          ), d = {
            added: o.filter(
              (f2) => !n.has(r(f2))
            ),
            removed: i.filter(
              (f2) => !c.has(r(f2))
            ),
            devices: o
          };
          if ((l = d.added) != null && l.length || (p = d.removed) != null && p.length) {
            this.logger.info("repopulated_full_device_list", {
              devices: JSON.stringify(o)
            });
            const f2 = [...d.added, ...d.removed];
            f2.some((S) => S.kind === "audioinput") && a(this, Ve).getValue("callstats").devices("AUDIO", o == null ? void 0 : o.filter((S) => S.kind === "audioinput")), f2.some((S) => S.kind === "videoinput") && a(this, Ve).getValue("callstats").devices("VIDEO", o == null ? void 0 : o.filter((S) => S.kind === "videoinput")), f2.some((S) => S.kind === "audiooutput") && a(this, Ve).getValue("callstats").devices("SPEAKER", o == null ? void 0 : o.filter((S) => S.kind === "audiooutput")), t(e, d, false);
          }
        }),
        { signal: a(this, nn).signal }
      );
    });
  }
}, nn = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), Ve = /* @__PURE__ */ new WeakMap(), Ug);
bs([
  E.trace("WebMediaInterface.destruct")
], Bt.prototype, "destruct", 1);
bs([
  E.trace("WebMediaInterface.handlePermissionErrors")
], Bt.prototype, "handlePermissionErrors", 1);
bs([
  E.trace("WebMediaInterface.getAudioAndVideoTrack")
], Bt.prototype, "getAudioAndVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getAudioTrack")
], Bt.prototype, "getAudioTrack", 1);
bs([
  E.trace("WebMediaInterface.getVideoTrack")
], Bt.prototype, "getVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getScreenShareTracks")
], Bt.prototype, "getScreenShareTracks", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevices")
], Bt.prototype, "getAvailableDevices", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevicesByKind")
], Bt.prototype, "getAvailableDevicesByKind", 1);
bs([
  E.trace("WebMediaInterface.getDevice")
], Bt.prototype, "getDevice", 1);
bs([
  E.trace("WebMediaInterface.onDeviceChange")
], Bt.prototype, "onDeviceChange", 1);
Bt = bs([
  ht("1600")
], Bt);
var Uf = Bt;
var Io = {
  setItem: (s, t, e) => {
    try {
      localStorage.setItem(s, t);
    } catch (r) {
      e == null || e.error("LocalStorage::setItem::crashed", {
        error: r,
        localStorage: { key: s, value: t }
      });
    }
  },
  getItem: (s, t) => {
    try {
      return localStorage.getItem(s);
    } catch (e) {
      t == null || t.error("LocalStorage::getItem::crashed", {
        error: e,
        localStorage: { key: s }
      });
    }
    return null;
  }
};
var l0 = (s = 0) => new Promise(
  (t) => setTimeout(t, s)
);
var u0 = (s, t, e) => {
  const r = typeof e == "number" ? e : 250, i = s.createMediaStreamSource(t), n = s.createAnalyser();
  n.fftSize = 2048, i.connect(n);
  const o = new Uint8Array(n.fftSize);
  let c = false;
  setTimeout(() => {
    c = true;
  }, r);
  function d() {
    return c ? Promise.resolve(true) : (n.getByteTimeDomainData(o), o.some((l) => l !== 128 && l !== 0) ? Promise.resolve(false) : l0().then(d));
  }
  return d().then(
    (l) => (i.disconnect(), l),
    (l) => {
      throw i.disconnect(), l;
    }
  );
};
var h0 = typeof AudioContext != "undefined" ? AudioContext : null;
var xh = class _xh {
  constructor(t) {
    h(this, "_AudioContext");
    h(this, "audioContext");
    h(this, "_audioContextRefContainers");
    const e = D({ AudioContext: h0 }, t);
    Object.defineProperties(this, {
      _AudioContext: {
        value: e.AudioContext
      },
      audioContext: {
        value: null,
        writable: true
      },
      _audioContextRefContainers: {
        value: /* @__PURE__ */ new Set()
      },
      AudioContextProvider: {
        enumerable: true,
        value: _xh
      }
    });
  }
  getOrCreate(t) {
    if (!this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.add(t), this._AudioContext && !this.audioContext))
      try {
        this.audioContext = new this._AudioContext();
      } catch (e) {
      }
    return this.audioContext;
  }
  release(t) {
    this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.delete(t), !this._audioContextRefContainers.size && this.audioContext && (this.audioContext.close(), this.audioContext = null));
  }
};
var pg = new xh();
var p0 = 3;
var g0 = 250;
function m0(s) {
  const t = {}, e = pg.getOrCreate(
    t
  );
  let r = p0;
  function i() {
    return r -= 1, u0(e, s.srcObject, g0).then((n) => n ? r > 0 ? i() : true : false).catch(() => true);
  }
  return i().finally(() => {
    pg.release(t);
  });
}
function gg(s, t) {
  return u(this, null, function* () {
    const e = new Audio(), r = new MediaStream();
    r.addTrack(t), e.srcObject = r;
    let i = false;
    try {
      const n = e.play();
      n && (yield n), i = yield m0(e), i && s.info("checkIfAudioTrackIsSilent::silence_detected");
    } catch (n) {
      s.error("checkIfAudioTrackIsSilent::failed_to_detect_silence", {
        error: n
      });
    } finally {
      e.pause(), e.remove();
    }
    return i;
  });
}
var f0 = Object.defineProperty;
var S0 = Object.getOwnPropertyDescriptor;
var $f = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? S0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && f0(t, e, i), i;
};
var Ld = class extends Jn {
  /**
   * Allows creation of an instance of BaseMediaHandler with a track.
   * We initialize it with a track when we want to enable streams on init.
   * @param mediaInterface
   * @param mediaTrack
   */
  constructor(t, e, r, i) {
    var o;
    const n = t.getValue("logger");
    super(n);
    h(this, "constructorName", this.constructor.name);
    h(this, "userSelectedDevice");
    h(this, "mediaInterface");
    h(this, "isNonPreferredDevice");
    h(this, "_mediaTrack");
    h(this, "transformedMediaTrack");
    h(this, "middlewares", []);
    h(this, "currentDevice");
    h(this, "userPreferredDeviceKey", `Dyte::${this.constructorName}::UserDeviceID`);
    h(this, "setUserPreferredDevice", (t2) => Io.setItem(
      this.userPreferredDeviceKey,
      t2,
      this.logger
    ));
    h(this, "getUserPreferredDevice", () => Io.getItem(
      this.userPreferredDeviceKey,
      this.logger
    ));
    h(this, "isCustomTrack", false);
    h(this, "context");
    this.context = t, this.mediaInterface = e, r && this.setMediaTrack(r), this.userSelectedDevice = (o = this.getUserPreferredDevice()) != null ? o : void 0, this.isNonPreferredDevice = i, this.onTrackEnded = this.onTrackEnded.bind(this), this.onTrackMuted = this.onTrackMuted.bind(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * NOTE(roerohan): DO NOT use this.#mediaTrack anywhere else,
   * except for these 3 functions below.
   */
  /**
   * Cleans up all acquired tracks.
   */
  disableTrack() {
    var t, e;
    this.removeMediaTrackListeners(), this.isCustomTrack || (t = this._mediaTrack) == null || t.stop(), this._mediaTrack = void 0, (e = this.transformedMediaTrack) == null || e.stop(), this.transformedMediaTrack = void 0;
  }
  get mediaTrack() {
    return this._mediaTrack;
  }
  setMediaTrack(t, e = false) {
    return u(this, null, function* () {
      const r = (i) => {
        this.logger.error(`${this.constructorName}.setMediaTrack.error`, {
          error: i
        });
      };
      try {
        this.disableTrack();
      } catch (i) {
        r(i);
      }
      this._mediaTrack = yield this.conditionallyChangeTrack(t, e), yield this.setTransformedTrack();
      try {
        this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        r(i);
      }
    });
  }
  /**
   * Represents current audio/video state according to track status
   */
  get trackEnabled() {
    return !!this.mediaTrack && this.mediaTrack.readyState === "live" && this.mediaTrack.enabled;
  }
  /**
   * Mutes track if it's present, DOES NOT STOP IT!
   * Only used for audio streams
   */
  muteTrack() {
    if (!this.mediaTrack) {
      this.logger.warn(
        "BaseMediaHandler.muteTrack Tried muting with no track present"
      );
      return;
    }
    this.transformedMediaTrack && (this.transformedMediaTrack.enabled = false), this.mediaTrack.enabled = false;
  }
  unmuteTrack() {
    return u(this, null, function* () {
      try {
        this.mediaTrack ? this.mediaTrack.enabled = true : yield this.enableTrack(false);
      } catch (t) {
        throw this.logger.error(`${this.constructorName}.unmuteTrack.error`, {
          error: t
        }), this.disableTrack(), new R("Failed to unmute track", "1611");
      }
    });
  }
  // NOTE(ishita1805): Not to be used for screenshare or audiooutput
  getCurrentDeviceId() {
    var e;
    const { kind: t } = this.mediaTrack;
    switch (t) {
      case "audio": {
        const { deviceId: r } = this.mediaTrack.getSettings();
        if (r)
          return r;
        const i = this.mediaTrack.getConstraints();
        return this.userSelectedDevice ? (i && typeof i.deviceId == "object" && "exact" in i.deviceId ? i.deviceId.exact : i.deviceId) || ((e = i == null ? void 0 : i.advanced) == null ? void 0 : e[0].deviceId) || "default" : this.mediaTrack.getSettings().deviceId;
      }
      default:
        return this.mediaTrack.getSettings().deviceId;
    }
  }
  /**
   * Called after every track switch, maintains local state of current
   * selected device for this particular stream.
   */
  setCurrentDevice() {
    return u(this, null, function* () {
      var e;
      if (!this.mediaTrack) {
        this.currentDevice = void 0;
        return;
      }
      const t = this.getCurrentDeviceId();
      ((e = this.currentDevice) == null ? void 0 : e.deviceId) !== t && (this.currentDevice = yield this.mediaInterface.getDevice(t));
    });
  }
  setDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn(`${this.constructorName}.setDevice No device received`), new R("No device received!", "1603");
      this.userSelectedDevice = t.deviceId, this.setUserPreferredDevice(t.deviceId), yield this.onSetDevice(t);
    });
  }
  /**
   * Middleware Utility
   */
  addMiddleware(t) {
    return u(this, null, function* () {
      if (Te.isWebKitBased() && !$_.hasFeature(X.ALLOW_SAFARI_MEDIA_MIDDLEWARES))
        return {
          success: false,
          message: "Middlewares are not supported in this WebKit engine based browser."
        };
      if (this.middlewares.includes(t))
        return {
          success: false,
          message: "This middleware has been applied, already. Skipping."
        };
      try {
        return this.middlewares.push(t), this.trackEnabled && (yield this.setTransformedTrack()), { success: true, message: "Successfully added the middleware." };
      } catch (e) {
        return this.logger.error("While adding middleware", { error: e }), this.removeMiddleware(t), { success: false, message: e == null ? void 0 : e.message };
      }
    });
  }
  removeMiddleware(t) {
    return u(this, null, function* () {
      const e = this.middlewares.indexOf(t, 0);
      if (e > -1)
        try {
          return this.middlewares.splice(e, 1), yield this.setTransformedTrack(true), {
            success: true,
            message: "Successfully removed the middleware."
          };
        } catch (r) {
          return this.logger.error("While removing middleware", { error: r }), { success: false, message: r == null ? void 0 : r.message };
        }
      return {
        success: false,
        message: "No such middleware was found. Skipping."
      };
    });
  }
  removeAllMiddlewares() {
    return u(this, null, function* () {
      var t;
      if ((t = this.middlewares) != null && t.length)
        try {
          return this.middlewares = [], yield this.setTransformedTrack(true), {
            success: true,
            message: "Successfully removed all the middlewares."
          };
        } catch (e) {
          return this.logger.error("While removing all the middlewares", { error: e }), { success: false, message: e == null ? void 0 : e.message };
        }
      return {
        success: false,
        message: "No middlewares were found. Skipping."
      };
    });
  }
  addMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.addMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.mediaTrack.addEventListener("ended", this.onTrackEnded), this.mediaTrack.addEventListener("mute", this.onTrackMuted));
  }
  removeMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.removeMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.logger.info(`${this.constructorName}.removeMediaTrackListeners`), this.mediaTrack.removeEventListener("ended", this.onTrackEnded), this.mediaTrack.removeEventListener("mute", this.onTrackMuted));
  }
};
$f([
  E.trace("BaseMediaHandler.unmuteTrack")
], Ld.prototype, "unmuteTrack", 1);
Ld = $f([
  ht("1600")
], Ld);
var Ff = Ld;
var v0 = Object.defineProperty;
var y0 = Object.getOwnPropertyDescriptor;
var Uh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? y0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && v0(t, e, i), i;
};
var vu = "[Dyte]nonSilentDeviceLabels";
var Kl = class extends Ff {
  onSetDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn("AudioMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (t.kind !== "audioinput")
        throw this.logger.warn("AudioMediaHandler.setDevice Received non audio device"), new R(
          "Non audio device received while setting device!",
          "1603"
        );
      try {
        const e = this.trackEnabled;
        yield this.setMediaTrack(
          yield this.mediaInterface.getAudioTrack(
            !e,
            this.userSelectedDevice
          )
        );
      } catch (e) {
        throw this.logger.error("AudioMediaHandler.setDevice.error", {
          error: e
        }), this.disableTrack(), new R(e.message, "1604");
      }
    });
  }
  enableTrack(t, e) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("AudioMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (e) {
        this.isCustomTrack = true, yield this.setMediaTrack(e, true);
        return;
      }
      this.isCustomTrack = false;
      const r = yield this.mediaInterface.getAudioTrack(
        t,
        this.userSelectedDevice
      );
      yield this.setMediaTrack(r);
    });
  }
  setTransformedTrack(t) {
    return u(this, null, function* () {
      var e;
      if (!t && !((e = this.middlewares) != null && e.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield e0(
          this.context,
          this.middlewares,
          this.mediaTrack
        ), this.emit("trackChanged");
      } catch (r) {
        this.logger.error("AudioMediaHandler.setTransformedTrack", {
          error: r
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("AudioMediaHandler.TrackEnded"), this.emit("trackEnded");
      const t = this.mediaTrack.enabled;
      this.disableTrack(), yield this.enableTrack(!t), yield this.setTransformedTrack(), this.emit("trackChanged");
    });
  }
  onTrackMuted() {
    this.logger.info("AudioMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(t, e = false) {
    return u(this, null, function* () {
      var d;
      if (!t || this.userSelectedDevice || e)
        return t;
      let r = t;
      const i = yield this.mediaInterface.getAudioInputDevices(), n = this.isNonPreferredDevice ? i.filter((l) => l && !this.isNonPreferredDevice(l)) : i;
      if (!(n != null && n.length))
        return r;
      n.find(
        (l) => l.deviceId === t.getSettings().deviceId
      ) || (r.stop(), this.logger.info("localmediahandler::setupstreams::found_audio_non_preferred"), r = yield this.mediaInterface.getAudioTrack(
        false,
        n[0].deviceId
      ));
      const o = JSON.parse(
        Io.getItem(vu, this.logger)
      );
      if (o != null && o.devices.some(
        (l) => l.label === r.label
      ))
        return r;
      if (!(yield gg(this.logger, r))) {
        const l = (d = o == null ? void 0 : o.devices.concat({
          label: r.label
        })) != null ? d : [{ label: r.label }];
        return Io.setItem(vu, JSON.stringify({
          devices: l
        }), this.logger), r;
      }
      this.logger.info("AudioMediaHandler.conditionallyChangeTrack.DetectedSilentTrack");
      const c = r.getSettings().deviceId;
      return n.filter((l) => l.deviceId !== c).some((l) => u(this, null, function* () {
        if (r = yield this.mediaInterface.getAudioTrack(
          false,
          l.deviceId
        ), !(yield gg(this.logger, r))) {
          const p = o.devices.concat({
            label: r.label
          });
          return Io.setItem(vu, JSON.stringify({
            devices: p
          }), this.logger), this.logger.info("AudioMediaHandler.conditionallyChangeTrack.SuccesfullyChangedTrack"), true;
        }
        return this.logger.info("AudioMediaHandler.conditionallyChangeTrack.AnotherSilentTrackFound"), false;
      })), r;
    });
  }
};
Uh([
  E.trace("AudioMediaHandler.setTransformedTrack")
], Kl.prototype, "setTransformedTrack", 1);
Uh([
  E.trace("AudioMediaHandler.onTrackEnded")
], Kl.prototype, "onTrackEnded", 1);
Uh([
  E.trace("AudioMediaHandler.conditionallyChangeTrack")
], Kl.prototype, "conditionallyChangeTrack", 1);
var T0 = Kl;
var on;
var E0 = class {
  constructor(t) {
    g(this, on, void 0);
    h(this, "currentDevice");
    m(this, on, t);
  }
  setupSpeaker(t) {
    return u(this, null, function* () {
      var i, n;
      if (!(a(this, on) instanceof Uf))
        return;
      let e = t;
      if (t || ([e] = (yield a(this, on).getAvailableDevicesByKind(
        "audiooutput"
      )).filter((c) => !Ju(c))), !e)
        throw new R("No speaker found", "1608");
      if (((i = this.currentDevice) == null ? void 0 : i.deviceId) === e.deviceId)
        return;
      this.currentDevice = e;
      const r = document.querySelectorAll("audio");
      (n = r[0]) != null && n.setSinkId && r.forEach((o) => u(this, null, function* () {
        if (typeof o.sinkId != "undefined" && this.currentDevice.deviceId && o.sinkId !== this.currentDevice.deviceId)
          try {
            yield o.setSinkId(this.currentDevice.deviceId);
          } catch (c) {
          }
      }));
    });
  }
};
on = /* @__PURE__ */ new WeakMap();
var _0 = E0;
var Qo;
var P0 = class extends Jn {
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    h(this, "mediaInterface");
    h(this, "audioMediaTrack");
    h(this, "videoMediaTrack");
    g(this, Qo, void 0);
    m(this, Qo, e), this.mediaInterface = r;
  }
  get trackEnabled() {
    return !!this.videoMediaTrack;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      var e, r;
      try {
        const { audioTrack: i, videoTrack: n } = yield this.mediaInterface.getScreenShareTracks();
        if (this.audioMediaTrack = i, this.videoMediaTrack = n, this.addMediaTrackListeners(), ((r = (e = this.mediaInterface) == null ? void 0 : e.permissions) == null ? void 0 : r.screenshare) === "ACCEPTED")
          return;
        this.mediaInterface.permissions && (this.mediaInterface.permissions.screenshare = "ACCEPTED", a(this, Qo).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.mediaInterface.permissions.screenshare,
          kind: "screenshare"
        }));
      } catch (i) {
      }
    });
  }
  disableScreenShare() {
    var e, r;
    this.removeMediaTrackListeners(), (e = this.audioMediaTrack) == null || e.stop(), (r = this.videoMediaTrack) == null || r.stop(), this.videoMediaTrack = void 0, this.audioMediaTrack = void 0;
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this.videoMediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this.videoMediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), this.addMediaTrackListeners();
      } catch (i) {
        this.logger.error("ScreenShareHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  addMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.addEventListener(
      "ended",
      this.onTrackEnded.bind(this)
    ), Te.isWebKitBased() && ((r = this.videoMediaTrack) == null || r.addEventListener(
      "mute",
      this.onTrackEnded.bind(this)
    ));
  }
  removeMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.removeEventListener("ended", this.onTrackEnded), (r = this.videoMediaTrack) == null || r.removeEventListener("mute", this.onTrackEnded);
  }
  onTrackEnded() {
    this.emit("trackEnded");
  }
};
Qo = /* @__PURE__ */ new WeakMap();
var C0 = P0;
var R0 = Object.defineProperty;
var w0 = Object.getOwnPropertyDescriptor;
var zl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? w0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && R0(t, e, i), i;
};
var cn;
var Xo;
var Yc = class extends Ff {
  constructor(e, r, i, n) {
    super(e, r, i, n);
    g(this, cn, void 0);
    g(this, Xo, {
      disablePerFrameCanvasRendering: false
    });
    m(this, cn, new t0(e));
  }
  onSetDevice(e) {
    return u(this, null, function* () {
      if (!e)
        throw this.logger.warn("VideoMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (e.kind !== "videoinput")
        throw this.logger.warn("VideoMediaHandler.setDevice Received non video device", {
          devices: [e]
        }), new R(
          "Non video device received while setting video device!",
          "1603"
        );
      if (!(this.mediaTrack && this.mediaTrack.enabled)) {
        this.logger.warn(
          "VideoMediaHandler.setDevice Tried switching device with video disabled",
          {
            devices: [e]
          }
        ), this.currentDevice = e;
        return;
      }
      try {
        yield this.setMediaTrack(
          yield this.mediaInterface.getVideoTrack(this.userSelectedDevice)
        );
      } catch (r) {
        throw this.logger.error("VideoMediaHandler.setDevice.error", {
          error: r
        }), this.disableTrack(), new R("Failed to change device", "1600", this.logger);
      }
    });
  }
  enableTrack(e, r) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("VideoMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (r) {
        this.isCustomTrack = true, yield this.setMediaTrack(r, true);
        return;
      }
      this.isCustomTrack = false;
      const i = yield this.mediaInterface.getVideoTrack(
        this.userSelectedDevice
      );
      yield this.setMediaTrack(i);
    });
  }
  setTransformedTrack(e) {
    return u(this, null, function* () {
      var r;
      if (!e && !((r = this.middlewares) != null && r.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield a(this, cn).getTransformedVideoTrack(
          this.middlewares,
          this.mediaTrack,
          a(this, Xo)
        ), this.emit("trackChanged");
      } catch (i) {
        this.logger.error("VideoMediaHandler.setTransformedTrack", {
          error: i
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  setVideoMiddlewareGlobalConfig(e) {
    return u(this, null, function* () {
      m(this, Xo, e);
    });
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this._mediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this._mediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), yield this.setTransformedTrack(), this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        this.logger.error("VideoMediaHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  terminateMiddlewareWebWorker() {
    a(this, cn).terminateMiddlewareWebWorker();
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("VideoMediaHandler.TrackEnded"), this.disableTrack(), this.emit("trackEnded");
    });
  }
  onTrackMuted() {
    this.logger.info("VideoMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(e, r = false) {
    return u(this, null, function* () {
      if (!e || this.userSelectedDevice || r)
        return e;
      let i = e;
      const n = yield this.mediaInterface.getVideoInputDevices(), o = this.isNonPreferredDevice ? n.filter((c) => !this.isNonPreferredDevice(
        c
      )) : n;
      return !(o != null && o.length) || window.FAST_DYTE || o.find(
        (c) => c.deviceId === e.getSettings().deviceId
      ) || (i.stop(), this.logger.info("localmediahandler::setupstreams::found_video_non_preferred"), i = yield this.mediaInterface.getVideoTrack(
        o[0].deviceId
      )), i;
    });
  }
};
cn = /* @__PURE__ */ new WeakMap(), Xo = /* @__PURE__ */ new WeakMap();
zl([
  E.trace("VideoMediaHandler.setTransformedTrack")
], Yc.prototype, "setTransformedTrack", 1);
zl([
  E.trace("VideoMediaHandler.setVideoMiddlewareGlobalConfig")
], Yc.prototype, "setVideoMiddlewareGlobalConfig", 1);
zl([
  E.trace("VideoMediaHandler.onTrackEnded")
], Yc.prototype, "onTrackEnded", 1);
zl([
  E.trace("VideoMediaHandler.conditionallyChangeTrack")
], Yc.prototype, "conditionallyChangeTrack", 1);
var b0 = Yc;
var mg = _s(
  kh()
);
var Rt;
var Ii;
var Zo;
var dn;
var Da = class {
  constructor(t) {
    g(this, Rt, void 0);
    g(this, Ii, void 0);
    g(this, Zo, void 0);
    g(this, dn, void 0);
    if (!t)
      throw new R("Could not load preset.", "0904");
    m(this, Rt, t.config), m(this, Zo, t.name), m(this, Ii, t.ui || _s(kh().ui)), m(this, dn, t.permissions.plugins.config);
  }
  /** @deprecated. Use init() */
  static fromResponse(t) {
    return new Da(t);
  }
  /** @deprecated. Use init() */
  static default() {
    return new Da(mg);
  }
  static init(t, e = true) {
    return !t || e ? new Da(mg) : new Da(t);
  }
  /**
   * @deprecated
   * The `setupScreen` represents the setup screen for the meeting.
   */
  get setupScreen() {
    return {
      isEnabled: true
    };
  }
  /**
   * @deprecated
   * The `waitingRoom` contains the properties to show a layout when
   * the participant is in waiting to join the meeting.
   */
  get waitingRoom() {
    return {
      isEnabled: true
    };
  }
  /**
   * @deprecated
   * The `controlBar` contains the properties to show the meeting control bar with
   * various action buttons for the meeting.
   * The `elements` key contains the various action buttons.
   */
  get controlBar() {
    return {
      isEnabled: true,
      elements: {
        chat: true,
        fullscreen: true,
        invite: false,
        layout: false,
        participants: true,
        plugins: true,
        polls: true,
        reactions: false,
        screenshare: true
      }
    };
  }
  /**
   * @deprecated
   * The `header` contains the properties to show the meeting header with various elements.
   * The `elements` key contains the following properties
   * `logo` - string value representing the public URL for the logo
   * `timer` - boolean value suggesting if the timer should be shown
   * `title` - boolean value suggesting if the meeting title should be shown
   * `participantCount` - boolean value suggesting if the participant count shuld be shown
   * `changeLayout` - boolean value suggesting if the participant can change layout
   */
  get header() {
    return {
      isEnabled: true,
      elements: {
        logo: a(this, Ii).designTokens.logo,
        timer: true,
        title: true,
        participantCount: true,
        changeLayout: false
      }
    };
  }
  /**
   * @deprecated
   * The `pipMode` property returns a boolean value
   * If true, picture-in-picture mode is enabled for the participant.
   */
  get pipMode() {
    return true;
  }
  /**
   * The `viewType` tells the type of the meeting
   * possible values are: GROUP_CALL| LIVESTREAM | CHAT | AUDIO_ROOM
   */
  get viewType() {
    return a(this, Rt).viewType;
  }
  /**
   * The `livestreamViewerQualities` specifies the allowed qualities of a stream,
   * that can be viewed by a livestream viewer
   * */
  get livestreamViewerQualities() {
    return a(this, Rt).livestreamViewerQualities || [];
  }
  /**
   * The `maxVideoStreams` contains the maximum video
   * streams for mobile and desktop
   */
  get maxVideoStreams() {
    return a(this, Rt).maxVideoStreams;
  }
  /**
   * The `maxScreenShareCount` contains the maximum
   * possible concurrent screen shares
   */
  get maxScreenShareCount() {
    return a(this, Rt).maxScreenshareCount;
  }
  /**
   * @deprecated in favour of permissions.plugins.config
   */
  get plugins() {
    return [];
  }
  /**
   * The `disabledPlugins` property returns id of all disabled plugins
   */
  get disabledPlugins() {
    return Object.keys(a(this, dn)).filter((t) => a(this, dn)[t].disabled);
  }
  get designTokens() {
    return a(this, Ii).designTokens;
  }
  get configDiff() {
    return a(this, Ii).configDiff;
  }
  get mediaConstraints() {
    var t, e, r, i, n, o, c, d, l, p, f2, S, T, _, P, w, A, N, H, $, F, K, re, Je;
    return {
      audio: {
        enableStereo: (i = (r = (e = (t = a(this, Rt)) == null ? void 0 : t.media) == null ? void 0 : e.audio) == null ? void 0 : r.enableStereo) != null ? i : Pa.audio.enableStereo,
        enableHighBitrate: (d = (c = (o = (n = a(this, Rt)) == null ? void 0 : n.media) == null ? void 0 : o.audio) == null ? void 0 : c.enableHighBitrate) != null ? d : Pa.audio.enableHighBitrate
      },
      video: {
        quality: (S = (f2 = (p = (l = a(this, Rt)) == null ? void 0 : l.media) == null ? void 0 : p.video) == null ? void 0 : f2.quality) != null ? S : Pa.video.quality,
        frameRate: (w = (P = (_ = (T = a(this, Rt)) == null ? void 0 : T.media) == null ? void 0 : _.video) == null ? void 0 : P.frameRate) != null ? w : Pa.video.frameRate
      },
      screenshare: {
        quality: ($ = (H = (N = (A = a(this, Rt)) == null ? void 0 : A.media) == null ? void 0 : N.screenshare) == null ? void 0 : H.quality) != null ? $ : Pa.screenshare.quality,
        frameRate: (Je = (re = (K = (F = a(this, Rt)) == null ? void 0 : F.media) == null ? void 0 : K.screenshare) == null ? void 0 : re.frameRate) != null ? Je : Pa.screenshare.frameRate
      }
    };
  }
  get name() {
    return a(this, Zo);
  }
};
var Ku = Da;
Rt = /* @__PURE__ */ new WeakMap(), Ii = /* @__PURE__ */ new WeakMap(), Zo = /* @__PURE__ */ new WeakMap(), dn = /* @__PURE__ */ new WeakMap();
var k0 = Object.defineProperty;
var I0 = Object.getOwnPropertyDescriptor;
var Hf = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? I0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && k0(t, e, i), i;
};
var ln;
var ec;
var $h = class extends qt {
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    g(this, ln, void 0);
    h(this, "state", "IDLE");
    h(this, "playbackUrl");
    h(this, "ingestionCredentials");
    h(this, "viewerCount");
    g(this, ec, void 0);
    m(this, ln, r), m(this, ec, e), this.viewerCount = 0;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ec).getValue("telemetry");
  }
  setLivestreamState(e) {
    const r = this.state;
    this.state = e, r !== e && this.emitCurrentLivestreamState();
  }
  emitCurrentLivestreamState() {
    this.emit("livestreamUpdate", this.state);
  }
  start() {
    return u(this, arguments, function* (e = {
      manualIngestion: false
    }) {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::start::permission_denied"), new R(
          "User does not have permission to start livestreaming",
          "1901"
        );
      this.setLivestreamState("STARTING");
      try {
        const r = lt(), {
          playbackUrl: i,
          ingestionCredentials: n
        } = yield r.startLivestreaming(e);
        this.playbackUrl = i, this.ingestionCredentials = n, e != null && e.manualIngestion && this.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
      } catch (r) {
        throw this.logger.error("DyteRecording::stop::livestream_failed_to_start", {
          error: r
        }), this.setLivestreamState("IDLE"), new R("Error while starting livestream", "1900", this.logger);
      }
    });
  }
  stop() {
    return u(this, null, function* () {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::stop::permission_denied"), new R(
          "User does not have permission to stop livestreaming",
          "1901"
        );
      if (this.state !== "LIVESTREAMING" && this.state !== "WAITING_ON_MANUAL_INGESTION")
        throw this.logger.error("DyteLivestream::stop::inconsistent_state"), new R("Livestream not started yet", "1902");
      try {
        this.setLivestreamState("STOPPING"), yield lt().stopLivestreaming();
      } catch (e) {
        throw this.logger.error("DyteLivestream::stop::livestream_failed_to_stop", {
          error: e
        }), this.setLivestreamState("STOPPING"), new R("Error while stopping livestream", "1900", this.logger);
      }
    });
  }
};
ln = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap();
Hf([
  E.trace("livestream.start")
], $h.prototype, "start", 1);
Hf([
  E.trace("livestream.stop")
], $h.prototype, "stop", 1);
var A0 = Object.defineProperty;
var M0 = Object.getOwnPropertyDescriptor;
var D0 = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? M0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && A0(t, e, i), i;
};
var un;
var hn;
var Ys;
var Ms;
var Bf = class {
  constructor(t, e, r) {
    h(this, "livestream");
    g(this, un, void 0);
    g(this, hn, void 0);
    g(this, Ys, void 0);
    g(this, Ms, void 0);
    m(this, Ms, t), m(this, hn, e), this.livestream = new $h(t, e), m(this, Ys, r), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ms).getValue("logger");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ms).getValue("telemetry");
  }
  fetchInitialLivestreamingState() {
    return u(this, null, function* () {
      const t = lt(), {
        status: e,
        playbackUrl: r,
        manualIngest: i,
        ingestionCredentials: n
      } = yield t.getActiveLivestream();
      this.livestream.playbackUrl = r, this.livestream.ingestionCredentials = n, e === "LIVE" && this.livestream.setLivestreamState("LIVESTREAMING"), e === "INVOKED" && i && this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
    });
  }
  setupEvents() {
    a(this, Ys).on(
      x.startedLivestream,
      (t) => u(this, null, function* () {
        this.livestream.playbackUrl = t.playbackUrl, this.livestream.setLivestreamState("LIVESTREAMING");
        try {
          a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
        } catch (e) {
          this.logger.error("Error: LivestreamController.fetchLivestream during startedLivestream re-fetch");
        }
      })
    ), a(this, Ys).on(
      x.livestreamingInvoked,
      (t) => u(this, null, function* () {
        if (t.manualIngest) {
          this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
          try {
            a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
          } catch (e) {
            this.logger.error("Error: LivestreamController.fetchLivestream during livestreamingInvoked re-fetch");
          }
        }
      })
    ), a(this, Ys).on(x.stoppedLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0, this.livestream.ingestionCredentials = void 0;
    }), a(this, Ys).on(x.erroredLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0;
    }), a(this, Ys).on(
      x.roomPeerCount,
      (t) => {
        this.livestream.viewerCount = t.count, this.livestream.emit("viewerCountUpdate", t.count);
      }
    ), a(this, Ms).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (t) => u(this, null, function* () {
        var e;
        ((e = t.flags) == null ? void 0 : e.hiddenParticipant) === true && t.recorderType === "LIVESTREAMER" && (m(this, un, t.id), this.livestream.setLivestreamState("LIVESTREAMING"));
      })
    ), a(this, Ms).getValue("peerSessionStore").on(k.PEER_CLOSED, (t) => {
      t.id === a(this, un) && (m(this, un, void 0), this.livestream.setLivestreamState("IDLE"));
    }), a(this, Ms).getValue("peerSessionStore").onAsync(k.LEAVE_MEDIA_ROOM, () => u(this, null, function* () {
      if (!this.livestream.playbackUrl) {
        this.logger.info("Fetching livestreaming state on leave stage");
        try {
          yield this.fetchInitialLivestreamingState();
        } catch (t) {
          this.logger.error("Failed to fetch livestreaming state on leave stage", { error: t });
        }
      }
    })), a(this, Ms).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      try {
        yield this.fetchInitialLivestreamingState();
      } catch (t) {
        this.logger.error("Error: LivestreamController.fetchLivestream");
      }
    }));
  }
};
un = /* @__PURE__ */ new WeakMap(), hn = /* @__PURE__ */ new WeakMap(), Ys = /* @__PURE__ */ new WeakMap(), Ms = /* @__PURE__ */ new WeakMap();
D0([
  E.trace("LivestreamController.setupEvents")
], Bf.prototype, "setupEvents", 1);
var O0 = Object.defineProperty;
var N0 = Object.getOwnPropertyDescriptor;
var Qc = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? N0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && O0(t, e, i), i;
};
var nt;
var Ur;
var $r;
var Kd;
var qf;
var Yn = class {
  constructor({ name: t, socketHandler: e, meetingId: r }) {
    g(this, Kd);
    h(this, "name", "");
    g(this, nt, {});
    g(this, Ur, "");
    g(this, $r, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "bulkRateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "listeners", {});
    this.name = t, m(this, $r, e), m(this, Ur, r);
  }
  /**
     * @description Sets a value in the store.
     * @param {string} key - Unique identifier used to store value.
     * @param {any} value - Data to be set.
     * @returns {Promise<void>} A promise.
     */
  set(t, e, r = true, i = false) {
    return u(this, null, function* () {
      a(this, nt)[t] = e, r && this.remoteSet(t, e), i && (this.listeners[t] && this.listeners[t].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ), this.listeners["*"] && this.listeners["*"].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ));
    });
  }
  remoteSet(t, e) {
    a(this, $r).storeInsertKeys(a(this, Ur), this.name, [{ key: t, payload: e }]);
  }
  bulkSet(t) {
    return u(this, null, function* () {
      t.forEach(({ key: e, payload: r }) => {
        a(this, nt)[e] = r;
      }), a(this, $r).storeInsertKeys(a(this, Ur), this.name, t);
    });
  }
  update(t, e, r = true) {
    return u(this, null, function* () {
      L(this, Kd, qf).call(this, t, e, r);
    });
  }
  // eslint-disable-next-line consistent-return
  delete(t, e = true, r = false) {
    return u(this, null, function* () {
      if (a(this, nt)[t] && delete a(this, nt)[t], e)
        return a(this, $r).storeDeleteKeys(
          a(this, Ur),
          this.name,
          [{ key: t }]
        );
      r && (this.listeners[t] && (this.listeners[t].forEach((i) => i({ [t]: void 0 })), delete this.listeners[t]), this.listeners["*"] && this.listeners["*"].forEach((i) => i({ [t]: void 0 })));
    });
  }
  bulkDelete(t) {
    return u(this, null, function* () {
      return t.forEach(({ key: e }) => {
        a(this, nt)[e] && delete a(this, nt)[e];
      }), a(this, $r).storeDeleteKeys(
        a(this, Ur),
        this.name,
        t
      );
    });
  }
  /**
   * @description Returns value for the given key.
   * @param {string} key - Unique identifier used to store value.
   * @returns {any} Value for the given key.
   */
  get(t) {
    if (a(this, nt)[t])
      return a(this, nt)[t];
  }
  /**
   * @description Returns the entire store.
   * @returns {StoreData} An instance of StoreData.
   */
  getAll() {
    return a(this, nt);
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  get bulkRateLimits() {
    return this.bulkRateLimitConfig;
  }
  // eslint-disable-next-line class-methods-use-this
  updateBulkRateLimits(t, e) {
    this.bulkRateLimitConfig.maxInvocations = t, this.bulkRateLimitConfig.period = e;
  }
  /**
   * @description Listens for data change on a store key.
   * @param {string} key - Unique identifier used to store value.
   * @param {Function} cb - The callback function that gets executed
   * when data is modified.
   * @returns {void} void
   */
  subscribe(t, e) {
    if (this.listeners[t]) {
      this.listeners[t].push(e);
      return;
    }
    this.listeners[t] = [e];
  }
  /**
     * @description Removes all listeners for a key on the store.
     * @param {string} key - Unique identifier used to store value.
  * * @param {Function} cb - Callback to be removed.
     * @returns {void} void
     */
  unsubscribe(t, e) {
    var r;
    if (e) {
      this.listeners[t] = ((r = this.listeners[t]) == null ? void 0 : r.filter((i) => i !== e)) || [];
      return;
    }
    this.listeners[t] && delete this.listeners[t];
  }
  populate(t) {
    m(this, nt, t);
  }
};
nt = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), $r = /* @__PURE__ */ new WeakMap(), Kd = /* @__PURE__ */ new WeakSet(), qf = function(t, e, r = true) {
  let i;
  const n = a(this, nt)[t], o = Object.prototype.toString.call(e), c = Object.prototype.toString.call(n);
  if (o !== c) {
    this.set(t, e);
    return;
  }
  switch (c) {
    case "[object Array]":
      i = [...n, ...e];
      break;
    case "[object Object]":
      i = D(D({}, n), e);
      break;
    case "[object Map]":
      i = new Map([...n, ...e]);
      break;
    case "[object Set]":
      i = /* @__PURE__ */ new Set([...n, ...e]);
      break;
    default:
      i = e;
      break;
  }
  this.set(t, i, r);
};
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "remoteSet", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkSet", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "update", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "delete", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkDelete", 1);
var Ai;
var Mi;
var tc;
var zu;
var sc;
var Fr;
var zd;
var jf;
var V0 = class {
  constructor(t, e) {
    g(this, tc);
    g(this, zd);
    h(this, "stores", /* @__PURE__ */ new Map());
    g(this, Ai, void 0);
    g(this, Mi, "");
    g(this, sc, void 0);
    g(this, Fr, /* @__PURE__ */ new Map());
    m(this, Ai, e), m(this, Mi, t.getValue("meetingId")), m(this, sc, t), L(this, zd, jf).call(this);
  }
  create(t) {
    const e = new Yn(
      { name: t, socketHandler: a(this, Ai), meetingId: a(this, Mi) }
    );
    return a(this, Ai).storeGetKeys(a(this, Mi), t, []), new Promise((i, n) => {
      const o = setTimeout(() => n(Error("Failed")), 3e3);
      a(this, Fr).set(t, { rejectTimeout: o, resolve: i, store: e });
    });
  }
};
Ai = /* @__PURE__ */ new WeakMap(), Mi = /* @__PURE__ */ new WeakMap(), tc = /* @__PURE__ */ new WeakSet(), zu = function() {
  return a(this, sc).getValue("peerId");
}, sc = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), zd = /* @__PURE__ */ new WeakSet(), jf = function() {
  [
    W.storeInsertKeys,
    W.storeGetKeys,
    W.storeDeleteKeys
  ].forEach((t) => {
    a(this, Ai).on(
      t,
      (e) => u(this, null, function* () {
        var n, o;
        if (e.pluginId !== a(this, Mi))
          return;
        const r = (n = e.storeItems) == null ? void 0 : n.map((c) => {
          var d;
          return {
            timestamp: c.timestamp,
            peerId: c.peerId,
            payload: JSON.parse(
              (d = c.payload) != null && d.length ? new TextDecoder().decode(c.payload) : "{}"
            ),
            key: c.storeKey
          };
        });
        if (t === W.storeGetKeys) {
          const c = a(this, Fr).get(e.storeName), d = this.stores.get(e.storeName) || (c == null ? void 0 : c.store);
          a(this, Fr).get(e.storeName) && (this.stores.set(e.storeName, c.store), c.resolve(d), clearTimeout(c.rejectTimeout), a(this, Fr).delete(e.storeName)), r.forEach((l) => {
            d.set(l.key, l.payload, false, false);
          });
          return;
        }
        const i = this.stores.get(e.storeName) || ((o = a(this, Fr).get(e.storeName)) == null ? void 0 : o.store);
        i !== void 0 && (t === W.storeInsertKeys && r.forEach(({ key: c, peerId: d, payload: l }) => {
          d !== a(this, tc, zu) && i.set(c, l, false, true);
        }), t === W.storeDeleteKeys && r.forEach(({ key: c, peerId: d }) => {
          d !== a(this, tc, zu) && i.delete(c, false, true);
        }));
      })
    );
  });
};
function gi(s) {
  var t, e, r, i, n, o, c, d, l, p, f2, S, T;
  return s ? {
    media: {
      audio: {
        enabled: s.audioEnabled,
        trackId: (t = s.audioTrack) == null ? void 0 : t.id,
        permission: "mediaPermissions" in s ? (e = s.mediaPermissions) == null ? void 0 : e.audio : null
      },
      video: {
        enabled: s.videoEnabled,
        trackId: (r = s.videoTrack) == null ? void 0 : r.id,
        permission: "mediaPermissions" in s ? (i = s.mediaPermissions) == null ? void 0 : i.video : null
      },
      screenshare: {
        enabled: s.screenShareEnabled,
        permission: "mediaPermissions" in s ? (n = s.mediaPermissions) == null ? void 0 : n.screenshare : null,
        audio: {
          enabled: (c = (o = s.screenShareTracks) == null ? void 0 : o.audio) == null ? void 0 : c.enabled,
          trackId: (l = (d = s.screenShareTracks) == null ? void 0 : d.audio) == null ? void 0 : l.id
        },
        video: {
          enabled: (f2 = (p = s.screenShareTracks) == null ? void 0 : p.video) == null ? void 0 : f2.enabled,
          trackId: (T = (S = s.screenShareTracks) == null ? void 0 : S.video) == null ? void 0 : T.id
        }
      }
    }
  } : {};
}
var L0 = Object.defineProperty;
var x0 = Object.getOwnPropertyDescriptor;
var Qn = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? x0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && L0(t, e, i), i;
};
var U0 = 0.8;
var $0 = 1.2;
var pn;
var gn;
var $t;
var Di;
var vo;
var Hr;
var wa;
var Oi;
var yo;
var Yd;
var Gf;
var Qs;
var rc;
var Br;
var Ni;
var To;
var Xs;
var Qd;
var ic;
var Yu;
var Xd;
var Wf;
var Zd;
var Jf;
var $g;
var yr = ($g = class extends qt {
  constructor(t, e, r, i) {
    const n = t.getValue("logger");
    super(n);
    g(this, Di);
    g(this, Hr);
    g(this, Oi);
    g(this, Yd);
    g(this, Ni);
    g(this, ic);
    g(this, Xd);
    g(this, Zd);
    h(this, "id");
    h(this, "userId");
    h(this, "name");
    h(this, "picture");
    h(this, "isHost");
    h(this, "customParticipantId");
    h(this, "flags");
    h(this, "device");
    h(this, "videoTrack");
    h(this, "audioTrack");
    h(this, "screenShareTracks");
    h(this, "videoEnabled");
    h(this, "audioEnabled");
    h(this, "screenShareEnabled");
    h(this, "producers");
    h(this, "manualProducerConfig");
    g(this, pn, void 0);
    h(this, "supportsRemoteControl", false);
    g(this, gn, void 0);
    h(this, "presetName");
    g(this, $t, void 0);
    g(this, Qs, void 0);
    g(this, rc, void 0);
    g(this, Br, /* @__PURE__ */ new Map());
    g(this, Xs, 1);
    g(this, Qd, Ih((t2) => {
      if (!this.videoTrack)
        return;
      const { clientWidth: e2, clientHeight: r2 } = t2, { width: i2, height: n2 } = this.videoTrack.getSettings();
      if (!i2 || !n2)
        return;
      const o2 = n2 / r2, c2 = i2 / e2, d2 = Math.max(o2, c2);
      d2 > $0 && a(this, Xs) === 1 ? (m(this, Xs, 0), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      })) : d2 < U0 && a(this, Xs) === 0 && (m(this, Xs, 1), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      }));
    }, 2e3));
    m(this, $t, t);
    const {
      id: o,
      userId: c,
      displayName: d,
      device: l,
      picture: p,
      isHost: f2,
      flags: S,
      clientSpecificId: T,
      stageStatus: _,
      customParticipantId: P,
      audioMuted: w,
      audioTrack: A,
      videoEnabled: N = false,
      videoTrack: H,
      producers: $,
      metadata: F
    } = e;
    this.id = o, this.userId = c, this.name = d, this.device = l, this.picture = p, this.isHost = f2, this.flags = S, this.manualProducerConfig = EC, m(this, gn, _ != null ? _ : "ON_STAGE"), this.customParticipantId = P != null ? P : T, this.audioEnabled = !w, this.audioTrack = A, this.videoEnabled = N, this.videoTrack = H, this.screenShareTracks = {
      audio: void 0,
      video: void 0
    }, this.producers = $ != null ? $ : [], this.presetName = F == null ? void 0 : F.preset_name, m(this, pn, false), m(this, Qs, r), m(this, rc, i), this.setupEvents(), this.updateVideo = this.updateVideo.bind(this), L(this, ic, Yu).call(this);
  }
  /**
   * @deprecated
   * Use `customParticipantId`
   */
  get clientSpecificId() {
    return this.customParticipantId;
  }
  /** Denotes the participants's current stage status. */
  get stageStatus() {
    return a(this, gn);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, $t).getValue("telemetry");
  }
  setVideoEnabled(t, e = true) {
    this.videoEnabled = t, e && (this.logger.info("DyteParticipant::setVideoEnabled::videoUpdate", D({}, gi(this))), this.emit("videoUpdate", {
      videoEnabled: this.videoEnabled,
      videoTrack: this.videoTrack
    }));
  }
  setAudioEnabled(t, e = true) {
    this.audioEnabled = t, e && (this.logger.info("DyteParticipant::setAudioEnabled::audioUpdate", D({}, gi(this))), this.emit("audioUpdate", {
      audioEnabled: this.audioEnabled,
      audioTrack: this.audioTrack
    }));
  }
  setScreenShareEnabled(t, e = true) {
    this.screenShareEnabled = t, e && this.emit("screenShareUpdate", {
      screenShareEnabled: this.screenShareEnabled,
      screenShareTracks: this.screenShareTracks
    });
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ic, Yu)), a(this, Hr, wa) && (this.on("audioUpdate", L(this, Xd, Wf)), this.on("screenShareUpdate", L(this, Zd, Jf)));
  }
  /**
   * Returns `participant.id` if user has permission
   * to pin participants.
   */
  pin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t pin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to pin participants.", "1201");
      return a(this, Di, vo).pinPeer(this.id);
    });
  }
  /**
   * Returns `participant.id` if user has permission
   * to unpin participants.
   */
  unpin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t unpin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to unpin participants.", "1201");
      return a(this, Di, vo).pinPeer(null);
    });
  }
  /**
   * @access private
   * Not for external use
   */
  setIsPinned(t, e = true) {
    var i;
    m(this, pn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, Ni, To)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  disableAudio() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_audio", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant audio without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantAudio)
        return a(this, Di, vo).disableAudio(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_audio", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant audio.",
        "1201"
      );
    });
  }
  kick() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::kick", {
        dyteParticipant: { id: t }
      }), !a(this, Yd, Gf))
        throw new R("Can`t kick participant without joining room", "1205");
      if (a(this, Qs).permissions.kickParticipant) {
        yield a(this, $t).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
          peerId: t
        });
        return;
      }
      throw this.logger.error("DyteParticipant::unauthorized_kick", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to kick participants.",
        "1201"
      );
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_video", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant video without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantVideo)
        return a(this, Di, vo).disableVideo(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_video", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant video.",
        "1201"
      );
    });
  }
  getPermissions() {
    return u(this, null, function* () {
      return a(this, rc).getUserPermissions(this.userId);
    });
  }
  setStageStatus(t) {
    m(this, gn, t), this.emit("stageStatusUpdate", this);
  }
  /**
   * Returns true if the participant is pinned.
   */
  get isPinned() {
    return a(this, pn);
  }
  registerVideoElement(t) {
    var r, i, n, o;
    if (!t)
      return;
    let e;
    (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), "ResizeObserver" in window && (e = new ResizeObserver(() => a(this, Qd).call(this, t)), e.observe(t)), a(this, Br).set(t, { observer: e }), this.updateVideo(t), (o = a(this, Ni, To)) == null || o.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (n = this.raised) != null ? n : false
    );
  }
  deregisterVideoElement(t) {
    var e, r, i, n;
    if (!t) {
      (e = a(this, Ni, To)) == null || e.removeSource(this.id);
      return;
    }
    t.srcObject = void 0, (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), a(this, Br).delete(t), (n = a(this, Ni, To)) == null || n.removeSource(this.id);
  }
  /**
   * Internal method, do not use
   */
  updateVideo(t) {
    var e;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const r = (e = t.srcObject) == null ? void 0 : e.getTracks()[0];
      if ((r == null ? void 0 : r.id) === this.videoTrack.id)
        return;
      const i = new MediaStream();
      i.addTrack(this.videoTrack), t.srcObject = i;
    } else
      t.srcObject = void 0;
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, pn = /* @__PURE__ */ new WeakMap(), gn = /* @__PURE__ */ new WeakMap(), $t = /* @__PURE__ */ new WeakMap(), Di = /* @__PURE__ */ new WeakSet(), vo = function() {
  return a(this, $t).getValue("roomNodeClient");
}, Hr = /* @__PURE__ */ new WeakSet(), wa = function() {
  return a(this, $t).getValue("audioPlayback");
}, Oi = /* @__PURE__ */ new WeakSet(), yo = function() {
  return a(this, $t).getValue("connectionHandler").mediaJoined;
}, Yd = /* @__PURE__ */ new WeakSet(), Gf = function() {
  return a(this, $t).getValue("connectionHandler").socketJoined;
}, Qs = /* @__PURE__ */ new WeakMap(), rc = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), Ni = /* @__PURE__ */ new WeakSet(), To = function() {
  return a(this, $t).getValue("pip");
}, Xs = /* @__PURE__ */ new WeakMap(), Qd = /* @__PURE__ */ new WeakMap(), ic = /* @__PURE__ */ new WeakSet(), Yu = function() {
  Array.from(a(this, Br).keys()).forEach(this.updateVideo);
}, Xd = /* @__PURE__ */ new WeakSet(), Wf = function() {
  var t, e;
  this.audioEnabled && this.audioTrack ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(this.id, this.audioTrack) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(this.id);
}, Zd = /* @__PURE__ */ new WeakSet(), Jf = function() {
  var t, e;
  this.screenShareEnabled && this.screenShareTracks.audio ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(`screenshare-${this.id}`, this.screenShareTracks.audio) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(`screenshare-${this.id}`);
}, $g);
Qn([
  E.trace("DyteParticipant.disableAudio")
], yr.prototype, "disableAudio", 1);
Qn([
  E.trace("DyteParticipant.kick")
], yr.prototype, "kick", 1);
Qn([
  E.trace("DyteParticipant.disableVideo")
], yr.prototype, "disableVideo", 1);
Qn([
  E.trace("DyteParticipant.getPermissions")
], yr.prototype, "getPermissions", 1);
Qn([
  E.trace("DyteParticipant.setStageStatus")
], yr.prototype, "setStageStatus", 1);
yr = Qn([
  ht("1200")
], yr);
var mi = class extends Vf {
  constructor(t, e) {
    const {
      onAddEvent: r = "participantJoined",
      onDeleteEvent: i = "participantLeft",
      onClearEvent: n = "participantsCleared"
    } = e != null ? e : {};
    super({
      onAddEvent: r,
      onDeleteEvent: i,
      onClearEvent: n
    }, t);
  }
  add(t, e = true) {
    return this.has(t.id) && Object.is(this.get(t.id), t) === false && this.delete(t.id), super.add(t, e);
  }
  clear(t = true, e = false) {
    return super.clear(t, e);
  }
  delete(t, e = true, r = false) {
    return super.delete(t, e, r);
  }
};
var qr;
var F0 = class extends Jn {
  constructor(e) {
    super(e);
    g(this, qr, void 0);
    m(this, qr, /* @__PURE__ */ new Map());
  }
  /**
   * @private
   */
  __set(e, r) {
    return a(this, qr).set(e, r);
  }
  /**
   * @private
   */
  __clear() {
    return a(this, qr).clear();
  }
  get(e) {
    return a(this, qr).get(e);
  }
  toArray() {
    return Array.from(a(this, qr).values());
  }
};
qr = /* @__PURE__ */ new WeakMap();
var H0 = class {
  constructor() {
    h(this, "_orderedArray");
    h(this, "_map");
    this._map = /* @__PURE__ */ new Map(), this._orderedArray = [];
  }
  add(t, e) {
    if (!this._map.has(t))
      return this._map.set(t, { peerId: t, priority: e }), this._orderedArray.splice(Math.max(e - 1, 0), 0, t), this.index(t);
    const r = this.index(t);
    this.delete(t);
    const i = this.add(t, e);
    return r !== i ? i : -1;
  }
  delete(t) {
    if (this._map.has(t)) {
      const e = this.index(t);
      this._map.delete(t), this._orderedArray.splice(e, 1);
    }
  }
  index(t) {
    return this._map.has(t) ? this._orderedArray.indexOf(t) : -1;
  }
  [Symbol.iterator]() {
    return this._orderedArray[Symbol.iterator]();
  }
};
var B0 = class {
  constructor() {
    h(this, "_activeSpeakerPeers");
    h(this, "_compulsoryPeers");
    this._activeSpeakerPeers = new H0(), this._compulsoryPeers = /* @__PURE__ */ new Set();
  }
  add(t, e, r) {
    if (!t)
      return -1;
    if (e < 0)
      return this._compulsoryPeers.add(t), 0;
    const i = r.getValue("logger");
    if (this.compulsoryPeers.includes(t) && (e > 0 || e === 246267631)) {
      if (i.info("DyteSelectedPeer::removing_compulsory_peer", {
        selectedPeer: {
          peerId: t
        }
      }), this._removeFromCompulsoryPeer(t), e === 246267631)
        return -1;
    } else if (e === 229490415)
      return this.delete(t, r), -1;
    return this._activeSpeakerPeers.add(t, e);
  }
  delete(t, e) {
    const r = e == null ? void 0 : e.getValue("logger");
    r == null || r.info("DyteSelectedPeer::deleting_peer_from_selectedPeer", {
      selectedPeer: {
        peerId: t
      }
    }), this._removeFromCompulsoryPeer(t), this._activeSpeakerPeers.delete(t);
  }
  index(t) {
    return this._activeSpeakerPeers.index(t);
  }
  get peers() {
    return Array.from(new Set(this.compulsoryPeers.concat(this.activeSpeakerPeers)));
  }
  get compulsoryPeers() {
    return Array.from(this._compulsoryPeers.values());
  }
  get activeSpeakerPeers() {
    return Array.from(this._activeSpeakerPeers);
  }
  _removeFromCompulsoryPeer(t) {
    this._compulsoryPeers.delete(t);
  }
};
var Kf = new B0();
var q0 = Object.defineProperty;
var j0 = Object.getOwnPropertyDescriptor;
var Wt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? j0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && q0(t, e, i), i;
};
var G0 = ["ACTIVE_GRID", "PAGINATED", "MANUAL"];
var Le;
var Vi;
var Eo;
var Li;
var _o;
var mn;
var Td;
var xi;
var wt;
var Fg;
var Pt = (Fg = class extends qt {
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    g(this, Vi);
    g(this, Li);
    g(this, mn);
    h(this, "waitlisted");
    h(this, "joined");
    h(this, "active");
    h(this, "videoSubscribed");
    h(this, "audioSubscribed");
    h(this, "pinned");
    h(this, "all");
    g(this, Le, void 0);
    g(this, xi, void 0);
    g(this, wt, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "viewMode");
    h(this, "currentPage");
    h(this, "lastActiveSpeaker");
    h(this, "selectedPeers", Kf);
    m(this, Le, t), m(this, xi, e), m(this, wt, r), this.waitlisted = new mi(i), this.joined = new mi(i), this.videoSubscribed = new mi(i), this.audioSubscribed = new mi(i), this.active = this.videoSubscribed, this.pinned = new mi(i), this.all = new F0(i), this.viewMode = "ACTIVE_GRID", this.currentPage = 0, this.setupEvents();
  }
  /**
   * Return the controls for Picture-in-Picture
   */
  get pip() {
    return a(this, Le).getValue("pip");
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Le).getValue("telemetry");
  }
  setupEvents() {
    a(this, Le).getValue("peerSessionStore").on(k.E2EE_ACTIVE_CONSUMER, ({ peerId: e }) => {
      var r;
      ((r = a(this, Le).getValue("modules").e2ee) == null ? void 0 : r.enabled) !== true && this.emit("media_decode_error", {
        reason: `Got encrypted media for participantId ${e}, but encryption wasn't enabled in init.defaults`,
        code: "1702"
      });
    });
    const t = a(this, Le).getValue("audioPlayback");
    t && this.audioSubscribed.on("participantLeft", (e) => {
      t.removeParticipantTrack(e.id);
    });
  }
  /**
   * Returns the number of participants who are joined in the meeting.
   */
  get count() {
    return this.joined.size;
  }
  /**
   * Returns the maximum number of participants that can be present in
   * the active map.
   */
  get maxActiveParticipantsCount() {
    var t;
    return (t = a(this, Le)) == null ? void 0 : t.getValue("maxPreferredStreams");
  }
  /**
   * Updates the maximum number of participants that are populated in
   * the active map.
   *
   * @param limit: Updated max limit
   */
  setMaxActiveParticipantsCount(t) {
    if (t < 0 || t > 24)
      throw new R("0 <= Max active participants count limit <= 24", "1203");
    a(this, Le).setValue("maxPreferredStreams", t), a(this, mn, Td) && a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  /**
   * Returns the number of pages that are available in the meeting in PAGINATED mode.
   * If the meeting is in ACTIVE_GRID mode, this value will be 0.
   */
  get pageCount() {
    if (this.viewMode === "PAGINATED") {
      const t = this.selectedPeers.compulsoryPeers.length, e = this.joined.toArray().filter((r) => r.stageStatus === "ON_STAGE");
      return Math.ceil(
        (e.length - t) / Math.max(this.maxActiveParticipantsCount - t, 1)
      );
    }
    return 0;
  }
  /**
   * Accepts requests from waitlisted participants if user
   * has appropriate permissions.
   * @param id peerId or userId of the waitlisted participant.
   */
  acceptWaitingRoomRequest(t) {
    var r, i;
    if (!a(this, Li, _o))
      throw new R(
        "Can`t accept waiting room request without joining room",
        "1205"
      );
    const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
    return a(this, wt).acceptWaitingRoomRequest([e]);
  }
  /**
   * We need a new event for socket service events
   * since if we send them all together, sequence of events
   * can be unreliable
   */
  acceptAllWaitingRoomRequest(t) {
    return u(this, null, function* () {
      const e = t.map((r) => {
        var i, n;
        return (n = (i = this.waitlisted.get(r)) == null ? void 0 : i.userId) != null ? n : r;
      });
      return a(this, wt).acceptWaitingRoomRequest(e);
    });
  }
  /**
   * Rejects requests from waitlisted participants if user
   * has appropriate permissions.
   * @param id participantId of the waitlisted participant.
   */
  rejectWaitingRoomRequest(t) {
    return u(this, null, function* () {
      var r, i;
      if (!a(this, Li, _o))
        throw new R(
          "Can`t reject waiting room request without joining room",
          "1205"
        );
      const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
      a(this, wt).rejectWaitingRoomRequest([e]);
    });
  }
  setViewMode(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_view_mode", {
        pageNavigation: {
          viewMode: t,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), !((r) => G0.includes(r))(t))
        throw this.logger.error("DyteParticipants::setViewMode::invalid_view_mode", {
          pageNavigation: {
            viewMode: t,
            currentPage: this.currentPage,
            pageCount: this.pageCount,
            maxActiveParticipantsCount: this.maxActiveParticipantsCount
          }
        }), new R(
          `Invalid view mode: ${t}. Try ACTIVE_GRID, PAGINATED or MANUAL.`,
          "1207"
        );
      if (this.viewMode === t) {
        this.logger.info(
          "DyteParticipants::setViewMode::view_mode_same_as_previous"
        );
        return;
      }
      if (t === "MANUAL")
        throw new R(
          "Manual Subscription is not enabled for your Organization. Please contact support.",
          "1208"
        );
      this.viewMode = t, t === "PAGINATED" ? (this.currentPage = 1, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: this.currentPage })) : t === "ACTIVE_GRID" && (this.currentPage = 0, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE)), this.emit("viewModeChanged", {
        viewMode: t,
        currentPage: this.currentPage,
        pageCount: this.pageCount
      });
    });
  }
  subscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: true
            }), this.videoSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: true
            }), this.audioSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: true
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: true
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).createConsumers(i);
    });
  }
  unsubscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: false
            });
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: false
            });
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: false
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: false
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).closeConsumers(i);
    });
  }
  // NOTE(itzmanish): hive systems specific code
  getPeerIdsForCurrentPage() {
    this.logger.info("DyteParticipants::getPeerIdsForCurrentPage()", {
      pageNavigation: {
        viewMode: this.viewMode,
        currentPage: this.currentPage,
        pageCount: this.pageCount,
        maxActiveParticipantsCount: this.maxActiveParticipantsCount
      }
    });
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (c) => this.joined.has(c)
    ), r = Array.from(this.pinned.keys()).filter(
      (c) => !e.includes(c)
    ), i = Array.from(this.joined.toArray().filter((c) => c.stageStatus === "ON_STAGE").map((c) => c.id)), n = Math.max(
      (this.currentPage - 1) * (this.maxActiveParticipantsCount - e.length - r.length)
    ), o = this.currentPage * (this.maxActiveParticipantsCount - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  setPage(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_page", {
        pageNavigation: {
          settingPage: t,
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), this.viewMode === "PAGINATED") {
        if (!Number.isInteger(t))
          throw this.logger.error("DyteParticipants::invalid_page_number"), new R(`Invalid page: ${t}. Page must be an integer and greater than 0 and less than or equal to .pageCount`, "1202");
        this.currentPage = t, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: t }), this.emit("pageChanged", {
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount
        });
      }
    });
  }
  disableAllAudio(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), !a(this, mn, Td))
        throw new R("Can`t disable all audio without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantAudio)
        return a(this, Vi, Eo).muteAll(t);
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), new R(
        "Unauthorized: User does not have permission to disable peer audio.",
        "1201"
      );
    });
  }
  disableAllVideo() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_video"), !a(this, mn, Td))
        throw new R("Can`t disable all video without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantVideo)
        return a(this, Vi, Eo).muteAllVideo();
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_video"), new R(
        "Unauthorized: User does not have permission to disable peer video.",
        "1201"
      );
    });
  }
  disableAudio(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableAudio();
    });
  }
  disableVideo(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableVideo();
    });
  }
  kick(t) {
    return u(this, null, function* () {
      yield a(this, Le).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
        peerId: t
      });
    });
  }
  kickAll() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::kick_all"), a(this, Le).getValue("viewType") !== "LIVESTREAM" && !a(this, Li, _o))
        throw new R("Can`t kick all without joining room", "1205");
      if (!a(this, xi).permissions.kickParticipant)
        throw this.logger.error("DyteParticipants::unauthorized_kick_all"), new R(
          "Unauthorized: User does not have permission to kick peers.",
          "1201"
        );
      const e = a(this, Le).getValue("flagsmith").hasFeature(X.PROPAGATE_KICK_ALL);
      a(this, wt).kickAll(e);
    });
  }
  broadcastMessage(t, e, r) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::broadcastMessage"), !a(this, Li, _o))
        throw new R("Can`t broadcast message without joining room", "1205");
      if (!(t != null && t.trim()))
        throw new R("`type` must be a non-empty string.", "1209");
      if (r)
        if ("meetingIds" in r)
          yield a(this, wt).broadcastToMeetings(t, r.meetingIds, e);
        else {
          let i = [];
          "participantIds" in r ? i = r.participantIds : i = this.joined.toArray().filter(
            (n) => {
              var o;
              return (o = r.presetNames) == null ? void 0 : o.includes(n.presetName);
            }
          ).map((n) => n.id), yield a(this, wt).broadcastToPeers(t, i, e);
        }
      else
        yield a(this, wt).broadcastMessage(t, e);
    });
  }
  getAllJoinedPeers(t, e, r) {
    return u(this, null, function* () {
      return (yield a(this, wt).getRoomPeers(t, e, r)).peers.map(_r.formatSocketServiceMessage);
    });
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = this.joined.toArray().filter((n) => t.includes(n.id)).map((n) => n.userId), i = [...new Set(r)];
      if (!i.length)
        throw new R("Cannot update permissions, no valid userIDs found", "1204");
      a(this, wt).updatePermissions(i, e);
    });
  }
  getParticipantsInMeetingPreJoin() {
    return u(this, null, function* () {
      return a(this, wt).getRoomPeersNonPaginated();
    });
  }
}, Le = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakSet(), Eo = function() {
  return a(this, Le).getValue("roomNodeClient");
}, Li = /* @__PURE__ */ new WeakSet(), _o = function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === true;
}, mn = /* @__PURE__ */ new WeakSet(), Td = function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === true;
}, xi = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), Fg);
Wt([
  E.trace("DyteParticipants.setViewMode")
], Pt.prototype, "setViewMode", 1);
Wt([
  E.trace("DyteParticipants.setPage")
], Pt.prototype, "setPage", 1);
Wt([
  E.trace("DyteParticipants.disableAllAudio")
], Pt.prototype, "disableAllAudio", 1);
Wt([
  E.trace("DyteParticipants.disableAllVideo")
], Pt.prototype, "disableAllVideo", 1);
Wt([
  E.trace("DyteParticipants.disablePeerAudio")
], Pt.prototype, "disableAudio", 1);
Wt([
  E.trace("DyteParticipants.disablePeerVideo")
], Pt.prototype, "disableVideo", 1);
Wt([
  E.trace("DyteParticipants.kickPeer")
], Pt.prototype, "kick", 1);
Wt([
  E.trace("DyteParticipants.kickAll")
], Pt.prototype, "kickAll", 1);
Wt([
  E.trace("DyteParticipants.broadcastMessage"),
  Dt(zn, "rateLimitConfig")
], Pt.prototype, "broadcastMessage", 1);
Wt([
  E.trace("DyteParticipants.getAllJoinedPeers"),
  Dt({ maxInvocations: 10, period: 60 })
], Pt.prototype, "getAllJoinedPeers", 1);
Wt([
  E.trace("DyteParticipant.updatePermissions"),
  Dt({ maxInvocations: 1e3, period: 60 })
], Pt.prototype, "updatePermissions", 1);
Wt([
  E.trace("DyteParticipants.getParticipantsInMeetingPreJoin")
], Pt.prototype, "getParticipantsInMeetingPreJoin", 1);
Pt = Wt([
  ht("1200")
], Pt);
var xa = ((s) => (s.NEW = "new", s.CONNECTING = "connecting", s.RECONNECTING = "reconnecting", s.DISCONNECTED = "disconnected", s.CONNECTED = "connected", s.FAILED = "failed", s.CLOSED = "closed", s))(xa || {});
var we = ((s) => (s[s.HIVE = 1] = "HIVE", s[s.ROOM_NODE = 2] = "ROOM_NODE", s[s.CF = 3] = "CF", s))(we || {});
var W0 = Object.defineProperty;
var J0 = Object.getOwnPropertyDescriptor;
var Ea = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? J0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && W0(t, e, i), i;
};
var Zs;
var er;
var tr;
var Ui;
var fn;
var Hg;
var ba = (Hg = class {
  constructor(s, t, e, r) {
    h(this, "participants");
    h(this, "self");
    h(this, "selectedPeers", Kf);
    h(this, "maxSpatialLayerUpdates", /* @__PURE__ */ new Map());
    h(this, "consumerPeerMap");
    h(this, "events");
    h(this, "roomSocketHandler");
    h(this, "context");
    h(this, "videoPeerConsumerMap", /* @__PURE__ */ new Map());
    g(this, Zs, { mode: "ACTIVE_GRID", page: 0 });
    g(this, er, void 0);
    g(this, tr, void 0);
    g(this, Ui, false);
    g(this, fn, false);
    h(this, "updateConsumerSpatialLayers", Ih(() => {
      const s2 = {}, t2 = new Map(this.maxSpatialLayerUpdates);
      this.maxSpatialLayerUpdates.clear(), Array.from(t2.entries()).forEach(([e2, r2]) => {
        s2[r2] === void 0 && (s2[r2] = {
          layer: r2,
          consumerIds: []
        }), s2[r2].consumerIds.push(e2);
      }), Object.keys(s2).forEach((e2) => {
        const r2 = s2[e2];
        this.logger.log(`Switching max spatial layer to ${r2.layer}`, { consumerIds: r2.consumerIds }), this.roomNodeClient.switchConsumersToLayer(r2.consumerIds, r2.layer);
      });
    }, 2e3));
    h(this, "updateConsumers", (s2, t2) => u(this, null, function* () {
      try {
        s2.length !== 0 && (this.logger.info("Queueing create consumers for producers", { producers: s2 }), yield this.roomNodeClient.createConsumers(s2));
      } catch (e2) {
        this.logger.error("Error activating peers", { error: e2 });
      }
      try {
        t2.length !== 0 && (this.logger.info("Queueing close consumers for producers", { producers: t2 }), yield this.roomNodeClient.closeConsumers(t2));
      } catch (e2) {
        this.logger.error("Error deactivating peers", { error: e2 });
      }
    }));
    this.context = s;
    const i = s.getValue("logger");
    switch (m(this, er, new mi(i)), m(this, tr, new mi(i)), this.roomSocketHandler = e, this.participants = new Pt(s, t, this.roomSocketHandler), this.self = t, this.consumerPeerMap = /* @__PURE__ */ new Map(), r) {
      case we.HIVE: {
        this.events = is;
        break;
      }
      case we.CF: {
        this.events = Ts;
        break;
      }
      default:
        this.events = is;
    }
    t.config.viewType !== "CHAT" && this.setupEventsGlobal(), this.setupEvents();
  }
  get roomNodeClient() {
    return this.context.getValue("roomNodeClient");
  }
  get mediaJoined() {
    var s;
    return ((s = this.roomNodeClient) == null ? void 0 : s.mediaJoined) === true;
  }
  get pip() {
    return this.context.getValue("pip");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  setupEvents() {
    this.roomSocketHandler.on(
      x.getWaitingRoomRequests,
      this.waitingRoomRequestHandler.bind(this)
    ), this.context.getValue("peerSessionStore").on(k.SOCKET_PEERS, (s) => u(this, null, function* () {
      const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
      if (t) {
        const e = s && (s == null ? void 0 : s.length) < 20 ? {
          peers: JSON.stringify(s.map((r) => r.peerId))
        } : void 0;
        this.logger.info("Processing socket peers", e);
      }
      s == null || s.forEach((e) => {
        e.waitlisted || this.onParticipantJoined(this.fromSocketService(e));
      }), t && this.logger.info("Processed socket peers");
    })), this.roomSocketHandler.on(
      this.events.peerJoinedBroadcast,
      ({ participant: s }) => {
        this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN) && this.logger.info("events.peerJoinedBroadcast", { peers: s.peerId }), this.onMediaJoined(
          s.peerId,
          s.producerStates,
          s.capabilities
        );
      }
    ), this.roomSocketHandler.on(
      this.events.selfJoinComplete,
      ({ participants: s, selectedPeers: t, roomState: e }) => {
        if (this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN)) {
          const n = s && (s == null ? void 0 : s.length) < 20 ? {
            peers: JSON.stringify(s.map((o) => o.peerId))
          } : void 0;
          this.logger.info("events.selfJoinComplete", n);
        }
        s.forEach(({ peerId: n, producerStates: o, capabilities: c }) => this.onMediaJoined(
          n,
          o,
          c
        ));
        const { audioPeers: r, compulsoryPeers: i } = t != null ? t : {};
        e.pinnedPeerIds.length !== 0 && this.onParticipantPinned(e.pinnedPeerIds[0]), this.computeActivateParticipants(r != null ? r : [], i), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: true });
      }
    ), this.context.getValue("peerSessionStore").on(
      k.MAX_SPATIAL_LAYER_CHANGE,
      ({ peerId: s, maxSpatialLayer: t }) => {
        const e = this.videoPeerConsumerMap.get(s);
        e && (this.maxSpatialLayerUpdates.set(e, t), this.updateConsumerSpatialLayers());
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_PRODUCER,
      ({ peerId: s, producer: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              },
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        if (e.producers.push(t), this.logger.info(
          "ParticipantController::NEW_PRODUCER::producer_added_to_participant",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        ), this.participants.viewMode === "MANUAL") {
          let r = false;
          const i = t.kind === "audio", n = t.kind === "video", o = e.manualProducerConfig;
          (i && (o.audio && !t.screenShare || o.screenshareAudio && t.screenShare) || n && (o.video && !t.screenShare || o.screenshareVideo && t.screenShare)) && (r = true), r ? this.roomNodeClient.createConsumers([t]) : this.logger.info(
            "ParticipantController::NEW_PRODUCER::not_consuming_producer",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                peerId: s,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              }
            }
          );
          return;
        }
        (t == null ? void 0 : t.kind) === "audio" && this.participants.audioSubscribed.get(s) || (t == null ? void 0 : t.kind) === "video" && this.participants.videoSubscribed.get(s) || t != null && t.screenShare ? this.roomNodeClient.createConsumers([t]).catch((r) => {
          this.logger.error("ParticipantController::createConsumer failed", { error: r });
        }) : this.logger.info(
          "ParticipantController::NEW_PRODUCER::not_consuming_producer",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_CLOSED,
      ({ peerId: s, producerId: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        e.producers = e.producers.filter(
          (r) => r.producerId !== t
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_TOGGLE,
      ({
        peerId: s,
        producerId: t,
        paused: e,
        kind: r
      }) => {
        const i = this.participants.joined.get(s);
        if (i) {
          r === "audio" && i.setAudioEnabled(!e);
          const n = i.producers.find(
            (o) => o.producerId === t
          );
          n && (n.pause = e);
        }
      }
    ), this.roomSocketHandler.on(
      this.events.globalPeerPinBroadcast,
      (s) => {
        let t;
        if (s && (t = s.participantId), !this.mediaJoined)
          return;
        const e = t;
        this.onParticipantPinned(e);
        const r = this.participants.joined.get(e);
        r && this.roomNodeClient.activatePeers(r.producers).catch((i) => {
          this.logger.error("unable to create consumers", {
            error: i
          });
        });
      }
    ), this.roomSocketHandler.on(this.events.selectedPeer, ({ audioPeers: s, compulsoryPeers: t }) => {
      this.mediaJoined && this.onSelectedPeers(t.concat(s));
    }), this.roomSocketHandler.on(this.events.selectedPeerDiff, ({ entries: s }) => {
      if (!this.mediaJoined)
        return;
      const t = s.map((e) => ({
        peerId: e.peerId,
        priority: e.priority
      }));
      this.updateActiveParticipantsWithPriorities(t, true);
    });
  }
  /**
   * Socket Service only
   */
  waitingRoomRequestHandler(s) {
    const t = s.requests.filter(
      (r) => !this.participants.waitlisted.toArray().find((i) => i.userId === r.userId)
    ), e = this.participants.waitlisted.toArray().filter(
      (r) => !s.requests.find((i) => i.userId === r.userId)
    );
    t.forEach((r) => this.participants.waitlisted.add(
      new yr(
        this.context,
        {
          id: r.peerId,
          displayName: r.displayName,
          audioMuted: true,
          videoEnabled: false,
          audioTrack: void 0,
          videoTrack: void 0,
          stageStatus: "OFF_STAGE",
          userId: r.userId,
          flags: {},
          isHost: false,
          customParticipantId: r.customParticipantId,
          picture: r.picture,
          metadata: {
            preset_name: r.presetName
          }
        },
        this.self,
        this.roomSocketHandler
      )
    )), e.forEach((r) => this.participants.waitlisted.delete(r.id));
  }
  get maxPreferredStreams() {
    return this.participants.maxActiveParticipantsCount;
  }
  selectPagePeers(s) {
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (d) => this.participants.joined.has(d)
    ), r = Array.from(this.participants.pinned.keys()).filter(
      (d) => !e.includes(d)
    ), i = Array.from(this.participants.joined.toArray().filter((d) => d.stageStatus === "ON_STAGE").map((d) => d.id)), n = Math.max(
      (s - 1) * (this.maxPreferredStreams - e.length - r.length)
    ), o = s * (this.maxPreferredStreams - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  selectActivePeers(s) {
    const t = /* @__PURE__ */ new Map(), e = Array.from(
      this.participants.joined.toArray().filter((p) => p.stageStatus === "ON_STAGE").map((p) => (t.set(p.id, true), p.id))
    ), r = this.selectedPeers.peers, i = this.participants.pinned.toArray().reduce((p, f2) => (f2.stageStatus !== "ON_STAGE" ? this.participants.pinned.delete(f2.id) : p.push(f2.id), p), []), n = this.self.stageStatus === "ON_STAGE" ? 1 : 0, o = s - n, c = new Set(
      r.concat(i).filter((p) => p !== this.self.id && t.has(p))
    );
    let d = Array.from(c);
    const l = o - c.size;
    if (l >= 0) {
      const p = e.filter((f2) => !c.has(f2) && f2 !== this.self.id).slice(0, l);
      d = Array.from(c).concat(p);
    } else
      d = d.slice(0, o);
    return d;
  }
  updateSubscriptions(s, t) {
    const { page: e, createAllConsumers: r } = t != null ? t : {};
    s && a(this, Zs).mode !== s && (a(this, Zs).mode = s), e && a(this, Zs).page !== e && (a(this, Zs).page = e);
    const { mode: i, page: n } = a(this, Zs);
    switch (r && (a(this, er).clear(), a(this, tr).clear()), i) {
      case "PAGINATED": {
        if (!n)
          return;
        const o = this.selectPagePeers(n), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMap(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c), this.logger.debug(
          "ParticipantController::updateActive::updating_current_page_peers",
          { peerIds: o }
        );
        break;
      }
      case "ACTIVE_GRID": {
        const o = this.selectActivePeers(this.participants.maxActiveParticipantsCount), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMapMinReplacement(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c);
        break;
      }
      default:
        throw new Error(`View mode ${s} not supported`);
    }
    setTimeout(() => this.syncConsumers(), a(this, Zs).mode === "PAGINATED" && !a(this, Ui) ? 200 : 0);
  }
  syncConsumers() {
    return u(this, null, function* () {
      var e, r, i;
      if (((i = (r = (e = this.context.getValue("connectionHandler")) == null ? void 0 : e.mediaState) == null ? void 0 : r.recv) == null ? void 0 : i.state) !== "connected")
        return;
      if (a(this, Ui)) {
        m(this, fn, true);
        return;
      }
      m(this, Ui, true), m(this, fn, false);
      let s = [], t = [];
      if (this.context.getValue("flagsmith").hasFeature(X.NEW_SYNC_CONSUMERS)) {
        const n = [], o = this.participants.videoSubscribed.toArray().reduce((P, w) => w.videoEnabled ? (n.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), c = [], d = this.participants.audioSubscribed.toArray().reduce((P, w) => w.audioEnabled ? (c.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), [l, p] = ba.mapDiff(
          a(this, er),
          o
        );
        this.updateParticipantsMap(a(this, er), n);
        const [f2, S] = ba.mapDiff(
          a(this, tr),
          d
        );
        this.updateParticipantsMap(a(this, tr), c);
        const T = p.filter((P) => !this.participants.videoSubscribed.get(P)), _ = S.filter((P) => !this.participants.audioSubscribed.get(P));
        s = [
          ...this.mapPeerIdsToProducers(l, ["video"]),
          ...this.mapPeerIdsToProducers(f2, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(T, ["video"]),
          ...this.mapPeerIdsToProducers(_, ["audio"])
        ];
      } else {
        const [n, o] = ba.mapDiff(
          a(this, er),
          this.participants.videoSubscribed
        );
        this.updateParticipantsMap(
          a(this, er),
          this.participants.videoSubscribed.toArray().filter(({ videoEnabled: l }) => !!l).map(({ id: l }) => l)
        );
        const [c, d] = ba.mapDiff(
          a(this, tr),
          this.participants.audioSubscribed
        );
        this.updateParticipantsMap(
          a(this, tr),
          this.participants.audioSubscribed.toArray().filter(({ audioEnabled: l }) => !!l).map(({ id: l }) => l)
        ), s = [
          ...this.mapPeerIdsToProducers(n, ["video"]),
          ...this.mapPeerIdsToProducers(c, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(o, ["video"]),
          ...this.mapPeerIdsToProducers(d, ["audio"])
        ];
      }
      try {
        (s.length > 0 || t.length > 0) && (yield this.updateConsumers(s, t));
      } finally {
        m(this, Ui, false);
      }
      a(this, fn) && this.syncConsumers();
    });
  }
  static mapDiff(s, t) {
    const e = [], r = [], i = Array.from(s.keys()), n = Array.from(t.keys());
    return i.forEach((o) => {
      n.includes(o) || r.push(o);
    }), n.forEach((o) => {
      i.includes(o) || e.push(o);
    }), [
      e,
      r
    ];
  }
  computeActivateParticipants(s, t) {
    const e = s.map((i, n) => ({
      peerId: i,
      priority: n + 1
    })), r = t == null ? void 0 : t.map((i, n) => ({
      peerId: i,
      priority: -(n + 1)
    }));
    e.push(...r != null ? r : []), e.length > 0 && this.updateActiveParticipantsWithPriorities(e);
  }
  fromSocketService(s) {
    const t = ba.formatSocketServiceMessage(s);
    return new yr(this.context, B(D({}, t), {
      isHost: false,
      videoEnabled: false,
      audioMuted: true,
      videoTrack: void 0,
      audioTrack: void 0
    }), this.self, this.roomSocketHandler);
  }
  updatePipSource(s, t) {
    var e, r;
    t ? (e = this.pip) == null || e.enableSource(s) : (r = this.pip) == null || r.disableSource(s);
  }
  onMediaJoined(s, t, e) {
    if (!this.mediaJoined || s === this.self.id)
      return;
    const r = this.participants.joined.get(s);
    if (!r) {
      this.logger.warn(`Received media.peerJoinedBroadcast for non-existent peer ${s}`);
      return;
    }
    t.forEach((i) => {
      i.kind === xs.AUDIO && !i.screenShare ? r.setAudioEnabled(!i.pause) : i.kind === xs.VIDEO && !i.screenShare && (r.setVideoEnabled(!i.pause), this.updatePipSource(r.id, !i.pause)), r.producers.push(B(D({}, i), {
        producingTransportId: i.producingTransportId,
        kind: i.kind === xs.AUDIO ? "audio" : "video",
        producingPeerId: s,
        mimeType: i.mimeType
      }));
    }), this.roomNodeClient.handlePeerCapabilities(s, e), this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || this.roomNodeClient.shareWebcam(this.self.videoTrack), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  /**
  	* NOTE(roerohan): The following piece of code updates .active and ensures that the positions
  	* in the peer map are not affected by the order of the peerIds
  	* sent in the input. If a participant is present in the 3rd position in the
  	* map, and room node sends the peerId in the 2nd position, the participant
  	* should remain in the 3rd position.
  */
  updateParticipantsMapMinReplacement(s, t) {
    const e = Array.from(s.keys()), r = new Map(s), i = new Set(t), n = [];
    e.forEach((o, c) => {
      (!i.has(o) || !this.participants.joined.get(o)) && n.push(c);
    }), t.forEach((o) => {
      if (s.get(o))
        return;
      if (e.length < t.length) {
        e.push(o);
        return;
      }
      const c = n.shift();
      e[c] = o;
    }), n.forEach((o) => {
      e.splice(o, 1);
    }), Array.from(s.keys()).forEach((o) => {
      s.delete(o, !i.has(o));
    }), e.forEach((o) => {
      if (!this.participants.joined.get(o)) {
        this.logger.warn(
          "updateActiveParticipants::participant_not_in_joined_list",
          {
            dyteParticipant: { id: o }
          }
        );
        return;
      }
      s.add(
        this.participants.joined.get(o),
        !r.get(o)
      );
    }), s.emit("participantsUpdate");
  }
  updateParticipantsMap(s, t) {
    Array.from(s.keys()).forEach((r) => {
      t.includes(r) || s.delete(r, true);
    }), t.forEach((r) => {
      s.get(r) || s.add(this.participants.joined.get(r), true);
    }), s.emit("participantsUpdate");
  }
  updatePinnedParticipants() {
    this.participants.pinned.forEach((s) => {
      s.setIsPinned(false), this.participants.pinned.delete(s.id);
    });
  }
  setupEventsGlobal() {
    this.roomSocketHandler.on(x.joinRoom, ({ peer: s }) => {
      if (!s.waitlisted) {
        const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
        t && this.logger.info("Processing socket join", { peers: s.peerId }), this.onParticipantJoined(this.fromSocketService(s)), t && this.logger.info("Processed socket join", { peers: s.peerId });
      }
    }), this.roomSocketHandler.on(x.leaveRoom, (s) => {
      const { peerId: t } = s.peer;
      this.selectedPeers.delete(t, this.context), this.onParticipantLeave(t);
    }), this.context.getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => {
        this.self.permissions.acceptWaitingRequests && this.roomSocketHandler.getWaitingRoomRequests();
      }
    ), this.self.permissions.on("permissionsUpdate", (s) => {
      const { acceptWaitingRequests: t } = s;
      t !== void 0 && (t ? this.roomSocketHandler.getWaitingRoomRequests() : this.participants.waitlisted.clear());
    }), this.context.getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, () => {
      this.participants.joined.clear(), this.participants.videoSubscribed.clear(), this.participants.audioSubscribed.clear(), this.participants.pinned.clear(), this.participants.currentPage = 0, this.participants.viewMode = "ACTIVE_GRID", this.participants.emit("viewModeChanged", {
        viewMode: "ACTIVE_GRID",
        currentPage: this.participants.currentPage,
        pageCount: this.participants.pageCount
      });
    }), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_PAUSED,
      ({ id: s }) => {
        this.processConsumerPaused(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_RESUMED,
      ({ id: s }) => {
        this.processConsumerResumed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_CONSUMER,
      ({ id: s }) => {
        this.processNewConsumer(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_CLOSED,
      ({ id: s }) => {
        this.processConsumerClosed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        t !== "spotlight" && this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.LOW_CONSUMER_SCORE,
      ({
        peerId: s,
        score: t,
        kind: e
      }) => {
        const r = this.participants.joined.get(s);
        r && (r.emit("poorConnection", { score: t, kind: e }), this.participants.emit("poorConnection", {
          participantId: s,
          score: t,
          kind: e
        }));
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        peerId: r,
        scoreStats: i
      }) => {
        var c;
        const n = t === "video" && ((c = e == null ? void 0 : e.screenShare) != null ? c : false), o = this.participants.joined.get(r);
        o && (o.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }), this.participants.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }));
      }
    ), this.context.getValue("peerSessionStore").onAsync(k.KICK_PEER, (t) => u(this, [t], function* ({ peerId: s }) {
      const e = this.participants.joined.get(s);
      this.roomNodeClient.kick(s), yield this.roomSocketHandler.kick(s), e ? e.emit("kicked") : this.participants.joined.emit("kicked", { id: s });
    })), this.context.getValue("peerSessionStore").on(k.UPDATE_ACTIVE, (...e) => u(this, [...e], function* ({ page: s, createAllConsumers: t } = {}) {
      this.updateSubscriptions(s ? "PAGINATED" : "ACTIVE_GRID", { page: s, createAllConsumers: t });
    }));
  }
  onParticipantPinned(s) {
    return u(this, null, function* () {
      if (!s) {
        this.self.isPinned && this.self.setIsPinned(false), this.participants.pinned.size !== 0 && this.updatePinnedParticipants();
        return;
      }
      if (s === this.self.id) {
        this.participants.pinned.size !== 0 && this.updatePinnedParticipants(), this.self.setIsPinned(true);
        return;
      }
      const t = this.participants.joined.get(s);
      this.self.isPinned && this.self.setIsPinned(false), this.updatePinnedParticipants(), t.setIsPinned(true), this.participants.pinned.add(t);
    });
  }
  onParticipantJoined(s) {
    return u(this, null, function* () {
      var t, e, r;
      this.self.id !== s.id && !((t = s.flags) != null && t.recorder) && !((e = s.flags) != null && e.hidden_participant) && !((r = s.flags) != null && r.hiddenParticipant) && (this.participants.videoSubscribed.delete(s.id), this.participants.audioSubscribed.delete(s.id), this.participants.joined.add(s), this.participants.waitlisted.delete(s.id), s.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: s.name,
          userId: s.userId,
          peerId: s.id
        },
        add: true
      })), this.context.getValue("peerSessionStore").emit(k.PEER_JOINED_INTERNAL, s);
    });
  }
  onParticipantLeave(s) {
    return u(this, null, function* () {
      const t = this.participants.joined.get(s);
      this.participants.joined.delete(s, true, true), this.participants.pinned.delete(s, true, true), this.participants.waitlisted.delete(s, true, true), this.roomNodeClient && (this.roomNodeClient.handlePeerLeaving(s), this.roomNodeClient.closeConsumers(t == null ? void 0 : t.producers)), t && t.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: t.name,
          userId: t.userId,
          peerId: t.id
        },
        add: false
      });
      const { currentPage: e } = this.participants, r = this.maxPreferredStreams * (e - 1), i = this.participants.videoSubscribed.get(s);
      r === 0 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.joined.size <= r ? e === 2 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.setPage(e - 1) : i && this.updateSubscriptions(
        e ? "PAGINATED" : "ACTIVE_GRID",
        { page: e }
      );
    });
  }
  processMedia(s) {
    var f2;
    const t = this.roomNodeClient.getConsumers(), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      producerId: o,
      rtpReceiver: c,
      paused: d,
      localId: l
    } = (f2 = t.get(s)) != null ? f2 : {};
    if (!e)
      return this.logger.warn("processMedia::Peer ID is undefined", {
        consumer: {
          id: s,
          kind: r,
          peerId: e,
          appData: {
            supportsRemoteControl: !!(i != null && i.supportsRemoteControl),
            screenShare: !!(i != null && i.screenShare)
          },
          remotelyPaused: d,
          producerId: o
        }
      }), {};
    const p = i;
    return r === "video" && p.screenShare !== true && this.videoPeerConsumerMap.set(e, s), this.logger.info("ParticipantController::processMedia", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: p,
        remotelyPaused: d,
        producerId: o
      }
    }), this.consumerPeerMap.set(s, {
      type: r,
      peerId: e,
      appData: p,
      remotelyPaused: d,
      producerId: o
    }), {
      peerId: e,
      kind: r,
      appData: p,
      remotelyPaused: d,
      track: n,
      producerId: o,
      rtpReceiver: c,
      localId: l
    };
  }
  processConsumerClosed(s) {
    const {
      peerId: t,
      type: e,
      appData: r,
      remotelyPaused: i,
      producerId: n
    } = this.consumerPeerMap.get(s) || {}, o = this.participants.joined.get(t);
    if (this.logger.info("ParticipantController::processConsumerClosed", {
      consumer: {
        id: s,
        peerId: t,
        appData: r,
        kind: e,
        remotelyPaused: i,
        producerId: n
      }
    }), this.consumerPeerMap.delete(s), e === "video" && r.screenShare !== true && this.videoPeerConsumerMap.delete(t), !o)
      return;
    const c = o.producers.find((l) => l.producerId === n);
    c && (c.consumer = {
      id: s,
      peerId: t,
      kind: void 0,
      appData: r,
      paused: i,
      producerId: n,
      rtpReceiver: void 0,
      localId: void 0
    });
    const d = [];
    r && r.screenShare ? (o.setScreenShareEnabled(false), this.context.getValue("callstats").consumerSharedMediaState(s, { screen: false }), o.screenShareTracks.video && d.push(o.screenShareTracks.video.id), o.screenShareTracks.audio && d.push(o.screenShareTracks.audio.id), o.screenShareTracks = {
      audio: void 0,
      video: void 0
    }) : e === "audio" ? (o.setAudioEnabled(false), o.audioTrack && d.push(o.audioTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { audio: false }), o.audioTrack = void 0) : e === "video" && (o.setVideoEnabled(false), this.updatePipSource(o.id, false), o.videoTrack && d.push(o.videoTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { video: false }), o.videoTrack = void 0), r.e2ee && d.forEach((l) => {
      this.context.getValue("peerSessionStore").emit(
        k.E2EE_INACTIVE_CONSUMER,
        {
          peerId: t,
          trackId: l
        }
      );
    });
  }
  processConsumerResumed(s) {
    var S;
    const t = this.processMedia(s), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      remotelyPaused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    } = t;
    if (!e)
      return;
    this.logger.info("ParticipantController::processConsumerResumed", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: i,
        remotelyPaused: o,
        producerId: c
      }
    });
    const p = this.participants.joined.get(e);
    if (!p)
      return;
    const f2 = p.producers.find((T) => T.producerId === c);
    if (f2 && (f2.consumer = {
      id: s,
      peerId: e,
      kind: r,
      appData: i,
      paused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    }), i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: e, rtpReceiver: d, track: n }), i.screenShare) {
      r === "video" ? p.screenShareTracks.video = n : r === "audio" && (p.screenShareTracks.audio = n), p.setScreenShareEnabled(true), (S = this.context) == null || S.getValue("callstats").consumerSharedMediaState(s, { screen: true });
      return;
    }
    r === "video" ? (p.videoTrack = n, p.setVideoEnabled(true), this.updatePipSource(p.id, true), this.context.getValue("callstats").consumerSharedMediaState(s, { video: true })) : r === "audio" && (p.audioTrack = n, p.setAudioEnabled(p.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: p.audioEnabled
    }));
  }
  processConsumerPaused(s) {
    this.logger.info(
      `ParticipantController::processConsumerPaused called for consumerId: ${s}`
    );
    const {
      peerId: t,
      kind: e,
      track: r,
      appData: i,
      remotelyPaused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processConsumerPaused", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        appData: i,
        remotelyPaused: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f2) => f2.producerId === o);
    p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: i,
      paused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), r && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_CONSUMER, { peerId: t, trackId: r.id }), e === "video" ? (l.videoTrack = r, l.setVideoEnabled(false), this.updatePipSource(l.id, false), this.context.getValue("callstats").consumerSharedMediaState(s, { video: false })) : e === "audio" && (l.audioTrack = r, l.setAudioEnabled(l.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: l.audioEnabled
    }));
  }
  processNewConsumer(s) {
    const {
      peerId: t,
      kind: e,
      remotelyPaused: r,
      track: i,
      appData: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processNewConsumer", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        remotelyPaused: r,
        appData: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f2) => f2.producerId === o);
    if (p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: n,
      paused: r,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), n.screenShare) {
      e === "video" ? l.screenShareTracks.video = i : e === "audio" && (l.screenShareTracks.audio = i), (!r || this.self.permissions.isRecorder || this.context.getValue("flagsmith").hasFeature(X.SCREEENSHARE_ERR_HACK)) && l.setScreenShareEnabled(true), n.supportsRemoteControl && (l.supportsRemoteControl = true), this.participants.broadcastMessage("screenshareConsumerCreated", {
        producerId: o,
        peerId: t,
        screenShare: true,
        consumerId: s,
        consumerPeerId: this.self.id
      }), this.logger.info("ParticipantController::newScreenshareConsumer::screenshareConsumerCreated", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          remotelyPaused: r,
          appData: n,
          producerId: o
        }
      });
      return;
    }
    e === "video" ? (l.videoTrack = i, r || (l.setVideoEnabled(true), this.updatePipSource(l.id, true)), this.context.getValue("callstats").consumerSharedMediaState(s, {
      video: !r
    })) : e === "audio" && (l.audioTrack = i, r || l.setAudioEnabled(true), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: !r
    })), !r && n.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: t, rtpReceiver: c, track: i });
  }
  static formatSocketServiceMessage(s) {
    var e, r, i, n, o, c;
    if (!s)
      return;
    const t = Nh(s.stageType);
    return {
      id: s.peerId,
      userId: s.userId,
      name: s.displayName,
      displayName: s.displayName,
      stageType: t,
      customParticipantId: s.customParticipantId,
      presetId: s.presetId,
      picture: s.displayPictureUrl,
      waitlisted: s.waitlisted,
      stageStatus: t,
      metadata: {
        preset_name: (e = s.flags) == null ? void 0 : e.presetName
      },
      recorderType: (r = s.flags) == null ? void 0 : r.recorderType,
      flags: {
        hiddenParticipant: (i = s.flags) == null ? void 0 : i.hiddenParticipant,
        hidden_participant: (n = s.flags) == null ? void 0 : n.hiddenParticipant,
        recorder: ((o = s.flags) == null ? void 0 : o.recorderType) !== void 0 && ((c = s.flags) == null ? void 0 : c.recorderType) !== "NONE"
      }
    };
  }
  mapPeerIdsToProducers(s, t) {
    const e = (i, n) => i.filter(({ kind: o, screenShare: c }) => n.includes(o) || c && n.includes("screenshare"));
    return s.flatMap((i) => {
      const n = this.participants.joined.get(i);
      if (n)
        return e(n.producers, t);
    }).filter((i) => !!i);
  }
  // XXX dead code, this event is not fired
  onSelectedPeers(s, t) {
    return u(this, null, function* () {
      this.participants.viewMode === "ACTIVE_GRID" && this.computeActivateParticipants(s, t);
    });
  }
  updateActiveParticipantsWithPriorities(s, t = false) {
    if (!this.mediaJoined) {
      this.logger.warn(
        "Skipped::ParticipantController::updateActiveParticipantsWithPriorities",
        {
          roomJoined: this.mediaJoined
        }
      );
      return;
    }
    s.forEach((r) => {
      this.selectedPeers.add(r.peerId, r.priority, this.context);
    });
    const e = this.selectedPeers.activeSpeakerPeers.at(0);
    e !== void 0 && e !== this.participants.lastActiveSpeaker && (this.participants.lastActiveSpeaker = e, this.participants.emit("activeSpeaker", {
      peerId: e,
      volume: 1
      // priority
    })), t && this.updateSubscriptions(this.participants.viewMode);
  }
}, Zs = /* @__PURE__ */ new WeakMap(), er = /* @__PURE__ */ new WeakMap(), tr = /* @__PURE__ */ new WeakMap(), Ui = /* @__PURE__ */ new WeakMap(), fn = /* @__PURE__ */ new WeakMap(), Hg);
var _r = ba;
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEvents", 1);
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEventsGlobal", 1);
Ea([
  E.trace("ParticipantController.processMedia")
], _r.prototype, "processMedia", 1);
Ea([
  E.trace("ParticipantController.processConsumerClosed")
], _r.prototype, "processConsumerClosed", 1);
Ea([
  E.trace("ParticipantController.processConsumerResumed")
], _r.prototype, "processConsumerResumed", 1);
Ea([
  E.trace("ParticipantController.processConsumerPaused")
], _r.prototype, "processConsumerPaused", 1);
Ea([
  E.trace("ParticipantController.processNewConsumer")
], _r.prototype, "processNewConsumer", 1);
var he = _s(
  kh().permissions
);
var q;
var Sn;
var $i;
var el;
var St;
var Vt;
var Oa = class extends qt {
  constructor(e, r, i, n = false) {
    const o = e.getValue("logger");
    super(o);
    g(this, St);
    g(this, q, void 0);
    g(this, Sn, void 0);
    g(this, $i, void 0);
    g(this, el, (e2) => {
      var p, f2, S;
      const l = e2, {
        chat: r2,
        connectedMeetings: i2,
        plugins: n2,
        polls: o2,
        media: c
      } = l, d = ho(l, [
        "chat",
        "connectedMeetings",
        "plugins",
        "polls",
        "media"
      ]);
      if (r2 && (r2.private && br(a(this, q).chat.private, r2.private), r2.public && br(a(this, q).chat.public, r2.public), this.emit("chatUpdate")), i2 && br(a(this, q).connectedMeetings, i2), c) {
        const T = (P) => {
          switch (P) {
            case Qr.NONE:
              return j.Allowed;
            case Qr.ALLOWED:
              return j.Allowed;
            case Qr.NOT_ALLOWED:
              return j.NotAllowed;
            case Qr.CAN_REQUEST:
              return j.CanRequest;
            default:
              return;
          }
        }, _ = {
          audio: void 0,
          video: void 0,
          screenshare: void 0
        };
        (p = c.audio) != null && p.canProduce && (_.audio = {
          canProduce: T(c.audio.canProduce)
        }), (f2 = c.video) != null && f2.canProduce && (_.video = {
          canProduce: T(c.video.canProduce)
        }), (S = c.screenshare) != null && S.canProduce && (_.screenshare = {
          canProduce: T(c.screenshare.canProduce)
        }), br(a(this, q).media, _);
      }
      n2 && (br(a(this, q).plugins, n2), this.emit("pluginsUpdate")), o2 && (br(a(this, q).polls, o2), this.emit("pollsUpdate")), Object.keys(d).length !== 0 && br(a(this, q), d), this.emit("permissionsUpdate", e2);
    });
    if (!r)
      throw this.logger.error("DytePermissionsPreset::load_preset_permissions_failed"), new R("Could not load preset permissions.", "0904");
    m(this, $i, e), m(this, Sn, i), m(this, q, r), n && this.setupEvents();
  }
  setupEvents() {
    a(this, $i).getValue("peerSessionStore").on(k.UPDATE_PERMISSIONS, a(this, el));
  }
  /** @deprecated. Use init() */
  static fromResponse(e, r, i) {
    return new Oa(i, e, r, true);
  }
  /** @deprecated. Use init() */
  static default(e, r) {
    return new Oa(e, he, r);
  }
  static init(e, r, i) {
    let n;
    return i ? n = new Oa(e, i, r, true) : n = new Oa(e, he, r), n;
  }
  get mediaRoomType() {
    const { sfu: e } = a(this, $i).getValue("roomNodeOptions");
    return e === we.CF ? "CF" : "HIVE";
  }
  /**
   * The `stageEnabled` property returns a boolean value.
   * If `true`, stage management is available for the participant.
   */
  get stageEnabled() {
    var e;
    return ((e = a(this, q)) == null ? void 0 : e.stageEnabled) || a(this, Sn) === Mt.Webinar || a(this, Sn) === Mt.Livestream;
  }
  get acceptStageRequests() {
    var e, r;
    return this.stageEnabled ? ((e = a(this, q)) == null ? void 0 : e.acceptStageRequests) || ((r = a(this, q)) == null ? void 0 : r.canAcceptProductionRequests) : false;
  }
  /**
   * The `stageAccess` property dictactes how a user interacts with the stage.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`;
   */
  get stageAccess() {
    var e, r, i;
    return ((e = a(this, q)) == null ? void 0 : e.stageAccess) === j.NotAllowed ? j.NotAllowed : ((r = a(this, q)) == null ? void 0 : r.stageAccess) === j.CanRequest ? j.CanRequest : ((i = a(this, q)) == null ? void 0 : i.stageAccess) === j.Allowed || a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed ? j.Allowed : a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest ? j.CanRequest : j.NotAllowed;
  }
  /**
   * The `acceptWaitingRequests` returns boolean value.
   * If `true`, participant can accept the request of waiting participant.
   */
  get acceptWaitingRequests() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.acceptWaitingRequests) != null ? r : he.acceptWaitingRequests;
  }
  /**
   * The `requestProduceVideo` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing video.
   */
  get requestProduceVideo() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.video) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `requestProduceAudio` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing audio.
   */
  get requestProduceAudio() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.audio) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `requestProduceScreenshare` returns boolean value.
   * If `true`, participant can send request to participants
   * about sharing screen.
   */
  get requestProduceScreenshare() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.screenshare) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `canAllowParticipantAudio` returns boolean value.
   * If `true`, participant can enable other participants` audio.
   */
  get canAllowParticipantAudio() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantAudio) != null ? r : he.disableParticipantAudio;
  }
  /**
   * The `canAllowParticipantScreensharing` returns boolean value.
   * If `true`, participant can enable other participants` screen share.
   */
  get canAllowParticipantScreensharing() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canAcceptProductionRequests) != null ? r : he.canAcceptProductionRequests;
  }
  /**
   * The `canAllowParticipantVideo` returns boolean value.
   * If `true`, participant can enable other participants` video.
   */
  get canAllowParticipantVideo() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantVideo) != null ? r : he.disableParticipantVideo;
  }
  /**
   * If `true`, a participant can disable other participants` audio.
   */
  get canDisableParticipantAudio() {
    return this.canAllowParticipantAudio;
  }
  /**
   * If `true`, a participant can disable other participants` video.
   */
  get canDisableParticipantVideo() {
    return this.canAllowParticipantVideo;
  }
  /**
   * The `kickParticipant` returns boolean value.
   * If `true`, participant can remove other participants from the meeting.
   */
  get kickParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.kickParticipant) != null ? r : he.kickParticipant;
  }
  /**
   * The `pinParticipant` returns boolean value.
   * If `true`, participant can pin a participant in the meeting.
   */
  get pinParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.pinParticipant) != null ? r : he.pinParticipant;
  }
  /**
   * The `canRecord` returns boolean value.
   * If `true`, participant can record the meeting.
   */
  get canRecord() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canRecord) != null ? r : he.canRecord;
  }
  /**
   * @deprecated in favour of `waitingRoomBehaviour`.
   * The `waitingRoomType` returns string value.
   * type of waiting room behavior
   * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
   */
  get waitingRoomType() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  /**
   * The `waitingRoomType` returns string value.
   * type of waiting room behavior
   * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
   */
  get waitingRoomBehaviour() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  /**
   * The `plugins` tells if the participant can act on plugins
   * there are 2 permissions with boolean values, `canStart` and `canClose`.
   */
  get plugins() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.plugins) != null ? r : he.plugins;
  }
  /**
   * The `polls` tells if the participant can use polls.
   * There are 3 permissions with boolean values, `canCreate`, `canVote`, `canViewResults`
   */
  get polls() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.polls) != null ? r : he.polls;
  }
  /**
   * @deprecated in favour of `canProduceVideo`
   * The `produceVideo` shows permissions for enabling video.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceVideo() {
    return this.canProduceVideo;
  }
  /**
   * @deprecated
   * The `requestProduce` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing audio, video or screenshare.
   */
  get requestProduce() {
    return a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest;
  }
  /**
   * The `canProduceVideo` shows permissions for enabling video.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceVideo() {
    var r;
    const e = (r = a(this, q).media.video.canProduce) != null ? r : he.media.video.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * @deprecated in favour of `canProduceScreenshare`
   * The `produceVideo` shows permissions for sharing screen.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceScreenshare() {
    return this.canProduceScreenshare;
  }
  /**
   * The `canProduceScreenshare` shows permissions for sharing screen.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceScreenshare() {
    var r;
    const e = (r = a(this, q).media.screenshare.canProduce) != null ? r : he.media.screenshare.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * @deprecated in favour of `canProduceAudio`
   * The `produceAudio` shows permissions for enabling audio.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceAudio() {
    return this.canProduceAudio;
  }
  /**
   * The `canProduceAudio` shows permissions for enabling audio.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceAudio() {
    var r;
    const e = (r = a(this, q).media.audio.canProduce) != null ? r : he.media.audio.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * The `chatPublic` shows permissions for public chat
   * there are 4 permissions
   * `canSend` - if true, the participant can send chat
   * `text` - if true, the participant can send text
   * `files` - if true, the participant can send files
   */
  get chatPublic() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.public) != null ? i : he.chat.public;
  }
  /**
   * The `chatPrivate` shows permissions for public chat
   * there are 4 permissions
   * `canSend` - if true, the participant can send private chat
   * `text` - if true, the participant can send text as private chat
   * `files` - if true, the participant can send files as private chat
   * `canReceive` - (optional) if true, the participant can receive private chat
   */
  get chatPrivate() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.private) != null ? i : he.chat.private;
  }
  get chatChannel() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.channel) != null ? i : he.chat.channel;
  }
  get chatMessage() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.message) != null ? i : he.chat.message;
  }
  get connectedMeetings() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.connectedMeetings) != null ? r : he == null ? void 0 : he.connectedMeetings;
  }
  /**
   * The `hiddenParticipant` returns boolean value.
   * If `true`, participant is hidden.
   */
  get hiddenParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.hiddenParticipant) != null ? r : he.hiddenParticipant;
  }
  /**
   * The `showParticipantList` returns boolean value.
   * If `true`, participant list can be shown to the participant.
   */
  get showParticipantList() {
    var e;
    return (e = a(this, q).showParticipantList) != null ? e : he.showParticipantList;
  }
  /**
   * @deprecated in favour of `canChangeParticipantPermissions`
   * The `canChangeParticipantRole` returns boolean value.
   * If `true`, allow changing the participants' role.
   */
  get canChangeParticipantRole() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  /**
   * The `canChangeParticipantPermissions` returns boolean value.
   * If `true`, allow changing the participants' permissions.
   */
  get canChangeParticipantPermissions() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  /**
   * @deprecated
   * The `canChangeTheme` returns boolean value.
   * If `true`, the participant can change the meeting theme.
   */
  // eslint-disable-next-line class-methods-use-this
  get canChangeTheme() {
    return false;
  }
  /**
   * @deprecated in favour of individual production settings
   * The `canPresent` returns boolean value.
   * If `true`, the participant can become a presentor.
   */
  get canPresent() {
    return a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed;
  }
  /**
   * @deprecated Use `acceptStageRequests` instead.
   */
  get acceptPresentRequests() {
    return this.acceptStageRequests;
  }
  get canEditDisplayName() {
    var e;
    return (e = a(this, q).canEditDisplayName) != null ? e : false;
  }
  /**
   * @deprecated DyteSelf.config.maxScreenShareCount
   */
  // eslint-disable-next-line class-methods-use-this
  get maxScreenShareCount() {
    return 1;
  }
  // eslint-disable-next-line class-methods-use-this
  get isRecorder() {
    return a(this, q).isRecorder;
  }
  get canSpotlight() {
    return a(this, q).canSpotlight;
  }
  /** Livestream */
  get canLivestream() {
    return a(this, q).canLivestream;
  }
  get transcriptionEnabled() {
    return a(this, q).transcriptionEnabled;
  }
};
var Qu = Oa;
q = /* @__PURE__ */ new WeakMap(), Sn = /* @__PURE__ */ new WeakMap(), $i = /* @__PURE__ */ new WeakMap(), el = /* @__PURE__ */ new WeakMap(), St = /* @__PURE__ */ new WeakSet(), Vt = function() {
  return a(this, $i).getValue("stageStatus");
};
var us;
var zf = class extends qt {
  constructor() {
    super(...arguments);
    h(this, "localMediaHandler");
    g(this, us, void 0);
  }
  updatePermission() {
    return u(this, null, function* () {
      var d, l;
      const e = (p, f2) => {
        this.mediaPermissions[p] = f2;
        const S = { message: this.mediaPermissions[p], kind: p };
        f2 === "DENIED" ? a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, S) : a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, S);
      };
      if (Te.getName() === "firefox")
        return;
      const r = "microphone", i = "camera", n = yield (d = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : d.query({ name: r }), o = yield (l = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : l.query({
        name: i
      }), c = (p, f2) => {
        switch (f2) {
          case "granted":
            e(p, "ACCEPTED");
            break;
          case "denied":
            e(p, "DENIED");
            break;
          case "prompt":
            e(p, "NOT_REQUESTED");
            break;
        }
        this.localMediaHandler.repopulateAvailableDevices();
      };
      n && (n.onchange = () => c("audio", n.state)), o && (o.onchange = () => c("video", o.state));
    });
  }
  // eslint-disable-next-line class-methods-use-this
  populateMediaPermissionsInCallstats(i) {
    return u(this, arguments, function* ({
      message: e,
      kind: r
    }) {
      var n, o, c, d;
      switch (r) {
        case "audio": {
          (n = a(this, us)) == null || n.getValue("callstats").mediaPermission("AUDIO", e), (o = a(this, us)) == null || o.getValue("callstats").mediaPermission("SPEAKER", e);
          break;
        }
        case "video": {
          (c = a(this, us)) == null || c.getValue("callstats").mediaPermission("VIDEO", e);
          break;
        }
        case "screenshare": {
          (d = a(this, us)) == null || d.getValue("callstats").mediaPermission("SCREENSHARE", e);
          break;
        }
      }
    });
  }
  get peerId() {
    var e;
    return (e = a(this, us)) == null ? void 0 : e.getValue("peerId");
  }
  init() {
    return u(this, arguments, function* (e = {}, r = false, i = null) {
      var n, o, c, d, l, p, f2;
      if (Te.init(), !this.localMediaHandler)
        try {
          let S = true;
          if ((n = i == null ? void 0 : i.getValue("defaults")) != null && n.mediaHandler)
            S = false, this.localMediaHandler = i.getValue("defaults").mediaHandler.localMediaHandler;
          else if (navigator.RNLocalMediaHandlerImpl) {
            const { RNLocalMediaHandlerImpl: T } = navigator;
            this.localMediaHandler = yield T.init(e);
          } else
            this.localMediaHandler = new Ot(
              i,
              e.constraints,
              (o = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : o.isNonPreferredDevice,
              (c = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : c.autoSwitchAudioDevice
            );
          if (i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_UPDATE,
            (T) => u(this, null, function* () {
              if (this.populateMediaPermissionsInCallstats({
                message: T.message,
                kind: T.kind
              }), T.message === "NOT_REQUESTED")
                switch (T == null ? void 0 : T.kind) {
                  case "audio":
                    this.rawAudioTrack && (this.logger.info("Disabling audio due to media permission update"), this.disableAudio());
                    break;
                  case "video":
                    this.rawVideoTrack && (this.logger.info("Disabling video due to media permission update"), this.disableVideo());
                    break;
                  default:
                    break;
                }
              this.emit("mediaPermissionUpdate", T);
            })
          ), i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_ERROR,
            (T) => u(this, null, function* () {
              const { kind: _, message: P, constraints: w } = T;
              this.populateMediaPermissionsInCallstats({
                message: P,
                kind: _
              }), _ === "audio" ? (this.logger.info(`Disabling audio due to media permission error  skipping: ${this.localMediaHandler.audioUpdateInProgress}`), this.localMediaHandler.audioUpdateInProgress === false && this.disableAudio()) : _ === "video" && (this.logger.info(`Disabling video due to media permission error skipping: ${this.localMediaHandler.videoUpdateInProgress}`), this.localMediaHandler.videoUpdateInProgress === false && this.disableVideo()), this.logger.error("SelfController::mediaPermissionError", {
                error: { message: P },
                constraints: w,
                mediaPermissionsErrors: {
                  kind: _,
                  message: P
                }
              }), this.emit("mediaPermissionError", T), this.emit("mediaPermissionUpdate", { message: P, kind: _ });
            })
          ), S) {
            this.logger.info(`Setting up DyteSelfMedia streams using media handler. audio:${(d = e == null ? void 0 : e.audio) != null ? d : true} video:${(l = e == null ? void 0 : e.video) != null ? l : true}`);
            const T = this.localMediaHandler.setupStreams({
              video: (p = e == null ? void 0 : e.video) != null ? p : true,
              audio: (f2 = e == null ? void 0 : e.audio) != null ? f2 : true
            });
            r || (yield T);
          }
        } catch (S) {
          this.logger.error("DyteSelf::init::Failed To Setup Streams", {
            error: { name: S.name, message: S.message }
          });
        }
    });
  }
  set context(e) {
    m(this, us, e), this.localMediaHandler.context = e;
  }
  /**
   * Returns the `audioTrack`.
   */
  get audioTrack() {
    return this.localMediaHandler.audioTrack;
  }
  /**
   * Returns the `rawAudioTrack` having no middleware executed on it.
   */
  get rawAudioTrack() {
    return this.localMediaHandler.rawAudioTrack;
  }
  /**
   * Returns the current audio and video permissions given by the user.
   * 'ACCEPTED' if the user has given permission to use the media.
   * 'CANCELED' if the user has canceled the screenshare.
   * 'DENIED' if the user has denied permission to use the media.
   * 'SYS_DENIED' if the user's system has denied permission to use the media.
   * 'UNAVAILABLE' if the media is not available (or being used by a different application).
   */
  get mediaPermissions() {
    return this.localMediaHandler.permissions;
  }
  /**
   * Adds the audio middleware to be executed on the raw audio stream.
   * If there are more than 1 audio middlewares,
   * they will be executed in the sequence they were added in.
   * If you want the sequence to be altered, please remove all previous middlewares and re-add.
   */
  addAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addAudioMiddleware(e);
    });
  }
  /**
   * Removes the audio middleware, if it is there.
   */
  removeAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAudioMiddleware(e);
    });
  }
  /**
   * Removes all audio middlewares, if they are there.
   */
  removeAllAudioMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllAudioMiddlewares();
    });
  }
  /**
   * Returns the `videoTrack`.
   */
  get videoTrack() {
    return this.localMediaHandler.videoTrack;
  }
  /**
   * Returns the `videoTrack` having no middleware executed on it.
   */
  get rawVideoTrack() {
    return this.localMediaHandler.rawVideoTrack;
  }
  /**
   * Adds the video middleware to be executed on the raw video stream.
   * If there are more than 1 video middlewares,
   * they will be executed in the sequence they were added in.
   * If you want the sequence to be altered, please remove all previous middlewares and re-add.
   */
  addVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addVideoMiddleware(e);
    });
  }
  /**
   * Sets global config to be used by video middlewares.
   * @param config config
   * @param config.disablePerFrameCanvasRendering If set to true,
   * Instead of calling Middleware for every frame,
   * Middleware will only be called once that too with empty canvas,
   *  it is the responsibility of the middleware author to keep updating this canvas.
   * `meeting.self.rawVideoTrack` can be used to retrieve video track for the periodic updates.
   */
  setVideoMiddlewareGlobalConfig() {
    return u(this, arguments, function* (e = {
      disablePerFrameCanvasRendering: false
    }) {
      return this.localMediaHandler.setVideoMiddlewareGlobalConfig(e);
    });
  }
  /**
   * Removes the video middleware, if it is there.
   */
  removeVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeVideoMiddleware(e);
    });
  }
  /**
   * Removes all video middlewares, if they are there.
   */
  removeAllVideoMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllVideoMiddlewares();
    });
  }
  /**
   * Returns the screen share tracks.
   */
  get screenShareTracks() {
    return this.localMediaHandler.screenShareTracks;
  }
  /**
   * Returns true if audio is enabled.
   */
  get audioEnabled() {
    return this.localMediaHandler.audioEnabled;
  }
  /**
   * Returns true if video is enabled.
   */
  get videoEnabled() {
    return this.localMediaHandler.videoEnabled;
  }
  /**
   * Returns true if screen share is enabled.
   */
  get screenShareEnabled() {
    return this.localMediaHandler.screenShareEnabled;
  }
  enableAudio() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      this.localMediaHandler.disableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  /**
   * Returns the media devices currently being used.
   */
  getCurrentDevices() {
    return this.localMediaHandler.getCurrentDevices();
  }
  /**
   * Returns the local participant's audio devices.
   */
  getAudioDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getAudioDevices();
    });
  }
  /**
   * Returns the local participant's video devices.
   */
  getVideoDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getVideoDevices();
    });
  }
  /**
   * Returns the local participant's speaker devices.
   */
  getSpeakerDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getSpeakerDevices();
    });
  }
  /**
   * Returns the local participant's device, indexed by ID and kind.
   * @param deviceId The ID of the device.
   * @param kind The kind of the device: audio, video, or speaker.
   */
  getDeviceById(e, r) {
    let i;
    return r === "audio" ? i = "audioinput" : r === "video" ? i = "videoinput" : r === "speaker" && (i = "audiooutput"), this.localMediaHandler.getDeviceById(e, i);
  }
  /**
   * Change the current media device that is being used by the local participant.
   * @param device The device that is to be used. A device of the same `kind` will be replaced.
   * the primary stream.
   */
  setDevice(e) {
    return u(this, null, function* () {
      switch (e.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(e);
          } catch (r) {
          } finally {
            this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(e);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(e);
          } catch (r) {
          } finally {
            this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
      this.emit("deviceUpdate", {
        device: e
      });
    });
  }
};
us = /* @__PURE__ */ new WeakMap();
var K0 = Object.defineProperty;
var z0 = Object.getOwnPropertyDescriptor;
var Ct = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? z0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && K0(t, e, i), i;
};
var vn;
var vt;
var yn;
var He;
var sr;
var di;
var je;
var Ze;
var Tn;
var Ed;
var xe;
var Be;
var En;
var _n;
var ac;
var Xu;
var Bg;
var Xe = (Bg = class extends zf {
  constructor(t, e, r, i, n) {
    var c;
    const o = t.getValue("logger");
    super(o);
    g(this, sr);
    g(this, je);
    g(this, Tn);
    g(this, xe);
    g(this, ac);
    h(this, "name");
    h(this, "picture");
    h(this, "customParticipantId");
    h(this, "waitlistStatus");
    g(this, vn, void 0);
    g(this, vt, void 0);
    g(this, yn, void 0);
    h(this, "role");
    h(this, "userId");
    h(this, "organizationId");
    h(this, "supportsRemoteControl", false);
    h(this, "device");
    g(this, He, void 0);
    h(this, "hidden", false);
    h(this, "presetName");
    h(this, "roomState", "init");
    g(this, En, /* @__PURE__ */ new Set());
    g(this, _n, /* @__PURE__ */ new Set());
    m(this, He, t), this.userId = e.id, this.name = e.name, this.picture = e.picture, this.customParticipantId = (c = e.customParticipantId) != null ? c : e.clientSpecificId, this.waitlistStatus = "none", m(this, vt, r), m(this, vn, i), this.hidden = false, m(this, yn, false), this.organizationId = e.organizationId, this.supportsRemoteControl = Te.isElectron(), this.device = Te.getDeviceInfo(), this.presetName = n, i.viewType !== Mt.Chat && this.updatePermission(), this.updateVideo = this.updateVideo.bind(this), L(this, ac, Xu).call(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, He).getValue("telemetry");
  }
  get stageStatus() {
    return a(this, He).getValue("stageStatus");
  }
  get id() {
    return this.peerId;
  }
  /** NOTE(ishita1805): Discussed with Ravindra, added a duplicate for consistency
   * when using identifiers in DyteLocker.
   * We might want to look at deprecating the `id` sometime later. */
  get peerId() {
    return a(this, He).getValue("peerId");
  }
  static __init__(t, e, r, i, n, o = false) {
    return u(this, null, function* () {
      var S, T, _, P, w, A;
      let c = (T = (S = t.getValue("defaults")) == null ? void 0 : S.audio) != null ? T : true, d = (P = (_ = t.getValue("defaults")) == null ? void 0 : _.video) != null ? P : true;
      r.canProduceAudio !== "ALLOWED" && (c = false), r.canProduceVideo !== "ALLOWED" && (d = false);
      const l = new Xe(t, e, r, i, n);
      if (i.viewType === Mt.Chat)
        return l;
      const p = a0(i.mediaConstraints);
      br(p, (w = t.getValue("defaults")) == null ? void 0 : w.mediaConfiguration);
      const f2 = (A = t.getValue("defaults")) == null ? void 0 : A.mediaHandler;
      return f2 && (f2.context = t), yield l.init({
        audio: c,
        video: d,
        constraints: p
      }, o, t), l.setupEvents(), l;
    });
  }
  cleanupEvents() {
    this.removeAllListeners("videoUpdate"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("VIDEO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_LIST_UPDATED"), this.localMediaHandler.removeAllListeners("SCREENSHARE_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("SCREENSHARE_ENDED"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_SILENT"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_AUDIO"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_VIDEO"), a(this, vt).removeAllListeners("permissionsUpdate");
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ac, Xu));
    const t = a(this, Tn, Ed);
    t && t.onError((e) => {
      this.emit("autoplayError", e);
    }), this.localMediaHandler.on("AUDIO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::AUDIO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.audioEnabled)
        try {
          yield a(this, je, Ze).shareMic(this.audioTrack);
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::Error while sharing mic", {
            error: e
          }), this.localMediaHandler.disableAudio();
        }
      this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    })), this.localMediaHandler.on("VIDEO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::VIDEO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.rawVideoTrack === void 0)
        this.logger.info("DyteSelf::VIDEO_TRACK_CHANGE::Forcing_disable_video"), this.disableVideo();
      else if (this.videoEnabled && a(this, xe, Be))
        try {
          const e = yield a(this, je, Ze).shareWebcam(this.videoTrack);
          e && e.id !== this.videoTrack.id && a(this, He).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, je, Ze).shareWebcam(this.videoTrack));
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::failed shareWebcam", {
            error: e
          }), this.videoEnabled && (yield this.localMediaHandler.disableVideo());
        }
      this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    })), this.localMediaHandler.on(
      "DEVICE_CHANGE",
      (r) => u(this, [r], function* ({ device: e }) {
        var i;
        this.emit("deviceUpdate", {
          device: e
        }), e.kind === "audiooutput" && typeof HTMLAudioElement.prototype.setSinkId == "function" && ((i = a(this, Tn, Ed)) == null || i.setSpeakerDevice(e.deviceId));
      })
    ), this.localMediaHandler.on("DEVICE_LIST_UPDATED", (e) => {
      this.emit("deviceListUpdate", e);
    }), this.localMediaHandler.on("SCREENSHARE_TRACK_CHANGE", () => u(this, null, function* () {
      if (!a(this, xe, Be)) {
        this.logger.error(
          "DyteSelf.SCREENSHARE_TRACK_CHANGE.LocalMediaInitialized_WithoutRoomNode"
        );
        return;
      }
      if (this.screenShareEnabled)
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (e) {
          this.logger.error(
            "DyteSelf::setupEvents::Error while sharing screen",
            {
              error: e
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
      this.logger.info("DyteSelf::setupEvents::SCREENSHARE_TRACK_CHANGE", D({}, gi(this))), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    })), this.localMediaHandler.on("SCREENSHARE_ENDED", () => u(this, null, function* () {
      this.logger.log("Disabling screenshare due to SCREENSHARE_ENDED"), yield this.disableScreenShare(), this.logger.info("DyteSelf::setupEvents::SCREENSHARE_ENDED", D({}, gi(this)));
    })), this.localMediaHandler.on("AUDIO_TRACK_SILENT", () => {
      var e;
      (e = a(this, He)) == null || e.getValue("callstats").mediaTrackMuted("AUDIO");
    }), this.localMediaHandler.on("FORCE_MUTE_AUDIO", () => {
      this.disableAudio();
    }), this.localMediaHandler.on("FORCE_MUTE_VIDEO", () => u(this, null, function* () {
      var e;
      a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (e = a(this, He)) == null || e.getValue("callstats").videoOff();
    })), a(this, vt).on("permissionsUpdate", (e) => {
      var r, i, n;
      (r = e == null ? void 0 : e.media) != null && r.audio && a(this, vt).canProduceAudio !== j.Allowed && (this.disableAudio(), this.logger.info(`Disabled audio due to dynamic preset change: canProduceAudio: ${this.permissions.canProduceAudio}`)), (i = e == null ? void 0 : e.media) != null && i.video && a(this, vt).canProduceVideo !== j.Allowed && (this.disableVideo(), this.logger.info(`Disabled video due to dynamic preset change: canProduceVideo: ${this.permissions.canProduceVideo}`)), (n = e == null ? void 0 : e.media) != null && n.screenshare && a(this, vt).canProduceScreenshare !== j.Allowed && (this.disableScreenShare(), this.logger.info(`Disabled screenshare due to dynamic preset change: canProduceScreenshare: ${this.permissions.canProduceScreenshare}`));
    });
  }
  /**
   * Returns the current permission given to the user for the meeting.
   */
  get permissions() {
    return a(this, vt);
  }
  /**
   * Returns configuration for the meeting.
   */
  get config() {
    return a(this, vn);
  }
  /**
   * Returns true if the local participant has joined the meeting.
   */
  get roomJoined() {
    var t;
    return a(this, vn).viewType === Mt.Livestream && this.stageStatus !== "ON_STAGE" ? ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === true : a(this, xe, Be);
  }
  /**
   * The name of the user can be set by calling this method.
   * This will get reflected to other participants ONLY if
   * this method is called before the room is joined.
   * @param name Name of the user.
   */
  setName(t) {
    if (!t)
      throw new R("Name cannot be empty.", "1103");
    this.name = t;
  }
  setupTracks() {
    return u(this, arguments, function* (t = {}) {
      t.forceReset, yield this.disableAudio(), yield this.disableVideo(), this.localMediaHandler.removeAudioTrack(), this.localMediaHandler.removeVideoTrack(), t.audio && (yield this.enableAudio()), t.video && (yield this.enableVideo());
    });
  }
  destructMediaHandler() {
    return u(this, null, function* () {
      return this.localMediaHandler.destruct();
    });
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeDocumentEventListeners();
    });
  }
  enableAudio(t) {
    return u(this, null, function* () {
      var e;
      if (this.permissions.canProduceAudio !== j.NotAllowed && !(a(this, vt).canProduceAudio === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.audioEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").audioOn(), yield this.localMediaHandler.enableAudio(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE") {
          if (this.audioTrack)
            try {
              yield a(this, je, Ze).shareMic(this.audioTrack);
            } catch (r) {
              this.logger.error("DyteSelf::enableAudio::Error while sharing mic", {
                error: r
              }), this.localMediaHandler.disableAudio();
            }
          if (!this.audioEnabled)
            return;
          a(this, je, Ze).unmuteSelf();
        }
        this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      }
    });
  }
  enableVideo(t) {
    return u(this, null, function* () {
      var e;
      if (a(this, vt).canProduceVideo !== j.NotAllowed && !(a(this, vt).canProduceVideo === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.videoEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").videoOn(), yield this.localMediaHandler.enableVideo(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE")
          try {
            yield a(this, je, Ze).shareWebcam(this.videoTrack);
          } catch (r) {
            this.logger.error("DyteSelf::enableVideo::Error while sharing video", {
              error: r
            }), this.videoEnabled && this.localMediaHandler.disableVideo();
          }
        this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        }), this.logger.info("DyteSelf.enableVideo", D({}, gi(this)));
      }
    });
  }
  updateVideoConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateVideoConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateVideoConstraints(t);
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t enable screenshare without joining room", "1105");
      if (a(this, vt).canProduceScreenshare !== j.NotAllowed && !(a(this, vt).canProduceScreenshare === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.screenShareEnabled && (yield this.localMediaHandler.enableScreenShare(), this.screenShareTracks.audio || this.screenShareTracks.video)) {
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (t) {
          this.logger.error(
            "DyteSelf::enableScreenShare::Error while sharing screen",
            {
              error: t
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
        this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      }
    });
  }
  updateScreenshareConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateScreenshareConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateScreenshareConstraints(t);
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      var t;
      this.audioEnabled && (this.localMediaHandler.disableAudio(), a(this, xe, Be) && a(this, je, Ze).muteSelf(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").audioOff());
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      var t;
      this.videoEnabled && (yield this.localMediaHandler.disableVideo(), a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").videoOff());
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare(), a(this, xe, Be) && (yield a(this, je, Ze).disableScreenShare()), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      }));
    });
  }
  /**
   * Returns all media devices accessible by the local participant.
   */
  getAllDevices() {
    return this.localMediaHandler.getAllDevices();
  }
  /**
   * @access private
   * Not for external use.
   */
  setIsPinned(t, e = true) {
    var i;
    m(this, yn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, sr, di)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  /**
   * Returns true if the current user is pinned.
   */
  get isPinned() {
    return a(this, yn);
  }
  /**
   * Returns `self.id` if user has permission
   * to pin participants.
   */
  pin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t pin participants without joining room", "1105");
      return this.show(), a(this, je, Ze).pinPeer(this.id);
    });
  }
  /**
   * Returns `self.id` if user has permission
   * to unpin participants.
   */
  unpin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t unpin participants without joining room", "1105");
      return a(this, je, Ze).pinPeer(null);
    });
  }
  /**
   * Hide's user's tile in the UI (locally)
   */
  hide() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t toggle participant tile without joining room", "1105");
      this.hidden = true, this.emit("toggleTile", { hidden: this.hidden });
    });
  }
  /**
   * Show's user's tile in the UI if hidden (locally)
   */
  show() {
    if (!a(this, xe, Be))
      throw new R("Can`t toggle participant tile without joining room", "1105");
    this.hidden = false, this.emit("toggleTile", { hidden: this.hidden });
  }
  setDevice(t) {
    return u(this, null, function* () {
      var r, i, n;
      if (!t)
        throw new R("No device selected", "1104");
      const e = this.getCurrentDevices();
      if (t.deviceId && (((r = e == null ? void 0 : e.audio) == null ? void 0 : r.deviceId) === t.deviceId || ((i = e == null ? void 0 : e.video) == null ? void 0 : i.deviceId) === t.deviceId || ((n = e == null ? void 0 : e.speaker) == null ? void 0 : n.deviceId) === t.deviceId) && (this.logger.warn("DyteSelf.setDevice.setting_to_in_use_device", { devices: [t] }), a(this, He).getValue("flagsmith").hasFeature(X.SKIP_SETTING_IN_USE_DEVICE)))
        throw new R("Cannot set device currently in use", "1106");
      switch (t.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).muteSelf()), this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(t);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
    });
  }
  cleanUpTracks() {
    var t, e, r, i;
    (t = this.audioTrack) == null || t.stop(), (e = this.rawAudioTrack) == null || e.stop(), (r = this.videoTrack) == null || r.stop(), (i = this.rawVideoTrack) == null || i.stop();
  }
  playAudio() {
    var t;
    return (t = a(this, Tn, Ed)) == null ? void 0 : t.play();
  }
  registerVideoElement(t, e = false) {
    var r, i;
    t && (e ? a(this, En).add(t) : a(this, _n).add(t), this.updateVideo(t), e || (i = a(this, sr, di)) == null || i.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (r = this.raised) != null ? r : false
    ));
  }
  deregisterVideoElement(t, e = false) {
    if (!t) {
      a(this, sr, di).removeSource(this.id);
      return;
    }
    t.srcObject = void 0, e ? a(this, En).delete(t) : (a(this, _n).delete(t), a(this, sr, di).removeSource(this.id));
  }
  /**
   * Internal method, do not use
   */
  updateVideo(t, e = false) {
    var r, i, n;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const o = (r = t.srcObject) == null ? void 0 : r.getTracks()[0];
      if ((o == null ? void 0 : o.id) === this.videoTrack.id)
        return;
      const c = new MediaStream();
      c.addTrack(this.videoTrack), t.srcObject = c, e || (i = a(this, sr, di)) == null || i.enableSource(this.id);
    } else
      t.srcObject = void 0, e || (n = a(this, sr, di)) == null || n.disableSource(this.id);
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, vn = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakMap(), yn = /* @__PURE__ */ new WeakMap(), He = /* @__PURE__ */ new WeakMap(), sr = /* @__PURE__ */ new WeakSet(), di = function() {
  return a(this, He).getValue("pip");
}, je = /* @__PURE__ */ new WeakSet(), Ze = function() {
  return a(this, He).getValue("roomNodeClient");
}, Tn = /* @__PURE__ */ new WeakSet(), Ed = function() {
  return a(this, He).getValue("audioPlayback");
}, xe = /* @__PURE__ */ new WeakSet(), Be = function() {
  var t;
  return ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === true;
}, En = /* @__PURE__ */ new WeakMap(), _n = /* @__PURE__ */ new WeakMap(), ac = /* @__PURE__ */ new WeakSet(), Xu = function() {
  Array.from(a(this, _n)).forEach((t) => this.updateVideo(t, false)), Array.from(a(this, En)).forEach((t) => this.updateVideo(t, true));
}, Bg);
Ct([
  E.trace("DyteSelf.cleanupEvents")
], Xe.prototype, "cleanupEvents", 1);
Ct([
  E.trace("DyteSelf.setupEvents")
], Xe.prototype, "setupEvents", 1);
Ct([
  E.trace("DyteSelf.setupTracks")
], Xe.prototype, "setupTracks", 1);
Ct([
  E.trace("DyteSelf.destructMediaHandler")
], Xe.prototype, "destructMediaHandler", 1);
Ct([
  E.trace("DyteSelf.removeDocumentEventListeners")
], Xe.prototype, "removeDocumentEventListeners", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableAudio")
], Xe.prototype, "enableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableVideo")
], Xe.prototype, "enableVideo", 1);
Ct([
  E.trace("DyteSelf.updateVideoConstraints")
], Xe.prototype, "updateVideoConstraints", 1);
Ct([
  E.trace("DyteSelf.enableScreenShare"),
  Er.executeWithLock({
    methodName: "meeting.self.enableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  })
], Xe.prototype, "enableScreenShare", 1);
Ct([
  E.trace("DyteSelf.updateScreenshareConstraints")
], Xe.prototype, "updateScreenshareConstraints", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableAudio")
], Xe.prototype, "disableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableVideo")
], Xe.prototype, "disableVideo", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableScreenShare")
], Xe.prototype, "disableScreenShare", 1);
Ct([
  E.trace("DyteSelf.setDevice")
], Xe.prototype, "setDevice", 1);
Xe = Ct([
  ht("1100")
], Xe);
var Fh = class _Fh extends Error {
  constructor(t) {
    super(t != null ? t : "AwaitQueue stopped"), this.name = "AwaitQueueStoppedError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _Fh);
  }
};
var Hh = class _Hh extends Error {
  constructor(t) {
    super(t != null ? t : "AwaitQueue task removed"), this.name = "AwaitQueueRemovedTaskError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, _Hh);
  }
};
var nc;
var Zu = class {
  constructor(t, e = false) {
    h(this, "pendingTasks", /* @__PURE__ */ new Map());
    h(this, "nextTaskId", 0);
    h(this, "stopping", false);
    g(this, nc, void 0);
    this.log = e, m(this, nc, { info: e && t ? t.info : () => {
    } });
  }
  get size() {
    return this.pendingTasks.size;
  }
  push(t, e, r) {
    return u(this, null, function* () {
      if (e = e != null ? e : t.name, typeof t != "function")
        throw new TypeError("given task is not a function");
      if (e)
        try {
          Object.defineProperty(t, "name", { value: e });
        } catch (i) {
        }
      return new Promise((i, n) => {
        const o = {
          id: this.nextTaskId++,
          task: t,
          metadata: r,
          name: e,
          enqueuedAt: Date.now(),
          executedAt: void 0,
          completed: false,
          resolve: (c) => {
            if (o.completed)
              return;
            o.completed = true, this.pendingTasks.delete(o.id), i(c);
            const [d] = this.pendingTasks.values();
            d && !d.executedAt && this.execute(d);
          },
          reject: (c) => {
            if (!o.completed && (o.completed = true, this.pendingTasks.delete(o.id), n(c), !this.stopping)) {
              const [d] = this.pendingTasks.values();
              d && !d.executedAt && this.execute(d);
            }
          }
        };
        this.pendingTasks.set(o.id, o), this.pendingTasks.size === 1 && this.execute(o);
      });
    });
  }
  stop() {
    this.stopping = true;
    for (const t of this.pendingTasks.values())
      t.reject(new Fh());
    this.stopping = false;
  }
  remove(t) {
    const e = Array.from(this.pendingTasks.values())[t];
    e && e.reject(new Hh());
  }
  get(t) {
    return Array.from(this.pendingTasks.values())[t];
  }
  dump() {
    const t = Date.now();
    let e = 0;
    return Array.from(this.pendingTasks.values()).map((r) => ({
      idx: e++,
      task: r.task,
      name: r.name,
      enqueuedTime: r.executedAt ? r.executedAt - r.enqueuedAt : t - r.enqueuedAt,
      executionTime: r.executedAt ? t - r.executedAt : 0
    }));
  }
  execute(t) {
    return u(this, null, function* () {
      if (t.executedAt)
        throw new Error("task already being executed");
      t.executedAt = Date.now();
      try {
        const e = this.pendingTasks.size, r = yield t.task(), i = Date.now();
        a(this, nc).info(
          `AwaitQueue.push(${t.name})_timings`,
          {
            awaitQueueTask: {
              id: t.id,
              metadata: t.metadata,
              queueSizeAtStart: e,
              execTime: (i - t.executedAt) / 1e3,
              taskStartTime: (t.executedAt - t.enqueuedAt) / 1e3
            }
          }
        ), t.resolve(r);
      } catch (e) {
        t.reject(e);
      }
    });
  }
};
nc = /* @__PURE__ */ new WeakMap();
function Y0(s, t) {
  const e = new Error(t);
  return e.name = s, e;
}
var Uo = class _Uo extends R {
  constructor(t) {
    super(t), this.name = "UnsupportedError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, _Uo) : this.stack = new Error(t).stack;
  }
};
var At = class _At extends R {
  constructor(t) {
    super(t), this.name = "InvalidStateError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, _At) : this.stack = new Error(t).stack;
  }
};
var fi = class extends R {
  constructor(t) {
    super(t), this.name = "TransportConnectionError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, At) : this.stack = new Error(t).stack;
  }
};
var fg = (s) => new Promise((t) => setTimeout(t, s));
function Yf(s, t) {
  return u(this, null, function* () {
    return new Promise((e, r) => u(this, null, function* () {
      const { strategy: i, maxRetryCount: n, delayTime: o } = D({
        strategy: "linear",
        maxRetryCount: 3,
        delayTime: 10
      }, t);
      let c = 0, d, l = false;
      const p = (f2) => {
        l = true, r(f2);
      };
      for (; c < n; ) {
        try {
          const f2 = yield s(c, p);
          return e(f2);
        } catch (f2) {
          if (d = f2, l)
            break;
          if (c < n)
            i === "linear" ? yield fg(o * (c + 1)) : i === "exponential" && (yield fg(o * (c + Math.max(0, c - 1))));
          else
            break;
        }
        c += 1;
      }
      return r(d);
    }));
  });
}
function Q0(s) {
  return s.map((t) => ({
    channels: t.channels,
    clockRate: t.clockRate,
    mimeType: t.mimeType,
    sdpFmtpLine: t.sdpFmtpLine
  }));
}
function X0(s) {
  return s.map((t) => ({
    uri: t.uri
  }));
}
function dd(s) {
  return {
    codecs: Q0(s.codecs),
    headerExtensions: X0(s.headerExtensions ? s.headerExtensions : [])
  };
}
function Z0(s) {
  const t = RTCRtpReceiver.getCapabilities("audio"), e = RTCRtpReceiver.getCapabilities("video"), r = RTCRtpSender.getCapabilities("audio"), i = RTCRtpSender.getCapabilities("video");
  s && (e.codecs = e.codecs.filter(({ mimeType: d }) => s === d), i.codecs = i.codecs.filter(({ mimeType: d }) => s === d));
  const n = {
    audio: dd(t),
    video: dd(e)
  };
  return {
    sender: {
      audio: dd(r),
      video: dd(i)
    },
    receiver: n
  };
}
var ze;
var eD = class {
  constructor(t, e) {
    g(this, ze, void 0);
    h(this, "events");
    h(this, "sfuType");
    m(this, ze, t), this.sfuType = e, this.events = e === we.CF ? Ts : is;
  }
  joinRoom(t, e, r, i = false, n = null) {
    return u(this, null, function* () {
      const o = {
        roomUuid: t,
        displayName: e,
        prejoined: i,
        capabilities: r
      };
      return n && (o.location = n), (yield a(this, ze).sendMessagePromiseWithTimeout({
        event: this.events.joinRoom,
        protobuf: gR.toBinary(o),
        timeout: 5e3
      })).payload;
    });
  }
  connectTransport(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.createWebRTCTransport,
        BC.toBinary(t)
      )).payload, { transportId: r, description: i, producerIds: n } = lf.fromBinary(e), o = {
        sdp: i == null ? void 0 : i.sdp,
        type: i.type
      };
      return {
        transportId: r,
        answer: o,
        producerIds: n
      };
    });
  }
  produce(t) {
    return u(this, null, function* () {
      var n, o;
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.produce,
        IR.toBinary(t)
      )).payload, r = uw.fromBinary(e);
      return {
        answer: {
          sdp: (n = r == null ? void 0 : r.description) == null ? void 0 : n.sdp,
          type: (o = r == null ? void 0 : r.description) == null ? void 0 : o.type
        },
        producerId: r.producerId
      };
    });
  }
  consume(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.consume,
        PR.toBinary(t)
      )).payload, {
        consumerIdsMap: { map: r },
        description: i
      } = dw.fromBinary(e);
      return { consumerStateMap: r, sessionDescription: i };
    });
  }
  closeProducer(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.closeProducer,
        LR.toBinary(t)
      )).payload, { description: r } = vw.fromBinary(e);
      return r;
    });
  }
  closeConsumer(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      return (yield a(this, ze).sendMessagePromise(
        this.events.closeConsumer,
        UR.toBinary(t)
      )).payload;
    });
  }
  updateConsumersSimulcastConfig(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Method not implemented");
      return (yield a(this, ze).sendMessagePromise(
        this.events.updateConsumersSimulcastConfig,
        bR.toBinary(t)
      )).payload;
    });
  }
  hostControlForPeer(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: e === "audio",
        screeShare: false,
        video: e === "video",
        participantId: t
      }, i = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlPeer,
        jR.toBinary(r)
      )).payload;
      if (!i)
        return false;
      const { status: n } = Rw.fromBinary(i);
      return n === "success";
    });
  }
  hostControlForAll(t) {
    return u(this, null, function* () {
      const e = {
        audio: t === "audio",
        screenShare: false,
        video: t === "video"
      }, r = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlAllPeers,
        WR.toBinary(e)
      )).payload;
      if (!r)
        return false;
      const { status: i } = bw.fromBinary(r);
      return i === "success";
    });
  }
  /**
   * Ideally should have been async with a response but
   * this is basically a fire and forget since socket does not
   * send a response at the moment
   */
  kickAll() {
    return u(this, null, function* () {
      const t = {
        propagateKickAcrossRooms: false
      };
      a(this, ze).sendMessagePromise(
        /**
         * Does not use mediaEventSlugs is the same irrespective of the SFU
         */
        x.kickAll,
        gf.toBinary(t)
      );
    });
  }
  /**
   * Ideally should have been async with a response but
   * this is basically a fire and forget since socket does not
   * send a response at the moment
   */
  kickPeer(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessagePromise(
        /**
         * Does not use mediaEventSlugs is the same irrespective of the SFU
         */
        x.kick,
        yf.toBinary(t)
      );
    });
  }
  changeDisplayName(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.changeDisplayName,
        BR.toBinary(t)
      )).payload;
      if (!e)
        return false;
      const { status: r } = Iw.fromBinary(e);
      return r === "success";
    });
  }
  notifySelfJoinComplete() {
    return u(this, null, function* () {
      const t = {}, e = (yield a(this, ze).sendMessagePromise(
        this.events.selfJoinComplete,
        fR.toBinary(t)
      )).payload;
      return Du.fromBinary(e);
    });
  }
  audioActivity(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessage(this.events.audioActivity, jC.toBinary(t));
    });
  }
};
ze = /* @__PURE__ */ new WeakMap();
var oc;
var Yl = class extends ut.EventEmitter {
  constructor(e) {
    super();
    g(this, oc, void 0);
    m(this, oc, e), this.setMaxListeners(1 / 0);
  }
  get logger() {
    return a(this, oc).getValue("logger");
  }
  safeEmit(e, ...r) {
    const i = this.listenerCount(e);
    try {
      return this.emit(e, ...r);
    } catch (n) {
      return this.logger.error(
        `EnhancedEventEmitter:: safeEmit() | event listener ${e} threw an error`,
        {
          error: n
        }
      ), Boolean(i);
    }
  }
  safeEmitAsPromise(e, ...r) {
    return u(this, null, function* () {
      const i = {}.EVENT_PROMISE_TIMEOUT ? parseInt({}.EVENT_PROMISE_TIMEOUT, 10) : 1e4;
      return this.safeEmitAsPromiseWithTimeout(e, i, ...r);
    });
  }
  safeEmitAsPromiseWithTimeout(e, r, ...i) {
    return u(this, null, function* () {
      return new Promise((n, o) => {
        setTimeout(o, r, "event request timeout");
        try {
          this.emit(e.toString(), ...i, n, o);
        } catch (c) {
          this.logger.error(
            `EnhancedEventEmitter:: safeEmitAsPromise() | event listener for event ${e.toString()} threw an error [event:%s]:%o`,
            {
              error: c
            }
          ), o(c);
        }
      });
    });
  }
};
oc = /* @__PURE__ */ new WeakMap();
var Bh = class extends Yl {
  constructor() {
    super(...arguments);
    h(this, "_sendWebStream", new MediaStream());
    h(this, "_sendScreenShareStream", new MediaStream());
    h(this, "_direction");
    h(this, "pc");
    h(this, "_transportReady", false);
    h(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
    h(this, "enableHighBitrate", false);
    h(this, "enableStereo", false);
    h(this, "enableDtx", true);
    h(this, "sfu", we.HIVE);
  }
  get midTransceiverMap() {
    return this._mapMidTransceiver;
  }
  close() {
    if (this.logger.debug(`${this.name}::close()`), this.pc)
      try {
        this.pc.close();
      } catch (e) {
        this.logger.error(`${this.name}::pc.close()`, { error: e });
      }
  }
  restartIce() {
    return u(this, null, function* () {
      this.logger.debug(`${this.name}::restartIce()`);
      const e = yield this.pc.createOffer({
        iceRestart: true
      });
      return this.logger.debug(`${this.name}::restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), {
        offerSdp: e,
        callback: (i) => u(this, null, function* () {
          this.logger.info(`${this.name}::restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(i)}]`), yield this.pc.setRemoteDescription(i);
        })
      };
    });
  }
  init({
    direction: e,
    iceServers: r,
    iceTransportPolicy: i,
    additionalSettings: n,
    proprietaryConstraints: o,
    onTrackHandler: c
  }) {
    this.logger.debug("HandlerInterface::init()"), this._direction = e, this.pc = new RTCPeerConnection(
      D({
        iceServers: r || [],
        iceTransportPolicy: i || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require"
      }, n),
      o
    ), c && this.pc.addEventListener("track", (d) => {
      c(d);
    }), this._addEventListeners();
  }
  connect() {
    return u(this, null, function* () {
      let e;
      this.sfu === we.CF ? this.pc.addTransceiver("video", { direction: "sendonly" }) : e = this.pc.createDataChannel("dyte");
      const r = yield this.pc.createOffer();
      return yield this.pc.setLocalDescription(r), this.logger.info(`connect offer: ${JSON.stringify(r)}`), {
        offerSdp: r,
        callback: (n) => u(this, null, function* () {
          this.logger.debug(`${this.name}::connect() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`), yield this.pc.setRemoteDescription(n), e == null || e.close();
        })
      };
    });
  }
  getTransportStats() {
    return u(this, null, function* () {
      return this.pc.getStats();
    });
  }
  _assertSendDirection() {
    if (this._direction !== "send")
      throw new Error(
        'method can just be called for handlers with "send" direction'
      );
  }
  _assertRecvDirection() {
    if (this._direction !== "recv")
      throw new Error(
        'method can just be called for handlers with "recv" direction'
      );
  }
  getReceiverStats(e) {
    return u(this, null, function* () {
      this._assertRecvDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.receiver.getStats();
    });
  }
  stopSending(e) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`stopSending() [localId:${e}]`);
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      r.sender.replaceTrack(null), this.pc.removeTrack(r.sender), r.direction = "inactive";
      const i = yield this.pc.createOffer();
      return this.logger.debug(`stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(i)}]`), yield this.pc.setLocalDescription(i), {
        offerSdp: i,
        callback: (o) => u(this, null, function* () {
          this.logger.debug(`stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(o)}]`), yield this.pc.setRemoteDescription(o), this.midTransceiverMap.delete(e);
        })
      };
    });
  }
  replaceTrack(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), r ? this.logger.debug(`replaceTrack() [localId:${e}, track.id:${r.id}]`) : this.logger.debug(`replaceTrack() [localId:${e}, no track]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      yield i.sender.replaceTrack(r);
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          c <= r ? o.active = true : o.active = false;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  setRtpEncodingParameters(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          n.encodings[c] = D(D({}, o), r);
        }
      ), yield i.sender.setParameters(n);
    });
  }
  getSenderStats(e) {
    this._assertSendDirection();
    const r = this.midTransceiverMap.get(e);
    if (!r)
      throw new Error("associated RTCRtpTransceiver not found");
    return r.sender.getStats();
  }
  _addEventListeners() {
    this.pc.addEventListener(
      "icecandidate",
      (e) => {
        e.candidate && this.emit("@icecandidate", {
          candidate: e.candidate
        });
      }
    ), this.pc.addEventListener("iceconnectionstatechange", () => {
      switch (this.pc.iceConnectionState) {
        case "checking":
          this.emit("@connectionstatechange", "connecting");
          break;
        case "connected":
        case "completed":
          this.emit("@connectionstatechange", "connected"), this._transportReady = true;
          break;
        case "failed":
          this.emit("@connectionstatechange", "failed");
          break;
        case "disconnected":
          this.emit("@connectionstatechange", "disconnected");
          break;
        case "closed":
          this.emit("@connectionstatechange", "closed");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("negotiationneeded", () => {
      this.emit("@negotiationneeded", {}), this.logger.debug("negotiationneeded");
    }), this.pc.addEventListener("icegatheringstatechange", () => {
      switch (this.pc.iceGatheringState) {
        case "gathering":
          this.logger.debug("icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
          break;
        case "complete":
          this.logger.debug("icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("icecandidateerror", (e) => {
      this.logger.warn("icecandidateerror", {
        error: {
          code: e.errorCode,
          message: e.errorText
        }
      });
    }), this.pc.addEventListener("datachannel", (e) => {
      this.logger.info("data channel created: ", {
        rtcChannel: {
          label: e.channel.label
        }
      });
      const { channel: r } = e;
      r.onopen = () => {
        this.logger.info("data channel open: ", {
          rtcChannel: {
            label: e.channel.label
          }
        }), this.safeEmit("dc_open", e.channel);
      }, r.onclose = () => {
        this.logger.warn("data channel closed: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
      }, r.onerror = () => {
        this.logger.error("data channel error: ", {
          rtcChannel: {
            label: e.channel.label
          }
          // error: error as unknown as LogData, // Need to fix this, where to get message, reason
        });
      };
    }), this.addCustomEventListeners();
  }
  // eslint-disable-next-line class-methods-use-this
  addCustomEventListeners() {
  }
};
var qh = class _qh extends Bh {
  /**
   * Creates a factory function.
   */
  static createFactory(t) {
    return () => new _qh(t);
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Chrome74";
  }
  init({
    direction: t,
    iceServers: e,
    iceTransportPolicy: r,
    additionalSettings: i,
    proprietaryConstraints: n,
    onTrackHandler: o
  }) {
    this._direction = t, this.pc = new RTCPeerConnection(
      D({
        iceServers: e || [],
        iceTransportPolicy: r || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        sdpSemantics: "unified-plan"
      }, i),
      n
    ), o && this.pc.addEventListener("track", (c) => {
      o(c);
    }), this._addEventListeners();
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection();
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      });
      if (!navigator.isReactNative) {
        this.logger.debug("creating new transceiver");
        const l = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
        this.logger.info(`senders available params: ${JSON.stringify(l)}`);
        const p = [];
        r && r.length && r.forEach((f2) => {
          var T;
          const S = l.codecs.find((_) => _.mimeType.includes(f2.name));
          if (f2.parameters) {
            this.logger.debug(`codecOption.parameters:${JSON.stringify(f2.parameters)}`);
            const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
            _.push(...f2.parameters);
            const P = Array.from(new Set(_).values());
            S.sdpFmtpLine = P.join(";");
          }
          p.push(S);
        }), this.logger.info(`selected codecs: ${JSON.stringify(p)}`), o.setCodecPreferences(p);
      }
      const c = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(c), r && r.findIndex(({ name: l }) => l === "opus") >= 0) {
        const { enableDtx: l, enableStereo: p } = this, f2 = this.enableHighBitrate ? p ? 128e3 : 64e3 : p ? 64e3 : 32e3;
        c.sdp = c.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${l ? "usedtx=1;" : ""}${p ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${f2}`
        ), c.sdp += `a=rtcp-fb:111 nack\r
`;
      }
      this.midTransceiverMap.set(o.mid, o);
      const d = (l) => u(this, null, function* () {
        return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(l)}]`), yield this.pc.setRemoteDescription(l), o.mid;
      });
      return this.logger.debug(`send() | calling pc.setLocalDescription() [offer: ${JSON.stringify(c, void 0, 2)}]`), {
        offerSdp: c,
        callback: d,
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => {
        this.safeEmit(
          "datachannel",
          t.channel,
          String.fromCharCode(...new Uint8Array(r.data))
        );
      };
    });
  }
};
var xd = class _xd extends Bh {
  // eslint-disable-next-line no-useless-constructor
  constructor(e, r) {
    super(e);
    h(this, "supportsSendEncodings", false);
    this.supportsSendEncodings = r.supportsSendEncodings;
  }
  /**
   * Creates a factory function.
   */
  static createFactory(e, r) {
    return () => new _xd(
      e,
      r
    );
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Firefox60";
  }
  send(o) {
    return u(this, arguments, function* ({
      track: e,
      encodings: r,
      codecOptions: i,
      screenShare: n
    }) {
      this._assertSendDirection();
      const c = this.supportsSendEncodings && r !== void 0 ? { sendEncodings: r } : {}, d = this.pc.addTransceiver(e, D({
        direction: "sendonly",
        streams: [
          n ? this._sendScreenShareStream : this._sendWebStream
        ]
      }, c));
      if (!this.supportsSendEncodings && r) {
        r.reverse();
        const S = d.sender.getParameters();
        S.encodings = r, yield d.sender.setParameters(S);
      }
      const l = (S, T) => {
        var $;
        const _ = cs.parse(S), P = _.media[_.media.length - 1], w = P.rtp.filter((F) => T.some((K) => K.name === F.codec)), A = P.fmtp.filter((F) => w.some((K) => K.payload === F.payload)), N = ($ = P.rtcpFb) == null ? void 0 : $.filter((F) => w.some((K) => K.payload === F.payload)), H = w.map((F) => F.payload);
        return _.media[_.media.length - 1].rtp = w, _.media[_.media.length - 1].fmtp = A, _.media[_.media.length - 1].rtcpFb = N, _.media[_.media.length - 1].payloads = H.join(" "), cs.write(_);
      }, p = yield this.pc.createOffer();
      if (p.sdp = l(p.sdp, i), this.logger.debug(`send() | calling pc.setLocalDescription() [offer:${JSON.stringify(p)}]`), yield this.pc.setLocalDescription(p), e === "audio" || e.kind === "audio") {
        const { enableDtx: S, enableStereo: T } = this, _ = this.enableHighBitrate ? T ? 128e3 : 64e3 : T ? 64e3 : 32e3;
        p.sdp = p.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${T ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${_}`
        );
      }
      return this.midTransceiverMap.set(d.mid, d), {
        offerSdp: p,
        callback: (S) => u(this, null, function* () {
          return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(S)}]`), yield this.pc.setRemoteDescription(S), d.mid;
        }),
        sender: d.sender,
        mid: d.mid
      };
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters(), o = n.encodings.length - 1 - r;
      n.encodings.forEach(
        (c, d) => {
          d >= o ? c.active = true : c.active = false;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (e) => {
      const { channel: r } = e;
      r.onmessage = (i) => u(this, null, function* () {
        const n = yield i.data.arrayBuffer();
        this.safeEmit(
          "datachannel",
          e.channel,
          String.fromCharCode(...new Uint8Array(n))
        );
      });
    });
  }
};
var jh = class _jh extends Bh {
  /**
   * Creates a factory function.
   */
  static createFactory(t) {
    return () => new _jh(t);
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Safari12";
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection(), this.logger.debug("Safari12::creating new transceiver");
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      }), c = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
      this.logger.info(`Safari12::senders available params: ${JSON.stringify(c)}`);
      const d = [];
      r && r.length > 0 && r.forEach((f2) => {
        var T;
        const S = c.codecs.find(
          (_) => _.mimeType.includes(f2.name)
        );
        if (f2.parameters) {
          this.logger.info(`Safari12::codecOption.parameters:, ${JSON.stringify(f2.parameters)}`);
          const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
          _.push(...f2.parameters);
          const P = [...new Set(_).values()];
          S.sdpFmtpLine = P.join(";");
        }
        d.push(S);
      }), this.logger.info(`Safari12::selected codecs: ${JSON.stringify(d)}`), o.setCodecPreferences(d);
      const l = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(l), t === "audio" || t.kind === "audio") {
        const { enableStereo: f2, enableDtx: S } = this, T = this.enableHighBitrate ? f2 ? 128e3 : 64e3 : f2 ? 64e3 : 32e3;
        l.sdp = l.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${f2 ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${T}`
        );
      }
      return this.midTransceiverMap.set(o.mid, o), {
        offerSdp: l,
        callback: (f2) => u(this, null, function* () {
          return this.logger.debug(
            `Safari12::send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(f2)}]`
          ), yield this.pc.setRemoteDescription(f2), o.mid;
        }),
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.ondatachannel = (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => u(this, null, function* () {
        const i = String.fromCharCode(
          ...new Uint8Array(r.data)
        );
        this.safeEmit("datachannel", t.channel, i);
      });
    };
  }
};
function tD(s, t) {
  return typeof s == "undefined" ? t : typeof window != "undefined" && Object.getOwnPropertyDescriptor(window, "structuredClone") ? structuredClone(s) : JSON.parse(JSON.stringify(s));
}
var cc;
var Fi;
var Ds;
var tl;
var Os;
var kr;
var dc;
var eh;
var sl;
var Qf;
var rl;
var Xf;
var sD = class extends Yl {
  constructor(e, r) {
    var i;
    super(e);
    g(this, Os);
    g(this, dc);
    g(this, sl);
    g(this, rl);
    h(this, "rtpReceiver");
    h(this, "id");
    h(this, "localId");
    h(this, "producerId");
    h(this, "producingTransportId");
    h(this, "mimeType");
    h(this, "track");
    h(this, "peerId");
    h(this, "appData");
    h(this, "transceiver");
    g(this, cc, void 0);
    g(this, Fi, void 0);
    g(this, Ds, void 0);
    g(this, tl, void 0);
    this.id = r.id, this.localId = r.localId, m(this, cc, r.handler), this.appData = r.appData, this.peerId = r.producingPeerId, this.producingTransportId = r.producingTransportId, m(this, Ds, false), this.producerId = r.producerId, this.track = r.track, m(this, Fi, (i = r.paused) != null ? i : false), this.mimeType = r.mimeType, this.transceiver = r.transceiver, this.rtpReceiver = r.rtpReceiver, L(this, sl, Qf).call(this), m(this, tl, e);
  }
  /**
   * Indicates whether this consumer is closed
   */
  get closed() {
    return a(this, Ds);
  }
  /**
   * Kind of media on to this consumer
   */
  get kind() {
    return this.track.kind;
  }
  /**
   * Indicates whether the consumer is paused
   */
  get paused() {
    return a(this, Fi);
  }
  /**
   * Closes the Consumer.
   */
  close(e, r) {
    a(this, Ds) || (this.logger.debug(`Consumer::close() ${e ? `with reason ${e}` : ""}`, a(this, Os, kr)), m(this, Ds, true), r && (L(this, rl, Xf).call(this), this.transceiver.stop()), this.safeEmit("close", e));
  }
  /**
   * Get associated RTCRtpReceiver stats.
   */
  getStats() {
    return u(this, null, function* () {
      if (a(this, Ds))
        throw new At("closed");
      return a(this, cc).getReceiverStats(this.localId);
    });
  }
  /**
   * Pauses receiving media.
   */
  pause() {
    if (this.logger.debug("consumer::pause()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("consumer::pause() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, true), this.track.enabled = false, this.safeEmit("pause");
  }
  /**
   * Resumes receiving media.
   */
  resume() {
    if (this.logger.debug("consumer::resume()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("Consumer::resume() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, false), this.track.enabled = true, this.safeEmit("resume");
  }
};
cc = /* @__PURE__ */ new WeakMap(), Fi = /* @__PURE__ */ new WeakMap(), Ds = /* @__PURE__ */ new WeakMap(), tl = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakSet(), kr = function() {
  return {
    consumer: {
      id: this.id,
      appData: this.appData,
      peerId: this.peerId,
      kind: this.kind
    }
  };
}, dc = /* @__PURE__ */ new WeakSet(), eh = function() {
  this.logger.debug('Consumer::track "ended" event', a(this, Os, kr)), this.safeEmit("trackended");
}, sl = /* @__PURE__ */ new WeakSet(), Qf = function() {
  this.track.addEventListener("ended", L(this, dc, eh).bind(this));
}, rl = /* @__PURE__ */ new WeakSet(), Xf = function() {
  try {
    this.track.removeEventListener("ended", L(this, dc, eh)), this.track.stop();
  } catch (e) {
    this.logger.error("Consumer::destroyTrack()", B(D({}, a(this, Os, kr)), {
      error: e
    }));
  }
};
var hs;
var Pn;
var Cn;
var Hi;
var es;
var et;
var jr;
var Rn;
var il;
var Ft;
var os;
var rD = class extends Yl {
  /**
   * @emits transportclose
   * @emits trackended
   * @emits @replacetrack - (track: MediaStreamTrack | null)
   * @emits @setmaxspatiallayer - (spatialLayer: string)
   * @emits @setrtpencodingparameters - (params: any)
   * @emits @getstats
   */
  constructor(e, r) {
    var i, n;
    super(e);
    g(this, Ft);
    h(this, "id");
    h(this, "localId");
    g(this, hs, void 0);
    h(this, "kind");
    h(this, "appData");
    h(this, "rtpSender");
    g(this, Pn, void 0);
    g(this, Cn, void 0);
    g(this, Hi, void 0);
    g(this, es, false);
    g(this, et, void 0);
    g(this, jr, void 0);
    g(this, Rn, void 0);
    g(this, il, void 0);
    this.id = r.id, this.localId = r.localId, m(this, et, r.track), this.kind = (i = r.track) == null ? void 0 : i.kind, m(this, jr, r.disableTrackOnPause ? !((n = r.track) != null && n.enabled) : false), m(this, Rn, void 0), m(this, Pn, r.stopTracks), m(this, Cn, r.disableTrackOnPause), m(this, Hi, r.zeroRtpOnPause), this.appData = r.appData || {}, this._onTrackEnded = this._onTrackEnded.bind(this), m(this, hs, r.handler), this.rtpSender = r.rtpSender, this._handleTrack(), m(this, il, e);
  }
  /**
   * Whether the Producer is closed.
   */
  get closed() {
    return a(this, es);
  }
  /**
   * The associated track.
   */
  get track() {
    return a(this, et);
  }
  /**
   * Whether the Producer is paused.
   */
  get paused() {
    return a(this, jr);
  }
  /**
   * Max spatial layer.
   *
   * @type {Number | undefined}
   */
  get maxSpatialLayer() {
    return a(this, Rn);
  }
  /**
   * Closes the Producer.
   */
  close(e) {
    return u(this, null, function* () {
      if (a(this, es))
        return;
      if (this.logger.debug(`Producer::close() ${e ? `with reason ${e}` : ""}`, a(this, Ft, os)), m(this, es, true), this._destroyTrack(), e === Ud) {
        this.safeEmit("close", { reason: e });
        return;
      }
      const { offerSdp: r, callback: i } = yield a(this, hs).stopSending(this.localId), { answer: n } = yield this.safeEmitAsPromise("close", { offer: r, reason: e });
      i(n);
    });
  }
  /**
   * Get associated RTCRtpSender stats.
   */
  getStats() {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      return a(this, hs).getSenderStats(this.localId);
    });
  }
  /**
   * Pauses sending media.
   */
  pause() {
    this.logger.debug("Producer::pause()", a(this, Ft, os)), a(this, es) && this.logger.error("Producer::pause() | Producer closed", a(this, Ft, os)), m(this, jr, true), a(this, et) && a(this, Cn) && (a(this, et).enabled = false), a(this, Hi) && a(this, hs).replaceTrack(this.localId, null), this.emit("pause");
  }
  /**
   * Resumes sending media.
   */
  resume() {
    if (this.logger.debug("Producer::resume()", a(this, Ft, os)), a(this, es)) {
      this.logger.error("Producer::resume() | Producer closed", a(this, Ft, os));
      return;
    }
    m(this, jr, false), a(this, et) && a(this, Cn) && (a(this, et).enabled = true), a(this, Hi) && a(this, hs).replaceTrack(this.localId, a(this, et)), this.emit("resume");
  }
  /**
   * Replaces the current track with a new one or null.
   */
  replaceTrack(r) {
    return u(this, arguments, function* ({
      track: e
    }) {
      if (this.logger.debug(`Producer::replaceTrack() trackId: ${e == null ? void 0 : e.id}`, a(this, Ft, os)), a(this, es)) {
        if (e && a(this, Pn))
          try {
            e.stop();
          } catch (i) {
            this.logger.error("Producer::replaceTrack", B(D({}, a(this, Ft, os)), {
              error: i
            }));
          }
        throw new At("closed");
      } else if (e && e.readyState === "ended")
        throw new At("track ended");
      if (e === a(this, et)) {
        this.logger.debug(`replaceTrack() | same track, ignored trackId: ${e.id}`, a(this, Ft, os));
        return;
      }
      (!a(this, Hi) || !a(this, jr)) && (yield a(this, hs).replaceTrack(this.localId, e)), this._destroyTrack(), m(this, et, e), this._handleTrack();
    });
  }
  /**
   * Sets the video max spatial layer to be sent.
   */
  setMaxSpatialLayer(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (this.kind !== "video")
        throw new Uo("not a video Producer");
      if (typeof e != "number")
        throw new TypeError("invalid spatialLayer");
      yield a(this, hs).setMaxSpatialLayer(this.localId, e), m(this, Rn, e);
    });
  }
  /**
   * Sets the DSCP value.
   */
  setRtpEncodingParameters(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (typeof e != "object")
        throw new TypeError("invalid params");
      yield a(this, hs).setRtpEncodingParameters(this.localId, e);
    });
  }
  _onTrackEnded() {
    this.logger.debug(`Producer::track "ended" event trackId: ${this.track.id}`, a(this, Ft, os)), this.safeEmit("trackended", this.track.id);
  }
  _handleTrack() {
    a(this, et) && a(this, et).addEventListener("ended", this._onTrackEnded);
  }
  _destroyTrack() {
    var e;
    if (a(this, et))
      try {
        a(this, et).removeEventListener("ended", this._onTrackEnded), a(this, Pn) && a(this, et).stop();
      } catch (r) {
        this.logger.error(`Producer::_destroyTrack trackId: ${(e = this.track) == null ? void 0 : e.id}`, B(D({}, a(this, Ft, os)), {
          error: r
        }));
      }
  }
};
hs = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), Hi = /* @__PURE__ */ new WeakMap(), es = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), jr = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakSet(), os = function() {
  return {
    producer: {
      id: this.id,
      appData: this.appData,
      kind: this.kind
    }
  };
};
function Zf(s) {
  return typeof s == "object" && !Array.isArray(s) && s !== null;
}
function yu(s) {
  return Math.random().toString(36).substring(2, 2 + s);
}
var ld = 1;
function Sg(s) {
  const t = s;
  return delete t.payload._bolt, t;
}
function iD(s) {
  return s.payload && Zf(s.payload);
}
function eS(s) {
  var t, e;
  return iD(s) && (e = (t = s.payload._bolt) == null ? void 0 : t.id) != null ? e : "";
}
var Gr;
var al;
var Bi;
var Na = class extends ut.EventEmitter {
  constructor(e, r, i, n) {
    super();
    h(this, "channel");
    h(this, "queue");
    h(this, "serverProtocolVersion");
    g(this, Gr, /* @__PURE__ */ new Map());
    g(this, al, void 0);
    g(this, Bi, void 0);
    h(this, "respond", (e2, r2, i2 = false) => {
      let n2;
      i2 ? n2 = Na.createErrorResponse(e2, r2) : n2 = Na.createResponse(e2, r2), this.channel.send(JSON.stringify(n2));
    });
    h(this, "notify", (e2) => {
      const r2 = Na.createNotification(e2);
      this.channel.send(JSON.stringify(r2));
    });
    h(this, "request", (e2) => u(this, null, function* () {
      const r2 = Na.createRequest(e2), i2 = new Promise((n2, o) => {
        const { id: d } = r2.payload._bolt, l = {
          id: d,
          method: r2.type,
          resolve: (p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), n2(p));
          },
          timer: setTimeout(() => {
            this.queue.delete(d) && o(new Error(`request timeout for message id: ${d}`));
          }, 2e4),
          cancel: (p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), o(p));
          }
        };
        this.queue.set(d, l);
      });
      return this.channel.send(JSON.stringify(r2)), i2;
    }));
    h(this, "send", (e2) => {
      const r2 = JSON.stringify(e2), i2 = 16384;
      if (r2.length > i2) {
        const n2 = i2 - 200, o = Math.ceil(r2.length / n2), c = [];
        for (let l = 0; l < o; l += 1) {
          const p = l * n2, f2 = (l + 1) * n2;
          c.push(r2.slice(p, f2));
        }
        const d = v4_default();
        for (let l = 0; l < o; l += 1) {
          const p = c[l], S = JSON.stringify({
            id: d,
            count: o,
            chunkIndex: l,
            chunk: p
          });
          a(this, Bi).debug(`Sending message chunk over dc: ${S}`), this.channel.send(S);
        }
      } else
        a(this, Bi).debug(`Sending message over dc: ${r2}`), this.channel.send(r2);
    });
    h(this, "processMessage", (e2) => {
      var i2;
      a(this, Gr).has(e2.id) || a(this, Gr).set(e2.id, []);
      const r2 = a(this, Gr).get(e2.id);
      if (r2[e2.chunkIndex] = e2, (r2 == null ? void 0 : r2.length) === e2.count && !r2.some((n2) => n2 === void 0)) {
        const n2 = a(this, Gr).get(e2.id), o = n2 == null ? void 0 : n2.reduce((d, l) => d + l.chunk, "");
        a(this, Gr).delete(e2.id);
        const c = JSON.parse(o);
        if (!c.payload || !Zf(c.payload))
          throw new Error("corrupted incoming message over dc", {
            cause: { code: "CORRUPT_DC_MESSAGE", values: c }
          });
        if (this.processBoltHandshake(c))
          return;
        if (this.serverProtocolVersion = (i2 = c.payload._bolt) == null ? void 0 : i2.version, !this.processResponseMsg(c))
          return c;
      }
    });
    h(this, "processResponseMsg", (e2) => {
      const { id: r2 } = e2.payload._bolt, i2 = this.queue.get(r2);
      return i2 ? (a(this, Bi).debug(`resolving pending request with id: ${r2}, complete response: ${JSON.stringify(e2)}`), e2.type === "error" ? i2.cancel(Sg(e2)) : i2.resolve(Sg(e2)), true) : false;
    });
    h(this, "processBoltHandshake", (e2) => {
      var r2, i2;
      return e2.type === "_bolt" || e2.type === "handshake" ? (this.respond((i2 = (r2 = e2.payload._bolt) == null ? void 0 : r2.id) != null ? i2 : yu(8), { type: "_bolt", payload: { message: "pong" } }), true) : false;
    });
    this.label = i, this.transportId = n, m(this, al, e), m(this, Bi, e.getValue("logger")), this.channel = r, this.queue = /* @__PURE__ */ new Map();
  }
};
var li = Na;
Gr = /* @__PURE__ */ new WeakMap(), al = /* @__PURE__ */ new WeakMap(), Bi = /* @__PURE__ */ new WeakMap(), h(li, "createRequest", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      _bolt: {
        id: yu(8),
        type: "REQUEST",
        version: ld
      }
    })
  };
}), h(li, "createResponse", (e, r) => {
  var i;
  if ((i = r.payload) != null && i._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: r.type,
    payload: B(D({}, r.payload), {
      _bolt: {
        id: e,
        type: "RESPONSE",
        version: ld
      }
    })
  };
}), h(li, "createNotification", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      bolt: {
        id: yu(8),
        type: "NOTIFY",
        version: ld
      }
    })
  };
}), h(li, "createErrorResponse", (e, r) => ({
  type: "error",
  payload: {
    error: r.message,
    _bolt: {
      id: e,
      type: "RESPONSE",
      version: ld
    }
  }
}));
var Ud = "transport closed";
var qi;
var ji;
var Va = class extends Yl {
  constructor(e, r, {
    id: i,
    direction: n,
    handlerFactory: o,
    iceServers: c,
    iceTransportPolicy: d,
    proprietaryConstraints: l,
    additionalSettings: p,
    appData: f2,
    config: S
  }) {
    var P, w, A;
    super(e);
    h(this, "awaitQueue");
    h(this, "observer");
    g(this, qi, void 0);
    h(this, "id");
    h(this, "serverId");
    h(this, "direction");
    h(this, "maxSctpMessageSize");
    h(this, "handler");
    h(this, "connectionState", "new");
    h(this, "producers");
    h(this, "consumers");
    h(this, "datachannels");
    h(this, "connected", false);
    h(this, "eventsDCReadyPromise");
    h(this, "eventsDCReadyPromiseResolver");
    h(this, "eventsDCFailureTimer");
    h(this, "transportConnectionPromise");
    h(this, "consumerTrackEvents");
    h(this, "unknownTracksMap");
    h(this, "appData");
    g(this, ji, void 0);
    m(this, ji, e);
    const T = e.getValue("logger");
    T.debug(`constructor() [id: ${i}, direction: ${n}]`), m(this, qi, r), this.id = i, this.direction = n;
    const _ = tD(p, {});
    delete _.iceServers, delete _.iceTransportPolicy, delete _.bundlePolicy, delete _.rtcpMuxPolicy, delete _.sdpSemantics, this.producers = /* @__PURE__ */ new Map(), this.consumers = /* @__PURE__ */ new Map(), this.datachannels = /* @__PURE__ */ new Map(), this.consumerTrackEvents = /* @__PURE__ */ new Map(), this.unknownTracksMap = /* @__PURE__ */ new Map(), this.awaitQueue = new Zu(T, true), this.handler = o(), this.handler.enableHighBitrate = (P = S == null ? void 0 : S.enableHighBitrate) != null ? P : false, this.handler.enableStereo = (w = S == null ? void 0 : S.enableStereo) != null ? w : false, this.handler.enableDtx = (A = S == null ? void 0 : S.enableDtx) != null ? A : true, this.handler.sfu = a(this, qi), this.handler.init({
      onTrackHandler: this._ontrack.bind(this),
      direction: n,
      iceServers: c,
      iceTransportPolicy: d,
      additionalSettings: p,
      proprietaryConstraints: l
    }), this.appData = f2 || {}, this.transportConnectionPromise = new Promise((N) => {
      this.once("connected", () => {
        N(true);
      }), this.once("disconnect", () => {
        N(false);
      }), this.once("close", () => {
        N(false);
      });
    }), this.eventsDCReadyPromise = new Promise((N) => {
      this.eventsDCReadyPromiseResolver = N;
    }), this.handler.on(
      "@connectionstatechange",
      (N) => {
        N !== this.connectionState && (this.logger.debug(`connection state changed to ${N}`), this.connectionState = N, N === "connected" && (this.connected = true, this.emit("connected")), N === "disconnected" && (this.connected = false, this.emit("disconnect")), (N === "failed" || N === "closed") && (this.connected = false, this.emit("close")), this.closed || this.safeEmit("connectionstatechange", N));
      }
    ), this.handler.on(
      "@icecandidate",
      ({ candidate: N }) => {
        this.closed || this.safeEmit("icecandidate", N);
      }
    ), this.handler.on("dc_open", (N) => {
      let H = this.datachannels.get(N.label);
      H || (H || (H = new li(a(this, ji), N, N.label, this.serverId), this.datachannels.set(N.label, H)), this.eventsDCFailureTimer = setTimeout(() => {
        N.label === "events" && (this.eventsDCReadyPromiseResolver(false), this.safeEmit("dc_error", N.label));
      }, 5e3));
    }), this.handler.on("datachannel", (N, H) => {
      N.label === "events" && (this.eventsDCReadyPromiseResolver(true), this.eventsDCFailureTimer && clearTimeout(this.eventsDCFailureTimer));
      const $ = this.datachannels.get(N.label);
      if (!$) {
        this.logger.error("unregistered datachannel for message", {
          rtcChannel: {
            label: N.label,
            message: H
          }
        });
        return;
      }
      try {
        const F = JSON.parse(H);
        this.logger.debug("datachannel message chunk recieved", {
          dataChannelMessageChunk: {
            id: F.id,
            count: F.count,
            chunkIndex: F.chunkIndex,
            chunk: F.chunk,
            transprtId: this.serverId
          }
        });
        const K = $.processMessage(F);
        if (!K)
          return;
        this.logger.debug(
          `datachannel message with id:${F.id} on transport:${this.serverId}complete - ${JSON.stringify(K)}`
        ), this.emit(`datachannel:${N.label}`, $.label, K);
      } catch (F) {
        this.logger.error("error parsing message", {
          error: F
        });
      }
    });
  }
  get closed() {
    return this.connectionState === "closed";
  }
  setServerId(e) {
    this.serverId = e;
  }
  getDatachannel(e) {
    return this.datachannels.get(e);
  }
  get isEventsDCReady() {
    return this.eventsDCReadyPromise;
  }
  /**
  	* Close the Transport.
  	*/
  close() {
    this.closed || (this.logger.debug("Transport close called"), this.connectionState = "closed", this.awaitQueue.stop(), this.awaitQueue = void 0, this.connected = false, this.handler.close(), Array.from(this.producers.values()).forEach(
      (e) => {
        e.close(Ud).catch(() => {
        });
      }
    ), this.producers.clear(), Array.from(this.consumers.values()).forEach((e) => {
      e.close(Ud);
    }), this.consumers.clear(), this.consumerTrackEvents.clear(), this.emit("close"));
  }
  /**
  	 * Get associated Transport (RTCPeerConnection) stats.
  	 *
  	 * @returns {RTCStatsReport}
  	 */
  getStats() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      return this.handler.getTransportStats();
    });
  }
  connect(e) {
    return u(this, null, function* () {
      try {
        if (yield this.awaitQueue.push(() => u(this, null, function* () {
          const { offerSdp: r, callback: i } = yield this.handler.connect(), {
            transportId: n,
            answer: o
          } = yield e(r);
          this.setServerId(n), yield i(o);
        })), !(yield this.transportConnectionPromise))
          throw new Error("ice connection failed");
        if (a(this, qi) === we.HIVE && !(yield this.isEventsDCReady))
          throw new Error("events datachannel not open");
      } catch (r) {
        throw this.logger.error("transport failed to connect:", { error: r }), r;
      }
    });
  }
  /**
  * Restart ICE connection.
  */
  restartIce() {
    return u(this, null, function* () {
      if (this.logger.debug("restartIce()"), this.closed)
        throw new At("closed");
      return this.handler.restartIce();
    });
  }
  canProduce(e) {
    return u(this, null, function* () {
      const { track: r, appData: i } = e;
      if (r) {
        if (this.direction !== "send")
          throw new Uo("not a sending Transport");
        if (r.readyState === "ended")
          throw new At("track ended");
        if (i && typeof i != "object")
          throw new TypeError("if given, appData must be an object");
      } else
        throw new TypeError("missing track");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return true;
    });
  }
  produce(e, r) {
    return u(this, null, function* () {
      if (!(yield this.canProduce(e)))
        throw new Error("Cannot produce");
      const {
        track: n,
        encodings: o,
        codecOptions: c,
        stopTracks: d = true,
        disableTrackOnPause: l = true,
        zeroRtpOnPause: p = false,
        appData: f2 = {}
      } = e;
      this.logger.debug(`produce() [track:${n.id}]`);
      const { producerId: S, localId: T, rtpSender: _ } = yield this.awaitQueue.push(() => u(this, null, function* () {
        const {
          offerSdp: P,
          callback: w,
          sender: A,
          mid: N
        } = yield this.handler.send({
          track: n,
          encodings: o,
          codecOptions: c,
          screenShare: f2 == null ? void 0 : f2.screenShare
        }), { answer: H, producerId: $ } = yield r(
          {
            offer: P,
            kind: n.kind,
            paused: l ? !n.enabled || Object.hasOwn(n, "fakeTracks") : false,
            appData: B(D({}, f2 || {}), { mid: N }),
            codecOptions: c,
            producingTransportId: this.serverId
          }
        ), F = yield w(H);
        return { producerId: $, localId: F, rtpSender: A };
      }), "Transport.produce");
      return this.createProducerObject({
        id: S,
        localId: T,
        track: n,
        stopTracks: d,
        disableTrackOnPause: l,
        zeroRtpOnPause: p,
        appData: f2,
        handler: this.handler,
        rtpSender: _
      });
    });
  }
  createProducerObject(e) {
    return u(this, null, function* () {
      const r = new rD(a(this, ji), e);
      return this.producers.set(r.id, r), r.once("close", () => {
        this.producers.delete(r.id);
      }), this.emit("newproducer", r), r;
    });
  }
  closeProducer(e) {
    return u(this, null, function* () {
      yield this.awaitQueue.push(e.close.bind(e), "Transport.closeProducer");
    });
  }
  canConsume() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      if (this.direction !== "recv")
        throw new Uo("not a receiving transport");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return true;
    });
  }
  consume(e, r, i) {
    return u(this, null, function* () {
      return this.awaitQueue.push(() => u(this, null, function* () {
        const n = {}, {
          consumerStates: o,
          sessionDescription: c,
          failedProducers: d
        } = yield r(e);
        o.forEach((p, f2) => {
          n[f2] = this.createConsumerObjectAndWaitForTrack(B(D({}, p), {
            producerId: f2
          }));
        }), c && (this.logger.info("Session description found, sending negotiation request"), yield i(c));
        const l = [];
        return yield Promise.all(Object.entries(n).map(
          ([p, f2]) => f2.then((S) => l.push(S)).catch(() => {
            this.logger.error(`Failed to create consumer object, producer: ${p}`, {
              error: { message: "This should not happen" },
              transport: { serverId: this.serverId }
            });
          })
        )), { consumers: l, failedProducers: d };
      }), "Transport.consume", { producersLength: e.length });
    });
  }
  static parseCodecAndFmtpMappings(e, r) {
    const i = cs.parse(e.sdp), n = {};
    return i.media.forEach((o) => {
      r.includes(o.mid.toString()) && (n[o.mid.toString()] = {
        rtp: o.rtp,
        fmtp: o.fmtp,
        payloads: o.payloads,
        rtcpFb: o.rtcpFb
      });
    }), n;
  }
  static setCodecAndFmtpMappings(e, r, i) {
    const n = cs.parse(e.sdp);
    return n.media = n.media.map((c) => {
      if (r.includes(c.mid.toString())) {
        const d = D({}, c);
        return d.rtp = i[c.mid.toString()].rtp, d.fmtp = i[c.mid.toString()].fmtp, d.payloads = i[c.mid.toString()].payloads, d.rtcpFb = i[c.mid.toString()].rtcpFb, d;
      }
      return c;
    }), B(D({}, e), {
      sdp: cs.write(n)
    });
  }
  static parseHeaderExtensionMappings(e) {
    const r = cs.parse(e.sdp), i = {};
    return r.media.forEach((n) => {
      i[n.mid] = n.ext;
    }), i;
  }
  static setHeaderExtensionMappings(e, r) {
    const i = cs.parse(e.sdp);
    return i.media = i.media.map((o) => {
      const c = D({}, o);
      return c.ext = r[o.mid], c;
    }), B(D({}, e), {
      sdp: cs.write(i)
    });
  }
  closeConsumers(e, r) {
    return u(this, null, function* () {
      try {
        const i = e.map((l) => l.transceiver.mid), n = Va.parseCodecAndFmtpMappings(
          this.handler.pc.remoteDescription,
          i
        ), o = Va.parseHeaderExtensionMappings(
          this.handler.pc.remoteDescription
        );
        this.logger.info("Stopping transceivers", { consumerIds: e.map(({ id: l }) => l) }), e.forEach((l) => l.close(void 0, true));
        let c = yield this.handler.pc.createOffer();
        this.logger.info("Created offer for closing consumers", { sdp: c.sdp }), c = Va.setCodecAndFmtpMappings(
          c,
          i,
          n
        ), c = Va.setHeaderExtensionMappings(
          c,
          o
        ), this.logger.info("Updated codec and fmtp mappings in close consumer offer", { sdp: c.sdp }), yield this.setLocalDescription(c), this.logger.info("Successfully set local description in close consumers");
        const d = yield r(e, c);
        this.logger.info("Received answer in close consumers", { sdp: d.sdp }), yield this.setRemoteDescription(d), this.logger.info("Remote description was set successfully in close consumers", { sdp: d.sdp });
      } catch (i) {
        this.logger.error("Failed to close consumers", { error: i });
      }
    });
  }
  setRemoteOffer(e) {
    return u(this, null, function* () {
      try {
        this.logger.info("Received offer from SFU", { sdp: e.sdp }), yield this.setRemoteDescription(e);
        const r = yield this.handler.pc.createAnswer();
        this.logger.info("Created answer corresponding to received offer", { sdp: r.sdp });
        const i = cs.parse(r.sdp);
        return i.media = i.media.map((n) => {
          if (n.type === "audio") {
            const o = D({}, n), c = o.fmtp.find(
              (l) => l.payload === 111
            );
            return c && (c.config += ";stereo=1;sprop-stereo=1"), o.rtcpFb || (o.rtcpFb = []), o.rtcpFb.some(
              (l) => l.type === "nack"
            ) || o.rtcpFb.push({
              payload: parseInt(o.payloads, 10),
              type: "nack"
            }), o;
          }
          return n;
        }), r.sdp = cs.write(i), this.logger.info("Setting munged SDP", { sdp: r.sdp }), yield this.setLocalDescription(r), this.logger.info("Successfully set local description", { sdp: r.sdp }), r;
      } catch (r) {
        throw this.logger.error("Set remote offer failed", { error: r }), r;
      }
    });
  }
  _ontrack(e) {
    const { track: r, transceiver: i, streams: n } = e;
    this.logger.info(`track event received [trackId: ${r.id}] [mid: ${i.mid}]`);
    let o;
    a(this, qi) === we.HIVE ? o = `${n[0].id}:${r.kind}` : o = `${i.mid}:${r.kind}`, r.addEventListener("ended", () => {
      this.logger.info(`rtc consumer track ended [trackId: ${r.id}]`), this.unknownTracksMap.delete(o);
    });
    const c = this.consumerTrackEvents.get(o);
    c ? (c(r, i), this.consumerTrackEvents.delete(o)) : (this.logger.warn(`track event handler not found ${o}`), this.unknownTracksMap.set(o, e));
  }
  sendErrorOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i, true);
  }
  sendResponseOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i);
  }
  createConsumerObjectAndWaitForTrack(e) {
    return u(this, null, function* () {
      const {
        consumerId: r,
        producerId: i,
        producingPeerId: n,
        producingTransportId: o,
        streamId: c,
        paused: d,
        screenShare: l,
        appData: p,
        kind: f2,
        mimeType: S
      } = e, T = `${c}:${f2}`, _ = B(D({}, e), {
        name: "consumer creation task error",
        message: "consumer creation failed"
      });
      return new Promise((P, w) => u(this, null, function* () {
        const A = setTimeout(() => {
          this.logger.warn(`Timed out waiting for track event ${T} producingPeerId: ${n}`), this.consumerTrackEvents.delete(T), _.isTimedout = true, w(_);
        }, 5e3), N = ($, F) => {
          try {
            if ($.readyState === "ended")
              clearTimeout(A), w(_);
            else {
              const K = $;
              K.enabled = true, this.handler.midTransceiverMap.set(F.mid, F);
              const re = new sD(a(this, ji), {
                id: r,
                localId: F.mid,
                transceiver: F,
                track: K,
                paused: d,
                producerId: i,
                producingPeerId: n,
                producingTransportId: o,
                handler: this.handler,
                appData: B(D({}, p), { screenShare: l, peerId: n }),
                rtpReceiver: F.receiver,
                mimeType: S
              });
              this.consumers.set(r, re), re.once("close", () => {
                this.consumers.delete(re.id), this.handler.midTransceiverMap.delete(F.mid);
              }), this.logger.info("consumer created for ", {
                consumer: {
                  id: r,
                  kind: f2,
                  appData: {
                    screenShare: l
                  },
                  peerId: n,
                  producerId: i
                }
              }), this.emit("newconsumer", re), clearTimeout(A), P(re);
            }
          } catch (K) {
            this.logger.warn("error while creating consumer:", K), clearTimeout(A), w(_);
          }
        }, H = this.unknownTracksMap.get(T);
        H ? (this.logger.info(`track event already received [trackId: ${H.track.id}] [mid: ${H.transceiver.mid}]`), this.unknownTracksMap.delete(T), N(H.track, H.transceiver)) : (this.logger.info(`Registering onTrack handler for key ${T} [producingPeerId: ${n}]`), this.consumerTrackEvents.set(T, N));
      }));
    });
  }
  setRemoteDescription(e) {
    return u(this, null, function* () {
      yield this.handler.pc.setRemoteDescription(e);
    });
  }
  setLocalDescription(e) {
    return u(this, null, function* () {
      this.logger.debug(`${this.direction}() {transportId: ${this.serverId}} | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), yield this.handler.pc.setLocalDescription(e);
    });
  }
  sendDataChannelMessage(e, r) {
    return u(this, null, function* () {
      const i = this.getDatachannel(e);
      if (!i)
        throw Y0("DC_NOT_READY", `${e} datachannel not ready`);
      const n = (yield i.request(r)).payload;
      return this.logger.info(`sendDataChannelMessage::response ${JSON.stringify(n)}`), n;
    });
  }
};
var th = Va;
qi = /* @__PURE__ */ new WeakMap(), ji = /* @__PURE__ */ new WeakMap();
function aD(s) {
  if (typeof navigator == "object" && navigator.product === "ReactNative") {
    if (typeof RTCPeerConnection == "undefined") {
      s.warn(
        "Device::this._detectDevice() | unsupported ReactNative without RTCPeerConnection"
      );
      return;
    }
    return s.debug("Device::this._detectDevice() | ReactNative handler chosen"), "Chrome74";
  }
  if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
    const t = navigator.userAgent, e = bowser_default.getParser(t), r = e.getEngine();
    if (e.satisfies({
      chrome: ">=74",
      chromium: ">=74",
      "microsoft edge": ">=88"
    }))
      return "Chrome74";
    if (e.satisfies({ chrome: ">=55", chromium: ">=55" }))
      return;
    if (e.satisfies({ firefox: ">=110" }))
      return "Firefox110";
    if (e.satisfies({ firefox: ">=60" }))
      return "Firefox60";
    if (e.satisfies({ ios: { OS: ">=14.3", firefox: ">=30.0" } }) || e.satisfies({ safari: ">=12.0" }) && typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection"))
      return "Safari12";
    if (e.satisfies({ safari: ">=11" }) || e.satisfies({ "microsoft edge": ">=11" }) && e.satisfies({ "microsoft edge": "<=18" }))
      return;
    if (r.name && r.name.toLowerCase() === "blink") {
      const i = t.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
      return i ? Number(i[1]) >= 74 ? "Chrome74" : void 0 : "Chrome74";
    }
    if (r.name.toLowerCase() === "webkit" && e.getOS().name.toLowerCase() === "ios")
      return typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") ? "Safari12" : void 0;
    s.warn("Device::this._detectDevice() | browser not supported");
    return;
  }
  s.warn("Device::this._detectDevice() | unknown device");
}
var lc;
var rr;
var Gi;
var nD = class {
  constructor(t, e, { handlerName: r, handlerFactory: i } = {}) {
    h(this, "handlerFactory");
    g(this, lc, void 0);
    g(this, rr, void 0);
    g(this, Gi, void 0);
    const n = t.getValue("logger");
    if (n.debug("constructor()"), m(this, rr, t), m(this, Gi, n), m(this, lc, e), r && i)
      throw new TypeError(
        "just one of handlerName or handlerInterface can be given"
      );
    if (i)
      this.handlerFactory = i;
    else {
      if (r)
        a(this, Gi).debug(`Device::constructor() | handler given: ${r}`);
      else if (r = aD(a(this, Gi)), r)
        a(this, Gi).debug(`Device::constructor() | detected handler: ${r}`);
      else
        throw new Error("device not supported");
      switch (r) {
        case "Chrome74":
          this.handlerFactory = qh.createFactory(a(this, rr));
          break;
        case "Safari12":
          this.handlerFactory = jh.createFactory(a(this, rr));
          break;
        case "Firefox60":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: false }
          );
          break;
        case "Firefox110":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: true }
          );
          break;
        default:
          throw new TypeError(`unknown handlerName "${r}"`);
      }
    }
  }
  /**
   * Creates a Transport for receiving media.
   *
   * @throws {InvalidStateError} if not loaded.
   * @throws {TypeError} if wrong arguments.
   */
  createTransport(t) {
    const e = v4_default();
    return new th(a(this, rr), a(this, lc), B(D({
      id: e
    }, t), {
      handlerFactory: this.handlerFactory
    }));
  }
};
lc = /* @__PURE__ */ new WeakMap(), rr = /* @__PURE__ */ new WeakMap(), Gi = /* @__PURE__ */ new WeakMap();
var oD = 2e3;
var wn;
var ot;
var ct;
var uc;
var hc;
var Wi;
var bn;
var kn;
var In;
var Ji;
var Ns;
var An;
var Mn;
var _d;
var pc;
var sh;
var nl;
var tS;
var gc;
var rh;
var ol;
var sS;
var cl;
var rS;
var dl;
var iS;
var ll;
var aS;
var ul;
var nS;
var mc;
var ih;
var fc;
var ah;
var cD = class extends ut.EventEmitter {
  constructor(e, r, i) {
    super();
    g(this, Mn);
    g(this, pc);
    g(this, nl);
    g(this, gc);
    g(this, ol);
    g(this, cl);
    g(this, dl);
    g(this, ll);
    g(this, ul);
    g(this, mc);
    g(this, fc);
    h(this, "context");
    g(this, wn, void 0);
    g(this, ot, void 0);
    g(this, ct, void 0);
    g(this, uc, void 0);
    g(this, hc, void 0);
    g(this, Wi, void 0);
    g(this, bn, void 0);
    g(this, kn, void 0);
    g(this, In, {
      transportFailureCount: {
        send: 0,
        recv: 0
      },
      lastConnectionTime: 0
    });
    g(this, Ji, void 0);
    g(this, Ns, "all");
    g(this, An, void 0);
    switch (this.context = e, m(this, Wi, r), m(this, An, i), m(this, wn, new nD(e, i)), m(this, bn, new eD(r, i)), i) {
      case we.CF: {
        m(this, kn, Ts);
        break;
      }
      case we.HIVE:
      default: {
        m(this, kn, is);
        break;
      }
    }
    a(this, Mn, _d).mediaState = {
      send: { state: xa.NEW },
      recv: { state: xa.NEW }
    }, (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy initially set to ${a(this, Ns)}`), L(this, pc, sh).call(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  get socket() {
    return a(this, Wi);
  }
  get socketHandler() {
    return a(this, bn);
  }
  get sendTransport() {
    return a(this, ot);
  }
  get recvTransport() {
    return a(this, ct);
  }
  get events() {
    return a(this, kn);
  }
  get nodeType() {
    return a(this, An);
  }
  set sendTransportConnectedCallback(e) {
    m(this, uc, e);
  }
  set recvTransportConnectedCallback(e) {
    m(this, hc, e);
  }
  setupTransports(e) {
    return u(this, null, function* () {
      yield L(this, nl, tS).call(this, e);
      let r, i;
      e.send && (r = L(this, gc, rh).call(this, a(this, ot)).then((n) => {
        try {
          a(this, uc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run send transport callback");
        }
      })), e.recv && (i = L(this, gc, rh).call(this, a(this, ct)).then((n) => {
        try {
          a(this, hc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run recv transport callback");
        }
      })), yield Promise.all([r, i]);
    });
  }
  stopTransports(e) {
    var r, i;
    if (e.send && this.sendTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ot);
      this.logger.info("Closing send transport", { transport: { id: n, serverId: o, type: c } }), a(this, ot).close(), a(this, ot).removeAllListeners(), m(this, ot, void 0);
    }
    if (e.recv && this.recvTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ct);
      this.logger.info("Closing recv transport", { transport: { id: n, serverId: o, type: c } }), (r = a(this, ct)) == null || r.close(), (i = a(this, ct)) == null || i.removeAllListeners(), m(this, ct, void 0);
    }
    L(this, pc, sh).call(this);
  }
  stopAllTransports() {
    this.logger.info("Closing all transports"), this.stopTransports({ send: true, recv: true });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  handleErrors(e) {
    throw new Error("Method not implemented.");
  }
};
wn = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), uc = /* @__PURE__ */ new WeakMap(), hc = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), bn = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakMap(), In = /* @__PURE__ */ new WeakMap(), Ji = /* @__PURE__ */ new WeakMap(), Ns = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakMap(), Mn = /* @__PURE__ */ new WeakSet(), _d = function() {
  return this.context.getValue("connectionHandler");
}, pc = /* @__PURE__ */ new WeakSet(), sh = function() {
  m(this, Ji, {
    send: void 0,
    recv: void 0
  });
}, nl = /* @__PURE__ */ new WeakSet(), tS = function(e) {
  return u(this, null, function* () {
    var o, c, d, l, p, f2, S, T;
    (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy set to ${a(this, Ns)}`);
    const n = yield lt().getICEServers().catch((_) => (this.logger.warn(`failed to get iceservers from server: ${_.message}`), []));
    if (e.send) {
      const _ = this.context.getValue("flagsmith").hasFeature(
        X.DISABLE_OPUS_DTX_CF
      );
      L(this, cl, rS).call(this, {
        iceServers: n,
        additionalSettings: {
          encodedInsertableStreams: (o = this.context.getValue("modules").e2ee) == null ? void 0 : o.enabled
        },
        config: {
          enableHighBitrate: (l = (d = (c = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : c.audio) == null ? void 0 : d.enableHighBitrate) != null ? l : false,
          enableStereo: (S = (f2 = (p = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : p.audio) == null ? void 0 : f2.enableStereo) != null ? S : false,
          enableDtx: a(this, An) === we.HIVE ? true : !!_
        },
        iceTransportPolicy: a(this, Ns)
      });
    }
    e.recv && L(this, dl, iS).call(this, {
      iceServers: n,
      additionalSettings: {
        encodedInsertableStreams: (T = this.context.getValue("modules").e2ee) == null ? void 0 : T.enabled
      },
      iceTransportPolicy: a(this, Ns)
    });
  });
}, gc = /* @__PURE__ */ new WeakSet(), rh = function(e) {
  return u(this, null, function* () {
    const { id: r, serverId: i, direction: n } = e;
    L(this, ll, aS).call(this, e);
    try {
      const o = this.context.getValue("flagsmith").hasFeature(
        X.ENABLE_HIVE_INFINITE_RETRIES
      ) ? 1 / 0 : 3;
      return yield Yf((c, d) => u(this, null, function* () {
        c > 0 && this.logger.debug(`Retrying transport connect, count: ${c}`, {
          transport: { id: r, serverId: i, type: n }
        });
        try {
          if (e.closed)
            throw new fi("Cannot reconnect closed transport");
          yield L(this, ol, sS).call(this, e);
        } catch (l) {
          if (l instanceof fi) {
            d(l);
            return;
          }
          throw this.logger.error("Failed to connect transport, retrying", { transport: e, error: l }), l;
        }
      }), {
        delayTime: 100,
        strategy: "exponential",
        maxRetryCount: o
      }), e;
    } catch (o) {
      throw this.logger.error(
        `Failed to connect send transport after retry: ${e.id}`,
        {
          error: o,
          transport: { id: r, serverId: i, type: n }
        }
      ), e.close(), e.removeAllListeners(), o;
    }
  });
}, ol = /* @__PURE__ */ new WeakSet(), sS = function(e) {
  return u(this, null, function* () {
    const { id: r, direction: i } = e;
    if (this.logger.info(`Connecting ${i} transport`, {
      transport: { id: r, type: i }
    }), !a(this, Wi).isConnected)
      throw new fi("Socket is not connected");
    if (e.connectionState === "closed")
      throw new fi("Transport is closed");
    try {
      yield e.connect(
        (n) => L(this, ul, nS).call(this, i, n)
      ), this.logger.info(`Connected ${i} transport`, {
        transport: { id: r, serverId: e.serverId, type: i }
      });
    } catch (n) {
      throw a(this, In).transportFailureCount[i] += 1, n.message === "ice connection failed" ? new fi(n.message) : n;
    }
  });
}, cl = /* @__PURE__ */ new WeakSet(), rS = function(e) {
  var r, i;
  if (a(this, ot) && a(this, ot).connected) {
    this.logger.info("Transport send is already connected", {
      transport: {
        id: (r = a(this, ot)) == null ? void 0 : r.id,
        serverId: (i = a(this, ot)) == null ? void 0 : i.serverId,
        type: "send"
      }
    });
    return;
  }
  m(this, ot, a(this, wn).createTransport(B(D({}, e), {
    direction: "send"
  }))), this.context.getValue("callstats").configureSendTransport(a(this, ot));
}, dl = /* @__PURE__ */ new WeakSet(), iS = function(e) {
  var r, i;
  if (a(this, ct) && a(this, ct).connected) {
    this.logger.info("Transport recv is already connected", {
      transport: {
        id: (r = a(this, ct)) == null ? void 0 : r.id,
        serverId: (i = a(this, ct)) == null ? void 0 : i.serverId,
        type: "recv"
      }
    });
    return;
  }
  m(this, ct, a(this, wn).createTransport(B(D({}, e), {
    direction: "recv"
  }))), this.context.getValue("callstats").configureRecvTransport(a(this, ct));
}, ll = /* @__PURE__ */ new WeakSet(), aS = function(e) {
  const { direction: r, id: i } = e;
  e.on("connectionstatechange", (n) => u(this, null, function* () {
    L(this, fc, ah).call(this, { state: n, direction: r }), this.logger.info(
      `Transport connection state changed for ${r} transport`,
      {
        transport: {
          id: i,
          serverId: e.serverId,
          type: r,
          status: n
        }
      }
    );
    const o = () => {
      const c = a(this, Ji)[r];
      c !== void 0 && (clearTimeout(c), a(this, Ji)[r] = void 0);
    };
    switch (n) {
      case "connected":
        o(), a(this, In).lastConnectionTime = performance.now();
        break;
      case "disconnected":
        a(this, Ji)[r] = setTimeout(() => u(this, null, function* () {
          this.logger.warn(`${r} transport is in disconnected state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        }), oD);
        break;
      case "failed":
        if (e.closed)
          return;
        o(), this.logger.warn(`${r} transport is in failed state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        break;
    }
  })), e.on("icecandidate", (n) => u(this, null, function* () {
    this.logger.debug("Sending iceCandidate:", { iceCandidate: n });
  })), e.on("datachannel:events", (n, o) => u(this, null, function* () {
    var c, d;
    this.logger.debug("Got data channel message on event:", {
      rtcChannel: { label: n, message: o }
    });
    try {
      switch (o.type) {
        case "handshake": {
          const l = {
            type: "handshake",
            payload: {
              message: "pong"
            }
          };
          e.sendResponseOverDC(n, eS(o), l);
          break;
        }
        case "hub-disconnect": {
          this.logger.debug(`media hub disconnected, full_reconnect: ${(c = o.payload) == null ? void 0 : c.full_reconnect}`), ((d = o.payload) == null ? void 0 : d.full_reconnect) === true && this.handleErrors("rejoin");
          break;
        }
        case "error":
          break;
        default:
          break;
      }
    } catch (l) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${n}`
      );
    }
  })), e.on("dc_error", () => {
    e.direction === "recv" && (this.logger.warn("Events datachannel did not open in 5s", { country: E.location.country }), this.handleErrors("reconnectRecvTransport"));
  });
}, ul = /* @__PURE__ */ new WeakSet(), nS = function(e, r) {
  return u(this, null, function* () {
    const i = e === "recv";
    try {
      const { sdp: n, type: o } = r, c = {
        consuming: i,
        description: {
          sdp: n,
          type: o,
          target: i ? vr.SUBSCRIBER : vr.PUBLISHER
        },
        producers: []
      };
      return a(this, bn).connectTransport(c);
    } catch (n) {
      throw this.logger.error(
        `Error in ${e} transport connection:`,
        { error: n, country: E.location.country }
      ), n;
    }
  });
}, mc = /* @__PURE__ */ new WeakSet(), ih = function(e) {
  return u(this, null, function* () {
    switch (this.logger.info("Called reconnect transport", { transport: { type: e } }), this.stopTransports({ [e]: true }), this.context.getValue("flagsmith").hasFeature(
      X.HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED
    ) && a(this, Wi).isConnected && a(this, In).transportFailureCount[e] > 2 && (this.logger.warn(`Multiple disconnections in ${e} transport, forcing relay`), m(this, Ns, "relay")), yield this.setupTransports({ [e]: true }), e) {
      case "send": {
        this.logger.info("Transport reconnected", { transport: a(this, ot) }), this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE);
        break;
      }
      case "recv": {
        this.logger.info("Transport reconnected", { transport: a(this, ct) }), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: true });
        break;
      }
      default:
        this.logger.warn("Unknown transport direction", { transport: { type: e } });
    }
    L(this, fc, ah).call(this, {
      state: xa.CONNECTED,
      direction: e
    });
  });
}, fc = /* @__PURE__ */ new WeakSet(), ah = function(e) {
  const { state: r, direction: i } = e;
  a(this, Mn, _d).mediaState[i] = {
    state: r
  }, this.context.getValue("peerSessionStore").emit(
    k.TRANSPORT_STATE_UPDATE,
    D({
      transport: i
    }, a(this, Mn, _d).mediaState[i])
  );
};
var Sc;
var hl;
var oS;
var dD = class {
  /* eslint-disable-next-line no-useless-constructor, no-empty-function */
  constructor(t, e) {
    g(this, hl);
    g(this, Sc, void 0);
    this.recvTransport = e, L(this, hl, oS).call(this), m(this, Sc, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Sc).getValue("logger");
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const r = {
        type: "create_consumer",
        payload: {
          producers: t.map(({
            producerId: c,
            producingTransportId: d,
            kind: l,
            mimeType: p
          }) => ({
            producerId: c,
            producingTransportId: d,
            preferredCodec: D(D({}, l === "video" && p ? { video: p } : {}), l === "audio" && p ? { audio: p } : {})
          }))
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), n = /* @__PURE__ */ new Map();
      t.forEach((c) => n.set(c.producerId, c));
      const o = /* @__PURE__ */ new Map();
      return Object.entries(i).forEach(([c, d]) => {
        const l = n.get(d.producerId);
        l && o.set(d.producerId, {
          consumerId: c,
          producingTransportId: l.producingTransportId,
          producingPeerId: l.producingPeerId,
          kind: l.kind,
          paused: l.pause,
          streamId: d.streamId,
          trackId: d.trackId,
          screenShare: l.screenShare,
          mimeType: l.mimeType,
          appData: {}
        });
      }), { consumerStates: o };
    });
  }
  negotiate(t, e, r) {
    return u(this, null, function* () {
      try {
        this.logger.debug(`Received offer over dc: ${t.sdp} for transport`);
        const i = yield this.recvTransport.setRemoteOffer(t), n = {
          type: "answer",
          payload: {
            type: i.type,
            sdp: i.sdp
          }
        };
        return this.logger.debug(`datachannel answer: ${JSON.stringify(n)}`), this.recvTransport.sendResponseOverDC(r, e, n), i;
      } catch (i) {
        throw this.logger.error("datachannel:events::Error:", i), i.code !== "DC_NOT_FOUND" && this.recvTransport.sendErrorOverDC(r, e, i), i;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = t.map((o) => o.id);
      this.logger.info(`Closing consumers: ${JSON.stringify(e)}`);
      const r = {
        type: "close_consumers",
        payload: {
          consumers: e
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), { failedConsumers: n } = i;
      return { failedConsumers: n };
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      var o;
      const r = this.recvTransport.getDatachannel("events");
      if (!r) {
        this.logger.warn("events datachannel not found");
        return;
      }
      const i = (o = t == null ? void 0 : t.map(({ id: c }) => c)) != null ? o : [], n = {
        type: "switch_consumer_layer",
        payload: {
          consumerIds: i,
          layer: e
        }
      };
      yield r.request(n), this.logger.info(`Consumers switched layers to ${e}`, { consumerIds: i });
    });
  }
};
Sc = /* @__PURE__ */ new WeakMap(), hl = /* @__PURE__ */ new WeakSet(), oS = function() {
  this.recvTransport.on("datachannel:events", (e, r) => u(this, null, function* () {
    try {
      switch (r.type) {
        case "negotiation": {
          const { sdp: i } = r.payload, n = {
            sdp: i,
            type: "offer"
          };
          this.negotiate(n, eS(r), e);
          break;
        }
        default:
          break;
      }
    } catch (i) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${e}`
      );
    }
  }));
};
var vc;
var ts;
var lD = class {
  constructor(t, e, r, i, n) {
    g(this, vc, void 0);
    g(this, ts, void 0);
    this.events = e, this.recvTransport = r, this.socket = i, this.socketHandler = n, m(this, vc, t), m(this, ts, t.getValue("logger"));
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const e = /* @__PURE__ */ new Map(), r = [];
      t.forEach((d) => {
        const { producingPeerId: l, producerId: p, producingTransportId: f2 } = d, S = a(this, vc).getValue("flagsmith").hasFeature(X.ENABLE_CF_SIMULCAST) ? {
          simulcast: {
            preferredRid: "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        } : {};
        e.set(p, l), r.push(D({
          producingPeerId: l,
          producerId: p,
          producingTransportId: f2
        }, S));
      });
      const i = yield this.socketHandler.consume({
        requests: r,
        consumingTransportId: this.recvTransport.serverId
      }), n = /* @__PURE__ */ new Map();
      t.forEach((d) => n.set(d.producerId, d));
      const o = /* @__PURE__ */ new Map(), c = [];
      return Object.entries(i.consumerStateMap).forEach(([d, l]) => {
        const p = n.get(d);
        if (!p)
          return;
        if (l.errorCode) {
          a(this, ts).warn(`Consumer request failed for producer ${d}`, {
            error: { message: l.errorCode }
          }), c.push(B(D({}, p), { errorCode: l.errorCode }));
          return;
        }
        let f2 = {};
        try {
          f2 = JSON.parse(l.producerState.appData);
        } catch (S) {
        }
        o.set(d, {
          consumerId: l.consumerId,
          producingTransportId: p.producingTransportId,
          producingPeerId: p.producingPeerId,
          kind: p.kind,
          paused: p.pause,
          streamId: l.producerTrack.streamId,
          trackId: l.producerTrack.trackId,
          screenShare: p.screenShare,
          mimeType: p.mimeType,
          appData: f2
        });
      }), { consumerStates: o, sessionDescription: i.sessionDescription, failedProducers: c };
    });
  }
  negotiate(t) {
    return u(this, null, function* () {
      try {
        a(this, ts).info("Negotiating socket consumer", { transport: this.recvTransport }), a(this, ts).debug(`setting remote offer: ${JSON.stringify(t)} on recvTransport`, {
          transport: this.recvTransport
        });
        const e = yield this.recvTransport.setRemoteOffer(t), r = {
          transportId: this.recvTransport.serverId,
          description: {
            sdp: e.sdp,
            type: e.type,
            target: vr.SUBSCRIBER
          }
        };
        return a(this, ts).debug(`sending renegotiate request: ${JSON.stringify(r)} on recvTransport`, {
          transport: this.recvTransport
        }), yield this.socket.sendMessagePromise(
          this.events.renegotiateSessionDescription,
          JC.toBinary(r)
        ), a(this, ts).info("Renegotiation done", { transport: this.recvTransport }), e;
      } catch (e) {
        a(this, ts).error("Failed to renegotiate", { error: e });
        return;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = (r, i) => u(this, null, function* () {
        const n = r.map((l) => l.localId);
        a(this, ts).info(`Closing consumers: ${JSON.stringify(n)}`);
        const o = {
          description: {
            sdp: i.sdp,
            type: i.type,
            target: vr.SUBSCRIBER
          },
          consumerIds: n,
          consumingTransportId: this.recvTransport.serverId
        }, c = yield this.socketHandler.closeConsumer(o), d = Tw.fromBinary(c).description;
        return {
          sdp: d.sdp,
          type: d.type
        };
      });
      return yield this.recvTransport.awaitQueue.push(() => this.recvTransport.closeConsumers(t, e), "ConsumerStrategy.close", { consumersLength: t.length }), {};
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      const r = {
        requests: [],
        consumingTransportId: this.recvTransport.serverId
      }, i = t.filter((n) => n && n.id);
      i.forEach(({ id: n, producingTransportId: o, localId: c }) => {
        r.requests.push({
          producerId: n,
          producingTransportId: o,
          mid: c,
          simulcast: {
            preferredRid: e === 0 ? "q" : "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        });
      }), yield this.socketHandler.updateConsumersSimulcastConfig(r), a(this, ts).info(`Consumers switched layers to ${e}`, { consumerIds: i == null ? void 0 : i.map(({ id: n }) => n) });
    });
  }
};
vc = /* @__PURE__ */ new WeakMap(), ts = /* @__PURE__ */ new WeakMap();
var Gh = class _Gh {
  /* eslint-disable-next-line no-useless-constructor, no-empty-function */
  constructor(t) {
    this.socketHandler = t;
  }
  static getMSIDFromSDP(t, e) {
    return cs.parse(t).media.filter(
      (n) => e === "video" ? n.type === "video" : n.type === "audio"
    ).at(-1).msid;
  }
  create(c) {
    return u(this, arguments, function* ({
      offer: t,
      kind: e,
      paused: r,
      appData: i,
      codecOptions: n,
      producingTransportId: o
    }) {
      var S, T;
      const d = _Gh.getMSIDFromSDP(t.sdp, e), l = {
        description: {
          sdp: t.sdp,
          type: t.type,
          target: vr.PUBLISHER
        },
        paused: r,
        kind: e,
        msid: d,
        appData: JSON.stringify(i),
        screenShare: (S = i.screenShare) != null ? S : false,
        mimeType: `${e}/${(T = n[0]) == null ? void 0 : T.name}`,
        producingTransportId: o
      }, { answer: p, producerId: f2 } = yield this.socketHandler.produce(l);
      return { answer: p, producerId: f2 };
    });
  }
};
var Ki;
var Wr;
var Dn;
var yc;
var ps;
var pl;
var ir;
var On;
var Tc;
var nh;
var gl;
var cS;
var ml;
var dS;
var fl;
var lS;
var Sl;
var uS;
var uD = class extends cD {
  constructor(e, r, i) {
    super(e, r, i);
    g(this, Tc);
    g(this, gl);
    g(this, ml);
    g(this, fl);
    g(this, Sl);
    g(this, Ki, void 0);
    g(this, Wr, void 0);
    g(this, Dn, void 0);
    g(this, yc, void 0);
    g(this, ps, void 0);
    g(this, pl, {
      producerCreationFailureCount: 0,
      consumerCreationFailureCount: 0,
      producerNotReadyFailureCount: 0
    });
    g(this, ir, []);
    g(this, On, void 0);
    this.context = e, this.sendTransportConnectedCallback = () => u(this, null, function* () {
      m(this, yc, new Gh(this.socketHandler));
    }), this.recvTransportConnectedCallback = (n) => u(this, null, function* () {
      switch (a(this, Dn).clear(), this.nodeType) {
        case we.CF: {
          m(this, ps, new lD(
            this.context,
            this.events,
            n,
            this.socket,
            this.socketHandler
          ));
          break;
        }
        case we.HIVE:
        default:
          m(this, ps, new dD(this.context, n));
      }
    }), this.reset();
  }
  get socketHandler() {
    return super.socketHandler;
  }
  get producers() {
    return a(this, Ki);
  }
  get consumers() {
    return a(this, Wr);
  }
  get producerIdToConsumerIdMap() {
    return a(this, Dn);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  reset() {
    m(this, Ki, /* @__PURE__ */ new Map()), m(this, Wr, /* @__PURE__ */ new Map()), m(this, Dn, /* @__PURE__ */ new Map());
  }
  createProducer(e, r) {
    return u(this, null, function* () {
      var i;
      if (!this.sendTransport || this.sendTransport.closed)
        throw new Error("Send transport is closed");
      try {
        const n = yield this.sendTransport.produce(
          e,
          L(this, gl, cS).bind(this)
        );
        return (i = e.appData) != null && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, n), L(this, ml, dS).call(this, n, r), n;
      } catch (n) {
        throw this.logger.error("Failed to create producer", { error: n }), a(this, pl).producerCreationFailureCount += 1, n;
      }
    });
  }
  closeProducer(e, r) {
    return u(this, null, function* () {
      var n;
      const i = this.producers.get(e);
      if (!i) {
        this.logger.warn(`Producer with ID ${e} was not found`);
        return;
      }
      r != null && r.stopTrack && i.track.stop();
      try {
        yield this.sendTransport.closeProducer(i), (n = this.context.getValue("modules").e2ee) != null && n.enabled && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_PRODUCER, i);
      } catch (o) {
        this.logger.error("Failed to close producer on server", { error: o, producer: i });
      }
    });
  }
  closeAllProducers() {
    return Promise.all(Array.from(a(this, Ki).entries()).map(([, e]) => e.close()));
  }
  createConsumer(e) {
    return this.createConsumers([e]);
  }
  createConsumers(e) {
    return u(this, null, function* () {
      a(this, On) || clearTimeout(a(this, On)), m(this, ir, a(this, ir).concat(e)), yield L(this, Tc, nh).call(this);
    });
  }
  closeConsumer(e) {
    return this.closeConsumers([e]);
  }
  closeConsumers(e) {
    return u(this, null, function* () {
      if (!a(this, ps))
        return;
      const r = e.map((n) => this.consumers.get(n)).filter((n) => n !== void 0);
      if (r.length === 0)
        return;
      const { failedConsumers: i } = yield a(this, ps).close(r);
      i != null && i.length && this.logger.warn("Failed to close some consumers", { consumerIds: i });
    });
  }
  closeAllConsumers() {
    return this.closeConsumers(Array.from(a(this, Wr).keys()));
  }
  switchConsumersToLayer(e, r) {
    return u(this, null, function* () {
      a(this, ps).switchConsumersToLayer(e, r);
    });
  }
};
Ki = /* @__PURE__ */ new WeakMap(), Wr = /* @__PURE__ */ new WeakMap(), Dn = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), ps = /* @__PURE__ */ new WeakMap(), pl = /* @__PURE__ */ new WeakMap(), ir = /* @__PURE__ */ new WeakMap(), On = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakSet(), nh = function() {
  return u(this, null, function* () {
    if (!this.recvTransport || this.recvTransport.closed)
      throw new Error("Recv transport is closed");
    const e = 500, r = a(this, ir).splice(0, a(this, ir).length);
    try {
      const i = new Set(Array.from(this.consumers.values()).map(({ producerId: d }) => d)), n = r.filter(({ producerId: d }) => !this.producers.get(d) && !i.has(d));
      if (n.length === 0)
        return;
      const { consumers: o, failedProducers: c } = yield this.recvTransport.consume(
        n,
        L(this, fl, lS).bind(this),
        a(this, ps).negotiate.bind(a(this, ps))
      );
      if (o.forEach(L(this, Sl, uS).bind(this)), c != null && c.length) {
        this.logger.error("Failed to create consumers for producers", { producers: c });
        const d = c.filter(({ errorCode: l, producerId: p }) => l === "not_found_track_error" ? (this.logger.error(`Track not found for producer: ${p}. This will not be retried.`), false) : l === "backend_error" ? (this.logger.error("Unrecoverable error: backend error"), false) : true);
        m(this, ir, a(this, ir).concat(d)), m(this, On, setTimeout(
          L(this, Tc, nh).bind(this),
          e
        ));
      }
    } catch (i) {
      if (this.logger.error("failed to consume on transport", { error: i }), i.errorCode === "internal_error" && i.errorDescription === "Backend error" || i.errorCode === "invalid_session_description") {
        this.logger.error(
          "Irrecoverable error, closing current recvTransport to create a new one",
          {
            transport: this.recvTransport,
            error: { code: i.errorCode, message: i.errorDescription }
          }
        );
        try {
          this.stopTransports({ recv: true });
        } catch (n) {
        }
        yield this.setupTransports({ recv: true });
      }
    }
  });
}, gl = /* @__PURE__ */ new WeakSet(), cS = function(e) {
  return a(this, yc).create(e);
}, ml = /* @__PURE__ */ new WeakSet(), dS = function(e, r) {
  e.on("close", (i, n) => u(this, null, function* () {
    const { offer: o, reason: c } = i;
    if (this.logger.info("producer::closing", {
      debuggingHint: c,
      producer: B(D({}, e), { status: "closing" })
    }), c !== Ud) {
      const d = {
        producerId: e.id,
        description: {
          sdp: o.sdp,
          type: o.type,
          target: vr.PUBLISHER
        }
      };
      try {
        const l = yield this.socketHandler.closeProducer(d), p = {
          sdp: l == null ? void 0 : l.sdp,
          type: l == null ? void 0 : l.type
        };
        this.logger.info("producer::closed", { producer: B(D({}, e), { status: "closed" }) }), n({ answer: p });
      } catch (l) {
        this.logger.error("producer close error", l);
      }
    }
    this.producers.delete(e.id), r();
  })), e.on("trackended", () => {
    this.logger.info("producer::trackended", { producer: B(D({}, e), { status: "UNKNOWN" }) });
  }), a(this, Ki).set(e.id, e);
}, fl = /* @__PURE__ */ new WeakSet(), lS = function(e) {
  return u(this, null, function* () {
    try {
      return yield this.recvTransport.canConsume(), yield a(this, ps).create(e);
    } catch (r) {
      throw this.logger.error("Error in consume request", { error: r }), r;
    }
  });
}, Sl = /* @__PURE__ */ new WeakSet(), uS = function(e) {
  e.on("close", (r) => u(this, null, function* () {
    this.logger.debug("consumer closed", {
      consumer: {
        closureReason: r,
        id: e.id,
        kind: e.kind,
        appData: e.appData
      }
    }), a(this, Wr).delete(e.id), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, { id: e.id });
  })), a(this, Wr).set(e.id, e), this.producerIdToConsumerIdMap.set(e.producerId, e.id), this.context.getValue("peerSessionStore").emit(k.NEW_CONSUMER, {
    id: e.id,
    appData: e.appData,
    peerId: e.peerId
  });
};
var Ec;
var _c;
var Pc;
var Nn;
var Vn;
var Ln;
var Cc;
var Rc;
var xn;
var bt;
var gs;
var ms;
var zi;
var Yi;
var ar;
var wc;
var vl;
var hS;
var yl;
var pS;
var Tl;
var gS;
var El;
var mS;
var _l = class {
  constructor({
    initialEnergyThreshold: t = 0.015,
    zeroCrossingThreshold: e = 20,
    minVoiceDuration: r = 3,
    hangoverFrames: i = 5,
    noiseAdaptationRate: n = 0.95,
    voiceAdaptationRate: o = 0.99,
    minEnergyThreshold: c = 5e-3,
    maxEnergyThreshold: d = 0.2,
    energyRatioThreshold: l = 1.5,
    noiseHistorySize: p = 50
  } = {}) {
    g(this, vl);
    g(this, yl);
    g(this, Ec, void 0);
    g(this, _c, void 0);
    g(this, Pc, void 0);
    g(this, Nn, void 0);
    g(this, Vn, void 0);
    g(this, Ln, void 0);
    g(this, Cc, void 0);
    g(this, Rc, void 0);
    g(this, xn, void 0);
    g(this, bt, void 0);
    g(this, gs, void 0);
    g(this, ms, false);
    g(this, zi, 0);
    g(this, Yi, 0);
    g(this, ar, []);
    g(this, wc, void 0);
    m(this, Nn, t), m(this, bt, t), m(this, Ec, e), m(this, _c, r), m(this, Pc, i), m(this, Vn, n), m(this, Ln, o), m(this, Cc, c), m(this, Rc, d), m(this, xn, l), m(this, wc, p), m(this, gs, t / 2);
  }
  get voiceDetected() {
    return a(this, ms);
  }
  /**
   * Process an audio chunk and determine if it contains voice activity
   * @param audioChunk - Float32Array containing audio samples in range [-1, 1]
   * @returns boolean indicating if voice activity is detected
   */
  processAudioChunk(t) {
    var o, c;
    const e = L(o = _l, Tl, gS).call(o, t), r = L(c = _l, El, mS).call(c, t);
    return L(this, vl, hS).call(this, e), e / a(this, gs) > a(this, xn) && e > a(this, bt) && r > a(this, Ec) ? (m(this, zi, a(this, zi) + 1), m(this, Yi, a(this, Pc)), a(this, zi) >= a(this, _c) && m(this, ms, true)) : (m(this, zi, 0), a(this, Yi) > 0 ? m(this, Yi, a(this, Yi) - 1) : a(this, ms) && m(this, ms, false), a(this, ms) || L(this, yl, pS).call(this, e)), { energy: e, isVoice: a(this, ms) };
  }
  /**
   * Reset the detector state
   */
  reset() {
    m(this, ms, false), m(this, zi, 0), m(this, Yi, 0), m(this, bt, a(this, Nn)), m(this, gs, a(this, Nn) / 2), m(this, ar, []);
  }
  /**
   * Get current adaptive threshold values for debugging/visualization
   */
  getThresholdInfo() {
    return {
      currentEnergyThreshold: a(this, bt),
      backgroundNoiseEnergy: a(this, gs),
      energyRatioThreshold: a(this, xn)
    };
  }
};
var Po = _l;
Ec = /* @__PURE__ */ new WeakMap(), _c = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), Rc = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), gs = /* @__PURE__ */ new WeakMap(), ms = /* @__PURE__ */ new WeakMap(), zi = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), vl = /* @__PURE__ */ new WeakSet(), hS = function(t) {
  a(this, ms) ? m(this, bt, a(this, Ln) * a(this, bt) + (1 - a(this, Ln)) * t) : m(this, bt, a(this, Vn) * a(this, bt) + (1 - a(this, Vn)) * a(this, gs)), m(this, bt, Math.max(
    a(this, Cc),
    Math.min(a(this, Rc), a(this, bt))
  ));
}, yl = /* @__PURE__ */ new WeakSet(), pS = function(t) {
  if (t < a(this, bt) * 1.2)
    if (a(this, ar).push(t), a(this, ar).length > a(this, wc) && a(this, ar).shift(), a(this, ar).length >= 10) {
      const e = [...a(this, ar)].sort((i, n) => i - n), r = Math.floor(e.length / 2);
      m(this, gs, e[r]);
    } else
      m(this, gs, 0.95 * a(this, gs) + 0.05 * t);
}, Tl = /* @__PURE__ */ new WeakSet(), gS = function(t) {
  return Math.sqrt(
    t.map((e) => e * e).reduce((e, r) => e + r) / t.length
  );
}, El = /* @__PURE__ */ new WeakSet(), mS = function(t) {
  let e = 0;
  for (let r = 1; r < t.length; r += 1)
    (t[r] >= 0 && t[r - 1] < 0 || t[r] < 0 && t[r - 1] >= 0) && (e += 1);
  return e;
}, g(Po, Tl), g(Po, El);
var bc;
var vg = class {
  constructor(t) {
    h(this, "RNAudioSampleHandler");
    g(this, bc, void 0);
    m(this, bc, t);
    const { RNAudioSampleHandlerImpl: e } = navigator;
    e == null || e.init().then((r) => {
      this.RNAudioSampleHandler = r;
    }).catch((r) => {
      this.logger.error("ReactNativeAudioSampler: Failed to initialize audio sampler", r);
    });
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, bc).getValue("logger");
  }
  get samples() {
    var e;
    const t = new Float32Array(1024);
    return (e = this.RNAudioSampleHandler) == null || e.getFloatTimeDomainData(t), t;
  }
  stop() {
    var t;
    (t = this.RNAudioSampleHandler) == null || t.destructor();
  }
};
bc = /* @__PURE__ */ new WeakMap();
var kc;
var yg = class {
  constructor(t) {
    h(this, "audioContext");
    h(this, "analyser");
    g(this, kc, void 0);
    m(this, kc, t), this.audioContext = new AudioContext(), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2048;
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, kc).getValue("logger");
  }
  get samples() {
    if (this.audioContext.state === "suspended")
      try {
        this.audioContext.resume();
      } catch (e) {
        this.logger.error("AudioContextSampler: Failed to resume audio context", e);
      }
    const t = new Float32Array(this.analyser.frequencyBinCount);
    return this.analyser.getFloatTimeDomainData(t), t;
  }
  set audioTrack(t) {
    const e = new MediaStream();
    e.addTrack(t), this.audioContext.createMediaStreamSource(e).connect(this.analyser);
  }
};
kc = /* @__PURE__ */ new WeakMap();
var hD = class {
  static setInterval(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setInterval(t, e, ...r) : global.setInterval(t, e, ...r);
  }
  static clearInterval(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearInterval(t) : global.clearInterval(t);
  }
  static setTimeout(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setTimeout(t, e, ...r) : global.setTimeout(t, e, ...r);
  }
  static clearTimeout(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearTimeout(t) : global.clearTimeout(t);
  }
};
var pD = 60;
var gD = 400;
var nr;
var or;
var fs;
var Ic;
var Qi;
var Un;
var cr;
var Jr;
var $n;
var dr;
var lr;
var Vs;
var Pl;
var fS;
var Ac;
var oh;
var Cl;
var SS;
var Rl;
var vS;
var No = class {
  constructor(t, e) {
    g(this, Pl);
    g(this, Cl);
    g(this, nr, void 0);
    g(this, or, void 0);
    g(this, fs, void 0);
    g(this, Ic, void 0);
    g(this, Qi, void 0);
    g(this, Un, void 0);
    g(this, cr, void 0);
    g(this, Jr, void 0);
    g(this, $n, void 0);
    g(this, dr, void 0);
    g(this, lr, void 0);
    g(this, Vs, void 0);
    this.reportRequest = e, m(this, dr, t), m(this, Un, new Po());
    const { isReactNative: r } = navigator;
    m(this, lr, r ? new vg(a(this, dr)) : new yg(a(this, dr))), m(this, Vs, r ? hD : module_exports);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, dr).getValue("logger");
  }
  set producerId(t) {
    m(this, fs, t);
  }
  set audioTrack(t) {
    m(this, Ic, t), a(this, lr) instanceof yg && (a(this, lr).audioTrack = t);
  }
  start() {
    this.logger.debug(`AudioActivityReporter: Starting audio activity reporter: ${a(this, fs)}`), a(this, nr) && a(this, Vs).clearInterval(a(this, nr)), m(this, nr, a(this, Vs).setInterval(() => u(this, null, function* () {
      var i;
      if (!a(this, Ic) || !a(this, fs))
        return;
      const { energy: t } = L(this, Pl, fS).call(this), e = L(i = No, Ac, oh).call(i, t);
      let r = 0.9;
      a(this, $n) !== e && a(this, $n) ? r = 0.9 : e ? r = 0.3 : r = 0.5, m(this, Qi, (a(this, Qi) || 0) * (1 - r) + t * r);
    }), pD)), a(this, or) && a(this, Vs).clearInterval(a(this, or)), m(this, or, a(this, Vs).setInterval(
      L(this, Cl, SS).bind(this),
      gD
    ));
  }
  stop() {
    try {
      this.logger.debug(`AudioActivityReporter: Stopping audio activity reporter: ${a(this, fs)}`), a(this, nr) && (a(this, Vs).clearInterval(a(this, nr)), m(this, nr, void 0)), a(this, or) && (a(this, Vs).clearInterval(a(this, or)), m(this, or, void 0));
    } catch (t) {
    }
    a(this, Un).reset(), a(this, lr) instanceof vg && a(this, lr).stop();
  }
};
var Co = No;
nr = /* @__PURE__ */ new WeakMap(), or = /* @__PURE__ */ new WeakMap(), fs = /* @__PURE__ */ new WeakMap(), Ic = /* @__PURE__ */ new WeakMap(), Qi = /* @__PURE__ */ new WeakMap(), Un = /* @__PURE__ */ new WeakMap(), cr = /* @__PURE__ */ new WeakMap(), Jr = /* @__PURE__ */ new WeakMap(), $n = /* @__PURE__ */ new WeakMap(), dr = /* @__PURE__ */ new WeakMap(), lr = /* @__PURE__ */ new WeakMap(), Vs = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakSet(), fS = function() {
  var o;
  const { samples: t } = a(this, lr), { energy: e, isVoice: r } = a(this, Un).processAudioChunk(t), i = L(o = No, Rl, vS).call(o, e);
  return a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(
    `AudioActivityReporter: producer: ${a(this, fs)}, energy: ${a(this, Qi)},
				slogScale: ${i}, isVoice: ${r}, minEnergy: ${a(this, cr)},
				maxEnergy: ${a(this, Jr)}`
  ), i === -1 / 0 || e < 1e-6 ? { energy: 0, isVoice: false } : ((!a(this, cr) || i < a(this, cr)) && m(this, cr, i), (!a(this, Jr) || i > a(this, Jr)) && m(this, Jr, i), { energy: (i - a(this, cr)) / (a(this, Jr) - a(this, cr)) * 10 || 0, isVoice: r });
}, Ac = /* @__PURE__ */ new WeakSet(), oh = function(t) {
  return t < 5;
}, Cl = /* @__PURE__ */ new WeakSet(), SS = function(t = a(this, Qi)) {
  var r;
  if (!a(this, fs) || !t) {
    a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(`AudioActivityReporter: No producerId or energy to report: ${a(this, fs)}`);
    return;
  }
  const e = {
    producerId: a(this, fs),
    energy: Math.round(t),
    silent: L(r = No, Ac, oh).call(r, t)
  };
  m(this, $n, e.silent), this.reportRequest(e);
}, Rl = /* @__PURE__ */ new WeakSet(), vS = function(t) {
  const e = Math.log10(t);
  return Math.round(e);
}, g(Co, Ac), g(Co, Rl);
var mD = (s = false) => {
  if ("MediaStreamTrackGenerator" in window && "AudioData" in window)
    try {
      const e = new window.MediaStreamTrackGenerator({ kind: "audio" }), r = e.writable.getWriter(), i = 48e3, n = 128, o = 1;
      let c = 0, d = null;
      const l = () => u(void 0, null, function* () {
        try {
          const S = new Float32Array(n * o), T = new window.AudioData({
            format: "f32",
            sampleRate: i,
            numberOfFrames: n,
            numberOfChannels: o,
            timestamp: c,
            data: S
          });
          c += n / i * 1e6, yield r.ready, yield r.write(T);
        } catch (S) {
          d && clearInterval(d), r.releaseLock(), e.writable.abort();
        }
      });
      d = window.setInterval(l, 100);
      const f2 = new MediaStream([e]).getAudioTracks()[0];
      return f2.addEventListener("ended", () => {
        d && clearInterval(d), r.releaseLock(), e.writable.abort();
      }), Object.assign(f2, { fakeTracks: "fakeTracks:fakeAudioTrack" }), f2.enabled = s, f2;
    } catch (e) {
    }
  const t = window.AudioContext || window.webkitAudioContext;
  if (t)
    try {
      const e = new t();
      if (!e || e.state !== "running" || !e.destination)
        return;
      const r = e.createOscillator();
      r.frequency.value = 0, r.type = "sine";
      const i = e.createGain();
      i.gain.value = 0, r.connect(i);
      const n = e.createMediaStreamDestination();
      i.connect(n), r.start();
      const o = n.stream.getAudioTracks()[0];
      return o ? (Object.assign(o, { fakeTracks: "fakeTracks:fakeAudioTrack" }), o.enabled = s, o) : void 0;
    } catch (e) {
      return;
    }
};
var fD = (s = false) => {
  var n, o;
  const t = new MediaStream().getVideoTracks()[0], e = document.createElement("canvas");
  e.height = (n = t == null ? void 0 : t.getSettings().height) != null ? n : 720, e.width = (o = t == null ? void 0 : t.getSettings().width) != null ? o : 1280;
  const r = e.getContext("2d");
  r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height), setInterval(() => {
    r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height);
  }, 1e3);
  const i = e.captureStream().getVideoTracks()[0];
  return Object.assign(i, { fakeTracks: "fakeTracks:fakeVideoTrack" }), i.enabled = s, i;
};
var SD = Object.defineProperty;
var vD = Object.getOwnPropertyDescriptor;
var le = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? vD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && SD(t, e, i), i;
};
var Nt = ["video/VP9", "video/VP8"];
var Mc;
var Dc;
var dt;
var G;
var Fn;
var Ls;
var yt;
var Xi;
var Zi;
var ea;
var Oc;
var ss;
var ur;
var Nc;
var ta;
var sa;
var Tt;
var kt;
var Kr;
var ka;
var wl;
var TS;
var bl;
var ES;
var kl;
var _S;
var Vc;
var ch;
var Il;
var Tu;
var PS;
var Al;
var CS;
var Ml;
var RS;
var Dl;
var wS;
var tt;
var gt;
var ra;
var Ro;
var Ol;
var bS;
var Nl;
var kS;
var Vl;
var IS;
var yS = (Tu = class {
  constructor(s, t, e) {
    g(this, Kr);
    g(this, wl);
    g(this, bl);
    g(this, kl);
    g(this, Vc);
    g(this, Al);
    g(this, Ml);
    g(this, Dl);
    g(this, tt);
    g(this, ra);
    g(this, Ol);
    g(this, Nl);
    g(this, Vl);
    h(this, "context");
    h(this, "authToken");
    h(this, "e2ee");
    g(this, Mc, void 0);
    g(this, Dc, void 0);
    g(this, dt, void 0);
    g(this, G, void 0);
    g(this, Fn, void 0);
    g(this, Ls, void 0);
    g(this, yt, void 0);
    g(this, Xi, void 0);
    g(this, Zi, void 0);
    g(this, ea, void 0);
    g(this, Oc, void 0);
    g(this, ss, null);
    g(this, ur, void 0);
    g(this, Nc, void 0);
    g(this, ta, void 0);
    g(this, sa, void 0);
    g(this, Tt, void 0);
    g(this, kt, void 0);
    var i, n;
    this.context = s;
    const {
      socket: r
    } = e;
    this.mediaJoined = false, m(this, ta, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, sa, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, Ls, t), m(this, dt, r), m(this, Xi, false), m(this, G, new uD(s, r, t)), m(this, yt, a(this, G).events), m(this, ur, /* @__PURE__ */ new Set()), m(this, Tt, /* @__PURE__ */ new Map()), m(this, Zi, false), m(this, ea, new Zu(s.getValue("logger"))), t === we.CF && m(this, kt, new Co(
      this.context,
      a(this, G).socketHandler.audioActivity.bind(a(this, G).socketHandler)
    )), this.e2ee = (n = (i = s.getValue("modules").e2ee) == null ? void 0 : i.enabled) != null ? n : false, this.handleSocketEvents(), this.handleCallstatsEvents(), m(this, Oc, Ih(
      () => u(this, null, function* () {
        if (!a(this, Kr, ka).mediaJoinAttempted)
          return;
        const { roomJoined: o } = yield this.joinRoom(
          a(this, Dc),
          a(this, Mc),
          true,
          true
        );
        o && (this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_RECONNECTED));
      }),
      5e3,
      { leading: true, maxWait: 1e3 }
    ));
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  get mediaJoined() {
    return a(this, Kr, ka).mediaJoined;
  }
  set mediaJoined(s) {
    a(this, Kr, ka).mediaJoined = s;
  }
  reset() {
    a(this, G).closeAllProducers(), a(this, G).closeAllConsumers(), a(this, Tt).clear(), a(this, ur).clear(), m(this, ss, null), a(this, ea).stop(), a(this, G).stopAllTransports(), a(this, G).reset(), m(this, ea, new Zu());
  }
  joinRoom(n, o) {
    return u(this, arguments, function* (s, t, e = false, r = false, i = {}) {
      a(this, Kr, ka).mediaJoinAttempted = true, m(this, Xi, true), e && this.reset();
      try {
        return yield a(this, ea).push(
          () => L(this, wl, TS).call(this, s, t, r, i),
          "joinRoom"
        );
      } catch (c) {
        return this.logger.error("Error in room joining process", { error: c }), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_FAILED), { roomJoined: false };
      }
    });
  }
  /**
   * Initialize connection to the SFU.
   * This can be used to start establishing a connection
   * before the full join process.
   */
  initializeConnection(i, n) {
    return u(this, arguments, function* (s, t, e = false, r = {}) {
      return a(this, ss) ? a(this, ss) : (m(this, ss, (() => u(this, null, function* () {
        try {
          yield L(this, Vc, ch).call(this, s, t, e, r);
        } catch (o) {
          throw m(this, ss, null), o;
        }
      }))()), a(this, ss));
    });
  }
  getConsumers() {
    return a(this, G).consumers;
  }
  leaveRoom() {
    return u(this, null, function* () {
      a(this, G).stopAllTransports(), m(this, Zi, false), a(this, Kr, ka).mediaJoinAttempted = false;
      const s = {
        closeRoom: false
      };
      a(this, dt).sendMessagePromise(
        a(this, yt).leaveRoom,
        vR.toBinary(s)
      ).then((e) => {
        var r;
        (r = nw.fromBinary(e.payload)) != null && r.closed && this.logger.warn("Weird state on peer closed and should not happen");
      }).catch((e) => {
        this.logger.error("error on sending leave room request", { error: e });
      }), this.context.getValue("callstats").callEnded(), this.context.getValue("telemetry").destruct();
    });
  }
  activatePeers(s) {
    return u(this, null, function* () {
      return this.createConsumers(s);
    });
  }
  createConsumers(s) {
    return u(this, null, function* () {
      return s.length === 0 ? Promise.resolve() : a(this, G).createConsumers(s);
    });
  }
  closeConsumers(s) {
    return u(this, null, function* () {
      if (!s.length)
        return;
      const t = s.reduce((e, r) => {
        const i = a(this, G).producerIdToConsumerIdMap.get(
          r.producerId
        );
        return i ? (e.push(i), e) : (this.logger.warn(
          `consumer not found in close consumers: ${r.producerId}`
        ), e);
      }, []);
      yield a(this, G).closeConsumers(t);
    });
  }
  _shareWebcam(s, t) {
    return u(this, null, function* () {
      const e = t === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, r = L(this, tt, gt).call(this, e);
      if (r) {
        const p = yield r;
        if (a(this, G).producers.has(p)) {
          const f2 = a(this, G).producers.get(p);
          if (!f2.closed)
            return yield f2.replaceTrack({ track: s }), yield this.resumeWebcam(e), s;
          yield this.disableWebcam(t);
        }
        return this._shareWebcam(s, t);
      }
      const i = [t].concat(Nt.filter((p) => p !== t)), n = L(this, Vl, IS).call(this, s, i), o = Gn(this.context, "disableSimulcast"), c = a(this, Ls) === we.CF ? X.ENABLE_CF_SIMULCAST : X.ENABLE_HIVE_SIMULCAST;
      !o && this.context.getValue("flagsmith").hasFeature(c) ? (this.logger.info(`Simulcast enabled for SFU: ${a(this, Ls)}`), n.encodings = r0(this.context, s)) : this.logger.info(`Simulcast disabled for webcam producer, SFU: ${a(this, Ls)}`), this.context.getValue("flagsmith").hasFeature(X.TRACK_HINT) && (n.track.contentHint = this.context.getValue("flagsmith").getValue(
        X.TRACK_HINT
      ));
      const d = () => {
        this.logger.info("Disabling video due to the producer closure"), a(this, Tt).delete(e);
      }, l = a(this, G).createProducer(
        n,
        d
      );
      return L(this, ra, Ro).call(this, e, l.then((p) => p.id)), l.then((p) => p.track);
    });
  }
  shareWebcam(s) {
    return u(this, null, function* () {
      var r;
      if (s === void 0)
        return null;
      const t = (r = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : r.toString();
      if (t)
        return this.logger.debug(`Calling _shareWebcam with forced video codec: ${t}`), this._shareWebcam(s, t);
      const e = Nt.filter((i) => {
        var n, o;
        return (
          // NOTE(roerohan): If the codec is supported
          ((o = (n = a(this, Fn).sender) == null ? void 0 : n.video) == null ? void 0 : o.codecs.findIndex(
            (c) => c.mimeType === i
          )) >= 0 && a(this, sa).get(i).size > 0
        );
      });
      return e.length === 0 && e.push(Nt[0]), yield Promise.all(e.map((i) => (this.logger.debug(`Calling _shareWebcam with video codec: ${i}`), this._shareWebcam(s, i)))), s;
    });
  }
  shareScreen(s) {
    return u(this, null, function* () {
      const { video: t, audio: e } = s;
      if (t === void 0)
        return;
      const r = {
        track: t,
        codecOptions: [
          {
            name: "VP8"
          }
        ],
        appData: {
          screenShare: true,
          e2ee: this.e2ee,
          supportsRemoteControl: Te.isElectron()
        },
        stopTracks: false
      }, i = () => {
        this.logger.info("Disabling screenShare due to the producer closure"), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
      }, n = a(this, G).createProducer(
        r,
        i
      );
      L(this, ra, Ro).call(this, pe.SCREENSHARE_VIDEO, n.then((c) => c.id));
      let o;
      if (e) {
        const c = {
          track: e,
          codecOptions: [{ name: "opus" }],
          appData: {
            screenShare: true,
            e2ee: this.e2ee,
            supportsRemoteControl: Te.isElectron()
          },
          stopTracks: false,
          zeroRtpOnPause: a(this, Ls) !== we.CF
        }, d = () => {
        };
        o = a(this, G).createProducer(
          c,
          d
        ), L(this, ra, Ro).call(this, pe.SCREENSHARE_AUDIO, o.then((l) => l.id));
      }
      yield Promise.all([n, o || Promise.resolve()]), this.context.getValue("callstats").screenShareStart();
    });
  }
  shareMic(s) {
    return u(this, null, function* () {
      try {
        if (s === void 0)
          throw new At("track undefined");
        const t = L(this, tt, gt).call(this, pe.MIC);
        if (t) {
          const n = yield t;
          if (a(this, G).producers.has(n)) {
            const o = a(this, G).producers.get(n);
            if (!o.closed) {
              yield o.replaceTrack({ track: s }), yield this.resumeMic(), a(this, kt) && (a(this, kt).audioTrack = s, a(this, kt).producerId = n, a(this, kt).start());
              return;
            }
            yield a(this, G).closeProducer(n, { stopTrack: false });
          }
          yield this.shareMic(s);
          return;
        }
        const e = L(this, Nl, kS).call(this, s), r = () => {
          a(this, Tt).delete(pe.MIC);
        }, i = a(this, G).createProducer(
          e,
          r
        );
        L(this, ra, Ro).call(this, pe.MIC, i.then((n) => n.id)), yield i.then((n) => {
          a(this, kt) && (a(this, kt).audioTrack = n.track, a(this, kt).producerId = n.id, a(this, kt).start());
        });
      } catch (t) {
        throw new R(t);
      }
    });
  }
  pauseMic() {
    return u(this, null, function* () {
      var r;
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("pauseMic::could_not_find_mic_producer");
        return;
      }
      if (t.paused) {
        this.logger.info("pauseMic::mic_producer_already_paused");
        return;
      }
      t.pause(), (r = a(this, kt)) == null || r.stop();
      const e = {
        producerId: t.id,
        pause: true
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  pauseWebcam() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.WEBCAM), t = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP), e = a(this, G).producers.get(s), r = a(this, G).producers.get(t);
      if (!e && !r) {
        this.logger.error("pauseWebcam::could_not_find_webcam_producer");
        return;
      }
      const i = (n) => {
        const o = {
          producerId: n.id,
          pause: true
        };
        a(this, dt).sendMessage(
          a(this, yt).toggleProducer,
          id.toBinary(o)
        );
      };
      e && (e.pause(), i(e)), r && (r.pause(), i(r));
    });
  }
  resumeMic() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("resumeMic::could_not_find_mic_producer");
        return;
      }
      if (!t.pause) {
        this.logger.info("resumeMic::mic_producer_already_resumed");
        return;
      }
      t.resume(), t.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, t);
      const e = {
        producerId: t.id,
        pause: false
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  resumeWebcam() {
    return u(this, arguments, function* (s = pe.WEBCAM) {
      const t = yield L(this, tt, gt).call(this, s), e = a(this, G).producers.get(t);
      if (!e) {
        this.logger.error("resumeWebcam::could_not_find_webcam_producer");
        return;
      }
      if (!e.paused) {
        this.logger.info("resumeWebcam::webcam_producer_already_resumed");
        return;
      }
      e.resume(), e.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, e);
      const r = {
        producerId: e.id,
        pause: false
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(r)
      );
    });
  }
  disableWebcam(s) {
    return u(this, null, function* () {
      const t = s === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, e = yield L(this, tt, gt).call(this, t);
      L(this, Ol, bS).call(this, t), e && (yield a(this, G).closeProducer(e));
    });
  }
  disableMic() {
    return u(this, null, function* () {
      var t;
      const s = yield L(this, tt, gt).call(this, pe.MIC);
      s && (yield a(this, G).closeProducer(s)), (t = a(this, kt)) == null || t.stop(), a(this, Tt).delete(pe.MIC);
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.logger.info("screen_sharing_stopped"), this.context.getValue("callstats").screenShareStop();
      const s = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO), t = yield L(this, tt, gt).call(this, pe.SCREENSHARE_AUDIO);
      s && (yield a(this, G).closeProducer(s)), t && (yield a(this, G).closeProducer(t)), a(this, ur).clear(), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
    });
  }
  muteSelf() {
    return u(this, null, function* () {
      this.pauseMic();
    });
  }
  /* eslint-disable-next-line class-methods-use-this */
  unmuteSelf() {
    return u(this, null, function* () {
    });
  }
  resetVideoProducers(s, t) {
    return u(this, null, function* () {
      if (s) {
        const e = yield L(this, tt, gt).call(this, pe.WEBCAM), r = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP);
        yield a(this, G).closeProducer(e, { stopTrack: false }), yield a(this, G).closeProducer(r, { stopTrack: false }), this.shareWebcam(s);
      }
      if (t) {
        const e = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO);
        yield a(this, G).closeProducer(
          e,
          { stopTrack: false }
        ), this.shareScreen({ video: t });
      }
    });
  }
  changeDisplayName(s, t) {
    return u(this, null, function* () {
      const e = {
        displayName: s,
        participantId: t != null ? t : this.peerId
      };
      if (!(yield a(this, G).socketHandler.changeDisplayName(e)))
        throw new Error("failed to change display name!");
    });
  }
  kick(s) {
    const t = {
      peerIds: [s]
    };
    a(this, G).socketHandler.kickPeer(t);
  }
  kickAll() {
    a(this, G).socketHandler.kickAll();
  }
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
  muteAll(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("audio")))
        throw new Error("failed to mute all participant");
    });
  }
  muteAllVideo() {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("video")))
        throw new Error("failed to mute all video participant");
    });
  }
  disableAudio(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "audio"
      )))
        throw new Error("failed to mute given participant");
    });
  }
  disableVideo(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "video"
      )))
        throw new Error("failed to mute video of given participant");
    });
  }
  pinPeer(s) {
    return u(this, null, function* () {
      const t = {
        participantId: s != null ? s : ""
      };
      try {
        yield a(this, dt).sendMessagePromise(
          a(this, yt).globalPinPeer,
          DR.toBinary(t)
        );
      } catch (e) {
        this.logger.error("Error in pinning peer:", { error: e });
      }
    });
  }
  validateScreenShare(s) {
    return this.peerId === s.peerId && a(this, G).producers.get(s.producerId) && a(this, ur).add(s.consumerPeerId), a(this, ur).size;
  }
  switchConsumersToLayer(s, t) {
    return u(this, null, function* () {
      const e = s.map((r) => this.getConsumers().get(r));
      a(this, G).switchConsumersToLayer(e, t);
    });
  }
  handleSocketEvents() {
    return u(this, null, function* () {
      a(this, dt).on(
        a(this, yt).peerProducerCreateBroadcast,
        ({ payload: s }) => {
          var t, e;
          if (this.mediaJoined)
            try {
              const { participantId: r, producerState: i } = Lw.fromBinary(s);
              if (r === this.peerId)
                return;
              if (i != null && i.mimeType || (i.mimeType = i.kind === xs.AUDIO ? "audio/opus" : "video/VP8"), i.kind === xs.VIDEO && !i.screenShare && // Can receive vp9
              ((e = (t = a(this, Fn).receiver) == null ? void 0 : t.video) == null ? void 0 : e.codecs.findIndex(
                (n) => n.mimeType === Nt[0]
              )) >= 0 && a(this, ta).get(Nt[0]).has(r) && i.mimeType !== Nt[0]) {
                this.logger.warn(`Ignoring producer: ${i.producerId}`);
                return;
              }
              this.logger.info(
                `producer created broadcast: ${r}, producer state: ${i}`
              ), this.context.getValue("peerSessionStore").emit(k.NEW_PRODUCER, {
                peerId: r,
                producer: B(D({}, i), {
                  kind: i.kind === xs.AUDIO ? "audio" : "video",
                  producingPeerId: r
                })
              });
            } catch (r) {
              this.logger.error("error in peer-producer-create-broadcast", {
                error: r
              });
            }
        }
      ), a(this, dt).on(
        a(this, yt).peerProducerToggleBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                initiatorParticipantId: e,
                producerState: { kind: r, pause: i, producerId: n }
              } = Wp.fromBinary(s), o = r === xs.AUDIO ? "audio" : "video";
              if (this.logger.info(
                `producer toggle broadcast: ${t}, producerId: ${n}, kind:${o}, paused:${i} payload: ${JSON.stringify(Wp.fromBinary(s))}`
              ), t === this.peerId && e !== this.peerId && i && this.context.getValue("peerSessionStore").emit(
                o === "audio" ? k.MUTE_SELF : k.MUTE_SELF_VIDEO
              ), t === this.peerId)
                return;
              this.context.getValue("peerSessionStore").emit(k.PRODUCER_TOGGLE, {
                peerId: t,
                producerId: n,
                paused: i,
                kind: o
              }), Array.from(
                this.getConsumers().values()
              ).filter((d) => d.producerId === n).forEach((d) => {
                d.paused !== i && (this.logger.debug(
                  `consumer state mismatched for ${d.id}. updating consumer pause state ${d.paused} to ${i}`
                ), i ? (d.pause(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_PAUSED, {
                  id: d.id
                })) : (d.resume(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_RESUMED, {
                  id: d.id
                })));
              });
            } catch (t) {
              this.logger.error("error in producer toggle broadcast handler", {
                error: t
              });
            }
        }
      ), a(this, dt).on(a(this, yt).peerLeaveBroadcast, ({ payload: s }) => {
        if (this.mediaJoined)
          try {
            const { participantId: t } = Ou.fromBinary(s);
            if (t === this.peerId)
              return;
            this.logger.info(`peer left broadcast:${t}`), a(this, ur).delete(t), a(this, G).consumers.forEach(
              (e) => {
                e.peerId === t && e.close();
              }
            ), this.context.getValue("peerSessionStore").emit(k.PEER_CLOSED, { id: t });
          } catch (t) {
            this.logger.error("error in peer left broadcast", { error: t });
          }
      }), a(this, dt).on(
        a(this, yt).peerProducerCloseBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                producerState: { producerId: e }
              } = $w.fromBinary(s);
              if (t === this.peerId)
                return;
              this.logger.info(`producer closed broadcast:${t}`), this.context.getValue("peerSessionStore").emit(k.PRODUCER_CLOSED, {
                peerId: t,
                producerId: e
              });
              const r = a(this, G).producerIdToConsumerIdMap.get(e);
              if (!r) {
                this.logger.warn(`no consumer found for producer:${e}`);
                return;
              }
              this.logger.info(
                `closing consumer ${r}, producer id: ${e}`
              ), a(this, G).closeConsumer(r).then(() => {
                this.logger.info(`closed consumer: ${r}`), a(this, G).producerIdToConsumerIdMap.delete(e), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, {
                  id: r
                });
              }).catch((i) => {
                this.logger.error("error closing consumer", { error: i });
              });
            } catch (t) {
              this.logger.error("error on producer close broadcast", { error: t });
            }
        }
      ), a(this, dt).on(
        a(this, yt).mediaRoomTerminationBroadcastResponse,
        () => {
          !this.mediaJoined && !a(this, Xi) && !a(this, Zi) || (this.logger.warn(
            "media hub termination broadcast received, rejoining room"
          ), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_DISCONNECTED), a(this, Oc).call(this));
        }
      );
    });
  }
  handleCallstatsEvents() {
    this.context.getValue("callstats").onConsumerScore((s) => {
      s.forEach((t, e) => {
        const r = a(this, G).consumers.get(e);
        r && this.context.getValue("peerSessionStore").emit(k.CONSUMER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          peerId: r.peerId,
          score: t.score,
          scoreStats: t
        });
      });
    }), this.context.getValue("callstats").onProducerScore((s) => {
      s.forEach((t, e) => {
        const r = Array.from(a(this, G).producers.values()).find(
          (i) => i.id === e
        );
        r && this.context.getValue("peerSessionStore").emit(k.PRODUCER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          appData: r.appData,
          score: t.score,
          scoreStats: t
        });
      });
    });
  }
  handlePeerCapabilities(s, t) {
    var e, r, i, n;
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (
        // if the codec is present in the peer capabilities
        ((r = (e = t == null ? void 0 : t.receiver) == null ? void 0 : e.video) == null ? void 0 : r.codecs.findIndex(
          (d) => d.mimeType === c
        )) >= 0 || o === Nt.length - 1
      ) {
        a(this, sa).get(c).add(s);
        break;
      }
    }
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (
        // if the codec is present in the peer capabilities
        ((n = (i = t == null ? void 0 : t.sender) == null ? void 0 : i.video) == null ? void 0 : n.codecs.findIndex(
          (d) => d.mimeType === c
        )) >= 0 || o === Nt.length - 1
      ) {
        a(this, ta).get(c).add(s);
        break;
      }
    }
  }
  handlePeerLeaving(s) {
    this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || (a(this, ta).forEach((t) => t.delete(s)), a(this, sa).forEach((t, e) => {
      t.delete(s), !(t.size !== 0 || e === Nt[0]) && this.disableWebcam(e);
    }));
  }
}, Mc = /* @__PURE__ */ new WeakMap(), Dc = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakMap(), Ls = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), Xi = /* @__PURE__ */ new WeakMap(), Zi = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap(), Oc = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), ur = /* @__PURE__ */ new WeakMap(), Nc = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), Tt = /* @__PURE__ */ new WeakMap(), kt = /* @__PURE__ */ new WeakMap(), Kr = /* @__PURE__ */ new WeakSet(), ka = function() {
  return this.context.getValue("connectionHandler");
}, wl = /* @__PURE__ */ new WeakSet(), TS = function(s, t, e, r) {
  return u(this, null, function* () {
    m(this, Dc, s);
    try {
      return a(this, ss) ? yield a(this, ss) : yield L(this, Vc, ch).call(this, s, t, e, r), L(this, kl, _S).call(this, t), { roomJoined: yield L(this, bl, ES).call(this) };
    } catch (i) {
      return this.logger.error("Failed to complete room join", { error: i }), { roomJoined: false };
    } finally {
      m(this, ss, null);
    }
  });
}, bl = /* @__PURE__ */ new WeakSet(), ES = function() {
  return u(this, null, function* () {
    try {
      this.mediaJoined = true;
      const { roomState: s } = yield a(this, G).socketHandler.notifySelfJoinComplete();
      return m(this, Mc, s.roomUuid), m(this, Zi, true), m(this, Xi, false), true;
    } catch (s) {
      return this.logger.error("Error completing room join", { error: s }), this.mediaJoined = false, false;
    }
  });
}, kl = /* @__PURE__ */ new WeakSet(), _S = function(s) {
  navigator.product !== "ReactNative" && setTimeout(() => {
    try {
      const e = {
        userId: this.context.getValue("userId"),
        peerId: this.peerId,
        roomUUID: s,
        roomViewType: "groupCall",
        deviceInfo: B(D({}, Te.getDeviceInfo()), {
          userAgent: navigator.userAgent,
          memory: navigator.deviceMemory,
          cpus: navigator.hardwareConcurrency
        }),
        sdkName: this.context.getValue("sdkName"),
        sdkVersion: this.context.getValue("sdkVersion"),
        metaData: {},
        permissions: {}
      };
      this.context.getValue("callstats").roomJoined(e);
    } catch (t) {
      this.logger.error("Error reporting room joined analytics", { error: t });
    }
  }, 0);
}, Vc = /* @__PURE__ */ new WeakSet(), ch = function(s, t, e, r) {
  return u(this, null, function* () {
    var i, n;
    try {
      (n = a(this, Nc)) != null || m(this, Nc, L(i = yS, Il, PS).call(i));
      const o = L(this, Al, CS).call(this);
      yield L(this, Ml, RS).call(this, s, t, e, o), yield a(this, G).setupTransports({ send: true, recv: true }), yield L(this, Dl, wS).call(this, r);
    } catch (o) {
      throw this.logger.error("Failed to initialize connection", { error: o }), o;
    }
  });
}, Il = /* @__PURE__ */ new WeakSet(), PS = function() {
  const { ipInfo: s } = lt();
  if (!(s != null && s.loc))
    return;
  const [t, e] = s.loc.split(",").map(parseFloat);
  return { latitude: t, longitude: e };
}, Al = /* @__PURE__ */ new WeakSet(), CS = function() {
  var e;
  const s = (e = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : e.toString(), t = Z0(s);
  return m(this, Fn, t), t;
}, Ml = /* @__PURE__ */ new WeakSet(), RS = function(s, t, e, r) {
  return u(this, null, function* () {
    yield Yf(
      (i, n) => u(this, null, function* () {
        if (!a(this, dt).isConnected) {
          n(new Error("Socket is not connected"));
          return;
        }
        i > 0 && this.logger.warn("Retry: send joinRoom message", {
          debuggingHint: `Retry attempt ${i}`
        });
        try {
          yield a(this, G).socketHandler.joinRoom(
            t,
            s,
            r,
            e,
            a(this, Nc)
          );
        } catch (o) {
          throw this.logger.error("Failed to send joinRoom message after retries", { error: o }), o;
        }
      }),
      {
        delayTime: 1e3,
        strategy: "exponential",
        maxRetryCount: this.context.getValue("flagsmith").hasFeature(X.ENABLE_HIVE_INFINITE_RETRIES) ? 1 / 0 : 3
      }
    );
  });
}, Dl = /* @__PURE__ */ new WeakSet(), wS = function(s) {
  return u(this, null, function* () {
    if (!(a(this, Ls) === we.HIVE || !this.context.getValue("flagsmith").hasFeature(
      X.PRECREATE_PRODUCERS
    ) || !s))
      try {
        const e = [];
        if (s.canProduceVideo === j.Allowed && e.push(this.shareWebcam(fD(false))), s.canProduceAudio === j.Allowed) {
          const r = mD(false);
          r && e.push(this.shareMic(r));
        }
        e.length > 0 && (yield Promise.all(e));
      } catch (e) {
        this.logger.warn("Failed to precreate producers", { error: e });
      }
  });
}, tt = /* @__PURE__ */ new WeakSet(), gt = function(s) {
  return a(this, Tt).get(s);
}, ra = /* @__PURE__ */ new WeakSet(), Ro = function(s, t) {
  return a(this, Tt).set(s, t);
}, Ol = /* @__PURE__ */ new WeakSet(), bS = function(s) {
  return a(this, Tt).delete(s);
}, Nl = /* @__PURE__ */ new WeakSet(), kS = function(s) {
  return {
    track: s,
    encodings: [
      {
        priority: "high"
      }
    ],
    codecOptions: [
      {
        name: "opus"
      }
    ],
    appData: {
      e2ee: this.e2ee
    },
    stopTracks: false,
    zeroRtpOnPause: a(this, Ls) !== we.CF
  };
}, Vl = /* @__PURE__ */ new WeakSet(), IS = function(s, t) {
  return {
    track: s,
    codecOptions: t ? t.map((e) => ({
      name: e.split("/")[1]
    })) : [{ name: "VP8" }],
    appData: {
      screenShare: false,
      e2ee: this.e2ee
    },
    stopTracks: false
  };
}, g(Tu, Il), Tu);
var oe = yS;
le([
  E.trace("MediaNodeClient.reset", { country: E.location.country })
], oe.prototype, "reset", 1);
le([
  E.trace("MediaNodeClient.joinRoom")
], oe.prototype, "joinRoom", 1);
le([
  E.trace("MediaNodeClient.leaveRoom")
], oe.prototype, "leaveRoom", 1);
le([
  E.trace("MediaNodeClient.activatePeers")
], oe.prototype, "activatePeers", 1);
le([
  E.trace("MediaNodeClient.createConsumers")
], oe.prototype, "createConsumers", 1);
le([
  E.trace("MediaNodeClient.closeConsumers")
], oe.prototype, "closeConsumers", 1);
le([
  E.trace("MediaNodeClient._shareWebcam")
], oe.prototype, "_shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareWebcam")
], oe.prototype, "shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareScreen")
], oe.prototype, "shareScreen", 1);
le([
  E.trace("MediaNodeClient.shareMic")
], oe.prototype, "shareMic", 1);
le([
  E.trace("MediaNodeClient.pauseMic")
], oe.prototype, "pauseMic", 1);
le([
  E.trace("MediaNodeClient.pauseWebcam")
], oe.prototype, "pauseWebcam", 1);
le([
  E.trace("MediaNodeClient.resumeMic")
], oe.prototype, "resumeMic", 1);
le([
  E.trace("MediaNodeClient.resumeWebcam")
], oe.prototype, "resumeWebcam", 1);
le([
  E.trace("MediaNodeClient.disableWebcam")
], oe.prototype, "disableWebcam", 1);
le([
  E.trace("HiveClient.disableMic")
], oe.prototype, "disableMic", 1);
le([
  E.trace("HiveClient.disableScreenShare")
], oe.prototype, "disableScreenShare", 1);
le([
  E.trace("MediaNodeClient.muteSelf")
], oe.prototype, "muteSelf", 1);
le([
  E.trace("MediaNodeClient.resetVideoProducers")
], oe.prototype, "resetVideoProducers", 1);
le([
  E.trace("MediaNodeClient.changeDisplayName")
], oe.prototype, "changeDisplayName", 1);
le([
  E.trace("MediaNodeClient.kickPeer")
], oe.prototype, "kick", 1);
le([
  E.trace("MediaNodeClient.kickAllPeers")
], oe.prototype, "kickAll", 1);
le([
  E.trace("MediaNodeClient.muteAll")
], oe.prototype, "muteAll", 1);
le([
  E.trace("MediaNodeClient.muteAllVideo")
], oe.prototype, "muteAllVideo", 1);
le([
  E.trace("MediaNodeClient.disableAudio")
], oe.prototype, "disableAudio", 1);
le([
  E.trace("MediaNodeClient.disableVideo")
], oe.prototype, "disableVideo", 1);
le([
  E.trace("MediaNodeClient.pinPeer")
], oe.prototype, "pinPeer", 1);
le([
  E.trace("MediaNodeClient.validateScreenShare")
], oe.prototype, "validateScreenShare", 1);
function AS(s, t, e) {
  const r = s.getValue("roomNodeClient");
  if (r) {
    if (r)
      return r;
    throw new Error("Room node client already set up.");
  }
  const i = new oe(s, t, e);
  return s.setValue("roomNodeClient", i), i;
}
function MS(s) {
  const t = s.getValue("roomNodeClient");
  try {
    t == null || t.leaveRoom();
  } catch (e) {
    s.getValue("logger").error("roomNodeClient::cleanupRoomNodeClient");
  }
  s.setValue("roomNodeClient", void 0);
}
var yD = Object.defineProperty;
var TD = Object.getOwnPropertyDescriptor;
var _a = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yD(t, e, i), i;
};
var ia;
var Ss;
var te;
var Et;
var Lt;
var qg;
var DS = (qg = class {
  /**
   * Use await SelfController.init(roomNodeClient) instead
   */
  constructor(s, t, e, r) {
    g(this, Et);
    h(this, "self");
    h(this, "authToken");
    g(this, ia, void 0);
    h(this, "viewType");
    g(this, Ss, void 0);
    g(this, te, void 0);
    const { socket: i } = e, n = s.getValue("authToken");
    this.self = t, m(this, te, s), this.viewType = r, this.authToken = n, m(this, ia, i), m(this, Ss, e), t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  get peerId() {
    return a(this, te).getValue("peerId");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, te).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, te).getValue("logger");
  }
  get mediaJoined() {
    return a(this, te).getValue("connectionHandler").mediaJoined;
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = lt(), o = s.getValue("peerId"), c = !!s.getValue("cachedUserDetails"), d = yield Xe.__init__(
        s,
        e,
        r,
        i,
        i.name,
        c
      );
      s.setValue("self", d);
      const l = s.getValue("logger");
      if (navigator.product !== "ReactNative") {
        const p = !s.getValue("flagsmith").hasFeature(X.PRECALL_BANDWIDTH_TEST);
        setTimeout(() => u(this, null, function* () {
          const f2 = yield d.getAllDevices();
          l.info("populated_full_device_list", {
            devices: JSON.stringify(f2)
          }), s.getValue("callstats").devices("AUDIO", f2 == null ? void 0 : f2.filter((S) => S.kind === "audioinput")), s.getValue("callstats").devices("VIDEO", f2 == null ? void 0 : f2.filter((S) => S.kind === "videoinput")), s.getValue("callstats").devices("SPEAKER", f2 == null ? void 0 : f2.filter((S) => S.kind === "audiooutput")), l.info("Callstats:: initializing");
          try {
            yield s.getValue("callstats").initialize({
              peerId: o,
              engineName: Te.getDeviceInfo().engineName,
              env: s.getValue("env"),
              iceServers: yield n.getICEServers(),
              apiBase: s.getValue("apiBase"),
              flags: s.getValue("flagsmith").getAllFlags(),
              logger: l,
              apiHostnames: cf(s),
              skipConnectivityChecks: p
            }), l.info("Callstats:: initialized");
          } catch (S) {
            l.error("Callstats:: initialization failed", { error: S });
          }
        }), 0);
      } else
        l.info("Callstats:: Skipped initialization due to navigator product being ReactNative.");
      return new DS(s, d, t, i.viewType);
    });
  }
  shareMediaTracks() {
    return u(this, null, function* () {
      var c;
      const {
        audioTrack: s,
        videoTrack: t,
        permissions: e,
        audioEnabled: r,
        videoEnabled: i,
        screenShareEnabled: n,
        screenShareTracks: o
      } = this.self;
      if (e.canProduceAudio === j.Allowed && r)
        try {
          yield a(this, Et, Lt).shareMic(s), this.self.audioEnabled || a(this, Et, Lt).pauseMic();
        } catch (d) {
          this.self.disableAudio();
        }
      if (e.canProduceVideo === j.Allowed && i)
        try {
          const d = yield a(this, Et, Lt).shareWebcam(t);
          d && d.id !== t.id && a(this, te).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, Et, Lt).shareWebcam(d)), this.self.videoEnabled || a(this, Et, Lt).pauseWebcam();
        } catch (d) {
          this.self.disableVideo();
        }
      if (e.canProduceScreenshare === j.Allowed && n)
        try {
          yield (c = a(this, Et, Lt)) == null ? void 0 : c.shareScreen({
            video: o.video,
            audio: o.audio
          });
        } catch (d) {
          this.self.disableScreenShare();
        }
    });
  }
  kickHandler(s) {
    return u(this, null, function* () {
      let t = "kicked";
      (s == null ? void 0 : s.kickType) === "kickAll" && (t = "ended"), this.leaveRoom(t);
    });
  }
  /**
   * Waitlist handlers
   */
  waitlistedHandler() {
    this.logger.info("SelController.waitlisted"), this.self.waitlistStatus = "waiting", this.self.roomState = "waitlisted", this.self.emit("waitlisted");
  }
  waitlistAcceptHandler() {
    if (this.logger.info("SelController.waitlistAccepted"), this.self.waitlistStatus === "accepted") {
      this.logger.warn("SelfController.WAITLIST_ACCEPTED.UserAlreadyAccepted");
      return;
    }
    this.self.waitlistStatus = "accepted", this.joinRoom();
  }
  waitlistRejectedHandler() {
    if (this.logger.info("SelfController.waitlistRejected"), this.self.waitlistStatus === "rejected") {
      this.logger.warn("SelfController.WAITLIST_REJECTED.UserAlreadyRejected");
      return;
    }
    this.self.waitlistStatus = "rejected", this.leaveRoom("rejected");
  }
  resetSelf(s) {
    return u(this, null, function* () {
      a(this, te).getValue("callstats").callEnded(), a(this, Et, Lt).reset(), s && (yield this.joinRoom(s));
    });
  }
  setupEvents() {
    a(this, te).getValue("peerSessionStore").on(k.RESET_PRODUCER_STATE, () => u(this, null, function* () {
      this.mediaJoined && this.shareMediaTracks();
    })), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_RECONNECTED, () => {
      this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: true });
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_DISCONNECTED, () => {
      this.self.roomState !== "disconnected" && (this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" }));
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_RECONNECTED, ({ wasJoinAttempted: s }) => {
      s === false && (this.self.roomState = "init"), this.resetSelf(s);
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, ({ joinAttempted: s }) => {
      if (this.self.roomState === "disconnected")
        return;
      let { peerId: t } = this;
      s && a(this, te).getValue("flagsmith").hasFeature(X.REFRESH_ID_ON_DISCONNECTION) && (t = v4_default()), a(this, ia).updateURL(t), a(this, te).getValue("telemetry").resetPeerId(t), lt().setHeader("dyte-tracing-id", t), mr.remapContext(t, a(this, te)), this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, Ss).on(x.waitingRoomRequestAccepted, () => {
      this.waitlistAcceptHandler();
    }), a(this, Ss).on(fd.updateUserPreset, (s) => {
      s.updatePeersPresets.forEach((t) => {
        t.userIds === this.self.userId && a(this, te).getValue("peerSessionStore").emit(k.UPDATE_PERMISSIONS, t.patch);
      });
    }), a(this, Ss).on(x.waitingRoomRequestDenied, () => {
      this.waitlistRejectedHandler();
    }), a(this, Ss).on(x.kick, () => {
      this.kickHandler({ kickType: "kick" });
    }), a(this, Ss).on(x.kickAll, () => {
      this.kickHandler({ kickType: "kickAll" });
    }), a(this, te).getValue("peerSessionStore").onAsync(k.JOIN_MEDIA_ROOM, this.joinMediaRoom.bind(this)), a(this, te).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        scoreStats: r
      }) => {
        var n;
        const i = (n = e == null ? void 0 : e.screenShare) != null ? n : false;
        this.self.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: i,
          score: s,
          participantId: this.self.id,
          scoreStats: r
        });
      }
    ), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF, () => u(this, null, function* () {
      this.self.audioEnabled && (yield this.self.disableAudio(), a(this, te).getValue("callstats").audioOff());
    })), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF_VIDEO, () => u(this, null, function* () {
      this.self.videoEnabled && (yield this.self.disableVideo(), a(this, te).getValue("callstats").videoOff());
    })), a(this, te).getValue("peerSessionStore").onAsync(
      k.LEAVE_MEDIA_ROOM,
      this.leaveMediaRoom.bind(this)
    ), a(this, te).getValue("peerSessionStore").on(
      k.PIP_HANGUP,
      this.leaveRoom.bind(this)
    );
  }
  joinRoom(s = false) {
    return u(this, null, function* () {
      try {
        const { peer: t } = yield a(this, Ss).joinRoom(
          this.self
        );
        a(this, Ss).socket.flush();
        const e = Nh(t.stageType);
        if (a(this, te).setValue("stageStatus", e, false), t.waitlisted) {
          this.waitlistedHandler();
          return;
        }
        yield this.joinMediaRoom(s), a(this, te).notify("stageStatus");
      } catch (t) {
        throw this.logger.error("Error in joinRoom", { error: t }), t;
      }
    });
  }
  leaveRoom(s = "left") {
    return u(this, null, function* () {
      var t, e;
      if (this.logger.info(`Leaving room with state: ${s}`), (t = a(this, te).getValue("roomSocketHandler")) == null || t.cleanup(), s === "rejected") {
        this.self.roomState = s, this.self.emit("roomLeft", { state: s });
        return;
      }
      this.self.setIsPinned(false), a(this, te).setValue("stageStatus", "OFF_STAGE", false), yield this.leaveMediaRoom(s), a(this, te).notify("stageStatus");
      try {
        (e = a(this, ia)) == null || e.disconnect();
      } catch (r) {
        this.logger.error("SelfController::leaveRoom::socketDisconnect");
      }
      MS(a(this, te)), this.self.roomState = s, this.self.emit("roomLeft", { state: s }), this.logger.info(`roomLeft event emitted with state: ${s}`);
    });
  }
  joinMediaRoom(s = false) {
    return u(this, null, function* () {
      var c, d;
      const {
        peerId: t,
        viewType: e,
        meetingId: r,
        stageStatus: i,
        roomNodeOptions: n
      } = a(this, te).getAllValues(), { sfu: o } = n;
      try {
        if (e === Mt.Livestream) {
          if (i !== "ON_STAGE") {
            this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
            return;
          }
          AS(a(this, te), o, {
            socket: a(this, ia),
            peerId: t
          });
        }
        const { canProduceAudio: l, canProduceVideo: p, canProduceScreenshare: f2 } = this.self.permissions, { roomJoined: S } = (d = yield (c = a(this, Et, Lt)) == null ? void 0 : c.joinRoom(
          this.self.name,
          r,
          s,
          s,
          {
            canProduceAudio: l,
            canProduceVideo: p,
            canProduceScreenshare: f2
          }
        )) != null ? d : {};
        if (!S)
          return;
        i === "ON_STAGE" && (yield this.shareMediaTracks()), this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
      } catch (l) {
        throw this.logger.error("Error:SelfController.mediaRoomJoin", { error: l }), new R("Error: could not join media room", "0002");
      }
    });
  }
  leaveMediaRoom(s) {
    return u(this, null, function* () {
      const t = a(this, te).getValue("viewType");
      s !== "connected-meeting" && (yield this.cleanupSelf()), !(s === "stageLeft" && t === Mt.Webinar) && a(this, Et, Lt) && (a(this, Et, Lt).mediaJoined && s !== "disconnected" && (yield a(this, Et, Lt).leaveRoom()), !(s === "stageLeft" && t === Mt.Livestream) && (a(this, Et, Lt).mediaJoined = false));
    });
  }
  cleanupSelf() {
    return u(this, null, function* () {
      yield this.self.disableAudio(), yield this.self.disableVideo(), yield this.self.disableScreenShare(), this.self.cleanUpTracks(), this.self.destructMediaHandler(), navigator.isReactNative || this.self.removeDocumentEventListeners();
    });
  }
}, ia = /* @__PURE__ */ new WeakMap(), Ss = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap(), Et = /* @__PURE__ */ new WeakSet(), Lt = function() {
  return a(this, te).getValue("roomNodeClient");
}, qg);
var ai = DS;
_a([
  E.trace("SelfController.resetSelf")
], ai.prototype, "resetSelf", 1);
_a([
  E.trace("SelfController.setupEvents")
], ai.prototype, "setupEvents", 1);
_a([
  E.trace("SelfController.joinRoom")
], ai.prototype, "joinRoom", 1);
_a([
  E.trace("SelfController.leaveRoom")
], ai.prototype, "leaveRoom", 1);
_a([
  E.trace("SelfController.joinMediaRoom")
], ai.prototype, "joinMediaRoom", 1);
_a([
  E.trace("SelfController.leaveMediaRoom")
], ai.prototype, "leaveMediaRoom", 1);
_a([
  E.trace("SelfController.init")
], ai, "init", 1);
var Lc;
var ED = class {
  constructor(t) {
    g(this, Lc, void 0);
    m(this, Lc, t);
  }
  on(t, e) {
    let r;
    t === x.roomPeerCount ? r = zp.fromBinary.bind(zp) : r = ng.fromBinary.bind(ng), a(this, Lc).on(t, ({ payload: i }) => {
      if (t === x.roomPeerCount && !i)
        return;
      const n = r(i);
      e(n);
    });
  }
};
Lc = /* @__PURE__ */ new WeakMap();
var xc;
var Uc;
var _D = class {
  constructor(t, e) {
    g(this, xc, void 0);
    g(this, Uc, void 0);
    m(this, xc, e), m(this, Uc, t);
  }
  /**
   * @private access
   * Not for external use
   */
  get logger() {
    return a(this, Uc).getValue("logger");
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.transcript: {
        r = lu.fromBinary.bind(
          lu
        ), i = lu.create();
        break;
      }
      default: {
        this.logger.debug("AISocketHandler switch case hit default, event not accounted for.");
        break;
      }
    }
    a(this, xc).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
};
xc = /* @__PURE__ */ new WeakMap(), Uc = /* @__PURE__ */ new WeakMap();
var PD = Object.defineProperty;
var CD = Object.getOwnPropertyDescriptor;
var Wh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? CD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && PD(t, e, i), i;
};
var hr;
var Hn;
var Ql = class {
  constructor(t, e) {
    g(this, hr, void 0);
    g(this, Hn, void 0);
    m(this, hr, e), m(this, Hn, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Hn).getValue("logger");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Hn).getValue("telemetry");
  }
  getPolls() {
    return a(this, hr).sendMessagePromise(qs.getPolls);
  }
  createPoll(t, e, r = false, i = false) {
    const n = {
      anonymous: r,
      hideVotes: i,
      question: t,
      options: e
    };
    return a(this, hr).sendMessage(
      qs.createPoll,
      bA.toBinary(n)
    );
  }
  votePoll(t, e) {
    const r = {
      index: e,
      pollId: t
    };
    return a(this, hr).sendMessage(
      qs.votePoll,
      IA.toBinary(r)
    );
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case qs.updatePoll:
      case qs.createPoll:
      case qs.votePoll: {
        r = fu.fromBinary.bind(fu), i = fu.create();
        break;
      }
    }
    a(this, hr).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("pollSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  removeListeners(t) {
    a(this, hr).removeListeners(t);
  }
};
hr = /* @__PURE__ */ new WeakMap(), Hn = /* @__PURE__ */ new WeakMap();
Wh([
  E.trace("PollSocketHandler.getPolls")
], Ql.prototype, "getPolls", 1);
Wh([
  E.trace("PollSocketHandler.createPoll")
], Ql.prototype, "createPoll", 1);
Wh([
  E.trace("PollSocketHandler.votePoll")
], Ql.prototype, "votePoll", 1);
var RD = Object.defineProperty;
var wD = Object.getOwnPropertyDescriptor;
var bD = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? wD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && RD(t, e, i), i;
};
var Ht;
var OS = class {
  constructor(t, e) {
    h(this, "socket");
    g(this, Ht, void 0);
    m(this, Ht, t), this.socket = e, this.handleSocketEvents(), a(this, Ht).setValue("roomSocketHandler", this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ht).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ht).getValue("logger");
  }
  cleanup() {
    var t;
    try {
      (t = this.socket) == null || t.disconnect();
    } catch (e) {
      this.logger.error("roomSocketHandler::cleanup");
    }
  }
  joinRoom(t) {
    return u(this, null, function* () {
      var i;
      this.socket.joinAttempted = true;
      const e = {
        capabilities: [],
        peer: {
          displayName: (i = t.name) != null ? i : "Participant",
          customParticipantId: t.customParticipantId,
          peerId: t.id,
          userId: t.userId,
          displayPictureUrl: t.picture,
          waitlisted: false
        },
        roomUuid: ""
      }, r = this.socket.sendMessagePromise(
        x.joinRoom,
        gb.toBinary(e)
      );
      try {
        const { peer: n } = Ca.fromBinary((yield r).payload);
        a(this, Ht).getValue("connectionHandler").socketJoined = true, a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_ROOM_JOINED, { peer: n });
        const o = this.getRoomState(), c = this.getRoomPeersNonPaginated(), [{ room: d }, { peers: l }] = yield Promise.all([o, c]);
        return a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_STATE, d), a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_PEERS, l), { peer: n };
      } catch (n) {
        throw this.logger.error("RoomSocketHandler.joinRoom.failed", {
          error: n
        }), new R(
          "Error: RoomSocketHandler.joinRoom failed.",
          "0002",
          this.logger,
          n
        );
      }
    });
  }
  getAllAddedParticipants() {
    return u(this, null, function* () {
      try {
        return Xb.fromBinary(
          (yield this.socket.sendMessagePromise(x.getAllAddedParticipants)).payload
        ).participants.map(
          (i) => {
            var n = i, { id: e } = n, r = ho(n, ["id"]);
            return B(D({}, r), { userId: e });
          }
        );
      } catch (t) {
        return [];
      }
    });
  }
  getRoomPeers(t, e, r) {
    return u(this, null, function* () {
      let i;
      try {
        const n = {
          // F
          seachQuery: t,
          limit: e,
          offset: r
        }, o = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo,
          ib.toBinary(n)
        );
        i = uu.fromBinary(o.payload);
      } catch (n) {
        this.logger.error("getRoomPeers::binary_decode_error", { error: n });
      }
      return i;
    });
  }
  getRoomPeersNonPaginated() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  /**
   *  TODO:(ishita1805): uncomment this code when
   * socket service sends entire peer objects for roomEvents.getStagePeers
   */
  getStagePeers() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      let e;
      try {
        const r = yield this.socket.sendMessagePromise(
          x.getPeerInfo,
          Sf.toBinary({ peerId: t })
        );
        e = Ca.fromBinary(r.payload);
      } catch (r) {
        this.logger.error("getPeerInfo::binary_decode_error", { error: r });
      }
      return e;
    });
  }
  getRoomState() {
    return u(this, null, function* () {
      let t = Yp.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomInfo);
        t = Yp.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getRoomStageState() {
    return u(this, null, function* () {
      let t = eg.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomStageState);
        t = eg.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomStageState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  broadcastMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(e)),
        timestamp: Date.now(),
        ids: []
        // broadcast to all in all cases, this field has no value
      };
      return this.socket.sendMessagePromise(
        x.broadcastMessage,
        fo.toBinary(r)
      );
    });
  }
  broadcastToMeetings(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        // Broadcast to given meetings
        broadcastType: 1
        // meetings
      };
      return this.socket.sendMessagePromise(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  broadcastToPeers(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        // Broadcast to peers
        broadcastType: 0
        // peers
      };
      return this.socket.sendMessage(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  leaveRoom() {
    return u(this, null, function* () {
      this.socket.joinAttempted = false, this.socket.sendMessagePromise(
        x.leaveRoom,
        fb.toBinary({})
      );
    });
  }
  kick(t) {
    return u(this, null, function* () {
      const e = {
        peerIds: [t]
      };
      this.socket.sendMessage(
        x.kick,
        yf.toBinary(e)
      );
    });
  }
  kickAll(t = false) {
    return u(this, null, function* () {
      const e = {
        propagateKickAcrossRooms: t
      };
      this.socket.sendMessage(
        x.kickAll,
        gf.toBinary(e)
      );
    });
  }
  getWaitingRoomRequests() {
    this.socket.sendMessage(x.getWaitingRoomRequests);
  }
  acceptWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.acceptWaitingRoomRequests,
      ik.toBinary(e)
    );
  }
  rejectWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.denyWaitingRoomRequests,
      nk.toBinary(e)
    );
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = {
        updatePeersPresets: []
      };
      return t.forEach((i) => {
        r.updatePeersPresets.push({
          userIds: i,
          patch: e
        });
      }), this.socket.sendMessagePromise(
        fd.updateUserPreset,
        Vk.toBinary(r)
      );
    });
  }
  handleSocketEvents() {
    this.socket.on(x.broadcastMessage, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode broadcast message:", e);
      }
    }), this.socket.on(x.broadcastToEntity, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode peer broadcast message:", e);
      }
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.joinRoom:
      case x.leaveRoom:
      case x.kick:
      case x.kickAll: {
        r = Ca.fromBinary.bind(Ca), i = Ca.create();
        break;
      }
      case x.getWaitingRoomRequests: {
        r = (n, o) => n ? Zp.fromBinary(n, o) : { requests: [] }, i = Zp.create();
        break;
      }
      case x.recordingPaused:
      case x.recordingStarted:
      case x.recordingStopped: {
        r = dg.fromBinary.bind(dg);
        break;
      }
      case fd.updateUserPreset: {
        r = tg.fromBinary.bind(tg);
        break;
      }
      case Ts.peerJoinedBroadcast:
      case is.peerJoinedBroadcast: {
        r = jp.fromBinary.bind(jp);
        break;
      }
      case Ts.selfJoinComplete:
      case is.selfJoinComplete: {
        r = Du.fromBinary.bind(Du);
        break;
      }
      case Ts.globalPeerPinBroadcast:
      case is.globalPeerPinBroadcast: {
        r = Jp.fromBinary.bind(Jp);
        break;
      }
      case Ts.selectedPeer:
      case is.selectedPeer: {
        r = Mu.fromBinary.bind(Mu);
        break;
      }
      case Ts.selectedPeerDiff:
      case is.selectedPeerDiff: {
        r = qp.fromBinary.bind(qp);
        break;
      }
      case Ts.leaveRoom:
      case is.leaveRoom: {
        r = Ou.fromBinary.bind(Ou);
        break;
      }
    }
    this.socket.on(t, ({ payload: n }) => {
      let o = i;
      if (!r)
        return e(void 0);
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("roomSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  getUserPermissions(t) {
    return u(this, null, function* () {
      const e = {
        userIds: [t]
      };
      try {
        const r = yield this.socket.sendMessagePromise(
          fd.getUserPresets,
          kk.toBinary(e)
        ), i = Dk.fromBinary(r.payload).peerPresets[0], n = new TextDecoder().decode(i.preset), o = JSON.parse(n).permissions;
        return { chat: o.chat, polls: o.polls, plugins: o.plugins };
      } catch (r) {
        throw this.logger.error("Error in getting user preset", { error: r }), r;
      }
    });
  }
};
Ht = /* @__PURE__ */ new WeakMap();
bD([
  E.trace("RoomSocketHandler.joinRoom")
], OS.prototype, "joinRoom", 1);
var It;
var kD = class {
  constructor(t) {
    g(this, It, void 0);
    m(this, It, t);
  }
  getStageRequests() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, It).sendMessagePromise(
        x.getStageRequests
      );
      return t ? mu.fromBinary(t) : { stageRequests: [] };
    });
  }
  requestAccess() {
    a(this, It).sendMessage(x.requestStageAccess);
  }
  cancelRequestAccess() {
    a(this, It).sendMessage(x.cancelStageRequest);
  }
  grantAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.grantStageAccess,
        SA.toBinary(e)
      );
    });
  }
  denyAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.denyStageAccess,
        yA.toBinary(e)
      );
    });
  }
  joinStage() {
    return a(this, It).sendMessagePromise(
      x.joinStage,
      void 0,
      void 0,
      x.peerStageStatusUpdate
    );
  }
  leaveStage(t) {
    const e = {
      userIds: [t]
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e),
      void 0,
      x.peerStageStatusUpdate
    );
  }
  kick(t) {
    const e = {
      userIds: t
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case x.grantStageAccess:
      case x.denyStageAccess: {
        r = void 0;
        break;
      }
      case x.getStagePeers: {
        r = og.fromBinary.bind(
          og
        );
        break;
      }
      case x.getStageRequests:
      case x.requestStageAccess:
      case x.cancelStageRequest: {
        r = mu.fromBinary.bind(
          mu
        );
        break;
      }
      case x.peerStageStatusUpdate: {
        r = Kp.fromBinary.bind(Kp);
        break;
      }
    }
    a(this, It).on(t, ({ payload: i, id: n }) => {
      if (!i || !r)
        return e(void 0, n);
      const o = r(i);
      return e(o, n);
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      const e = yield a(this, It).sendMessagePromise(
        x.getPeerInfo,
        Sf.toBinary({ peerId: t })
      );
      return Ca.fromBinary(e.payload);
    });
  }
};
It = /* @__PURE__ */ new WeakMap();
var Ge;
var $c;
var ID = class {
  constructor(t, e) {
    g(this, Ge, void 0);
    g(this, $c, void 0);
    m(this, Ge, e), m(this, $c, t);
  }
  /**
   * @private access
   * Not available for external use
   */
  get logger() {
    return a(this, $c).getValue("logger");
  }
  addPlugin(t, e) {
    a(this, Ge).sendMessage(
      W.addPlugin,
      NI.toBinary({ pluginId: t, staggered: e })
    );
  }
  removePlugin(t) {
    a(this, Ge).sendMessage(
      W.removePlugin,
      LI.toBinary({ pluginId: t, staggered: false })
    );
  }
  getActivePlugins() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, Ge).sendMessagePromise(
        W.getPlugins
      );
      return t ? aA.fromBinary(t) : { plugins: [] };
    });
  }
  customPluginEventToRoom(t, e, r) {
    const i = {
      pluginId: t,
      pluginData: new TextEncoder().encode(JSON.stringify(e))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToRoom,
      WI.toBinary(i),
      r
    );
  }
  customPluginEventToPeers(t, e, r, i) {
    const n = {
      pluginId: t,
      peerIds: e,
      pluginData: new TextEncoder().encode(JSON.stringify(r))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToPeers,
      KI.toBinary(n),
      i
    );
  }
  enablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.enablePluginForRoom,
      UI.toBinary({ pluginId: t }),
      e
    );
  }
  enablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.enablePluginForPeers,
      BI2.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  disablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.disablePluginForRoom,
      FI.toBinary({ pluginId: t }),
      e
    );
  }
  disablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.disablePluginForPeers,
      jI.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  storeInsertKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      insertKeys: r.map((o) => ({
        storeKey: o.key,
        payload: new TextEncoder().encode(JSON.stringify(o.payload))
      }))
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(n),
      i
    );
  }
  storeGetKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      getKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeGetKeys,
      XI.toBinary(n),
      i
    );
  }
  storeDeleteKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      deleteKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeDeleteKeys,
      eA.toBinary(n),
      i
    );
  }
  storeDelete(t, e, r) {
    a(this, Ge).sendMessage(
      W.storeDelete,
      sA.toBinary({ pluginId: t, storeName: e }),
      r
    );
  }
  /**
   * @deprecated
   */
  // eslint-disable-next-line class-methods-use-this
  getPluginDataOld(t, e) {
    this.logger.info("getPluginDataOld", {
      plugin: { id: t, storeName: e }
    });
  }
  /**
   * @deprecated
   */
  storePluginDataOld(t, e, r) {
    const i = {
      pluginId: t,
      storeName: e,
      insertKeys: [
        {
          storeKey: r.key,
          payload: new TextEncoder().encode(JSON.stringify(r))
        }
      ]
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(i)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case W.addPlugin:
      case W.enablePluginForPeers:
      case W.enablePluginForRoom: {
        r = xu.fromBinary.bind(xu);
        break;
      }
      case W.removePlugin:
      case W.disablePluginForPeers:
      case W.disablePluginForRoom: {
        r = rg.fromBinary.bind(
          rg
        );
        break;
      }
      case W.customPluginEventToPeers:
      case W.customPluginEventToRoom: {
        r = ag.fromBinary.bind(ag);
        break;
      }
      case W.storeInsertKeys:
      case W.storeGetKeys:
      case W.storeDeleteKeys:
      case W.storeDelete: {
        r = ig.fromBinary.bind(ig);
        break;
      }
    }
    a(this, Ge).on(t, ({ payload: i, id: n }) => {
      const o = r(i);
      return e(o, n);
    });
  }
};
Ge = /* @__PURE__ */ new WeakMap(), $c = /* @__PURE__ */ new WeakMap();
var AD = Object.defineProperty;
var MD = (s, t, e) => t in s ? AD(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var DD = (s, t, e) => (MD(s, typeof t != "symbol" ? t + "" : t, e), e);
var Jh = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var M = (s, t, e) => (Jh(s, t, "read from private field"), e ? e.call(s) : t.get(s));
var Se = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
};
var ne = (s, t, e, r) => (Jh(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e);
var _e = (s, t, e) => (Jh(s, t, "access private method"), e);
var $d = {};
var OD = {
  get exports() {
    return $d;
  },
  set exports(s) {
    $d = s;
  }
};
var Ua = typeof Reflect == "object" ? Reflect : null;
var Tg = Ua && typeof Ua.apply == "function" ? Ua.apply : function(s, t, e) {
  return Function.prototype.apply.call(s, t, e);
};
var Pd;
Ua && typeof Ua.ownKeys == "function" ? Pd = Ua.ownKeys : Object.getOwnPropertySymbols ? Pd = function(s) {
  return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s));
} : Pd = function(s) {
  return Object.getOwnPropertyNames(s);
};
function ND(s) {
  console && console.warn && console.warn(s);
}
var NS = Number.isNaN || function(s) {
  return s !== s;
};
function de() {
  de.init.call(this);
}
OD.exports = de;
$d.once = UD;
de.EventEmitter = de;
de.prototype._events = void 0;
de.prototype._eventsCount = 0;
de.prototype._maxListeners = void 0;
var Eg = 10;
function Xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(de, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return Eg;
  },
  set: function(s) {
    if (typeof s != "number" || s < 0 || NS(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    Eg = s;
  }
});
de.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
de.prototype.setMaxListeners = function(s) {
  if (typeof s != "number" || s < 0 || NS(s))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + s + ".");
  return this._maxListeners = s, this;
};
function VS(s) {
  return s._maxListeners === void 0 ? de.defaultMaxListeners : s._maxListeners;
}
de.prototype.getMaxListeners = function() {
  return VS(this);
};
de.prototype.emit = function(s) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t.push(arguments[e]);
  var r = s === "error", i = this._events;
  if (i !== void 0)
    r = r && i.error === void 0;
  else if (!r)
    return false;
  if (r) {
    var n;
    if (t.length > 0 && (n = t[0]), n instanceof Error)
      throw n;
    var o = new Error("Unhandled error." + (n ? " (" + n.message + ")" : ""));
    throw o.context = n, o;
  }
  var c = i[s];
  if (c === void 0)
    return false;
  if (typeof c == "function")
    Tg(c, this, t);
  else
    for (var d = c.length, l = FS(c, d), e = 0; e < d; ++e)
      Tg(l[e], this, t);
  return true;
};
function LS(s, t, e, r) {
  var i, n, o;
  if (Xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = VS(s), i > 0 && o.length > i && !o.warned) {
    o.warned = true;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, ND(c);
  }
  return s;
}
de.prototype.addListener = function(s, t) {
  return LS(this, s, t, false);
};
de.prototype.on = de.prototype.addListener;
de.prototype.prependListener = function(s, t) {
  return LS(this, s, t, true);
};
function VD() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function xS(s, t, e) {
  var r = { fired: false, wrapFn: void 0, target: s, type: t, listener: e }, i = VD.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
de.prototype.once = function(s, t) {
  return Xl(t), this.on(s, xS(this, s, t)), this;
};
de.prototype.prependOnceListener = function(s, t) {
  return Xl(t), this.prependListener(s, xS(this, s, t)), this;
};
de.prototype.removeListener = function(s, t) {
  var e, r, i, n, o;
  if (Xl(t), r = this._events, r === void 0)
    return this;
  if (e = r[s], e === void 0)
    return this;
  if (e === t || e.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[s], r.removeListener && this.emit("removeListener", s, e.listener || t));
  else if (typeof e != "function") {
    for (i = -1, n = e.length - 1; n >= 0; n--)
      if (e[n] === t || e[n].listener === t) {
        o = e[n].listener, i = n;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? e.shift() : LD(e, i), e.length === 1 && (r[s] = e[0]), r.removeListener !== void 0 && this.emit("removeListener", s, o || t);
  }
  return this;
};
de.prototype.off = de.prototype.removeListener;
de.prototype.removeAllListeners = function(s) {
  var t, e, r;
  if (e = this._events, e === void 0)
    return this;
  if (e.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : e[s] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete e[s]), this;
  if (arguments.length === 0) {
    var i = Object.keys(e), n;
    for (r = 0; r < i.length; ++r)
      n = i[r], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = e[s], typeof t == "function")
    this.removeListener(s, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(s, t[r]);
  return this;
};
function US(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? xD(i) : FS(i, i.length);
}
de.prototype.listeners = function(s) {
  return US(this, s, true);
};
de.prototype.rawListeners = function(s) {
  return US(this, s, false);
};
de.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : $S.call(s, t);
};
de.prototype.listenerCount = $S;
function $S(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
de.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Pd(this._events) : [];
};
function FS(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
function LD(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function xD(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function UD(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    HS(s, t, n, { once: true }), t !== "error" && $D(s, i, { once: true });
  });
}
function $D(s, t, e) {
  typeof s.on == "function" && HS(s, "error", t, e);
}
function HS(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var FD = class extends MessageType {
  constructor() {
    super("message.v1.SocketMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: true,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "metadata",
        kind: "scalar",
        opt: true,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
};
var _g = new FD();
var BS = class {
  static encode(t) {
    return _g.toBinary(t);
  }
  static decode(t) {
    return _g.fromBinary(new Uint8Array(t));
  }
};
function HD(s, t) {
  return Math.floor(Math.random() * (t - s + 1) + s);
}
var Ir;
var BD = class {
  constructor(t = {}) {
    DD(this, "opts"), Se(this, Ir, void 0), this.opts = {
      initialTimeout: t.initialTimeout || 1e3,
      maxTimeout: t.maxTimeout || 1e4,
      factor: t.factor || 2
    }, ne(this, Ir, 0);
  }
  wait() {
    return u(this, null, function* () {
      ne(this, Ir, M(this, Ir) + 1);
      const t = HD(0, Math.min(this.opts.maxTimeout, this.opts.initialTimeout * ep(2, M(this, Ir))));
      yield new Promise((e) => {
        setTimeout(e, t);
      });
    });
  }
  getAttempts() {
    return M(this, Ir);
  }
  reset() {
    ne(this, Ir, 0);
  }
};
Ir = /* @__PURE__ */ new WeakMap();
var wr = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
var ui;
var hi;
var qD = class {
  constructor(t) {
    Se(this, ui, void 0), Se(this, hi, void 0), ne(this, ui, console), ne(this, hi, t);
  }
  debug(...t) {
    wr[M(this, hi)] > wr.debug || M(this, ui).debug("[Sockrates]:", ...t);
  }
  info(...t) {
    wr[M(this, hi)] > wr.info || M(this, ui).info("[Sockrates]:", ...t);
  }
  warn(...t) {
    wr[M(this, hi)] > wr.warn || M(this, ui).warn("[Sockrates]:", ...t);
  }
  error(...t) {
    wr[M(this, hi)] > wr.error || M(this, ui).error("[Sockrates]:", ...t);
  }
};
ui = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap();
var qS = ((s) => (s[s.CONNECTING = 0] = "CONNECTING", s[s.OPEN = 1] = "OPEN", s[s.CLOSING = 2] = "CLOSING", s[s.CLOSED = 3] = "CLOSED", s))(qS || {});
var jD = "2";
var GD = "3";
var Ae;
var Ia;
var Ee;
var Ue;
var Ar;
var Ye;
var gr;
var Xr;
var ys;
var Aa;
var Bs;
var dh;
var jS;
var wo;
var Cd;
var lh;
var GS;
var uh;
var Pg;
var Fd;
var hh;
var ph;
var WS;
var Ao;
var Rd;
var Mo;
var Hd;
var Bd;
var gh;
var $a;
var Do;
var Oo;
var qd;
var WD = class {
  constructor(t, e) {
    var S, T, _, P, w, A, N, H, $, F;
    Se(this, dh), Se(this, wo), Se(this, lh), Se(this, uh), Se(this, Fd), Se(this, ph), Se(this, Ao), Se(this, Mo), Se(this, Bd), Se(this, $a), Se(this, Oo), Se(this, Ae, void 0), Se(this, Ia, void 0), Se(this, Ee, void 0), Se(this, Ue, void 0), Se(this, Ar, void 0), Se(this, Ye, void 0), Se(this, gr, void 0), Se(this, Xr, void 0), Se(this, ys, void 0), Se(this, Aa, void 0), Se(this, Bs, void 0);
    var r, i, n, o, c, d, l, p, f2;
    ne(this, Ia, t), ne(this, Ar, []), ne(this, Ye, new $d()), ne(this, gr, true), ne(this, ys, false), ne(this, Ee, e != null ? e : {}), (S = (r = M(this, Ee)).autoReconnect) != null || (r.autoReconnect = true), (T = (i = M(this, Ee)).retryConnectionInterval) != null || (i.retryConnectionInterval = 1e3), (_ = (n = M(this, Ee)).pingTimeout) != null || (n.pingTimeout = 3e4), (P = (o = M(this, Ee)).connectionTimeout) != null || (o.connectionTimeout = 5e3), (w = (c = M(this, Ee)).debug) != null || (c.debug = true), (A = (d = M(this, Ee)).maxReconnectionAttempts) != null || (d.maxReconnectionAttempts = 10), (N = (l = M(this, Ee)).disconnectOnPingTimeout) != null || (l.disconnectOnPingTimeout = true), (H = (p = M(this, Ee)).queueOnDisconnect) != null || (p.queueOnDisconnect = false), ($ = (f2 = M(this, Ee)).flushOnReconnect) != null || (f2.flushOnReconnect = false), ne(this, Xr, {
      code: void 0,
      reason: void 0
    }), ne(this, Ue, (F = M(this, Ee).logger) != null ? F : new qD(M(this, Ee).debug ? "debug" : "info")), ne(this, Bs, new BD());
  }
  /**
   * Ready state of the current WebSocket.
   */
  get readyState() {
    var t;
    return (t = M(this, Ae)) == null ? void 0 : t.readyState;
  }
  /**
   * Sockrates connection URL.
   */
  get url() {
    return M(this, Ia);
  }
  /**
   * Update connection URL.
   */
  updateURL(t) {
    ne(this, Ia, t), _e(this, ph, WS).call(this);
  }
  /**
   * Configuration options passed to Sockrates.
   */
  get config() {
    return M(this, Ee);
  }
  /**
   * Messages that got queued due to the
   * socket not being connected.
   */
  get sendQueue() {
    return M(this, Ar);
  }
  /**
   * Flushes all messages that were queued
   * due to the socket not being connected.
   */
  flush() {
    if (!M(this, Ee).queueOnDisconnect)
      return false;
    const t = [];
    return M(this, Ar).forEach((e) => {
      this.send(e.event, e.id, e.payload, e.metadata) || t.push(e);
    }), ne(this, Ar, t), M(this, Ar);
  }
  connect(t = false) {
    return u(this, null, function* () {
      if (!t && [
        0,
        1
        /* OPEN */
      ].includes(this.readyState)) {
        M(this, Ue).debug("Websocket was already connecting or connected.");
        return;
      }
      if (M(this, gr) !== false)
        return new Promise((e, r) => {
          _e(this, $a, Do).call(this), _e(this, Oo, qd).call(this);
          try {
            ne(this, Ae, new WebSocket(_e(this, dh, jS).call(this, M(this, Ia)))), M(this, Ae).binaryType = "arraybuffer", M(this, Ue).debug("Connecting");
            const i = setTimeout(() => {
              M(this, Ue).debug("Connection timeout. Closing socket"), ne(this, gr, true), _e(this, Oo, qd).call(this), M(this, Ae).close(3001, "Connection Timeout"), M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ye).emit(
                "reconnecting"
                /* reconnecting */
              ), _e(this, Ao, Rd).call(this)), r(new Error("Connection timed out!"));
            }, M(this, Ee).connectionTimeout);
            M(this, Ae).onopen = () => {
              M(this, Ue).debug(`Ready State: ${qS[M(this, Ae).readyState]}`), i && clearTimeout(i), _e(this, Bd, gh).call(this), ne(this, Xr, {
                code: void 0,
                reason: void 0
              }), M(this, Ye).emit(
                "connected"
                /* connected */
              ), M(this, Ee).flushOnReconnect && this.flush(), e();
            }, M(this, Ae).onclose = (n) => {
              try {
                i && clearTimeout(i);
                const { code: o, reason: c } = n;
                r(c), M(this, Ue).debug("Socket closed. Close event:", { event: n }), M(this, Ue).debug(`Connection closed code: ${o}`), M(this, Ue).debug(`Connection closed reason: ${c}`), M(this, ys) || _e(this, Fd, hh).call(this, o, c);
              } catch (o) {
                _e(this, wo, Cd).call(this, o);
              }
            }, M(this, Ae).onerror = (n) => {
              _e(this, wo, Cd).call(this, n);
            }, M(this, Ae).onmessage = (n) => _e(this, lh, GS).call(this, n);
          } catch (i) {
            _e(this, wo, Cd).call(this, i, r);
          }
        });
    });
  }
  /**
   * Send a message to the socket server.
   * @returns {boolean} Returns true if the payload was sent successfully.
   */
  send(t, e, r, i) {
    const n = { event: t, id: e, payload: r, metadata: i };
    if (M(this, Ee).queueOnDisconnect && (!M(this, Ae) || M(this, Ae).readyState !== 1))
      return M(this, Ue).debug("Queuing message since socket is not connected!", n), M(this, Ar).push(n), false;
    const o = BS.encode(n);
    return _e(this, Mo, Hd).call(this, o);
  }
  /**
   * Alias for `send`.
   */
  emit(t, e, r, i) {
    return this.send(t, e, r, i);
  }
  /**
   * Send a raw message to the socket server.
   */
  sendRaw(t) {
    return _e(this, Mo, Hd).call(this, t);
  }
  /**
   * Alias to `on`.
   */
  receive(t, e) {
    return M(this, Ye).on(t.toString(), e);
  }
  /**
   * Event listener that is fired on receiving socket messages.
   */
  on(t, e) {
    if (typeof t == "string" && (t === "connected" || t === "disconnected" || t === "errored" || t === "reconnected" || t === "reconnecting" || t === "reconnectAttempt" || t === "reconnectFailure" || t === "failed")) {
      M(this, Ye).on(t, e);
      return;
    }
    this.receive(t, e);
  }
  /**
   * Remove all event listeners that were added using `on`.
   */
  removeAllListeners() {
    M(this, Ye).removeAllListeners();
  }
  /**
   * Alias to `removeListener`.
   */
  removeReceiver(t, e) {
    this.removeListener(t, e);
  }
  /**
   * Remove a specific listener that was added using `on`.
   */
  removeListener(t, e) {
    M(this, Ye).removeListener(t.toString(), e);
  }
  /**
   * Alias to `removeListeners`.
   */
  removeReceivers(t) {
    this.removeListeners(t);
  }
  /**
   * Remove all listeners for a specific event.
   */
  removeListeners(t) {
    M(this, Ye).listeners(t.toString()).map(
      (e) => this.removeListener(t, e)
    );
  }
  /**
   * Disconnect the socket.
   */
  disconnect() {
    ne(this, gr, false), _e(this, $a, Do).call(this), this.removeAllListeners(), ne(this, Xr, {
      code: 1e3,
      reason: "Sockrates disconnect method called"
    }), M(this, Ae).close(1e3, "Sockrates disconnect method called.");
  }
};
Ae = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), Ee = /* @__PURE__ */ new WeakMap(), Ue = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), gr = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Bs = /* @__PURE__ */ new WeakMap(), dh = /* @__PURE__ */ new WeakSet(), jS = function(s) {
  if (s.startsWith("ws://") || s.startsWith("wss://"))
    return s;
  if (s.startsWith("https://"))
    return `wss://${s.substring(8)}`;
  if (s.startsWith("http://"))
    return `ws://${s.substring(7)}`;
  throw new Error("Invalid URL. URL must start with http(s):// or ws(s)://.");
}, wo = /* @__PURE__ */ new WeakSet(), Cd = function(s, t) {
  M(this, Ue).error("Error:", { error: s }), M(this, Ye).emit("errored", { error: s }), t == null || t(s);
}, lh = /* @__PURE__ */ new WeakSet(), GS = function(s) {
  if (_e(this, Bd, gh).call(this), s.data === jD) {
    M(this, Ue).debug("Received ping from server"), _e(this, Mo, Hd).call(this, GD);
    return;
  }
  const t = BS.decode(s.data), { id: e, payload: r } = t;
  M(this, Ue).debug("Received message", { event: t.event, messageID: e }), M(this, Ye).emit(t.event.toString(), { id: e, payload: r });
}, uh = /* @__PURE__ */ new WeakSet(), Pg = function() {
  return M(this, Ae).readyState === 1;
}, Fd = /* @__PURE__ */ new WeakSet(), hh = function(s, t) {
  ne(this, Xr, { reason: t, code: s }), M(this, Ye).emit("disconnected", { code: s, reason: t });
}, ph = /* @__PURE__ */ new WeakSet(), WS = function() {
  const { reason: s, code: t } = M(this, Xr);
  t && t !== 1e3 && M(this, gr) && M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ue).debug(`Triggering reconnection due to ${s}.`), M(this, Ye).emit(
    "reconnecting"
    /* reconnecting */
  ), _e(this, Ao, Rd).call(this));
}, Ao = /* @__PURE__ */ new WeakSet(), Rd = function(s = true) {
  return u(this, null, function* () {
    if (s && M(this, ys)) {
      M(this, Ue).debug("Reconnect called when already in a reconnect loop. Ignoring.");
      return;
    }
    if (M(this, ys) || M(this, Bs).reset(), M(this, Ee).maxReconnectionAttempts !== null && M(this, Bs).getAttempts() >= M(this, Ee).maxReconnectionAttempts) {
      M(this, Ye).emit(
        "failed"
        /* failed */
      ), ne(this, ys, false);
      return;
    }
    ne(this, ys, true), _e(this, Oo, qd).call(this), _e(this, $a, Do).call(this);
    try {
      if (yield M(this, Bs).wait(), M(this, gr) === false)
        return;
      if (M(this, Ue).debug(`Reconnection attempt ${M(this, Bs).getAttempts()}`), M(this, Ye).emit("reconnectAttempt", { attempt: M(this, Bs).getAttempts() }), yield this.connect(), !_e(this, uh, Pg).call(this))
        throw Error("Reconnect Failed");
      ne(this, ys, false), ne(this, Xr, {
        code: void 0,
        reason: void 0
      }), M(this, Ye).emit(
        "reconnected"
        /* reconnected */
      );
    } catch (t) {
      M(this, Ue).debug("Failed to reconnect."), M(this, Ye).emit("reconnectFailure", { attempt: M(this, Bs).getAttempts() }), _e(this, Ao, Rd).call(this, false);
    }
  });
}, Mo = /* @__PURE__ */ new WeakSet(), Hd = function(s) {
  try {
    return M(this, Ae).send(s), true;
  } catch (t) {
    return M(this, Ue).error(t.message), false;
  }
}, Bd = /* @__PURE__ */ new WeakSet(), gh = function() {
  this.config.disconnectOnPingTimeout && (M(this, Ue).debug("Resetting ping timeout"), _e(this, $a, Do).call(this), ne(this, Aa, setTimeout(() => {
    var s;
    M(this, Ue).debug("Disconnecting the socket due to ping timeout"), ne(this, gr, true);
    const t = 3002, e = "Ping timeout";
    (s = M(this, Ae)) == null || s.close(t, e), _e(this, Fd, hh).call(this, t, e);
  }, M(this, Ee).pingTimeout)));
}, $a = /* @__PURE__ */ new WeakSet(), Do = function() {
  M(this, Aa) && (clearTimeout(M(this, Aa)), ne(this, Aa, void 0));
}, Oo = /* @__PURE__ */ new WeakSet(), qd = function() {
  M(this, Ae) && (M(this, Ae).onopen = void 0, M(this, Ae).onerror = void 0, M(this, Ae).onmessage = void 0, M(this, Ae).onclose = void 0);
};
var JD = Object.defineProperty;
var KD = Object.getOwnPropertyDescriptor;
var Zl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JD(t, e, i), i;
};
var Cg = 65535;
var zD = 3e3;
var zr;
var Pe;
var Ce;
var De;
var rs;
var st;
var Fc;
var mh;
var Hc;
var fh;
var jg;
var JS = (jg = class {
  constructor(s, {
    peerId: t,
    meetingId: e,
    authToken: r,
    capabilities: i
  }) {
    g(this, Ce);
    g(this, Fc);
    g(this, Hc);
    g(this, zr, void 0);
    g(this, Pe, void 0);
    h(this, "roomName");
    h(this, "authToken");
    h(this, "capabilities");
    g(this, rs, void 0);
    g(this, st, void 0);
    var n;
    if (!t || !e || !r)
      throw new R("peerId, meetingId, or authToken can not be empty", "0404");
    m(this, rs, void 0), m(this, st, s), this.capabilities = i, this.roomName = e, this.authToken = r, m(this, zr, L(this, Fc, mh).call(this, t)), m(this, Pe, new WD(a(this, zr), {
      autoReconnect: true,
      disconnectOnPingTimeout: (n = i.includes("PING")) != null ? n : false,
      queueOnDisconnect: true,
      flushOnReconnect: false,
      logger: this.logger
    })), this.handleSocketConnectionEvents();
  }
  get joinAttempted() {
    return a(this, Ce, De).socketJoinAttempted;
  }
  set joinAttempted(s) {
    a(this, Ce, De).socketJoinAttempted = s;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, st).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, st).getValue("logger");
  }
  get peerId() {
    return a(this, st).getValue("peerId");
  }
  updateURL(s) {
    s !== this.peerId && (m(this, zr, L(this, Fc, mh).call(this, s)), this.logger.debug("SocketService:: Connection URL updated.")), a(this, Pe).updateURL(a(this, zr));
  }
  static getSocketEdgeDomain(s) {
    return da({ servicePrefix: "socket-edge", baseURI: s });
  }
  get url() {
    return a(this, zr);
  }
  connect() {
    return u(this, null, function* () {
      a(this, Ce, De).socketJoinAttempted = true, yield a(this, Pe).connect(), a(this, Ce, De).socketJoinAttempted = true, a(this, Ce, De).socketState = {
        state: "connected",
        reconnected: false,
        reconnectionAttempt: void 0
      };
    });
  }
  disconnect() {
    a(this, Ce, De).socketJoinAttempted = false, a(this, Pe).disconnect(), a(this, Ce, De).socketJoinAttempted = true, a(this, Ce, De).socketState = {
      state: "disconnected",
      reconnected: false,
      reconnectionAttempt: void 0
    };
  }
  get isConnected() {
    try {
      return a(this, Pe).readyState === 1;
    } catch (s) {
      return false;
    }
  }
  sendMessage(s, t, e) {
    const r = {};
    return a(this, st).getValue("telemetry").injectContext(r), a(this, Pe).send(
      s,
      e != null ? e : L(this, Hc, fh).call(this),
      t,
      new TextEncoder().encode(JSON.stringify(r))
    );
  }
  sendMessagePromise(s, t, e, r) {
    const i = parseInt({}.SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT, 10) || 2e4;
    return this.sendMessagePromiseWithTimeout({
      event: s,
      timeout: i,
      protobuf: t,
      messageId: e,
      resp: r
    });
  }
  sendMessagePromiseWithTimeout({
    event: s,
    timeout: t,
    protobuf: e,
    messageId: r,
    resp: i
  }) {
    const n = i != null ? i : s;
    return new Promise(
      (o, c) => {
        const d = (_, P) => {
          a(this, Pe).removeListener(n, _), a(this, Pe).removeListener(Cg, P), a(this, Pe).removeListener(
            is.errorResponse,
            P
          ), a(this, Pe).removeListener(
            Ts.errorResponse,
            P
          );
        }, l = r != null ? r : L(this, Hc, fh).call(this), p = {};
        a(this, st).getValue("telemetry").injectContext(p);
        const S = ({
          id: _,
          payload: P
        }) => {
          if (l === _) {
            let w;
            try {
              const A = YR.fromBinary(P);
              w = new Error(A.errorMessage);
            } catch (A) {
              w = new Error("failed to parse error message", { cause: A });
              try {
                const N = Qw.fromBinary(P);
                w = new Error(N.message);
              } catch (N) {
                w = new Error("failed to parse error message", { cause: N });
              }
            }
            c(w), d(T, S);
          }
        }, T = ({
          id: _,
          payload: P
        }) => {
          l === _ && (o({ id: _, payload: P }), d(T, S));
        };
        a(this, Pe).on(n, T), a(this, Pe).on(Cg, S), a(this, Pe).on(is.errorResponse, S), a(this, Pe).on(Ts.errorResponse, S), setTimeout(() => {
          d(T, S), c(new Error(`request timeout for callback eventId:${s}`));
        }, t), a(this, Pe).send(
          s,
          l,
          e,
          new TextEncoder().encode(JSON.stringify(p))
        );
      }
    );
  }
  on(s, t) {
    a(this, Pe).on(s, t);
  }
  onStateEvent(s, t) {
    a(this, Pe).on(s, t);
  }
  removeListener(s, t) {
    a(this, Pe).removeListener(s, t);
  }
  removeListeners(s) {
    a(this, Pe).removeListeners(s);
  }
  flush() {
    return a(this, Pe).flush();
  }
  handleSocketConnectionEvents() {
    this.onStateEvent("connected", () => u(this, null, function* () {
      this.logger.info("SocketService::Connected to socket-edge"), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, Ce, De).updateSocketConnectionState("connected");
    })), this.onStateEvent("disconnected", ({ code: s, reason: t }) => {
      var i;
      this.logger.info("SocketService::Disconnected from socket-edge", { error: { code: s, reason: t }, country: E.location.country });
      const { recv: e, send: r } = (i = a(this, Ce, De).mediaState) != null ? i : {};
      e != null && e.state && (e == null ? void 0 : e.state) !== xa.CONNECTED || r != null && r.state && (r == null ? void 0 : r.state) !== xa.CONNECTED ? a(this, st).getValue("peerSessionStore").emit(
        k.SOCKET_SERVICE_DISCONNECTED,
        {
          joinAttempted: a(this, Ce, De).joinAttempted
        }
      ) : m(this, rs, setTimeout(() => {
        a(this, st).getValue("peerSessionStore").emit(
          k.SOCKET_SERVICE_DISCONNECTED,
          { joinAttempted: a(this, Ce, De).joinAttempted }
        ), m(this, rs, void 0);
      }, zD)), a(this, Ce, De).updateSocketConnectionState("disconnected");
    }), this.onStateEvent("reconnecting", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnecting to socket-edge", { country: E.location.country }), a(this, Ce, De).updateSocketConnectionState("reconnecting");
    })), this.onStateEvent("reconnectAttempt", (t) => u(this, [t], function* ({ attempt: s }) {
      this.logger.info("SocketService::Attempting to reconnect to socket-edge", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectAttempt", s);
    })), this.onStateEvent("reconnectFailure", ({ attempt: s }) => {
      this.logger.info("SocketService::Reconnect attempt to socket-edge failed", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectFailure", s);
    }), this.onStateEvent("reconnected", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnected to socket-edge", { connectionState: { joinAttempted: a(this, Ce, De).mediaJoinAttempted } }), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_RECONNECTED, {
        wasJoinAttempted: a(this, Ce, De).mediaJoinAttempted
      }), a(this, Ce, De).updateSocketConnectionState("reconnected");
    })), this.onStateEvent("failed", () => u(this, null, function* () {
      this.logger.info("SocketService::Failed to connect to socket-edge", { country: E.location.country }), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_FAILED), a(this, Ce, De).updateSocketConnectionState("failed");
    }));
  }
}, zr = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap(), Ce = /* @__PURE__ */ new WeakSet(), De = function() {
  return a(this, st).getValue("connectionHandler");
}, rs = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakSet(), mh = function(s) {
  let t = JS.getSocketEdgeDomain(a(this, st).getValue("baseURI"));
  typeof Gn(a(this, st), "socket_server_base") == "string" && (t = Gn(a(this, st), "socket_server_base"));
  const e = `wss://${t}`, r = new URL(`${e}/ws`), i = this.peerId, n = B(D({
    roomID: this.roomName,
    peerID: s,
    authToken: this.authToken,
    useMediaV2: true
  }, i !== s && { oldPeerID: i }), {
    ping: this.capabilities.includes("PING"),
    capabilities: this.capabilities.map((o) => Nd[o]).join(" "),
    joinWithDetails: true,
    useCfWorker: true,
    useStartSession: true
  });
  return Object.entries(n).forEach(([o, c]) => {
    r.searchParams.append(o, c.toString());
  }), r.href;
}, Hc = /* @__PURE__ */ new WeakSet(), fh = function() {
  return `${this.peerId}-${(Math.random() + 1).toString(36).substring(7)}`;
}, jg);
var Xc = JS;
Zl([
  E.trace("SocketService.connect")
], Xc.prototype, "connect", 1);
Zl([
  E.trace("SocketService.disconnect")
], Xc.prototype, "disconnect", 1);
Zl([
  E.trace("SocketService.sendMessagePromise")
], Xc.prototype, "sendMessagePromise", 1);
Zl([
  E.trace("SocketService.sendMessagePromiseWithTimeout")
], Xc.prototype, "sendMessagePromiseWithTimeout", 1);
var YD = class {
  constructor(t) {
    h(this, "socketService");
    this.socketService = t;
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsDumpRaw({ payload: t }) {
    var n;
    const e = Cb.fromBinary(t), r = e.meetings.map((o) => {
      var c;
      return {
        id: o.id,
        title: o.title,
        participants: (c = o.participants) != null ? c : []
      };
    });
    return {
      parentMeeting: {
        id: e.parentMeeting.id,
        title: e.parentMeeting.title,
        participants: (n = e.parentMeeting.participants) != null ? n : []
      },
      meetings: r
    };
  }
  // eslint-disable-next-line class-methods-use-this
  handleTransferPeerRaw({ payload: t }) {
    const e = Yb.fromBinary(t);
    return { authToken: e.authToken, meetingId: e.meetingId };
  }
  // eslint-disable-next-line class-methods-use-this
  handleMovedPeerRaw({ payload: t }) {
    const e = vf.fromBinary(t);
    return {
      meetingId: e.meetingId,
      customParticipantId: e.customParticipantId
    };
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsUpdatedRaw({ payload: t }) {
    return Xp.fromBinary(t).payloads.map((r) => ({
      id: r.id,
      title: r.title
    }));
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsDeletedRaw({ payload: t }) {
    return Fb.fromBinary(t).payloads;
  }
  getConnectedRoomsDump() {
    return u(this, null, function* () {
      const t = yield this.socketService.sendMessagePromise(
        x.getConnectedRoomsDump
      );
      return this.handleConnectedRoomsDumpRaw(t);
    });
  }
  createConnectedRooms(t) {
    return u(this, null, function* () {
      const { payload: e } = yield this.socketService.sendMessagePromise(
        x.createConnectedRooms,
        kb.toBinary({ payloads: t })
      );
      return Xp.fromBinary(e).payloads.map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this
  updateConnectedRooms(t) {
    return u(this, null, function* () {
    });
  }
  disableConnectedRooms(t) {
    return u(this, null, function* () {
      const e = t.map((i) => ({ id: i })), r = yield this.socketService.sendMessagePromise(
        x.deleteConnectedRooms,
        Ub.toBinary({ payloads: e })
      );
      return this.handleConnectedRoomsDeletedRaw(
        r
      );
    });
  }
  movePeersBetweenRooms(t) {
    return u(this, null, function* () {
      try {
        const e = yield this.socketService.sendMessagePromise(
          x.movePeers,
          Wb.toBinary({
            sourceMeetingId: t.sourceMeetingId,
            destinationMeetingId: t.destinationMeetingId,
            participants: t.participants
          })
        );
        return new TextDecoder().decode(e.payload).includes("error") ? { success: false, error: "failed to move participants" } : { success: true };
      } catch (e) {
        return { success: false, error: e };
      }
    });
  }
};
var QD = Object.defineProperty;
var XD = Object.getOwnPropertyDescriptor;
var ZD = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QD(t, e, i), i;
};
var vs;
var KS = class extends qt {
  constructor(e) {
    const r = e.getValue("logger");
    super(r);
    h(this, "meetings", []);
    h(this, "parentMeeting", null);
    g(this, vs, void 0);
    m(this, vs, e);
  }
  get supportsConnectedMeetings() {
    return a(this, vs).getValue("self").id !== "";
  }
  get isActive() {
    return this.meetings.length !== 0;
  }
  validateConnectedMeetingsAction() {
    if (!this.supportsConnectedMeetings)
      throw new Error(`You are not allowed to perform this action.
						Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
  }
  getConnectedMeetings() {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").getConnectedRoomsDump();
    });
  }
  /**
   * create connected meetings
   */
  createMeetings(e) {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), (yield a(this, vs).getValue("connectedMeetingsSocketHandler").createConnectedRooms(
        e
      )).map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  /**
   * update meeting title
   */
  updateMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").updateConnectedRooms(
        e.map((r) => ({ meetingId: r.id, title: r.title }))
      );
    });
  }
  /**
   * delete connected meetings
   */
  deleteMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const r = this.meetings.map((n) => e.includes(n.id) && n.participants.length !== 0 ? this.moveParticipants(
        n.id,
        this.parentMeeting.id,
        n.participants.map((o) => o.id)
      ) : Promise.resolve());
      return yield Promise.all(r), yield a(this, vs).getValue("connectedMeetingsSocketHandler").disableConnectedRooms(
        e
      );
    });
  }
  /**
   * Trigger event to move participants
   *
   * @param {string} sourceMeetingId - id of source meeting
   * @param {string} destinationMeetingId - id of destination meeting
   * @param {string[]} participantIds - list of id of the participants
   */
  moveParticipants(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i.map((o) => ({
            id: o
          }))
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i), n;
    });
  }
  /**
   * Trigger event to move participants with custom preset
   */
  moveParticipantsWithCustomPreset(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i.map((o) => o.id)), n;
    });
  }
  moveSuccessHandler(e, r, i) {
    const n = /* @__PURE__ */ new Map();
    [
      ...this.parentMeeting.participants,
      ...this.meetings.flatMap((o) => o.participants)
    ].forEach((o) => n.set(o.id, o)), r === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.concat(
      i.map((o) => n.get(o))
    )), e === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.filter(
      (o) => !i.includes(o.id)
    )), this.meetings = this.meetings.map((o) => {
      if (r === o.id) {
        const c = o.participants.concat(
          i.map((d) => n.get(d))
        );
        return B(D({}, o), {
          participants: c
        });
      }
      if (e === o.id) {
        const c = o.participants.filter(
          (d) => !i.includes(d.id)
        );
        return B(D({}, o), {
          participants: c
        });
      }
      return o;
    });
  }
};
vs = /* @__PURE__ */ new WeakMap();
ZD([
  Dt({ maxInvocations: 60, period: 60 })
], KS.prototype, "getConnectedMeetings", 1);
var eO = Object.defineProperty;
var tO = Object.getOwnPropertyDescriptor;
var Kh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? tO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && eO(t, e, i), i;
};
var me;
var Gg;
var zS = (Gg = class {
  constructor(s) {
    h(this, "connectedMeetings");
    g(this, me, void 0);
    m(this, me, s), this.connectedMeetings = new KS(s);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, me).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, me).getValue("logger");
  }
  static init(s) {
    const t = new zS(
      s
    );
    return t.connectedMeetings.supportsConnectedMeetings && (t.setupEvents(), s.getValue("self").once(
      "roomJoined",
      () => t.getConnectedMeetings()
    )), t;
  }
  getConnectedMeetings() {
    this.connectedMeetings.getConnectedMeetings();
  }
  setupEvents() {
    a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.getConnectedRoomsDump,
      this.handleConnectedRoomsDump.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.transferPeer,
      this.handleTransferPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.movedPeer,
      this.handleMovedPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsUpdated,
      this.handleConnectedRoomsUpdated.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsDeleted,
      this.handleConnectedRoomsDeleted.bind(this)
    );
  }
  // event handlers
  handleTransferPeer(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleTransferPeerRaw(s);
    return this.switchMeeting(t);
  }
  switchMeeting(e) {
    return u(this, arguments, function* ({
      authToken: s,
      meetingId: t
    }) {
      var n, o, c, d;
      if (!this.connectedMeetings.supportsConnectedMeetings)
        throw new Error(`You are not allowed to perform this action.
								Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
      this.logger.info("ConnectedMeetingsController::switchMeeting:: asking ui-kit to show switching breakout UI"), this.connectedMeetings.emit("changingMeeting", t);
      const r = {
        video: a(this, me).getValue("self").videoEnabled,
        audio: a(this, me).getValue("self").audioEnabled
      };
      try {
        a(this, me).getValue("self").cleanupEvents(), yield a(this, me).getValue("meeting").leave("connected-meeting");
      } catch (l) {
        this.logger.error(`ConnectedMeetingsController:: switchMeeting:: issues in leaving previous meeting. Meeting Id: ${(o = (n = a(this, me).getValue("meeting")) == null ? void 0 : n.meta) == null ? void 0 : o.meetingId}`, { error: l });
      }
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initializing new meeting. Meeting Id: ${t}`);
      const i = yield lO.init(B(D({}, a(this, me).getValue("options")), {
        cachedUserDetails: null,
        defaults: B(D(D({}, a(this, me).getValue("options").defaults), r), {
          /**
           * NOTE(ravindra-dyte):
           * Protected methods & variables of DyteSelfMedia,
           * such as localMediaHandler cannot be type checked outside class hierarchy,
           * therefore typecasting DyteSelf to DyteSelfMedia,
           * Even though DyteSelf extends DyteSelfMedia.
           *
           * Alternative approach is to make either DyteSelfMedia methods public
           * or expose a public wrapper on DyteSelf.
           */
          mediaHandler: a(this, me).getValue("self")
        }),
        authToken: s
      }));
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initialized new meeting. Meeting Id: ${(c = i == null ? void 0 : i.meta) == null ? void 0 : c.meetingId}`);
      try {
        const { hidden: l } = a(this, me).getValue("self");
        i.self.setName(a(this, me).getValue("self").name), yield i.join(), l && i.self.hide();
      } catch (l) {
        this.logger.error("ConnectedMeetingsController.joinRoom", { error: l });
      }
      return this.logger.info(`ConnectedMeetingsController::switchMeeting:: asking ui-kit to show in-meeting ui of newly joined meeting id: ${(d = i == null ? void 0 : i.meta) == null ? void 0 : d.meetingId}`), this.connectedMeetings.emit("meetingChanged", i), i;
    });
  }
  handleConnectedRoomsDump(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDumpRaw(s);
    this.connectedMeetings.meetings = t.meetings.map((e) => ({
      id: e.id,
      title: e.title,
      participants: e.participants || []
    })), this.connectedMeetings.parentMeeting = {
      id: t.parentMeeting.id,
      title: t.parentMeeting.title,
      participants: t.parentMeeting.participants
    }, this.emitStateUpdate();
  }
  // eslint-disable-next-line class-methods-use-this
  handleMovedPeer(s) {
    return a(this, me).getValue("connectedMeetingsSocketHandler").handleMovedPeerRaw(s);
  }
  handleConnectedRoomsUpdated(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsUpdatedRaw(s), e = /* @__PURE__ */ new Map();
    this.connectedMeetings.meetings.forEach((r) => {
      e.set(r.id, r);
    }), t.forEach((r) => {
      e.has(r.id) ? e.get(r.id).title = r.title : e.set(r.id, B(D({}, r), { participants: [] }));
    }), this.connectedMeetings.meetings = Array.from(e.values()), this.emitStateUpdate();
  }
  handleConnectedRoomsDeleted(s) {
    const e = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDeletedRaw(s).map((r) => r.id);
    this.connectedMeetings.meetings = this.connectedMeetings.meetings.filter(
      (r) => !e.includes(r.id)
    ), this.emitStateUpdate();
  }
  emitStateUpdate() {
    this.connectedMeetings.emit("stateUpdate", {
      meetings: this.connectedMeetings.meetings,
      parentMeeting: this.connectedMeetings.parentMeeting
    });
  }
}, me = /* @__PURE__ */ new WeakMap(), Gg);
var eu = zS;
Kh([
  E.trace("ConnectedMeetingsController.getConnectedMeetings")
], eu.prototype, "getConnectedMeetings", 1);
Kh([
  E.trace("ConnectedMeetingsController.setupEvents")
], eu.prototype, "setupEvents", 1);
Kh([
  E.trace("ConnectedMeetingsController.switchMeeting")
], eu.prototype, "switchMeeting", 1);
var sO = Object.defineProperty;
var rO = Object.getOwnPropertyDescriptor;
var tu = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? rO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && sO(t, e, i), i;
};
var Ma = class {
  constructor(s, t, e) {
    h(this, "apiBase");
    h(this, "selfController");
    h(this, "pollController");
    h(this, "chatController");
    h(this, "metaController");
    h(this, "storesManager");
    h(this, "stageController");
    h(this, "pluginController");
    h(this, "internalsController");
    h(this, "recordingController");
    h(this, "livestreamController");
    h(this, "participantController");
    h(this, "connectedMeetingsController");
    h(this, "telemetry");
    h(this, "logger");
    this.apiBase = s, this.storesManager = t.storesManager, this.metaController = t.metaController, this.selfController = t.selfController, this.chatController = t.chatController, this.pollController = t.pollController, this.stageController = t.stageController, this.pluginController = t.pluginController, this.recordingController = t.recordingController, this.internalsController = t.internalsController, this.participantController = t.participantController, this.livestreamController = t.livestreamController, this.connectedMeetingsController = t.connectedMeetingsController, this.telemetry = e.getValue("telemetry"), this.logger = e.getValue("logger");
  }
  static init(s) {
    return u(this, null, function* () {
      var F, K;
      const {
        peerId: t,
        apiBase: e,
        authToken: r,
        meetingId: i,
        organizationId: n,
        cachedUserDetails: o,
        logger: c
      } = s.getAllValues();
      if (MS(s), Te.isSupported() === false)
        throw new R("Browser not supported", "0010", c, true);
      const d = cM(
        s,
        {
          authToken: r,
          baseURL: e,
          cachedUserDetails: o
        }
      );
      d.setRoomName(i), d.setRoomUUID(i), d.setOrganizationId(n), d.setHeader("dyte-tracing-id", t), s.setValue("apiClient", d);
      const l = new jM(s);
      s.setValue("connectionHandler", l);
      const p = Ma.createSocketService(s), f2 = p.connect(), S = d.getUserDetails(), T = d.getPlugins();
      let _ = we.HIVE, P, w = "";
      try {
        yield Ma.setupFlagsmith(s);
      } catch (re) {
        c.error("Failed to setup flagsmith", { error: re });
      }
      try {
        yield f2;
      } catch (re) {
        c.error(
          "[Controller]: Failed to connect to socket server:",
          { error: re }
        );
      }
      try {
        ({ sfu: _, meetingTitle: w } = yield d.getRoomNodeData()), P = yield S, c.info(`SFU ${_} is being used.`), s.setValue("presetName", P.preset.name), s.setValue("roomNodeOptions", { sfu: _ });
      } catch (re) {
        c.error("Failed to get room metadata", { error: re });
      }
      const A = Ku.init(P.preset, !s.getValue("modules").theme), N = Qu.init(
        s,
        A.viewType,
        P.preset.permissions
      ), H = Ma.setupControllers(
        p,
        s,
        P,
        T,
        w,
        A,
        N
      );
      OM(A) && ((F = Ma.createRoomNodeClient(s, p).initializeConnection(
        P.participant.name,
        i,
        false,
        N
      )) == null || F.catch((Je) => {
        c.error(
          "[Controller]: Failed to queue partial media room promise:",
          { error: Je }
        );
      })), E.location.country = (K = d.ipInfo) == null ? void 0 : K.country;
      const { controllers: $ } = yield H;
      return MC(), new Ma(e, $, s);
    });
  }
  static setupFlagsmith(s) {
    return u(this, null, function* () {
      var l;
      const {
        peerId: t,
        baseURI: e,
        overrides: r,
        meetingId: i,
        organizationId: n,
        logger: o
      } = s.getAllValues(), c = AC(i), d = B(D({
        entity: Iu.PEER,
        clientId: n,
        isAnonUser: !n,
        sdkVersion: s.getValue("sdkVersion"),
        presetName: s.getValue("presetName"),
        meetingHash: c,
        roomName: i
      }, Te.getDeviceInfo()), {
        isReactNative: navigator.isReactNative
      });
      try {
        const p = (l = r == null ? void 0 : r.whitelabelled_flags_endpoint) == null || l ? da({ servicePrefix: "flags", baseURI: e }) : "edge.api.flagsmith.com";
        yield s.getValue("flagsmith").identify(
          `${Iu.PEER}_${t}`,
          JSON.parse(JSON.stringify(d)),
          false,
          // force evaluate
          5e3,
          // timeout
          p,
          o
        ), o.info(
          "flagsmith::allFlags",
          { flags: JSON.stringify(s.getValue("flagsmith").getAllFlags()) },
          true
        );
      } catch (p) {
        o.error("Failed to fetch flagsmith flags");
      }
    });
  }
  static setupControllers(s, t, e, r, i, n, o) {
    return u(this, null, function* () {
      var $e, Cr, Rr;
      const c = t.getValue("modules"), { participant: d } = e, l = t.getValue("defaults"), p = t.getValue("logger"), { sfu: f2 } = t.getValue("roomNodeOptions"), { viewType: S, mediaConstraints: { audio: T } } = n;
      t.setValue("viewType", S), t.setValue("defaults", D({
        mediaConfiguration: {
          audio: {
            enableHighBitrate: ($e = T.enableHighBitrate) != null ? $e : false,
            enableStereo: (Cr = T.enableStereo) != null ? Cr : false
          }
        }
      }, l)), t.setValue("maxPreferredStreams", Te.isMobile() ? n.maxVideoStreams.mobile : n.maxVideoStreams.desktop);
      let _, P, w, A, N, H, $, F, K;
      const re = new _D(t, s), Je = new YD(
        s
      );
      t.setValue("connectedMeetingsSocketHandler", Je);
      const ks = new Ql(t, s), Pr = new as(t, s), ni = new kD(s), I = new OS(t, s), y = new ID(t, s), C = new ED(s), U = new pa(t, s), ie = yield ai.init(
        t,
        I,
        d,
        o,
        n
      );
      t.setValue("selfController", ie);
      const Me = yield Of.init(
        t,
        ie.self,
        I,
        re,
        i
      );
      if (c.participant && (F = new _r(
        t,
        ie.self,
        I,
        f2
      )), (Rr = c.e2ee) != null && Rr.enabled && c.e2ee.manager.init(p, t.getValue("peerSessionStore")), c.chat && (P = yield Es.init(
        t,
        Pr,
        U,
        ie.self,
        F.participants
      )), c.internals && (N = yield Lh.init(t)), c.livestream && n.viewType === Mt.Livestream && t.getValue("flagsmith").hasFeature(X.LIVESTREAM) && ($ = new Bf(
        t,
        ie.self,
        C
      )), n.viewType !== Mt.Chat) {
        if (c.poll && (_ = yield If.init(
          t,
          ie.self,
          ks
        )), c.recording && (H = new xf(
          t,
          ie.self,
          I
        )), c.stage && (w = new Nf(
          t,
          ni,
          I,
          ie.self,
          F.participants
        )), c.plugin) {
          if (!F)
            throw new R(
              "The plugin module cannot be initialized without the `participant` module",
              "0102"
            );
          const Fs = yield r;
          A = yield Kc.init(
            t,
            Fs,
            y,
            Pr,
            P == null ? void 0 : P.chat,
            ie.self,
            F.participants,
            i
          );
        }
        if (c.connectedMeetings && (K = yield eu.init(
          t
        )), c.pip) {
          const Fs = yield Au._init(t, ie.self);
          t.setValue("pip", Fs);
        }
      }
      const b = {
        storesManager: new V0(t, y),
        pollController: _,
        selfController: ie,
        metaController: Me,
        chatController: P,
        stageController: w,
        pluginController: A,
        recordingController: H,
        internalsController: N,
        livestreamController: $,
        participantController: F,
        connectedMeetingsController: K
      };
      return {
        theme: n,
        permissions: o,
        controllers: b
      };
    });
  }
  static createRoomNodeClient(s, t) {
    const {
      peerId: e,
      roomNodeOptions: r
    } = s.getAllValues(), { sfu: i } = r;
    return AS(s, i, {
      socket: t,
      peerId: e
    });
  }
  static createSocketService(s) {
    const {
      peerId: t,
      meetingId: e,
      authToken: r
    } = s.getAllValues(), i = ["PING"];
    return new Xc(s, {
      peerId: t,
      meetingId: e,
      authToken: r,
      capabilities: i
    });
  }
};
var Zc = Ma;
tu([
  E.trace("Controller.init")
], Zc, "init", 1);
tu([
  E.trace("setupFlagsmith")
], Zc, "setupFlagsmith", 1);
tu([
  E.trace("Controller.createRoomNodeClient")
], Zc, "createRoomNodeClient", 1);
tu([
  E.trace("Controller.createSocketService")
], Zc, "createSocketService", 1);
var iO = class {
  constructor() {
    h(this, "battery");
    h(this, "logger");
    h(this, "init", (t) => u(this, null, function* () {
      this.logger = t;
      try {
        "getBattery" in navigator && (this.battery = yield navigator.getBattery(), this.battery.addEventListener("chargingchange", this.updateChargeInfo), this.battery.addEventListener("levelchange", this.updateLevelInfo), this.updateLevelInfo(), this.updateChargeInfo());
      } catch (e) {
        t.error("Error getting battery", e);
      }
    }));
    h(this, "updateChargeInfo", () => {
      var t;
      this.logger.log(
        `Battery charging? ${(t = this.battery) != null && t.charging ? "Yes" : "No"}`
      );
    });
    h(this, "updateLevelInfo", () => {
      if (!this.battery) {
        this.logger.log("Battery level: Not known");
        return;
      }
      this.logger.log(`Battery level: ${this.battery.level * 100}%`);
    });
    h(this, "cleanup", () => {
      var t, e;
      "getBattery" in navigator && ((t = this.battery) == null || t.removeEventListener(
        "chargingchange",
        this.updateChargeInfo
      ), (e = this.battery) == null || e.removeEventListener("levelchange", this.updateLevelInfo));
    });
  }
};
var Rg = new iO();
function aO(s, t) {
  s.startsWith("eyJ") || console.error("Invalid auth token provided. Ensure you are passing a %cparticipant `authToken`%c — not an Org API Key or an incorrectly formatted token.\nYou get the participant token from the Add Participant API: https://docs.dyte.io/api#/operations/add_participant", "font-weight: bold", "font-weight: normal");
  try {
    const { meetingId: e, orgId: r, participantId: i } = JSON.parse(atob(s.split(".")[1]));
    if (!e)
      throw Error(`Received V1 auth token ${s}`);
    let n = "dyte.io";
    t && (n = t);
    const o = `https://${da({ servicePrefix: "api", baseURI: n })}`;
    return {
      meetingId: e,
      orgId: r,
      participantId: i,
      baseURI: n,
      apiBase: o
    };
  } catch (e) {
    throw new R("Invalid auth token", "0004");
  }
}
var Yr;
var aa;
var na;
var Bc;
var Ll;
var YS;
var nO = class {
  constructor() {
    g(this, Ll);
    g(this, Yr, new Audio());
    g(this, aa, new MediaStream());
    g(this, na, /* @__PURE__ */ new Map());
    g(this, Bc, void 0);
    a(this, Yr).srcObject = a(this, aa), a(this, Yr).autoplay = true;
  }
  playTracks(t) {
    return u(this, null, function* () {
      return t.forEach((e) => {
        a(this, na).has(e.id) || (a(this, aa).addTrack(e), a(this, na).set(e.id, e));
      }), this.play();
    });
  }
  setSpeakerDevice(t) {
    typeof HTMLAudioElement.prototype.setSinkId == "function" && a(this, Yr).setSinkId(t);
  }
  removeTrack(t) {
    const e = a(this, na).get(t);
    e && (a(this, aa).removeTrack(e), a(this, na).delete(t));
  }
  play() {
    return u(this, null, function* () {
      return a(this, Yr).srcObject = a(this, aa), a(this, Yr).play().catch((t) => {
        L(this, Ll, YS).call(this, t);
      });
    });
  }
  onError(t) {
    m(this, Bc, t);
  }
};
Yr = /* @__PURE__ */ new WeakMap(), aa = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), Bc = /* @__PURE__ */ new WeakMap(), Ll = /* @__PURE__ */ new WeakSet(), YS = function(t) {
  var e;
  (e = a(this, Bc)) == null || e.call(this, t);
};
var oa;
var oO = class extends nO {
  constructor() {
    super();
    g(this, oa, void 0);
    m(this, oa, /* @__PURE__ */ new Map());
  }
  addParticipantTrack(e, r) {
    a(this, oa).set(e, r.id), this.playTracks([r]);
  }
  removeParticipantTrack(e) {
    const r = a(this, oa).get(e);
    r && this.removeTrack(r), a(this, oa).delete(e);
  }
};
oa = /* @__PURE__ */ new WeakMap();
var cO = Object.defineProperty;
var dO = Object.getOwnPropertyDescriptor;
var su = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? dO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && cO(t, e, i), i;
};
var We;
var ca;
var Wg;
var ri = (Wg = class {
  constructor(t, e) {
    g(this, We, void 0);
    g(this, ca, void 0);
    m(this, ca, t), m(this, We, e);
  }
  get peerId() {
    return a(this, ca).getValue("peerId");
  }
  static initMedia(t = {}, e = false, r = void 0) {
    var d;
    const i = (d = r == null ? void 0 : r.peerId) != null ? d : v4_default(), n = mr.createContext(i, {
      peerId: i
    }), o = n.getValue("logger");
    o.init(n);
    const c = new zf(o);
    return c.init(t, e, n), n.setValue("defaults", { mediaHandler: c }), c;
  }
  static init(t) {
    return u(this, null, function* () {
      var T, _, P, A, N, H, $;
      Te.init();
      const { mediaHandler: e } = (T = t.defaults) != null ? T : {}, r = (e == null ? void 0 : e.peerId) || ((P = (_ = t == null ? void 0 : t.cachedUserDetails) == null ? void 0 : _.peerId) != null ? P : v4_default()), { authToken: i, baseURI: n } = t, w = aO(i, n), { meetingId: o } = w, c = ho(w, ["meetingId"]);
      window.__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;
      const d = ri.setupContext(
        r,
        t,
        o,
        c
      ), l = d.getValue("telemetry"), p = d.getValue("logger");
      av(p), Rg.init(p), l.init(d, {
        roomName: o,
        userId: c.participantId,
        organizationId: c.orgId,
        peerId: r
      }, (N = (A = t.modules) == null ? void 0 : A.tracing) != null ? N : true), p.init(d), p.info("DyteClient::init::options", {
        dyteClientInitOptions: B(D({}, t), {
          authToken: `${(H = t.authToken) == null ? void 0 : H.slice(0, 10)}...
				${($ = t.authToken) == null ? void 0 : $.slice(-10)}`
        })
      });
      const f2 = yield Zc.init(d), S = new ri(d, f2);
      return d.setValue("meeting", S), S;
    });
  }
  static setupContext(t, e, r, i) {
    var d, l;
    const n = mr.createContext(t, e), o = D(D({}, _C), e == null ? void 0 : e.modules), c = e.defaults || {
      audio: true,
      video: true
    };
    return n.setValue("options", e), n.setValue("peerId", t), n.setValue("modules", o), n.setValue("sdkName", "web-core"), n.setValue("meetingId", r), n.setValue("apiBase", i.apiBase), n.setValue("baseURI", i.baseURI), n.setValue("userId", i.participantId), n.setValue("organizationId", i.orgId), n.setValue("authToken", e.authToken), n.setValue("overrides", (d = e.overrides) != null ? d : {}), n.setValue("env", PC({ baseURI: i.baseURI })), n.setValue("defaults", c), n.setValue("onError", e.onError || (() => {
    })), n.setValue("cachedUserDetails", _s(e.cachedUserDetails)), n.setValue("sdkVersion", "3.1.7"), (l = e.modules) != null && l.experimentalAudioPlayback && n.setValue("audioPlayback", new oO()), n;
  }
  join() {
    return u(this, null, function* () {
      const { selfController: t } = a(this, We);
      return t.self.roomJoined ? null : t.joinRoom();
    });
  }
  leave(t) {
    return u(this, null, function* () {
      Rg.cleanup(), a(this, ca).getValue("peerSessionStore").reset();
      const { selfController: e } = a(this, We);
      return e.leaveRoom(t);
    });
  }
  /**
   * The `participants` object consists of 4 maps of participants,
   * `waitlisted`, `joined`, `active`, `pinned`. The maps are indexed by
   * `peerId`s, and the values are the corresponding participant objects.
   */
  get participants() {
    var t;
    return (t = a(this, We).participantController) == null ? void 0 : t.participants;
  }
  /**
   * The `self` object can be used to manipulate audio and video settings,
   * and other configurations for the local participant. This exposes methods
   * to enable and disable media tracks, share the user's screen, etc.
   */
  get self() {
    var t;
    return (t = a(this, We).selfController) == null ? void 0 : t.self;
  }
  /**
   * The `room` object stores information about the current meeting, such
   * as chat messages, polls, room name, etc.
   */
  get meta() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.meta;
  }
  /**
   * The `ai` object is used to interface with Dyte's AI features.
   * You can obtain the live meeting transcript and use other meeting AI
   * features such as summary, and agenda using this object.
   */
  get ai() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.ai;
  }
  /**
   * The `plugins` object stores information about the plugins available in
   * the current meeting. It exposes methods to activate and deactivate them.
   */
  get plugins() {
    var t;
    return (t = a(this, We).pluginController) == null ? void 0 : t.plugins;
  }
  /**
   * The chat object stores the chat messages that were sent in the meeting.
   * This includes text messages, images, and files.
   */
  get chat() {
    var t;
    return (t = a(this, We).chatController) == null ? void 0 : t.chat;
  }
  /**
   * The polls object stores the polls that were initiated in the meeting.
   * It exposes methods to create and vote on polls.
   */
  get polls() {
    var t;
    return (t = a(this, We).pollController) == null ? void 0 : t.polls;
  }
  /**
   * The connectedMeetings object stores the connected meetings states.
   * It exposes methods to create/read/update/delete methods for connected meetings.
   */
  get connectedMeetings() {
    var t;
    return (t = a(this, We).connectedMeetingsController) == null ? void 0 : t.connectedMeetings;
  }
  /*
   * The recording object stores the recording state of the meeting.
   * It exposes methods to start and stop recording.
   */
  get recording() {
    var t;
    return (t = a(this, We).recordingController) == null ? void 0 : t.recording;
  }
  get livestream() {
    var t;
    return (t = a(this, We).livestreamController) == null ? void 0 : t.livestream;
  }
  get stage() {
    var t;
    return (t = a(this, We).stageController) == null ? void 0 : t.stage;
  }
  get stores() {
    return a(this, We).storesManager;
  }
  get audio() {
    return a(this, ca).getValue("audioPlayback");
  }
  /**
   * The __internals__ object exposes the internal tools & utilities such as features and logger
   * so that client can utilise the same to build their own feature based UI.
   * DyteLogger (__internals__.logger) can be used to send logs to Dyte's servers
   *	to inform Dyte of issues, if any, proactively.
   */
  get __internals__() {
    var t;
    return (t = a(this, We).internalsController) == null ? void 0 : t.internals;
  }
  /** @deprecated Use `join()` instead */
  joinRoom() {
    return u(this, null, function* () {
      return this.join();
    });
  }
  /** @deprecated Use `leave()` instead */
  leaveRoom(t) {
    return u(this, null, function* () {
      return this.leave(t);
    });
  }
}, We = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), Wg);
su([
  ht("0002"),
  Er.executeWithLock({
    methodName: "meeting.join",
    lockName: "DyteClient.join",
    timeout: 3e3
  })
], ri.prototype, "join", 1);
su([
  ht("0003")
], ri.prototype, "leave", 1);
su([
  ht("0001"),
  Er.executeWithLock({
    methodName: "DyteClient.init",
    lockName: "DyteClient.init",
    timeout: 3e3
  })
], ri, "init", 1);
ri = su([
  ht("0000")
], ri);
var lO = ri;

// node_modules/@dytesdk/react-web-core/dist/index.es.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var DyteUpdates = class {
  constructor(meeting) {
    __publicField(this, "meeting");
    __publicField(this, "l");
    __publicField(this, "onUpdate", () => {
      this.l.forEach((l) => {
        l();
      });
    });
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m2, _n2, _o2, _p2;
    this.meeting = meeting;
    this.l = /* @__PURE__ */ new Set();
    (_a2 = this.meeting.self) == null ? void 0 : _a2.addListener("*", this.onUpdate);
    (_b2 = this.meeting.meta) == null ? void 0 : _b2.addListener("*", this.onUpdate);
    (_c2 = this.meeting.participants) == null ? void 0 : _c2.addListener("*", this.onUpdate);
    (_e2 = (_d2 = this.meeting.participants) == null ? void 0 : _d2.joined) == null ? void 0 : _e2.addListener("*", this.onUpdate);
    (_g2 = (_f2 = this.meeting.participants) == null ? void 0 : _f2.active) == null ? void 0 : _g2.addListener("*", this.onUpdate);
    (_i2 = (_h2 = this.meeting.participants) == null ? void 0 : _h2.waitlisted) == null ? void 0 : _i2.addListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.addListener("*", this.onUpdate);
    (_k2 = this.meeting.livestream) == null ? void 0 : _k2.addListener("*", this.onUpdate);
    (_l2 = this.meeting.chat) == null ? void 0 : _l2.addListener("*", this.onUpdate);
    (_m2 = this.meeting.plugins) == null ? void 0 : _m2.all.addListener("*", this.onUpdate);
    (_n2 = this.meeting.recording) == null ? void 0 : _n2.addListener("*", this.onUpdate);
    (_o2 = this.meeting.connectedMeetings) == null ? void 0 : _o2.addListener("*", this.onUpdate);
    (_p2 = this.meeting.polls) == null ? void 0 : _p2.addListener("*", this.onUpdate);
  }
  clean() {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m2, _n2, _o2, _p2;
    (_a2 = this.meeting.self) == null ? void 0 : _a2.removeListener("*", this.onUpdate);
    (_b2 = this.meeting.meta) == null ? void 0 : _b2.removeListener("*", this.onUpdate);
    (_c2 = this.meeting.participants) == null ? void 0 : _c2.removeListener("*", this.onUpdate);
    (_e2 = (_d2 = this.meeting.participants) == null ? void 0 : _d2.joined) == null ? void 0 : _e2.removeListener("*", this.onUpdate);
    (_g2 = (_f2 = this.meeting.participants) == null ? void 0 : _f2.active) == null ? void 0 : _g2.removeListener("*", this.onUpdate);
    (_i2 = (_h2 = this.meeting.participants) == null ? void 0 : _h2.waitlisted) == null ? void 0 : _i2.removeListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.removeListener("*", this.onUpdate);
    (_k2 = this.meeting.livestream) == null ? void 0 : _k2.removeListener("*", this.onUpdate);
    (_l2 = this.meeting.chat) == null ? void 0 : _l2.removeListener("*", this.onUpdate);
    (_m2 = this.meeting.plugins) == null ? void 0 : _m2.all.removeListener("*", this.onUpdate);
    (_n2 = this.meeting.recording) == null ? void 0 : _n2.removeListener("*", this.onUpdate);
    (_o2 = this.meeting.connectedMeetings) == null ? void 0 : _o2.removeListener("*", this.onUpdate);
    (_p2 = this.meeting.polls) == null ? void 0 : _p2.removeListener("*", this.onUpdate);
  }
  addListener(listener) {
    this.l.add(listener);
  }
  removeListener(listener) {
    this.l.delete(listener);
  }
};
var DyteContext = (0, import_react.createContext)({
  meeting: void 0,
  updates: void 0
});
function DyteProvider({
  value,
  children,
  fallback
}) {
  const [updates, setUpdates] = (0, import_react.useState)();
  const updatesRef = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (value) {
      setUpdates(new DyteUpdates(value));
    }
    return () => {
      var _a2;
      (_a2 = updatesRef.current) == null ? void 0 : _a2.clean();
    };
  }, [value]);
  return import_react.default.createElement(DyteContext.Provider, {
    value: {
      meeting: value,
      updates
    }
  }, value ? children : fallback);
}
var useDyteMeeting = () => {
  const { meeting } = (0, import_react.useContext)(DyteContext);
  if (!meeting)
    throw new Error("useDyteMeeting must be used within the DyteProvider");
  return { meeting };
};
var initDyteMedia = (options = {}, skipAwaits = false, cachedUserDetails = void 0) => lO.initMedia(options, skipAwaits, cachedUserDetails);
var useDyteClient = (dyteClientParams) => {
  const isRunning = (0, import_react.useRef)(false);
  const [client, setClient] = (0, import_react.useState)();
  const resetOnLeave = dyteClientParams == null ? void 0 : dyteClientParams.resetOnLeave;
  const initClient = (0, import_react.useCallback)(async (options) => {
    if (isRunning.current)
      return void 0;
    isRunning.current = true;
    return lO.init(options).then((meeting) => {
      setClient(meeting);
      return meeting;
    }).finally(() => {
      isRunning.current = false;
    });
  }, []);
  (0, import_react.useEffect)(() => {
    if (!client || !resetOnLeave)
      return () => {
      };
    const onLeave = ({ state }) => {
      if (state !== "connected-meeting" && state !== "disconnected") {
        setClient(void 0);
      }
    };
    client.self.on("roomLeft", onLeave);
    return () => {
      client.self.removeListener("roomLeft", onLeave);
    };
  }, [client]);
  (0, import_react.useEffect)(() => {
    if (!client || !client.connectedMeetings)
      return () => {
      };
    const onMeetingChanged = (newClient) => {
      setClient(void 0);
      setTimeout(() => {
        setClient(newClient);
      }, 100);
    };
    client.connectedMeetings.on("meetingChanged", onMeetingChanged);
    return () => {
      client.connectedMeetings.removeListener("meetingChanged", onMeetingChanged);
    };
  }, [client]);
  return [client, initClient];
};
var shouldUpdate = (slice, newSlice) => {
  if (slice !== newSlice) {
    return true;
  }
  if (Array.isArray(slice) && Array.isArray(newSlice)) {
    if (slice.length !== newSlice.length) {
      return true;
    }
  }
  return false;
};
var useDyteSelector = (selector) => {
  const { meeting, updates } = (0, import_react.useContext)(DyteContext);
  if (!meeting)
    throw new Error("useDyteSelector must be used within the DyteProvider");
  const state = (0, import_react.useRef)(selector(meeting));
  const [, forceUpdate] = (0, import_react.useReducer)((c) => c + 1, 0);
  (0, import_react.useEffect)(() => {
    const currentState = meeting && selector(meeting);
    const listener = () => {
      const newStateSlice = meeting && selector(meeting);
      if (shouldUpdate(state.current, newStateSlice)) {
        state.current = newStateSlice;
        forceUpdate();
      }
    };
    if (currentState && typeof currentState === "object" && "addListener" in currentState) {
      currentState.addListener("*", forceUpdate);
      return () => {
        currentState.removeListener("*", forceUpdate);
      };
    }
    updates == null ? void 0 : updates.addListener(listener);
    return () => {
      updates == null ? void 0 : updates.removeListener(listener);
    };
  }, [meeting, updates]);
  return state.current;
};
export {
  DyteContext,
  DyteProvider,
  initDyteMedia,
  useDyteClient,
  useDyteMeeting,
  useDyteSelector
};
/*! Bundled license information:

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=@dytesdk_react-web-core.js.map
