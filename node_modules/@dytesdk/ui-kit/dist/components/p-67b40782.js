import { p as proxyCustomElement, H, h } from './p-1d5392d7.js';
import { d as debounce } from './p-a08b5a59.js';

const dyteVirtualizedParticipantListCss = ":host{height:100%;width:100%}";
const DyteVirtualizedParticipantListStyle0 = dyteVirtualizedParticipantListCss;

const DyteVirtualizedParticipantList = /*@__PURE__*/ proxyCustomElement(class DyteVirtualizedParticipantList extends H {
    constructor() {
        super();
        this.__registerHost();
        /** Items to be virtualized */
        this.items = [];
        /** Height of each item in pixels (assumed fixed) */
        this.itemHeight = 55; // Mutable so we can update it
        /** Buffer items to render before and after the visible area */
        this.bufferedItemsCount = 5;
        /** Element to render if list is empty */
        this.emptyListElement = null;
        this.visibleStart = 0; // Start of visible items
        this.visibleEnd = 0; // End of visible items
        this.containerHeight = 0; // Height of the container
        this.lastScrollTop = 0; // To track and restore scrollTop
        this.recalculatePositioning = () => {
            // Measure container height and update visible items
            this.updateContainerHeight();
            // Check for the first item height
            requestAnimationFrame(() => {
                this.updateItemHeight();
            });
        };
        this.updateContainerHeight = () => {
            if (!this.el.querySelector('.virtual-list-container').clientHeight) {
                return;
            }
            // Check for the first item height
            requestAnimationFrame(() => {
                this.updateItemHeight();
            });
            this.containerHeight = this.el.querySelector('.virtual-list-container').clientHeight;
            this.updateVisibleRange();
        };
        this.onScroll = debounce(() => {
            const scrollTop = this.el.querySelector('.virtual-list-container').scrollTop;
            if (scrollTop > this.lastScrollTop && this.visibleEnd === this.items.length) {
                return;
            }
            // Track scrollTop for resetting after re-render
            this.lastScrollTop = scrollTop;
            this.updateVisibleRange();
        });
    }
    itemsChanged() {
        this.recalculatePositioning();
    }
    componentDidLoad() {
        this.recalculatePositioning();
        // Set up the scroll event listener
        this.el.querySelector('.virtual-list-container').addEventListener('scroll', this.onScroll);
        window.addEventListener('resize', this.recalculatePositioning);
    }
    componentDidUpdate() {
        // Update item height if it changes
        this.updateItemHeight();
    }
    disconnectedCallback() {
        // Remove event listeners to prevent memory leaks
        this.el.querySelector('.virtual-list-container').removeEventListener('scroll', this.onScroll);
        window.removeEventListener('resize', this.recalculatePositioning);
    }
    updateVisibleRange() {
        // Get the current scroll position
        const scrollTop = this.el.querySelector('.virtual-list-container').scrollTop;
        // Calculate the start and end of visible items based on scroll position and item height
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        // Calculate the number of fully visible items and include an extra one if there's a partially visible one
        const visibleCount = Math.ceil(this.containerHeight / this.itemHeight);
        // The end index should include the buffer and partially visible item
        const endIndex = Math.min(this.items.length, startIndex + visibleCount + this.bufferedItemsCount);
        // Update the visible range in the component's state
        this.visibleStart = startIndex;
        this.visibleEnd = endIndex;
        // Reset the scroll position to ensure smooth rendering
        this.el.querySelector('.virtual-list-container').scrollTop = this.lastScrollTop;
    }
    updateItemHeight() {
        // Get the first rendered item
        const firstRenderedItem = this.el.querySelector('.virtual-list-item');
        if (firstRenderedItem) {
            // Temporarily remove the height style to let the browser compute natural height
            const originalHeight = firstRenderedItem.style.height;
            firstRenderedItem.style.height = 'auto'; // Let it take natural height
            // Measure the natural height
            const naturalHeight = firstRenderedItem.getBoundingClientRect().height;
            // Reapply the original height (if needed)
            if (originalHeight) {
                firstRenderedItem.style.height = originalHeight;
            }
            // Check if the measured height differs from the current itemHeight
            if (naturalHeight && Math.floor(naturalHeight) !== Math.floor(this.itemHeight)) {
                this.itemHeight = naturalHeight;
            }
        }
    }
    renderItems() {
        // Slice the items array to only render the visible and buffered items
        const visibleItems = this.items.slice(this.visibleStart, this.visibleEnd);
        // Render each visible item at the correct position using absolute positioning
        return visibleItems.map((item, index) => {
            const itemIndex = this.visibleStart + index;
            return (h("div", { class: "virtual-list-item", key: item.id, style: {
                    position: 'absolute',
                    top: `${itemIndex * this.itemHeight}px`,
                    height: `${this.itemHeight}px`,
                    width: '100%',
                } }, this.renderItem(item, itemIndex)));
        });
    }
    render() {
        var _a;
        const totalHeight = this.items.length * this.itemHeight; // Total height of the list
        return (h("div", { key: '1b37d3baa0af9ff413be304f5368849d20a47b23', class: "virtual-list-container", style: {
                position: 'relative',
                height: '100%',
                overflowX: 'hidden',
                overflowY: 'auto',
            } }, h("div", { key: '6bfd8b0993b3a78ea2317715e54c68cb4458ec5a', style: { height: `${totalHeight}px`, position: 'relative' } }, !((_a = this.items) === null || _a === void 0 ? void 0 : _a.length) ? this.emptyListElement : this.renderItems()), h("div", { key: 'c6917ed47b4f3d579809f0b620f94aaf25779137', style: { height: `${this.itemHeight}px` } })));
    }
    get el() { return this; }
    static get watchers() { return {
        "items": ["itemsChanged"]
    }; }
    static get style() { return DyteVirtualizedParticipantListStyle0; }
}, [0, "dyte-virtualized-participant-list", {
        "items": [16],
        "renderItem": [16],
        "itemHeight": [1026, "item-height"],
        "bufferedItemsCount": [2, "buffered-items-count"],
        "emptyListElement": [16],
        "visibleStart": [32],
        "visibleEnd": [32]
    }, undefined, {
        "items": ["itemsChanged"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["dyte-virtualized-participant-list"];
    components.forEach(tagName => { switch (tagName) {
        case "dyte-virtualized-participant-list":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, DyteVirtualizedParticipantList);
            }
            break;
    } });
}
defineCustomElement();

export { DyteVirtualizedParticipantList as D, defineCustomElement as d };
