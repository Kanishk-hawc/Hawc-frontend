import { d as defaultConfig } from './ui-store-9dd5dd86.js';
export { B as BreakoutRoomsManager, d as defaultConfig, a as defaultIconPack, b as defaultLanguage, g as getInitialStates, u as uiStore, c as useLanguage } from './ui-store-9dd5dd86.js';
import { g as generateConfig } from './config-12515769.js';
export { e as extendConfig, g as generateConfig, p as provideDyteDesignSystem } from './config-12515769.js';
export { D as DyteNotificationsAudio } from './notification-6be43350.js';
export { g as generateChatGroupKey, a as getChatGroups, c as getParticipantUserId, b as getUnreadChatCounts } from './chat-8cb0e3a4.js';
import './index-08f4416b.js';
import './keysIn-310f65c1.js';
import './isObjectLike-773b9473.js';
import './logger-31448943.js';

/**
 * Send notification which will be displayed in the `<dyte-notifications />` component.
 * @param notification Notification object
 * @param playSound Sound type, if sound type is sent plays that sound with the notification.
 * @returns Return value of emitting the event
 */
const sendNotification = (notification, playSound = undefined) => {
    if (typeof document === 'undefined')
        return false;
    const event = new CustomEvent('dyteNotification', {
        detail: Object.assign(Object.assign({}, notification), { playSound }),
        composed: true,
    });
    return document.dispatchEvent(event);
};

/* eslint-disable no-console */
/*
    Elements can be of two types
    'dyte-mic-toggle' or ['dyte-mic-toggle', {prop: 1}]
    Custom findByName function to check for both
*/
function getFinder(query) {
    return (value) => {
        if (Array.isArray(value)) {
            return value[0] === query;
        }
        return value === query;
    };
}
/*
    Elements can be of two types
    'dyte-mic-toggle' or ['dyte-mic-toggle', {prop: 1}]
    Custom filterByName function to check for both
*/
function getFilter(query) {
    return (value) => {
        if (Array.isArray(value)) {
            return value[0] !== query;
        }
        return value !== query;
    };
}
/*
    transform JSX Component Name -> web component format
    eg. DyteMicToggle -> dyte-mic-toggle
*/
function convertComponentName(jsxName) {
    return jsxName.replace(/([a-z])([A-Z])/g, (g) => `${g[0]}-${g[1]}`.toLowerCase());
}
class UIElemEditor {
    constructor(elem, config, keyString) {
        this.elem = elem;
        this.config = config;
        this.keyString = keyString;
    }
    /**
     * Adds an element to the chilren
     * @param el :Name of the element - `dyte-mic-toggle`
     * @param props :Optional props for the element `{variant: 'solid'}`
     */
    add(el, props = {}) {
        var _a;
        el = convertComponentName(el);
        let composedElem = el;
        if (Object.keys(props).length > 0) {
            composedElem = [el, props];
        }
        if (Array.isArray(this.elem)) {
            this.elem.push(composedElem);
        }
        else if ('children' in this.elem && Array.isArray(this.elem.children)) {
            this.elem.children = [...this.elem.children, composedElem];
        }
        else if ('remove' in this.elem &&
            Array.isArray(this.elem.remove) &&
            this.elem.remove.find(getFinder(el))) {
            this.elem.remove = this.elem.remove.filter(getFilter(el));
        }
        else {
            if (!('add' in this.elem)) {
                this.elem.add = [];
            }
            (_a = this.elem.add) === null || _a === void 0 ? void 0 : _a.push(composedElem);
        }
        return this;
    }
    /**
     * Removes an element from the chilren
     * @param el :Name of the element to remove - `dyte-mic-toggle`
     */
    remove(el) {
        var _a;
        el = convertComponentName(el);
        if (Array.isArray(this.elem)) {
            const idx = this.elem.findIndex(getFinder(el));
            if (idx > -1) {
                this.elem.splice(idx, 1);
            }
        }
        else if ('children' in this.elem && Array.isArray(this.elem.children)) {
            this.elem.children = this.elem.children.filter(getFilter(el));
        }
        else if ('add' in this.elem &&
            Array.isArray(this.elem.add) &&
            this.elem.add.find((e) => e === el)) {
            this.elem.add = this.elem.add.filter(getFilter(el));
        }
        else {
            if (!('remove' in this.elem)) {
                this.elem.remove = [];
            }
            (_a = this.elem.remove) === null || _a === void 0 ? void 0 : _a.push(el);
        }
        return this;
    }
    set style(s) {
        console.log(s);
        // TODO: Not Implemented
    }
    setChildrenProps(childElem, props) {
        console.log(this.keyString, childElem, props);
        // TODO: Not Implemented
    }
    getChildrenProps(childElem) {
        console.log(this.keyString, childElem);
        // TODO: Not Implemented
        return {};
    }
    replace(e) {
        console.log(this.config, e);
        // TODO: Not Implemented
    }
}
/* eslint-enable no-console */
class DyteUIBuilder {
    constructor(config) {
        this.config = config || defaultConfig;
    }
    /**
     * Find an element anywhere in the Dyte hierarachy and returns an editor object
     * @param elem = 'dyte-participant-tile'
     * @param states = { activeSidebar: true, activeSettings: true, meeting: 'joined'}
     * @returns `UIElemEditor`
     */
    find(elem, states = {}) {
        elem = convertComponentName(elem);
        // eg. [activeSidebar, activeSettings]
        const booleanStates = [];
        // eg. [[meeting,joined]]
        const nonBooleanStates = [];
        Object.keys(states || {}).forEach((key) => {
            if (typeof states[key] === 'boolean') {
                booleanStates.push(key);
            }
            else {
                nonBooleanStates.push([key, states[key]]);
            }
        });
        booleanStates.sort();
        const root = this.config.root;
        if (root === undefined)
            return;
        let keyString = elem;
        let booleanStateString = '';
        if (booleanStates.length > 0) {
            // eg. '.activeSettings.activeSidebar'
            booleanStateString = `.${booleanStates.join('.')}`;
            // eg. 'dyte-participant-tile.activeSettings.activeSidebar'
            keyString = `${elem}${booleanStateString}`;
            // An element will only re-render when a state described in its `states` key changes
            // If the element has no states defined, ie. just array of children
            // convert to a complex element type
            if (Array.isArray(root[elem])) {
                root[elem] = {
                    states: [],
                    children: root[elem],
                };
            }
            if (root[elem].states === undefined) {
                root[elem].states = [];
            }
            // Add each boolean state if it is not there already
            booleanStates.forEach((e) => {
                var _a, _b;
                if (((_a = root[elem].states) === null || _a === void 0 ? void 0 : _a.indexOf(e)) === -1) {
                    (_b = root[elem].states) === null || _b === void 0 ? void 0 : _b.push(e);
                }
            });
        }
        if (nonBooleanStates.length > 0) {
            nonBooleanStates.forEach((k) => {
                // eg. '[meeting=joined]'
                const v = `[${k[0]}=${k[1]}]`;
                // eg. 'dyte-participant-tile[meeting=joined].activeSettings.activeSidebar'
                keyString = `${elem}${v}${booleanStateString}`;
                // An element will only re-render when a state described in its `states` key changes
                // If the element has no states defined, ie. just array of children
                // convert to a complex element type
                if (Array.isArray(root[elem])) {
                    root[elem] = {
                        state: k[0],
                        children: root[elem],
                    };
                }
            });
        }
        let target = root[keyString];
        if (target === undefined) {
            root[keyString] = {};
            target = root[keyString];
        }
        return new UIElemEditor(target, this.config, keyString);
    }
    build() {
        return this.config;
    }
}

/**
 * Register addons to the meeting
 * @param addons The list of addons to register
 * @param meeting The meeting object
 * @param config The current UIConfig
 * @returns The updated UIConfig
 */
function registerAddons(addons, meeting, config) {
    if (!config) {
        const generated = generateConfig(meeting.self.config, meeting);
        config = generated.config;
    }
    addons.map((addon) => {
        config = addon.register(config, meeting, (c) => new DyteUIBuilder(c));
    });
    return config;
}

export { DyteUIBuilder, registerAddons, sendNotification };
