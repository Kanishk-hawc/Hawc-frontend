import DyteClient, { DyteSelfMedia as DyteSelfMedia$1, MediaConstraints, CachedUserDetails, DyteClientOptions } from '@dytesdk/web-core';
import * as react_jsx_runtime from 'react/jsx-runtime';
import React, { ReactNode } from 'react';

type Listener = () => void;
declare class DyteUpdates {
    private meeting;
    private l;
    constructor(meeting: DyteClient);
    clean(): void;
    addListener(listener: Listener): void;
    removeListener(listener: Listener): void;
    private onUpdate;
}
declare const DyteContext: React.Context<{
    meeting: DyteClient | undefined;
    updates: DyteUpdates | undefined;
}>;
/**
 * Provider component which makes the DyteClient object
 * available to nested components
 * @component
 * @param value The DyteClient instance from `useDyteClient()`
 * @param fallback Any fallback UI you want to render until the instance initialises.
 */
declare function DyteProvider({ value, children, fallback, }: {
    value: DyteClient | undefined;
    children: ReactNode;
    fallback?: ReactNode;
}): react_jsx_runtime.JSX.Element;
/**
 * Hook which returns the reference to the DyteClient object
 * @returns meeting instance from `useDyteClient()`
 */
declare const useDyteMeeting: () => {
    meeting: DyteClient;
};

interface DyteClientParams {
    resetOnLeave?: boolean;
}
type DyteSelfMedia = Pick<DyteSelfMedia$1, 'addAudioMiddleware' | 'addVideoMiddleware' | 'audioEnabled' | 'audioTrack' | 'disableAudio' | 'disableScreenShare' | 'disableVideo' | 'enableAudio' | 'enableScreenShare' | 'enableVideo' | 'getAudioDevices' | 'getCurrentDevices' | 'getDeviceById' | 'getSpeakerDevices' | 'getVideoDevices' | 'init' | 'mediaPermissions' | 'rawAudioTrack' | 'rawVideoTrack' | 'removeAllAudioMiddlewares' | 'removeAllVideoMiddlewares' | 'removeVideoMiddleware' | 'removeAudioMiddleware' | 'screenShareEnabled' | 'screenShareTracks' | 'setDevice' | 'videoEnabled' | 'videoTrack' | 'setVideoMiddlewareGlobalConfig'>;
/**
 * Hook to initialise media before initialising DyteClient
 */
declare const initDyteMedia: (options?: {
    video?: boolean;
    audio?: boolean;
    constraints?: MediaConstraints;
}, skipAwaits?: boolean, cachedUserDetails?: CachedUserDetails | undefined) => DyteSelfMedia;
/**
 * Hook which manages a DyteClient instance
 */
declare const useDyteClient: (dyteClientParams?: DyteClientParams) => readonly [DyteClient | undefined, (options: DyteClientOptions) => Promise<DyteClient | undefined>];
type StateSelector<T extends object, U> = (state: T) => U;
/**
 * Hook which extracts data from the DyteClient object
 */
declare const useDyteSelector: <StateSlice>(selector: StateSelector<DyteClient, StateSlice>) => StateSlice;

export { DyteContext, DyteProvider, DyteSelfMedia, initDyteMedia, useDyteClient, useDyteMeeting, useDyteSelector };
