var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import React, { createContext, useState, useRef, useEffect, useContext, useCallback, useReducer } from "react";
import DyteClient from "@dytesdk/web-core";
class DyteUpdates {
  constructor(meeting) {
    __publicField(this, "meeting");
    __publicField(this, "l");
    __publicField(this, "onUpdate", () => {
      this.l.forEach((l) => {
        l();
      });
    });
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    this.meeting = meeting;
    this.l = /* @__PURE__ */ new Set();
    (_a = this.meeting.self) == null ? void 0 : _a.addListener("*", this.onUpdate);
    (_b = this.meeting.meta) == null ? void 0 : _b.addListener("*", this.onUpdate);
    (_c = this.meeting.participants) == null ? void 0 : _c.addListener("*", this.onUpdate);
    (_e = (_d = this.meeting.participants) == null ? void 0 : _d.joined) == null ? void 0 : _e.addListener("*", this.onUpdate);
    (_g = (_f = this.meeting.participants) == null ? void 0 : _f.active) == null ? void 0 : _g.addListener("*", this.onUpdate);
    (_i = (_h = this.meeting.participants) == null ? void 0 : _h.waitlisted) == null ? void 0 : _i.addListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.addListener("*", this.onUpdate);
    (_k = this.meeting.livestream) == null ? void 0 : _k.addListener("*", this.onUpdate);
    (_l = this.meeting.chat) == null ? void 0 : _l.addListener("*", this.onUpdate);
    (_m = this.meeting.plugins) == null ? void 0 : _m.all.addListener("*", this.onUpdate);
    (_n = this.meeting.recording) == null ? void 0 : _n.addListener("*", this.onUpdate);
    (_o = this.meeting.connectedMeetings) == null ? void 0 : _o.addListener("*", this.onUpdate);
    (_p = this.meeting.polls) == null ? void 0 : _p.addListener("*", this.onUpdate);
  }
  clean() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    (_a = this.meeting.self) == null ? void 0 : _a.removeListener("*", this.onUpdate);
    (_b = this.meeting.meta) == null ? void 0 : _b.removeListener("*", this.onUpdate);
    (_c = this.meeting.participants) == null ? void 0 : _c.removeListener("*", this.onUpdate);
    (_e = (_d = this.meeting.participants) == null ? void 0 : _d.joined) == null ? void 0 : _e.removeListener("*", this.onUpdate);
    (_g = (_f = this.meeting.participants) == null ? void 0 : _f.active) == null ? void 0 : _g.removeListener("*", this.onUpdate);
    (_i = (_h = this.meeting.participants) == null ? void 0 : _h.waitlisted) == null ? void 0 : _i.removeListener("*", this.onUpdate);
    (_j = this.meeting.stage) == null ? void 0 : _j.removeListener("*", this.onUpdate);
    (_k = this.meeting.livestream) == null ? void 0 : _k.removeListener("*", this.onUpdate);
    (_l = this.meeting.chat) == null ? void 0 : _l.removeListener("*", this.onUpdate);
    (_m = this.meeting.plugins) == null ? void 0 : _m.all.removeListener("*", this.onUpdate);
    (_n = this.meeting.recording) == null ? void 0 : _n.removeListener("*", this.onUpdate);
    (_o = this.meeting.connectedMeetings) == null ? void 0 : _o.removeListener("*", this.onUpdate);
    (_p = this.meeting.polls) == null ? void 0 : _p.removeListener("*", this.onUpdate);
  }
  addListener(listener) {
    this.l.add(listener);
  }
  removeListener(listener) {
    this.l.delete(listener);
  }
}
const DyteContext = createContext({
  meeting: void 0,
  updates: void 0
});
function DyteProvider({
  value,
  children,
  fallback
}) {
  const [updates, setUpdates] = useState();
  const updatesRef = useRef();
  useEffect(() => {
    if (value) {
      setUpdates(new DyteUpdates(value));
    }
    return () => {
      var _a;
      (_a = updatesRef.current) == null ? void 0 : _a.clean();
    };
  }, [value]);
  return /* @__PURE__ */ React.createElement(DyteContext.Provider, {
    value: {
      meeting: value,
      updates
    }
  }, value ? children : fallback);
}
const useDyteMeeting = () => {
  const { meeting } = useContext(DyteContext);
  if (!meeting)
    throw new Error("useDyteMeeting must be used within the DyteProvider");
  return { meeting };
};
const initDyteMedia = (options = {}, skipAwaits = false, cachedUserDetails = void 0) => DyteClient.initMedia(options, skipAwaits, cachedUserDetails);
const useDyteClient = (dyteClientParams) => {
  const isRunning = useRef(false);
  const [client, setClient] = useState();
  const resetOnLeave = dyteClientParams == null ? void 0 : dyteClientParams.resetOnLeave;
  const initClient = useCallback(async (options) => {
    if (isRunning.current)
      return void 0;
    isRunning.current = true;
    return DyteClient.init(options).then((meeting) => {
      setClient(meeting);
      return meeting;
    }).finally(() => {
      isRunning.current = false;
    });
  }, []);
  useEffect(() => {
    if (!client || !resetOnLeave)
      return () => {
      };
    const onLeave = ({ state }) => {
      if (state !== "connected-meeting" && state !== "disconnected") {
        setClient(void 0);
      }
    };
    client.self.on("roomLeft", onLeave);
    return () => {
      client.self.removeListener("roomLeft", onLeave);
    };
  }, [client]);
  useEffect(() => {
    if (!client || !client.connectedMeetings)
      return () => {
      };
    const onMeetingChanged = (newClient) => {
      setClient(void 0);
      setTimeout(() => {
        setClient(newClient);
      }, 100);
    };
    client.connectedMeetings.on("meetingChanged", onMeetingChanged);
    return () => {
      client.connectedMeetings.removeListener("meetingChanged", onMeetingChanged);
    };
  }, [client]);
  return [client, initClient];
};
const shouldUpdate = (slice, newSlice) => {
  if (slice !== newSlice) {
    return true;
  }
  if (Array.isArray(slice) && Array.isArray(newSlice)) {
    if (slice.length !== newSlice.length) {
      return true;
    }
  }
  return false;
};
const useDyteSelector = (selector) => {
  const { meeting, updates } = useContext(DyteContext);
  if (!meeting)
    throw new Error("useDyteSelector must be used within the DyteProvider");
  const state = useRef(selector(meeting));
  const [, forceUpdate] = useReducer((c) => c + 1, 0);
  useEffect(() => {
    const currentState = meeting && selector(meeting);
    const listener = () => {
      const newStateSlice = meeting && selector(meeting);
      if (shouldUpdate(state.current, newStateSlice)) {
        state.current = newStateSlice;
        forceUpdate();
      }
    };
    if (currentState && typeof currentState === "object" && "addListener" in currentState) {
      currentState.addListener("*", forceUpdate);
      return () => {
        currentState.removeListener("*", forceUpdate);
      };
    }
    updates == null ? void 0 : updates.addListener(listener);
    return () => {
      updates == null ? void 0 : updates.removeListener(listener);
    };
  }, [meeting, updates]);
  return state.current;
};
export { DyteContext, DyteProvider, initDyteMedia, useDyteClient, useDyteMeeting, useDyteSelector };
