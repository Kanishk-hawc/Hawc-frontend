var QS = Object.defineProperty, XS = Object.defineProperties;
var ZS = Object.getOwnPropertyDescriptors;
var ed = Object.getOwnPropertySymbols, ev = Object.getPrototypeOf, Xh = Object.prototype.hasOwnProperty, Zh = Object.prototype.propertyIsEnumerable, tv = Reflect.get;
var ep = Math.pow, iu = (s, t, e) => t in s ? QS(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e, D = (s, t) => {
  for (var e in t || (t = {}))
    Xh.call(t, e) && iu(s, e, t[e]);
  if (ed)
    for (var e of ed(t))
      Zh.call(t, e) && iu(s, e, t[e]);
  return s;
}, B = (s, t) => XS(s, ZS(t));
var ho = (s, t) => {
  var e = {};
  for (var r in s)
    Xh.call(s, r) && t.indexOf(r) < 0 && (e[r] = s[r]);
  if (s != null && ed)
    for (var r of ed(s))
      t.indexOf(r) < 0 && Zh.call(s, r) && (e[r] = s[r]);
  return e;
};
var h = (s, t, e) => (iu(s, typeof t != "symbol" ? t + "" : t, e), e), au = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var a = (s, t, e) => (au(s, t, "read from private field"), e ? e.call(s) : t.get(s)), g = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, m = (s, t, e, r) => (au(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e);
var L = (s, t, e) => (au(s, t, "access private method"), e), tp = (s, t, e) => tv(ev(s), e, t);
var u = (s, t, e) => new Promise((r, i) => {
  var n = (d) => {
    try {
      c(e.next(d));
    } catch (l) {
      i(l);
    }
  }, o = (d) => {
    try {
      c(e.throw(d));
    } catch (l) {
      i(l);
    }
  }, c = (d) => d.done ? r(d.value) : Promise.resolve(d.value).then(n, o);
  c((e = e.apply(s, t)).next());
});
import { v4 as ua, validate as Jg } from "uuid";
import Kg from "bowser";
import { MessageType as v, PbLong as po, typeofJsonValue as sv } from "@protobuf-ts/runtime";
import * as ud from "worker-timers";
import * as cs from "sdp-transform";
function rv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
Array.prototype.at || Object.assign(Array.prototype, { at: rv });
function iv(s) {
  const { length: t } = this, e = s >= 0 ? s : t + s;
  return e < 0 || e >= t ? void 0 : this[e];
}
String.prototype.at || Object.assign(String.prototype, { at: iv });
const av = (s) => {
  !navigator.isReactNative && typeof window != "undefined" && (window.addEventListener("error", (t) => {
    var e;
    !((e = t.filename) != null && e.includes("localhost")) && t.lineno !== 0 && s.error(
      "window::error",
      {
        error: t.error
      },
      !0
    );
  }), window.addEventListener(
    "unhandledrejection",
    (t) => {
      var e, r, i, n, o, c, d, l;
      s.error(
        "window::unhandledrejection",
        {
          error: t == null ? void 0 : t.reason,
          /**
                             * NOTE(ravindra-dyte):
                             * Network calls fail a lot for clients,
                             *	tracking more info to see where
                             *	*/
          networkCall: {
            url: (r = (e = t == null ? void 0 : t.reason) == null ? void 0 : e.config) == null ? void 0 : r.url,
            baseURL: (n = (i = t == null ? void 0 : t.reason) == null ? void 0 : i.config) == null ? void 0 : n.baseURL,
            method: (c = (o = t == null ? void 0 : t.reason) == null ? void 0 : o.config) == null ? void 0 : c.method,
            status: (d = t == null ? void 0 : t.reason) == null ? void 0 : d.status,
            statusText: (l = t == null ? void 0 : t.reason) == null ? void 0 : l.statusText
          }
        },
        !0
      );
    }
  ), window.addEventListener("offline", () => {
    s.info("window::offline");
  }), window.addEventListener("online", () => {
    s.info("window::online");
  }));
}, Vo = "chrome", zg = "opera", Yg = "firefox", Qg = "iexplorer", Xg = "safari", Zg = "nwjs", em = "electron", tm = "react-native", Sh = "unknown", wd = {
  Chrome: Vo,
  Chromium: Vo,
  Opera: zg,
  Firefox: Yg,
  "Internet Explorer": Qg,
  Safari: Xg
};
function nv() {
  const { userAgent: s } = navigator, t = {
    name: Sh,
    version: void 0
  };
  if (s.match(/Chrome/) && !s.match(/Edge/))
    if (s.match(/Edg(A?)/)) {
      const e = s.match(/Chrome\/([\d.]+)/)[1];
      Number.parseInt(e, 10) > 72 && (t.name = Vo, t.version = e);
    } else
      t.name = Vo, t.version = s.match(/Chrome\/([\d.]+)/)[1];
  return t;
}
function ov() {
  const { userAgent: s } = navigator;
  if (s.match(/Electron/)) {
    const t = s.match(/Electron\/([\d.]+)/)[1];
    return {
      name: em,
      version: t
    };
  }
  return null;
}
function cv() {
  const { userAgent: s } = navigator;
  if (s.match(/JitsiMeetNW/)) {
    const t = s.match(/JitsiMeetNW\/([\d.]+)/)[1];
    return {
      name: Zg,
      version: t
    };
  }
}
function dv() {
  const s = navigator.userAgent.match(
    /\b(react[ \t_-]*native)(?:\/(\S+))?/i
  );
  let t;
  if (s || navigator.product === "ReactNative")
    return s && s.length > 2 && (s[1], t = s[2]), t || (t = "unknown"), {
      name: tm,
      version: t
    };
}
function lv(s) {
  let t;
  const e = [dv, ov, cv];
  for (let i = 0; i < e.length; i += 1)
    if (t = e[i](), t)
      return t;
  const r = s.getBrowserName();
  return r in wd ? {
    name: wd[r],
    version: s.getBrowserVersion()
  } : (t = nv(), t || {
    name: Sh,
    version: void 0
  });
}
class uv {
  constructor() {
    h(this, "_bowser");
    h(this, "_name");
    h(this, "_version");
    h(this, "getDeviceInfo", () => ({
      isMobile: this.isMobile(),
      browserName: this._bowser.getBrowserName(),
      osName: this._bowser.getOSName(),
      browserVersion: this._bowser.getBrowserVersion(),
      osVersionName: this._bowser.getOSVersion(),
      engineName: this._bowser.getEngineName()
    }));
  }
  /**
   * Creates new BrowserDetection instance.
   *
   * @param {Object} [browserInfo] - Information about the browser.
   * @param {string} browserInfo.name - The name of the browser.
   * @param {string} browserInfo.version - The version of the browser.
   */
  init(t) {
    let e, r;
    if (this._bowser = Kg.getParser(navigator.userAgent), typeof t == "undefined") {
      const i = lv(this._bowser);
      e = i.name, r = i.version;
    } else
      t.name in wd ? (e = wd[t.name], r = t.version) : (e = Sh, r = void 0);
    this._name = e, this._version = r;
  }
  /**
   * Gets current browser name.
   * @returns {string}
   */
  getName() {
    return this._name;
  }
  /**
   * Checks if current browser is Chrome.
   * @returns {boolean}
   */
  isChrome() {
    return this._name === Vo;
  }
  /**
   * Checks if current browser is Opera.
   * @returns {boolean}
   */
  isOpera() {
    return this._name === zg;
  }
  /**
   * Checks if current browser is Firefox.
   * @returns {boolean}
   */
  isFirefox() {
    return this._name === Yg;
  }
  /**
   * Checks if current browser is Internet Explorer.
   * @returns {boolean}
   */
  isIExplorer() {
    return this._name === Qg;
  }
  /**
   * Checks if current browser is Safari.
   * @returns {boolean}
   */
  isSafari() {
    return this._name === Xg;
  }
  /**
   * Checks if current environment is NWJS.
   * @returns {boolean}
   */
  isNWJS() {
    return this._name === Zg;
  }
  /**
   * Checks if current environment is Electron.
   * @returns {boolean}
   */
  isElectron() {
    return this._name === em;
  }
  /**
   * Checks if current environment is React Native.
   * @returns {boolean}
   */
  isReactNative() {
    return this._name === tm || navigator.isReactNative === !0;
  }
  /**
   * Returns the version of the current browser.
   * @returns {string}
   */
  getVersion() {
    return this._version;
  }
  isMobile() {
    return this._bowser.getPlatformType() === "mobile";
  }
  /**
   * Check if the parsed browser matches the passed condition.
   *
   * @param {Object} checkTree - It's one or two layered object, which can include a
   * platform or an OS on the first layer and should have browsers specs on the
   * bottom layer.
   * Eg. { chrome: '>71.1.0' }
   *		 { windows: { chrome: '<70.2' } }
   * @returns {boolean | undefined} - Returns true if the browser satisfies the set
   * conditions, false if not and undefined when the browser is not defined in the
   * checktree object or when the current browser's version is unknown.
   * @private
   */
  _checkCondition(t) {
    if (this._version)
      return this._bowser.satisfies(t);
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * greater than the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   */
  isVersionGreaterThan(t) {
    return this._checkCondition({ [this._name]: `>${t}` });
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * lower than the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   */
  isVersionLessThan(t) {
    return this._checkCondition({ [this._name]: `<${t}` });
  }
  /**
   * Compares the passed version with the current browser version.
   *
   * @param {*} version - The version to compare with. Anything different
   * than string will be converted to string.
   * @returns {boolean|undefined} - Returns true if the current version is
   * equal to the passed version and false otherwise. Returns undefined if
   * the current browser version is unknown.
   * A loose-equality operator is used here so that it matches the sub-versions as well.
   */
  isVersionEqualTo(t) {
    return this._checkCondition({ [this._name]: `~${t}` });
  }
}
class hv extends uv {
  /**
   * Tells whether or not the <tt>MediaStream/tt> is removed from
   * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn
   * off the camera device).
   * @return {boolean} <tt>true</tt> if the current browser supports this
   * strategy or <tt>false</tt> otherwise.
   */
  doesVideoMuteByStreamRemove() {
    return this.isChromiumBased() || this.isWebKitBased();
  }
  /**
   * Check whether or not the current browser support peer to peer connections
   * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>
   * otherwise.
   */
  supportsP2P() {
    return !this.usesUnifiedPlan();
  }
  /**
   * Checks if the current browser is Chromium based, that is, it's either
   * Chrome / Chromium or uses it as its engine, but doesn't identify as
   * Chrome.
   *
   * This includes the following browsers:
   * - Chrome and Chromium
   * - Other browsers which use the Chrome engine, but are detected as Chrome,
   *	 such as Brave and Vivaldi
   * - Browsers which are NOT Chrome but use it as their engine, and have
   *	 custom detection code: Opera, Electron and NW.JS
   */
  isChromiumBased() {
    return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera();
  }
  /**
   * Checks if the current browser is WebKit based. It's either
   * Safari or uses WebKit as its engine.
   *
   * This includes Chrome and Firefox on iOS
   *
   * @returns {boolean}
   */
  isWebKitBased() {
    return this._bowser.isEngine("webkit") && typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getUserMedia != "undefined" && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1;
  }
  /**
   * Checks if the current browser is supported.
   *
   * @returns {boolean} true if the browser is supported, false otherwise.
   */
  isSupported() {
    return typeof RTCPeerConnection != "undefined";
  }
  /**
   * Returns whether or not the current environment needs a user interaction
   * with the page before any unmute can occur.
   *
   * @returns {boolean}
   */
  isUserInteractionRequiredForUnmute() {
    return this.isFirefox() && this.isVersionLessThan("68");
  }
  /**
   * Checks if the current browser triggers 'onmute'/'onunmute' events when
   * user's connection is interrupted and the video stops playback.
   * @returns {*|boolean} 'true' if the event is supported or 'false'
   * otherwise.
   */
  supportsVideoMuteOnConnInterrupted() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the current browser reports upload and download bandwidth
   * statistics.
   * @return {boolean}
   */
  supportsBandwidthStatistics() {
    return !this.isFirefox() && !this.isWebKitBased();
  }
  /**
   * Checks if the current browser supports setting codec preferences on the transceiver.
   * @returns {boolean}
   */
  supportsCodecPreferences() {
    return this.usesUnifiedPlan() && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(window.RTCRtpTransceiver.prototype).indexOf(
      "setCodecPreferences"
    ) > -1 && Object.keys(RTCRtpSender.prototype).indexOf("getCapabilities") > -1 && !this.isWebKitBased();
  }
  /**
   * Checks if the current browser support the device change event.
   * @return {boolean}
   */
  // eslint-disable-next-line class-methods-use-this
  supportsDeviceChangeEvent() {
    return navigator.mediaDevices && typeof navigator.mediaDevices.ondevicechange != "undefined" && typeof navigator.mediaDevices.addEventListener != "undefined";
  }
  /**
   * Checks if the current browser supports RTT statistics for srflx local
   * candidates through the legacy getStats() API.
   */
  supportsLocalCandidateRttStatistics() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the current browser supports the Long Tasks API that lets us observe
   * performance measurement events and be notified of tasks that take longer than
   * 50ms to execute on the main thread.
   */
  supportsPerformanceObserver() {
    return typeof window.PerformanceObserver != "undefined" && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1;
  }
  /**
   * Checks if the current browser supports audio level stats on the receivers.
   */
  supportsReceiverStats() {
    return typeof window.RTCRtpReceiver != "undefined" && Object.keys(RTCRtpReceiver.prototype).indexOf(
      "getSynchronizationSources"
    ) > -1;
  }
  /**
   * Checks if the current browser reports round trip time statistics for
   * the ICE candidate pair.
   * @return {boolean}
   */
  supportsRTTStatistics() {
    return !this.isFirefox();
  }
  /**
   * Checks if the browser uses plan B.
   *
   * @returns {boolean}
   */
  usesPlanB() {
    return !this.usesUnifiedPlan();
  }
  /**
   * Checks if the browser uses SDP munging for turning on simulcast.
   *
   * @returns {boolean}
   */
  usesSdpMungingForSimulcast() {
    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
  }
  /**
   * Checks if the browser uses unified plan.
   *
   * @returns {boolean}
   */
  usesUnifiedPlan() {
    return !!(this.isFirefox() || this.isWebKitBased());
  }
  /**
   * Returns whether or not the current browser should be using the new
   * getUserMedia flow, which utilizes the adapter shim. This method should
   * be temporary and used while migrating all browsers to use adapter and
   * the new getUserMedia.
   *
   * @returns {boolean}
   */
  usesNewGumFlow() {
    return !!(this.isChromiumBased() || this.isFirefox() || this.isWebKitBased());
  }
  /**
   * Checks if the browser uses webrtc-adapter. All browsers using the new
   * getUserMedia flow.
   *
   * @returns {boolean}
   */
  usesAdapter() {
    return this.usesNewGumFlow();
  }
  /**
   * Checks if the browser uses RIDs/MIDs for siganling the simulcast streams
   * to the bridge instead of the ssrcs.
   */
  usesRidsForSimulcast() {
    return !1;
  }
  /**
   * Checks if the browser supports getDisplayMedia.
   * @returns {boolean} {@code true} if the browser supports getDisplayMedia.
   */
  supportsGetDisplayMedia() {
    return typeof navigator.getDisplayMedia != "undefined" || typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getDisplayMedia != "undefined";
  }
  /**
   * Checks if the browser supports insertable streams, needed for E2EE.
   * @returns {boolean} {@code true} if the browser supports insertable streams.
   */
  supportsInsertableStreams() {
    if (!(typeof window.RTCRtpSender != "undefined" && (window.RTCRtpSender.prototype.createEncodedStreams || window.RTCRtpSender.prototype.createEncodedVideoStreams)))
      return !1;
    const t = new ReadableStream();
    try {
      return window.postMessage(t, "*", [t]), !0;
    } catch (e) {
      return !1;
    }
  }
  /**
   * Whether the browser supports the RED format for audio.
   */
  supportsAudioRed() {
    return Boolean(
      window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      ) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some(
        (t) => t.mimeType === "audio/red"
      )
    );
  }
  /**
   * Checks if the browser supports the "sdpSemantics" configuration option.
   * https://webrtc.org/web-apis/chrome/unified-plan/
   *
   * @returns {boolean}
   */
  supportsSdpSemantics() {
    return this.isChromiumBased();
  }
  /**
   * Returns the version of a Chromium based browser.
   *
   * @returns {Number}
   */
  _getChromiumBasedVersion() {
    if (this.isChromiumBased()) {
      if (this.isNWJS())
        return Number.parseInt(process.versions.chromium, 10);
      const t = navigator.userAgent;
      if (t.match(/Chrome/))
        return Number.parseInt(t.match(/Chrome\/([\d.]+)/)[1], 10);
    }
    return -1;
  }
  isIOSMobile() {
    return this.isMobile && this._bowser.getOSName() === "iOS";
  }
}
const Te = new hv();
var ut = {}, pv = {
  get exports() {
    return ut;
  },
  set exports(s) {
    ut = s;
  }
}, La = typeof Reflect == "object" ? Reflect : null, sp = La && typeof La.apply == "function" ? La.apply : function(t, e, r) {
  return Function.prototype.apply.call(t, e, r);
}, hd;
La && typeof La.ownKeys == "function" ? hd = La.ownKeys : Object.getOwnPropertySymbols ? hd = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : hd = function(t) {
  return Object.getOwnPropertyNames(t);
};
function gv(s) {
  console && console.warn && console.warn(s);
}
var sm = Number.isNaN || function(t) {
  return t !== t;
};
function ce() {
  ce.init.call(this);
}
pv.exports = ce;
ut.once = vv;
ce.EventEmitter = ce;
ce.prototype._events = void 0;
ce.prototype._eventsCount = 0;
ce.prototype._maxListeners = void 0;
var rp = 10;
function xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(ce, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return rp;
  },
  set: function(s) {
    if (typeof s != "number" || s < 0 || sm(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    rp = s;
  }
});
ce.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
ce.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || sm(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function rm(s) {
  return s._maxListeners === void 0 ? ce.defaultMaxListeners : s._maxListeners;
}
ce.prototype.getMaxListeners = function() {
  return rm(this);
};
ce.prototype.emit = function(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e.push(arguments[r]);
  var i = t === "error", n = this._events;
  if (n !== void 0)
    i = i && n.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (e.length > 0 && (o = e[0]), o instanceof Error)
      throw o;
    var c = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw c.context = o, c;
  }
  var d = n[t];
  if (d === void 0)
    return !1;
  if (typeof d == "function")
    sp(d, this, e);
  else
    for (var l = d.length, p = cm(d, l), r = 0; r < l; ++r)
      sp(p[r], this, e);
  return !0;
};
function im(s, t, e, r) {
  var i, n, o;
  if (xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = rm(s), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, gv(c);
  }
  return s;
}
ce.prototype.addListener = function(t, e) {
  return im(this, t, e, !1);
};
ce.prototype.on = ce.prototype.addListener;
ce.prototype.prependListener = function(t, e) {
  return im(this, t, e, !0);
};
function mv() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function am(s, t, e) {
  var r = { fired: !1, wrapFn: void 0, target: s, type: t, listener: e }, i = mv.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
ce.prototype.once = function(t, e) {
  return xl(e), this.on(t, am(this, t, e)), this;
};
ce.prototype.prependOnceListener = function(t, e) {
  return xl(e), this.prependListener(t, am(this, t, e)), this;
};
ce.prototype.removeListener = function(t, e) {
  var r, i, n, o, c;
  if (xl(e), i = this._events, i === void 0)
    return this;
  if (r = i[t], r === void 0)
    return this;
  if (r === e || r.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || e));
  else if (typeof r != "function") {
    for (n = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === e || r[o].listener === e) {
        c = r[o].listener, n = o;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? r.shift() : fv(r, n), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, c || e);
  }
  return this;
};
ce.prototype.off = ce.prototype.removeListener;
ce.prototype.removeAllListeners = function(t) {
  var e, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var n = Object.keys(r), o;
    for (i = 0; i < n.length; ++i)
      o = n[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = r[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function nm(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? Sv(i) : cm(i, i.length);
}
ce.prototype.listeners = function(t) {
  return nm(this, t, !0);
};
ce.prototype.rawListeners = function(t) {
  return nm(this, t, !1);
};
ce.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : om.call(s, t);
};
ce.prototype.listenerCount = om;
function om(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
ce.prototype.eventNames = function() {
  return this._eventsCount > 0 ? hd(this._events) : [];
};
function cm(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
function fv(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function Sv(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function vv(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    dm(s, t, n, { once: !0 }), t !== "error" && yv(s, i, { once: !0 });
  });
}
function yv(s, t, e) {
  typeof s.on == "function" && dm(s, "error", t, e);
}
function dm(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var z;
(function(s) {
  s[s.MAJOR_EVENT = 0] = "MAJOR_EVENT", s[s.MINOR_EVENT = 1] = "MINOR_EVENT";
})(z || (z = {}));
var O;
(function(s) {
  s.PRECALL_TEST_BEGIN = "precall_begin", s.PRECALL_TEST_COMPLETE = "precall_end", s.CALL_JOIN_BEGIN = "call_join", s.NET_QUALITY_TEST_BEGIN = "net_quality_test_begin", s.NET_QUALITY_TEST_END = "net_quality_test_end", s.WEBSOCKET_CONNECTED = "websocket_connected", s.TRANSPORT_CONNECTED = "transport_connected", s.AUDIO_ON = "audio_on", s.AUDIO_OFF = "audio_off", s.VIDEO_ON = "video_on", s.VIDEO_OFF = "video_off", s.PARTICIPANT_ROLE = "participant_role", s.PING_STAT = "ping_stat", s.DISCONNECT = "disconnect", s.RECONNECT_ATTEMPT = "reconnect_attempt", s.SCREENSHARE_START_REQUESTED = "screenshare_start_requested", s.SCREENSHARE_STARTED = "screenshare_started", s.SCREENSHARE_STOPPED = "screenshare_stopped", s.TAB_CHANGE = "tab_change", s.BROWSER_BACKGROUNDED = "browser_backgrounded", s.BROWSER_FOREGROUNDED = "browser_foregrounded", s.DOMINANT_SPEAKER = "dominant_speaker", s.AUDIO_DEVICES_UPDATES = "audio_devices_updates", s.VIDEO_DEVICES_UPDATES = "video_devices_updates", s.SPEAKER_DEVICES_UPDATES = "speaker_devices_updates", s.SELECTED_MICROHPONE_UPDATE = "selected_microphone_update", s.SELECTED_CAMERA_UPDATE = "selected_camera_update", s.SELECTED_SPEAKER_UPDATE = "selected_speaker_update", s.EXPECTED_VIDEO_RESOLUTION = "expected_video_resolution", s.EXPECTED_SCREENSHARE_RESOLUTION = "expected_screenshare_resolution", s.MEDIA_PERMISSION = "media_permission", s.LEGACY_SWITCH = "legacy_switch", s.AUDIO_PLAY_FAILED = "audio_play_failed", s.VIDEO_PLAY_FAILED = "video_play_failed", s.AUDIO_TRACK_MUTED = "audio_track_muted", s.VIDEO_TRACK_MUTED = "video_track_muted", s.IVS_PLAYER_REBUFFERING = "ivs_player_rebuffering", s.IVS_PLAYER_AUDIO_BLOCKED = "ivs_player_audio_blocked", s.IVS_PLAYER_PLAYBACK_BLOCKED = "ivs_player_playback_blocked", s.IVS_PLAYER_ERROR = "ivs_player_error", s.IVS_PLAYER_RECOVERABLE_ERROR = "ivs_player_recoverable_error", s.IVS_PLAYER_WORKER_ERROR = "ivs_player_worker_error", s.IVS_PLAYER_NETWORK_UNAVAILABLE = "ivs_player_network_unavailable", s.LIVESTREAM_LATENCY = "livestream_latency", s.IVS_PLAYER_ANALYTICS_EVENT = "ivs_player_analytics_event", s.IVS_PLAYER_PLAYBACK_RATE_CHANGED = "ivs_player_playback_rate_changed", s.IVS_PLAYER_QUALITY_CHANGED = "ivs_player_quality_changed", s.IVS_PLAYER_INITIALIZED = "ivs_player_initialized";
})(O || (O = {}));
const Tv = /* @__PURE__ */ new Map([
  [O.PRECALL_TEST_BEGIN, z.MINOR_EVENT],
  [O.PRECALL_TEST_COMPLETE, z.MINOR_EVENT],
  [O.CALL_JOIN_BEGIN, z.MAJOR_EVENT],
  [O.NET_QUALITY_TEST_BEGIN, z.MINOR_EVENT],
  [O.NET_QUALITY_TEST_END, z.MINOR_EVENT],
  [O.WEBSOCKET_CONNECTED, z.MINOR_EVENT],
  [O.TRANSPORT_CONNECTED, z.MAJOR_EVENT],
  [O.AUDIO_ON, z.MINOR_EVENT],
  [O.AUDIO_OFF, z.MINOR_EVENT],
  [O.VIDEO_ON, z.MINOR_EVENT],
  [O.VIDEO_OFF, z.MINOR_EVENT],
  [O.PARTICIPANT_ROLE, z.MINOR_EVENT],
  [O.PING_STAT, z.MAJOR_EVENT],
  [O.DISCONNECT, z.MAJOR_EVENT],
  [O.RECONNECT_ATTEMPT, z.MAJOR_EVENT],
  [O.SCREENSHARE_START_REQUESTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STARTED, z.MINOR_EVENT],
  [O.SCREENSHARE_STOPPED, z.MINOR_EVENT],
  [O.TAB_CHANGE, z.MINOR_EVENT],
  [O.BROWSER_BACKGROUNDED, z.MINOR_EVENT],
  [O.BROWSER_FOREGROUNDED, z.MINOR_EVENT],
  [O.DOMINANT_SPEAKER, z.MINOR_EVENT],
  [O.AUDIO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.VIDEO_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SPEAKER_DEVICES_UPDATES, z.MINOR_EVENT],
  [O.SELECTED_MICROHPONE_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_CAMERA_UPDATE, z.MINOR_EVENT],
  [O.SELECTED_SPEAKER_UPDATE, z.MINOR_EVENT],
  [O.MEDIA_PERMISSION, z.MINOR_EVENT],
  [O.LEGACY_SWITCH, z.MINOR_EVENT],
  [O.AUDIO_PLAY_FAILED, z.MINOR_EVENT],
  [O.VIDEO_PLAY_FAILED, z.MINOR_EVENT],
  [O.AUDIO_TRACK_MUTED, z.MINOR_EVENT],
  [O.VIDEO_TRACK_MUTED, z.MINOR_EVENT],
  // IVS Player Events
  [O.IVS_PLAYER_REBUFFERING, z.MAJOR_EVENT],
  [O.IVS_PLAYER_AUDIO_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_BLOCKED, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_RECOVERABLE_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_WORKER_ERROR, z.MAJOR_EVENT],
  [O.IVS_PLAYER_NETWORK_UNAVAILABLE, z.MAJOR_EVENT],
  // We are keeping live latency as major, so that it
  // acts as a ping alternative for livestream viewer
  [O.LIVESTREAM_LATENCY, z.MAJOR_EVENT],
  [O.IVS_PLAYER_ANALYTICS_EVENT, z.MINOR_EVENT],
  [O.IVS_PLAYER_PLAYBACK_RATE_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_QUALITY_CHANGED, z.MINOR_EVENT],
  [O.IVS_PLAYER_INITIALIZED, z.MINOR_EVENT],
  [O.EXPECTED_VIDEO_RESOLUTION, z.MINOR_EVENT],
  [O.EXPECTED_SCREENSHARE_RESOLUTION, z.MINOR_EVENT]
]);
class Ev {
  constructor() {
    h(this, "events");
    this.events = [];
  }
  add(t) {
    this.events.push(t);
  }
  flush() {
    return {
      entries: this.events.splice(0, 25)
    };
  }
}
class _v extends ut {
  constructor({ logger: e, peerId: r, apiHostnames: i }) {
    super();
    h(this, "logger");
    h(this, "peerId");
    h(this, "eventStore");
    h(this, "apiEndpoint");
    this.logger = e, this.peerId = r, this.apiEndpoint = `https://${i.daCollector}/api/v1/message`, this.eventStore = new Ev();
  }
  sendEventsChunkToServer(e) {
    return u(this, null, function* () {
      var i;
      const r = {
        payload: e,
        peerId: this.peerId
      };
      try {
        return yield fetch(this.apiEndpoint, {
          method: "POST",
          body: JSON.stringify(r)
        }), !0;
      } catch (n) {
        return this.logger.error("callStats::sendEventsChunkToServer::catch", { error: n }), (i = e.entries) == null || i.forEach((o) => {
          this.eventStore.add(o);
        }), !1;
      }
    });
  }
  callEvent(e) {
    e.timestamp = new Date(), this.eventStore.add(e), this.emit(e.event, e.metaData), Tv.get(e.event) === z.MAJOR_EVENT && this.flush();
  }
  flush() {
    return u(this, null, function* () {
      var r;
      const e = this.eventStore.flush();
      return (r = e == null ? void 0 : e.entries) != null && r.length ? (yield this.sendEventsChunkToServer(e), !0) : !1;
    });
  }
}
var ip;
(function(s) {
  s.CHROMIUM = "chromum", s.FIREFOX = "firefox", s.SAFARI = "safari";
})(ip || (ip = {}));
const bo = {
  DEVEL: "devel",
  PREPROD: "preprod",
  PROD: "prod"
};
var Jt;
(function(s) {
  s.AUDIO = "AUDIO", s.VIDEO = "VIDEO", s.SPEAKER = "SPEAKER", s.SCREENSHARE = "SCREENSHARE";
})(Jt || (Jt = {}));
var ap;
(function(s) {
  s[s.INIT = 0] = "INIT", s[s.ACCEPTED = 1] = "ACCEPTED", s[s.DENIED = 2] = "DENIED", s[s.SYS_DENIED = 3] = "SYS_DENIED", s[s.FAILED = 4] = "FAILED", s[s.NOTFOUND = 5] = "NOTFOUND", s[s.NOT_APPLICABLE = 6] = "NOT_APPLICABLE";
})(ap || (ap = {}));
function Zr(s) {
  return s ? s.split(".").slice(0, 2).concat(["0", "0"]).join(".") : "";
}
function bd({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
function kd({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
const lm = 240, um = 720, hm = 8, pm = 3, Ul = 10, $l = 0.02, Fl = 0.03;
function fr({ stat: s, weight: t, rangeMin: e, rangeMax: r, rangeRankingDirection: i }) {
  return s == null ? t : e === r ? i === "UP" ? s <= e ? t : 0 : s >= r ? t : 0 : i === "UP" ? (1 - Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e)) * t : i === "DOWN" ? Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e) * t : t;
}
function gm({ isLowQualityVideo: s, isVideoStuck: t, isVideoLagging: e, jitterQuality: r, packetsLostQuality: i }) {
  const n = 0.8 * ((s ? 0.85 : 1) * (e ? 0.7 : 1) * (t ? 0.5 : 1)) + 0.2 * (r * i);
  return Math.round((n + Number.EPSILON) * 100) / 100;
}
function mm({ packetsLost: s, packetsSent: t }) {
  return t > 0 ? s * 100 / t : 0;
}
function fm({ packetsLost: s, packetsSent: t, jitter: e }) {
  const i = fr({
    stat: mm({
      packetsLost: s,
      packetsSent: t
    }),
    weight: 0.7,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), o = fr({
    stat: e,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return i + o;
}
function Pv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
function Cv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
function Rv({ framesEncoded: s }) {
  return s === 0;
}
function Sm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsSent: r, jitter: i, isScreenShare: n, framesEncoded: o }) {
  const c = fr({
    stat: mm({
      packetsLost: e,
      packetsSent: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = Pv({
    frameWidth: s,
    isScreenShare: n
  }), p = Cv({
    framesPerSecond: t,
    isScreenShare: n
  }), f = Rv({
    framesEncoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
function vm({ packetsLost: s, packetsReceived: t }) {
  return t + s > 0 ? s * 100 / (t + s) : 0;
}
function ym({ concealmentEvents: s, packetsLost: t, packetsReceived: e, jitter: r }) {
  const n = fr({
    stat: s,
    weight: 0.2,
    rangeMin: 0,
    rangeMax: 3,
    rangeRankingDirection: "UP"
  }), o = 0.5, c = fr({
    stat: vm({
      packetsLost: t,
      packetsReceived: e
    }),
    weight: o,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), l = fr({
    stat: r,
    weight: 0.3,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  });
  return n + c + l;
}
function wv({ framesDecoded: s }) {
  return s === 0;
}
function bv({ framesPerSecond: s, isScreenShare: t }) {
  return s < (t ? pm : hm);
}
function kv({ frameWidth: s, isScreenShare: t }) {
  return s < (t ? um : lm);
}
function Tm({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsReceived: r, jitter: i, isScreenShare: n, framesDecoded: o }) {
  const c = fr({
    stat: vm({
      packetsLost: e,
      packetsReceived: r
    }),
    weight: 1,
    rangeMin: 0,
    rangeMax: Ul,
    rangeRankingDirection: "UP"
  }), d = fr({
    stat: i,
    weight: 1,
    rangeMin: $l,
    rangeMax: Fl,
    rangeRankingDirection: "UP"
  }), l = kv({
    frameWidth: s,
    isScreenShare: n
  }), p = bv({
    framesPerSecond: t,
    isScreenShare: n
  }), f = wv({
    framesDecoded: o,
    isScreenShare: n
  });
  return gm({
    isLowQualityVideo: l,
    isVideoLagging: p,
    isVideoStuck: f,
    jitterQuality: d,
    packetsLostQuality: c
  });
}
class Sr {
  constructor(t) {
    h(this, "pc1");
    h(this, "pc2");
    h(this, "constrainVideoBitrateKbps");
    h(this, "constrainOfferToRemoveVideoFec", !1);
    h(this, "iceCandidateFilter");
    const e = new RTCPeerConnection(t), r = new RTCPeerConnection(t);
    this.pc1 = e, this.pc2 = r, this.iceCandidateFilter = Sr.noFilter, this.pc1.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc2)), this.pc2.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc1));
  }
  static parseCandidate(t) {
    const e = "candidate:", r = t.indexOf(e) + e.length, i = t.substr(r).split(" ");
    return {
      type: i[7],
      protocol: i[2],
      address: i[4]
    };
  }
  static isNotHostCandidate(t) {
    return t.type !== "host";
  }
  static isHost(t) {
    return t.type === "host";
  }
  static isRelay(t) {
    return t.type === "relay";
  }
  static isReflexive(t) {
    return t.type === "srflx";
  }
  static noFilter(t) {
    return !0;
  }
  onIceCandidate(t, e) {
    if (e.candidate) {
      const r = Sr.parseCandidate(e.candidate.candidate);
      this.iceCandidateFilter(r) && t.addIceCandidate(e.candidate);
    }
  }
  setIceCandidateFilter(t) {
    this.iceCandidateFilter = t;
  }
  // Constraint max video bitrate by modifying the SDP when creating an answer.
  constrainVideoBitrate(t) {
    this.constrainVideoBitrateKbps = t;
  }
  // Remove video FEC if available on the offer.
  disableVideoFec() {
    this.constrainOfferToRemoveVideoFec = !0;
  }
  gotOffer(t) {
    this.constrainOfferToRemoveVideoFec && (t.sdp = t.sdp.replace(/(m=video 1 [^\r]+)(116 117)(\r\n)/g, `$1\r
`), t.sdp = t.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=fmtp:98 apt=116\r\n/g, "")), this.pc1.setLocalDescription(t), this.pc2.setRemoteDescription(t), this.pc2.createAnswer().then(this.gotAnswer.bind(this), this.reportFatal.bind(this));
  }
  gotAnswer(t) {
    this.constrainVideoBitrateKbps && (t.sdp = t.sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r
b=AS:${this.constrainVideoBitrateKbps}\r
`)), this.pc2.setLocalDescription(t), this.pc1.setRemoteDescription(t);
  }
  establishConnection() {
    this.pc1.createOffer().then(this.gotOffer.bind(this), this.reportFatal.bind(this));
  }
  // eslint-disable-next-line class-methods-use-this
  reportFatal(t) {
    console.error("Error:", t);
  }
  getRoundTripTime() {
    return u(this, null, function* () {
      const [t, e] = yield Promise.all([this.pc1.getStats(), this.pc2.getStats()]);
      let r, i;
      if (t.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === !0 && n.bytesSent > 0 && (r = n);
      }), e.forEach((n) => {
        n.type === "candidate-pair" && n.nominated === !0 && n.bytesReceived > 0 && (i = n);
      }), r && i)
        try {
          if (r.currentRoundTripTime && i.currentRoundTripTime)
            return {
              rtt: r.currentRoundTripTime,
              backendRTT: i.currentRoundTripTime
            };
          const n = (i.lastPacketReceivedTimestamp - r.lastPacketSentTimestamp) / 1e3;
          return {
            rtt: n,
            backendRTT: n
          };
        } catch (n) {
          return;
        }
    });
  }
  close() {
    this.pc1.close(), this.pc2.close();
  }
}
class Em extends ut {
  constructor(e) {
    super();
    h(this, "call");
    h(this, "timeOut");
    this.call = new Sr(e);
  }
  start(e = 1e4) {
    this.call.establishConnection(), this.timeOut = setTimeout(this.testFailed.bind(this), e);
  }
  testComplete(e) {
    clearTimeout(this.timeOut), this.call.close(), this.emit("done", e);
  }
  testFailed(e) {
    this.call.close(), this.emit("failed", e);
  }
}
const Iv = 8, Av = 1 / 1e3;
class Mv extends Em {
  constructor(e) {
    super(e);
    h(this, "senderChannel");
    h(this, "recieveChannel");
    h(this, "startTime");
    h(this, "lastBitrateMeasureTime");
    h(this, "sentPayloadBytes", 0);
    h(this, "recievedPayloadBytes", 0);
    h(this, "lastReceivedPayloadBytes", 0);
    h(this, "stopSending", !1);
    h(this, "testProgress", 0);
    h(this, "samplePacket", "");
    h(this, "finalBitrateSum", 0);
    h(this, "bitRateSampels", 0);
    h(this, "maxNumberOfPacketsToSend", 0);
    h(this, "bytesToKeepBuffered", 0);
    h(this, "testDurationSeconds", 5);
    this.call.setIceCandidateFilter(Sr.isNotHostCandidate), this.senderChannel = this.call.pc1.createDataChannel(null);
    for (let r = 0; r < 1024 * 256; r += 1)
      this.samplePacket += "h";
    this.maxNumberOfPacketsToSend = 1, this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend, this.testDurationSeconds = 4, this.senderChannel.addEventListener("open", this.sendingStep.bind(this)), this.call.pc2.addEventListener("datachannel", this.onRecieverChannel.bind(this));
  }
  sendingStep() {
    const e = new Date();
    this.startTime || (this.startTime = e, this.lastBitrateMeasureTime = e);
    for (let i = 0; i !== this.maxNumberOfPacketsToSend && !(this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered); i += 1) {
      this.sentPayloadBytes += this.samplePacket.length;
      try {
        this.senderChannel.send(this.samplePacket);
      } catch (n) {
      }
    }
    const r = e.getTime() - this.startTime.getTime();
    r >= 1e3 * this.testDurationSeconds ? (this.stopSending = !0, this.testProgress = 100) : (this.testProgress = r / (10 * this.testDurationSeconds), setTimeout(this.sendingStep.bind(this), 1));
  }
  onMessageRecieved(e) {
    this.recievedPayloadBytes += e.data.length;
    const r = new Date(), i = r.getTime() - this.lastBitrateMeasureTime.getTime();
    if (i >= 1e3) {
      const o = (this.recievedPayloadBytes - this.lastReceivedPayloadBytes) * Iv / (i / 1e3);
      this.finalBitrateSum += o, this.bitRateSampels += 1, this.lastReceivedPayloadBytes = this.recievedPayloadBytes, this.lastBitrateMeasureTime = r;
    }
    if (this.stopSending && this.sentPayloadBytes === this.recievedPayloadBytes) {
      const n = this.finalBitrateSum / this.bitRateSampels;
      this.testComplete({
        throughput: Math.round(n * Av)
      });
    }
  }
  testComplete(e) {
    this.call.getRoundTripTime().then(({ rtt: r, backendRTT: i }) => super.testComplete({
      RTT: r,
      backendRTT: i,
      throughput: e.throughput
    }));
  }
  onRecieverChannel(e) {
    this.recieveChannel = e.channel, this.recieveChannel.addEventListener("message", this.onMessageRecieved.bind(this));
  }
}
class vh extends Em {
  constructor(e, r = Sr.noFilter) {
    super(e);
    h(this, "ch1");
    h(this, "ch2");
    this.call.setIceCandidateFilter(r);
    const i = this.call.pc1.createDataChannel(null);
    this.ch1 = i, i.addEventListener("open", () => {
      i.send("hello");
    }), i.addEventListener("message", this.onCh1Recieve.bind(this)), this.call.pc2.addEventListener("datachannel", this.dataChannelHandler.bind(this));
  }
  onCh1Recieve(e) {
    e.data !== "world" ? this.hangup("Invalid data transmitted.") : this.testComplete({
      connectivity: !0
    });
  }
  onCh2Recieve(e) {
    if (e.data !== "hello")
      this.hangup("Invalid data transmitted.");
    else
      try {
        this.ch2.send("world");
      } catch (r) {
      }
  }
  dataChannelHandler(e) {
    const r = e.channel;
    this.ch2 = r, r.addEventListener("message", this.onCh2Recieve.bind(this));
  }
  hangup(e) {
    this.testFailed(e);
  }
}
class Dv extends vh {
  constructor(t) {
    super(t, Sr.isHost);
  }
}
class Ov extends vh {
  constructor(t) {
    super(t, Sr.isRelay);
  }
}
class Nv extends vh {
  constructor(t) {
    super(t, Sr.isReflexive);
  }
}
class Vv {
  constructor() {
    h(this, "ipInformation", null);
  }
  getIPDetails(i) {
    return u(this, arguments, function* ({ peerId: t, apiHostnames: e, logger: r }) {
      var n, o, c;
      if (!this.ipInformation) {
        try {
          const d = `https://${e.location}`, p = yield (yield fetch(d)).json();
          if (((n = p.loc) == null ? void 0 : n.length) > 5)
            return this.ipInformation = p, (o = this.ipInformation) != null && o.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip)), p;
          throw Error("Insufficient data");
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using location service", { error: d });
        }
        try {
          const d = yield fetch(`https://${e.locationLegacy}/?token=3c493932b0624c&peerId=${t}`, {
            method: "POST"
          });
          this.ipInformation = yield d.json(), (c = this.ipInformation) != null && c.ip && (this.ipInformation.ip = Zr(this.ipInformation.ip));
        } catch (d) {
          r.error("callstats::ipDetails:: failed to fetch ip using legacy location service", { error: d });
        }
      }
      return this.ipInformation;
    });
  }
  resetCache() {
    this.ipInformation = null;
  }
}
const yh = new Vv(), np = [
  {
    urls: "turn:turn.dyte.in:443?transport=tcp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  },
  {
    urls: "turn:turn.dyte.in:3478?transport=udp",
    username: "dyte",
    credential: "dytein",
    credentialType: "password"
  }
];
function op(s) {
  const [t, e] = s.split(",");
  return {
    coords: {
      latitude: Number(t),
      longitude: Number(e)
    }
  };
}
class _m {
  constructor() {
    h(this, "transport");
    h(this, "candidatePair");
    h(this, "outboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "inboundVideoRtp", /* @__PURE__ */ new Map());
    h(this, "outboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "inboundAudioRtp", /* @__PURE__ */ new Map());
    h(this, "remoteInboundRtp", /* @__PURE__ */ new Map());
    h(this, "producerStreamMap", /* @__PURE__ */ new Map());
    h(this, "consumerStreamMap", /* @__PURE__ */ new Map());
    h(this, "staleProducerStreamMap", !1);
    h(this, "staleConsumerStreamMap", !1);
  }
}
class Pm extends ut {
  constructor() {
    super();
    h(this, "observer");
    h(this, "outboundProducerMap", /* @__PURE__ */ new Map());
    h(this, "inboundConsumerMap", /* @__PURE__ */ new Map());
    h(this, "consumerPeerIdMap", /* @__PURE__ */ new Map());
    h(this, "pausedConsumerMap", /* @__PURE__ */ new Map());
    h(this, "pausedProducerMap", /* @__PURE__ */ new Map());
    h(this, "overallProducingTransportsStatsMap", {});
    h(this, "overallConsumingTransportsStatsMap", {});
    h(this, "overallConsumersStatsMap", {});
    h(this, "overallProducersStatsMap", {});
    h(this, "videoProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioProducerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "videoConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "audioConsumerToStatsMap", /* @__PURE__ */ new Map());
    h(this, "consumerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "consumerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
    h(this, "producerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
    h(this, "freezedProducingTransportIds", /* @__PURE__ */ new Set());
    h(this, "freezedConsumingTransportIds", /* @__PURE__ */ new Set());
    h(this, "screenShareProducers", /* @__PURE__ */ new Set());
    h(this, "screenShareConsumers", /* @__PURE__ */ new Set());
    h(this, "ipDetails");
    h(this, "callStatsInstance");
    this.observer = new ut();
  }
  registerProducer(e) {
    return u(this, null, function* () {
      yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === !0 && this.screenShareProducers.add(e.id);
    });
  }
  pauseProducer(e) {
    this.pausedProducerMap.set(e, {
      lastReportCalculated: !1
    });
  }
  resumeProducer(e) {
    this.pausedProducerMap.delete(e);
  }
  processInboundConsumerVideoStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalVideoPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "pause", e))) : (r.totalVideoPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedVideo.has(e) && (this.consumerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "resume", e))));
  }
  processInboundConsumerAudioStats(e, r, i) {
    var o, c;
    const n = ((c = (o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.consumerSharedMediaStatesMap) == null ? void 0 : c.get(e)) || {};
    r.totalAudioPacketsReceived === i.packetsReceived ? (this.consumerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "pause", e))) : (r.totalAudioPacketsReceived = i.packetsReceived, this.consumerIdsWithFreezedAudio.has(e) && (this.consumerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "resume", e))));
  }
  processOutboundProducerVideoStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalVideoPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedVideo.add(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "pause", e))) : (r.totalVideoPacketsSent = i.packetsSent, this.producerIdsWithFreezedVideo.has(e) && (this.producerIdsWithFreezedVideo.delete(e), this.callStatsInstance && n.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "resume", e))));
  }
  processOutboundProducerAudioStats(e, r, i) {
    var o;
    const n = ((o = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : o.currentUserMediaStates) || {};
    r.totalAudioPacketsSent === i.packetsSent ? (this.producerIdsWithFreezedAudio.add(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "pause", e))) : (r.totalAudioPacketsSent = i.packetsSent, this.producerIdsWithFreezedAudio.has(e) && (this.producerIdsWithFreezedAudio.delete(e), this.callStatsInstance && n.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "resume", e))));
  }
  processProducingTransportStats(e, r, i) {
    var p;
    const n = ((p = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : p.currentUserMediaStates) || {}, { audio: o, video: c, screen: d } = n, l = o || c || d;
    r.totalPacketsSent === i.packetsSent ? (this.freezedProducingTransportIds.add(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "pause", e))) : (r.totalPacketsSent = i.packetsSent, this.freezedProducingTransportIds.has(e) && (this.freezedProducingTransportIds.delete(e), this.callStatsInstance && l && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "resume", e))));
  }
  processConsumingTransportStats(e, r, i) {
    var c, d;
    const o = !!Array.from(((d = (c = this == null ? void 0 : this.callStatsInstance) == null ? void 0 : c.consumerSharedMediaStatesMap) == null ? void 0 : d.values()) || []).reduce((l, p) => l || p.audio || p.video || p.screen, !1);
    r.totalPacketsReceived === i.packetsSent ? (this.freezedConsumingTransportIds.add(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "pause", e))) : (r.totalPacketsReceived = i.packetsSent, this.freezedConsumingTransportIds.has(e) && (this.freezedConsumingTransportIds.delete(e), this.callStatsInstance && o && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "resume", e))));
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === !0 && this.screenShareConsumers.add(e.id);
    });
  }
  pauseConsumer(e) {
    this.pausedConsumerMap.set(e, {
      lastReportCalculated: !1
    });
  }
  resumeConsumer(e) {
    this.pausedConsumerMap.delete(e);
  }
  generateProducerStreamMap(e, r = !1) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getProducerStatsFromReport(this.parseRTCReport(i, ["outbound-rtp", "remote-inbound-rtp"], !1, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "outbound-rtp": {
            this.outboundProducerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  generateConsumerStreamMap(e, r = !1) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = r ? this.getConsumerStatsFromReport(this.parseRTCReport(i, ["inbound-rtp"], !1, e.id))[0] : void 0;
      for (const o of i.values())
        switch (o.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(o.id, e.id);
            break;
          }
        }
      return n;
    });
  }
  deregisterProducer(e) {
    this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  // eslint-disable-next-line class-methods-use-this
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  // eslint-disable-next-line class-methods-use-this
  getWorkingSimulcastVideoStats(e) {
    return e.find((i) => {
      const n = i.framesEncoded > 0, o = i.packetsSent > 0, c = i.frameWidth && i.frameHeight;
      return n && o && !!c;
    }) || e[e.length - 1];
  }
  parseRTCReport(e, r = [], i = !1, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === !0 || I.selected === !0) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            // @ts-ignore
            dtlsState: y.dtlsState,
            // @ts-ignore
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === !0)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: !0
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = !0;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped,
                framesPerSecond: b.framesPerSecond,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                // temp sending target bitrate in total encode time
                // to avoid the delay with making the backend changes
                totalEncodeTime: b.targetBitrate,
                totalPacketSendDelay: b.totalPacketSendDelay,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === !0)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: !0
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = !0;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped,
                framesPerSecond: V.framesPerSecond,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      // candidateStats: result.candidatePair,
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateProducerStreamMap(i, !0));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  getConsumersReport(e) {
    return u(this, null, function* () {
      const r = e.map((i) => this.generateConsumerStreamMap(i, !0));
      return r.length > 0 ? Promise.all(r) : void 0;
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getTransportReport(e) {
    return u(this, null, function* () {
      return e.getStats();
    });
  }
  getProcessedStats(e, r, i) {
    return u(this, null, function* () {
      const n = yield this.getTransportReport(e), o = { producing: i, consuming: r, id: e.id }, c = n, d = this.parseRTCReport(c, ["transport", "candidate-pair", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "local-candidate", "remote-candidate"], !1, void 0, o);
      if (!d)
        return;
      const l = {
        stats: d.transport,
        transportId: e.id,
        consuming: r,
        producing: i
      }, p = d.staleProducerStreamMap ? void 0 : this.getProducerStatsFromReport(d), f = d.staleConsumerStreamMap ? void 0 : this.getConsumerStatsFromReport(d);
      return {
        transportReport: l,
        producerReport: p,
        consumerReport: f
      };
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        var o, c;
        r.push({
          producerId: n,
          videoStats: i.outboundVideoRtpId.map((d) => e.outboundVideoRtp.get(d)),
          audioStats: i.outboundAudioRtpId.map((d) => e.outboundAudioRtp.get(d)),
          appData: ((c = (o = this.callStatsInstance.producers) == null ? void 0 : o.get(n)) == null ? void 0 : c.appData) || null
        });
      });
    } catch (i) {
      this.callStatsInstance.logger.error("callStats::measurements::getProducerStatsFromReport", {
        error: { reason: i.reason, message: i.message }
      });
    }
    return r;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(n);
        r.push({
          consumerId: n,
          peerId: o,
          producerId: c,
          appData: d,
          videoStats: i.inboundVideoRtpId.map((l) => e.inboundVideoRtp.get(l)),
          audioStats: i.inboundAudioRtpId.map((l) => e.inboundAudioRtp.get(l))
        });
      });
    } catch (i) {
      console.error("getConsumersReport: ", i, e);
    }
    return r;
  }
  // eslint-disable-next-line class-methods-use-this
  getUserLocation() {
    return u(this, null, function* () {
      return new Promise((e, r) => {
        try {
          navigator.geolocation ? navigator.geolocation.getCurrentPosition((i) => {
            e(i);
          }) : r();
        } catch (i) {
          r(i);
        }
      });
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getConnectivity(e) {
    return u(this, null, function* () {
      try {
        const r = {
          iceServers: e || np
        }, i = new Promise((p, f) => {
          try {
            const S = new Dv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: !1 });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), n = new Promise((p, f) => {
          try {
            const S = new Ov(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: !1 });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), o = new Promise((p, f) => {
          try {
            const S = new Nv(r);
            S.addListener("done", p), S.addListener("failed", () => {
              p({ connectivity: !1 });
            }), S.start(2e3);
          } catch (S) {
            f(S);
          }
        }), [c, d, l] = yield Promise.all([i, n, o]);
        return {
          host: c == null ? void 0 : c.connectivity,
          relay: d == null ? void 0 : d.connectivity,
          reflexive: l == null ? void 0 : l.connectivity
        };
      } catch (r) {
        return {
          host: !1,
          relay: !1,
          reflexive: !1
        };
      }
    });
  }
  // eslint-disable-next-line class-methods-use-this
  getThroughput(e) {
    return u(this, null, function* () {
      try {
        const i = yield new Promise((n, o) => {
          try {
            const c = {
              iceServers: e || np
            }, d = new Mv(c);
            d.addListener("done", n), d.addListener("failed", o), d.start(1e4);
          } catch (c) {
            o(c);
          }
        });
        return {
          throughput: i.throughput,
          fractionalLoss: 0,
          RTT: i.RTT,
          jitter: 0,
          backendRTT: i.backendRTT
        };
      } catch (r) {
        return;
      }
    });
  }
  getIPDetails() {
    return u(this, null, function* () {
      var e, r;
      try {
        return this.ipDetails || (this.ipDetails = yield yh.getIPDetails({
          peerId: (e = this.callStatsInstance) == null ? void 0 : e.peerId,
          apiHostnames: (r = this.callStatsInstance) == null ? void 0 : r.apiHostnames,
          logger: this.callStatsInstance.logger
        })), this.ipDetails;
      } catch (i) {
        return;
      }
    });
  }
  getNetworkQuality(e) {
    return u(this, null, function* () {
      const [r, i] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e)
      ]);
      return {
        connectivity: r,
        throughput: i == null ? void 0 : i.throughput,
        fractionalLoss: i == null ? void 0 : i.fractionalLoss,
        RTT: i == null ? void 0 : i.RTT,
        jitter: i == null ? void 0 : i.jitter,
        backendRTT: i == null ? void 0 : i.backendRTT
      };
    });
  }
  getNetworkInfo(e, r = !1) {
    return u(this, null, function* () {
      var c, d;
      if (r) {
        const l = yield this.getIPDetails();
        return {
          ipDetails: l,
          effectiveNetworkType: (c = navigator.connection) == null ? void 0 : c.effectiveType,
          location: l != null && l.loc ? op(l == null ? void 0 : l.loc) : void 0
          // userLocation,
        };
      }
      const [i, n, o] = yield Promise.all([
        this.getConnectivity(e),
        this.getThroughput(e),
        this.getIPDetails()
      ]);
      return {
        ipDetails: o,
        effectiveNetworkType: (d = navigator.connection) == null ? void 0 : d.effectiveType,
        location: o != null && o.loc ? op(o == null ? void 0 : o.loc) : void 0,
        turnConnectivity: i ? i.host || i.relay || i.reflexive : !1,
        connectivity: i,
        throughput: n == null ? void 0 : n.throughput,
        fractionalLoss: n == null ? void 0 : n.fractionalLoss,
        RTT: n == null ? void 0 : n.RTT,
        jitter: n == null ? void 0 : n.jitter,
        backendRTT: n == null ? void 0 : n.backendRTT
      };
    });
  }
}
class Lv extends Pm {
}
class Cm extends Pm {
  constructor() {
    super(...arguments);
    h(this, "producerMap", /* @__PURE__ */ new Map());
    h(this, "consumerMap", /* @__PURE__ */ new Map());
  }
  registerProducer(e) {
    return u(this, null, function* () {
      this.producerMap.set(e.id, e), yield this.generateProducerStreamMap(e), e.on("close", this.deregisterProducer.bind(this, e)), e.on("pause", this.pauseProducer.bind(this, e.id)), e.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === !0 && this.screenShareProducers.add(e.id);
    });
  }
  registerConsumer(e) {
    return u(this, null, function* () {
      this.consumerMap.set(e.id, e), yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
        producerId: e.producerId,
        peerId: e.appData.peerId,
        appData: e.appData
      }), e.on("close", this.deregisterConsumer.bind(this, e)), e.on("pause", this.pauseConsumer.bind(this, e.id)), e.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === !0 && this.screenShareConsumers.add(e.id);
    });
  }
  generateConsumerStreamMap(e, r = !1) {
    return u(this, null, function* () {
      const i = yield e.getStats(), n = this.parseRTCReport(i, ["inbound-rtp"], !1, e.id), o = [...n.consumerStreamMap.values()][0], c = r ? this.getConsumerStatsFromParsedConsumerStats(n, o, e.id) : void 0;
      for (const d of i.values())
        switch (d.type) {
          case "inbound-rtp": {
            this.inboundConsumerMap.set(d.id, e.id);
            break;
          }
        }
      return c;
    });
  }
  deregisterProducer(e) {
    this.producerMap.delete(e.id), this.outboundProducerMap.forEach((r, i) => {
      r === e.id && this.outboundProducerMap.delete(i);
    }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
  }
  deregisterConsumer(e) {
    this.consumerMap.delete(e.id), this.inboundConsumerMap.forEach((r, i) => {
      r === e.id && this.inboundConsumerMap.delete(i);
    }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
  }
  // eslint-disable-next-line class-methods-use-this
  getIceCandidateStats(e) {
    var r;
    return {
      id: e.id,
      type: e.candidateType || e.type,
      address: e.address,
      port: e.port,
      url: e.url,
      protocol: (r = e.relayProtocol) != null ? r : e.protocol,
      networkType: e.networkType,
      relatedAddress: e.relatedAddress,
      relatedPort: e.relatedPort
    };
  }
  parseRTCReport(e, r = [], i = !1, n = void 0, o = void 0) {
    var P, w, A, N, H, $, F, K, re, Je, ks, Pr, ni;
    const c = e, d = new _m(), l = r.length ? new Set(r) : void 0, p = [], f = [], S = [], T = /* @__PURE__ */ new Map(), _ = /* @__PURE__ */ new Map();
    for (const I of c.values()) {
      if (l) {
        if (l.size === 0)
          break;
        if (l.has(I.type))
          i && l.delete(I.type);
        else
          continue;
      }
      switch (I.type) {
        case "local-candidate": {
          p.push(this.getIceCandidateStats(I));
          break;
        }
        case "remote-candidate": {
          f.push(this.getIceCandidateStats(I));
          break;
        }
        case "candidate-pair": {
          const { nominated: y } = I, { selected: C } = I, U = I, ie = {
            nominated: y != null ? y : C,
            currentRoundTripTime: U.currentRoundTripTime,
            totalRoundTripTime: U.totalRoundTripTime,
            bytesReceived: U.bytesReceived,
            bytesSent: U.bytesSent,
            availableOutgoingBitrate: U.availableOutgoingBitrate,
            availableIncomingBitrate: U.availableIncomingBitrate,
            lastPacketReceivedTimestamp: U.lastPacketReceivedTimestamp,
            lastPacketSentTimestamp: U.lastPacketSentTimestamp,
            localCandidateId: U.localCandidateId,
            remoteCandidateId: U.remoteCandidateId,
            bytesDiscardedOnSend: U.bytesDiscardedOnSend,
            packetsSent: U.packetsSent,
            packetsReceived: U.packetsReceived,
            packetsDiscardedOnSend: U.packetsDiscardedOnSend
          };
          S.push(ie), (I.nominated === !0 || I.selected === !0) && (d.candidatePair = ie);
          break;
        }
        case "transport": {
          const y = I;
          o && (o.producing && (this.overallProducingTransportsStatsMap[o.id] || (this.overallProducingTransportsStatsMap[o.id] = {
            totalPacketsSent: 0
          })), o.consuming && (this.overallConsumingTransportsStatsMap[o.id] || (this.overallConsumingTransportsStatsMap[o.id] = {
            totalPacketsReceived: 0
          })));
          const C = {
            bytesReceived: y.bytesReceived,
            bytesSent: y.bytesSent,
            packetsSent: y.packetsSent,
            packetsReceived: y.packetsReceived,
            dtlsCipher: y.dtlsCipher,
            dtlsState: y.dtlsState,
            iceRole: y.iceRole
          };
          if (d.transport = C, o) {
            if (o.producing) {
              const U = this.overallProducingTransportsStatsMap[o.id];
              this.processProducingTransportStats(o.id, U, C);
            }
            if (o.consuming) {
              const U = this.overallConsumingTransportsStatsMap[o.id];
              this.processConsumingTransportStats(o.id, U, C);
            }
          }
          break;
        }
        case "remote-inbound-rtp": {
          const y = I, C = {
            jitter: y.jitter,
            fractionLost: y.fractionLost,
            roundTripTime: y.roundTripTime,
            roundTripTimeMeasurements: y.roundTripTimeMeasurements,
            totalRoundTripTime: y.totalRoundTripTime,
            packetsLost: y.packetsLost
          };
          d.remoteInboundRtp.set(y.localId, C);
          break;
        }
        case "outbound-rtp": {
          const y = I, C = n || this.outboundProducerMap.get(I.id), U = this.pausedProducerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === !0)
              break;
            this.pausedProducerMap.set(C, {
              lastReportCalculated: !0
            });
          }
          this.overallProducersStatsMap[C] || (this.overallProducersStatsMap[C] = {
            totalVideoPacketsSent: 0,
            totalAudioPacketsSent: 0
          });
          const ie = this.overallProducersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.outboundProducerMap.has(I.id)) {
              d.staleProducerStreamMap = !0;
              break;
            }
            const Me = this.callStatsInstance.producers.get(C);
            if (((P = Me == null ? void 0 : Me.track) == null ? void 0 : P.readyState) === "ended")
              break;
            d.producerStreamMap.has(C) || d.producerStreamMap.set(C, {
              outboundVideoRtpId: [],
              outboundAudioRtpId: []
            });
            const V = {
              bytesSent: y.bytesSent,
              packetsSent: y.packetsSent,
              nackCount: y.nackCount,
              ssrc: y.ssrc,
              mid: y.mid,
              active: y.active,
              codecId: y.codecId,
              headerBytesSent: y.headerBytesSent || 0,
              totalPacketSendDelay: y.totalPacketSendDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const b = y, $e = D({
                frameHeight: b.frameHeight,
                frameWidth: b.frameWidth,
                framesEncoded: b.framesEncoded,
                framesDropped: b.framesDropped ? b.framesDropped : b.droppedFrames,
                framesPerSecond: b.framesPerSecond ? b.framesPerSecond : b.framerateMean,
                framesSent: b.framesSent,
                keyFramesEncoded: b.keyFramesEncoded,
                firCount: b.firCount,
                encoderImplementation: b.encoderImplementation,
                hugeFramesSent: b.hugeFramesSent,
                pliCount: b.pliCount,
                qpSum: b.qpSum,
                qualityLimitationReason: b.qualityLimitationReason,
                qualityLimitationDurations: b.qualityLimitationDurations,
                qualityLimitationResolutionChanges: b.qualityLimitationResolutionChanges,
                totalEncodeTime: b.totalEncodeTime,
                totalPacketSendDelay: b.totalEncodeTime,
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent,
                scalabilityMode: b.scalabilityMode,
                powerEfficientEncoder: b.powerEfficientEncoder
              }, V);
              d.outboundVideoRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundVideoRtpId.push(I.id), this.processOutboundProducerVideoStats(C, ie, $e);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const b = y, $e = D({
                retransmittedBytesSent: b.retransmittedBytesSent,
                retransmittedPacketsSent: b.retransmittedPacketsSent
              }, V);
              d.outboundAudioRtp.set(I.id, $e), d.producerStreamMap.get(C).outboundAudioRtpId.push(I.id), this.processOutboundProducerAudioStats(C, ie, $e);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
        case "inbound-rtp": {
          const y = I, C = n || this.inboundConsumerMap.get(I.id), U = this.pausedConsumerMap.get(C);
          if (U) {
            if (U.lastReportCalculated === !0)
              break;
            this.pausedConsumerMap.set(C, {
              lastReportCalculated: !0
            });
          }
          if (y.ssrc === 1234)
            break;
          this.overallConsumersStatsMap[C] || (this.overallConsumersStatsMap[C] = {
            totalVideoPacketsReceived: 0,
            totalAudioPacketsReceived: 0
          });
          const ie = this.overallConsumersStatsMap[C];
          if (["video", "audio"].includes(y.mediaType) || ["video", "audio"].includes(y.kind)) {
            if (!this.inboundConsumerMap.has(I.id)) {
              d.staleConsumerStreamMap = !0;
              break;
            }
            d.consumerStreamMap.has(C) || d.consumerStreamMap.set(C, {
              inboundVideoRtpId: [],
              inboundAudioRtpId: []
            });
            const Me = {
              bytesReceived: y.bytesReceived,
              packetsReceived: y.packetsReceived,
              packetsLost: y.packetsLost >= 0 ? y.packetsLost : 0,
              jitter: y.jitter,
              nackCount: y.nackCount,
              jitterBufferDelay: y.jitterBufferDelay,
              jitterBufferEmittedCount: y.jitterBufferEmittedCount,
              lastPacketReceivedTimestamp: y.lastPacketReceivedTimestamp,
              ssrc: y.ssrc,
              mid: y.mid,
              codecId: y.codecId,
              headerBytesReceived: y.headerBytesReceived || 0,
              packetsDiscarded: y.packetsDiscarded || 0,
              jitterBufferMinimumDelay: y.jitterBufferMinimumDelay || 0,
              jitterBufferTargetDelay: y.jitterBufferTargetDelay || 0
            };
            if (y.mediaType === "video" || y.kind === "video") {
              const V = y, b = D({
                frameHeight: V.frameHeight,
                frameWidth: V.frameWidth,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped ? V.framesDropped : V.droppedFrames,
                framesPerSecond: V.framesPerSecond ? V.framesPerSecond : V.framerateMean,
                framesReceived: V.framesReceived,
                keyFramesDecoded: V.keyFramesDecoded,
                firCount: V.firCount,
                decoderImplementation: V.decoderImplementation,
                pliCount: V.pliCount,
                totalProcessingDelay: V.totalProcessingDelay,
                qpSum: V.qpSum || 0,
                totalAssemblyTime: V.totalAssemblyTime || 0,
                totalDecodeTime: V.totalDecodeTime || 0,
                totalFreezesDuration: V.totalFreezesDuration || 0,
                totalInterFrameDelay: V.totalInterFrameDelay || 0,
                totalPausesDuration: V.totalPausesDuration || 0,
                totalSquaredInterFrameDelay: V.totalSquaredInterFrameDelay || 0,
                freezeCount: V.freezeCount || 0,
                pauseCount: V.pauseCount || 0,
                powerEfficientDecoder: V.powerEfficientDecoder
              }, Me);
              b.score = Tm({
                frameWidth: b.frameWidth || 0,
                framesDecoded: (b.framesDecoded || 0) - (((w = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : w.framesDecoded) || 0),
                framesPerSecond: b.framesPerSecond || 0,
                packetsLost: (b.packetsLost || 0) - (((A = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : A.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((N = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : N.packetsReceived) || 0),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C)
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                frameWidth: b.frameWidth || 0,
                frameHeight: b.frameHeight || 0,
                framesPerSecond: b.framesPerSecond || 0,
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((H = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : H.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : $.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((F = this.videoConsumerToStatsMap.get(C)) == null ? void 0 : F.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.videoConsumerToStatsMap.set(C, b), d.inboundVideoRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundVideoRtpId.push(I.id), this.processInboundConsumerVideoStats(C, ie, b);
            } else if (y.mediaType === "audio" || y.kind === "audio") {
              const V = y, b = D({
                audioLevel: V.audioLevel,
                concealedSamples: V.concealedSamples,
                concealmentEvents: V.concealmentEvents,
                totalAudioEnergy: V.totalAudioEnergy,
                totalSamplesDuration: V.totalSamplesDuration,
                totalSamplesReceived: V.totalSamplesReceived,
                fecPacketsDiscarded: V.fecPacketsDiscarded || 0,
                fecPacketsReceived: V.fecPacketsReceived || 0,
                insertedSamplesForDeceleration: V.insertedSamplesForDeceleration || 0,
                removedSamplesForAcceleration: V.removedSamplesForAcceleration || 0,
                silentConcealedSamples: V.silentConcealedSamples || 0,
                playoutId: V.playoutId
              }, Me);
              b.score = ym({
                concealmentEvents: (b.concealmentEvents || 0) - (((K = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : K.concealmentEvents) || 0),
                packetsLost: (b.packetsLost || 0) - (((re = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : re.packetsLost) || 0),
                packetsReceived: (b.packetsReceived || 0) - (((Je = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Je.packetsReceived) || 0),
                jitter: b.jitter || 0
              }), _.set(C, {
                score: +(b.score * 10).toFixed(),
                packetsLostPercentage: kd({
                  packetsLost: (b.packetsLost || 0) - (((ks = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ks.packetsLost) || 0),
                  packetsReceived: (b.packetsReceived || 0) - (((Pr = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : Pr.packetsReceived) || 0)
                }),
                jitter: b.jitter || 0,
                isScreenShare: this.screenShareConsumers.has(C),
                bitrate: ((b.bytesReceived || 0) - (((ni = this.audioConsumerToStatsMap.get(C)) == null ? void 0 : ni.bytesReceived) || 0)) * 8 / 7
                // Bytes received in last 7 seconds
              }), this.audioConsumerToStatsMap.set(C, b), d.inboundAudioRtp.set(I.id, b), d.consumerStreamMap.get(C).inboundAudioRtpId.push(I.id), this.processInboundConsumerAudioStats(C, ie, b);
            }
          } else
            this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${y.mediaType} kind: ${y.kind}`);
          break;
        }
      }
    }
    if (d.producerStreamMap.forEach((I, y) => {
      var C, U, ie, Me, V, b, $e, Cr, Rr, Fs, Xn, Zn, eo, to, so, ro, io, ao, no, oo, co, lo, uo;
      if (I.outboundVideoRtpId.length > 0) {
        const ue = [];
        I.outboundVideoRtpId.forEach((ru) => {
          ue.push(d.outboundVideoRtp.get(ru));
        });
        const se = this.getWorkingSimulcastVideoStats(ue);
        se.score = Sm({
          frameWidth: se.frameWidth || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: ((C = se.remoteData) == null ? void 0 : C.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsSent: (se.packetsSent || 0) - (((U = this.videoProducerToStatsMap.get(y)) == null ? void 0 : U.packetsSent) || 0),
          packetsLost: (((ie = se.remoteData) == null ? void 0 : ie.packetsLost) || 0) - (((V = (Me = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Me.remoteData) == null ? void 0 : V.packetsLost) || 0),
          framesEncoded: (se.framesEncoded || 0) - (((b = this.videoProducerToStatsMap.get(y)) == null ? void 0 : b.framesEncoded) || 0)
        }), T.set(y, {
          score: +(se.score * 10).toFixed(),
          frameWidth: se.frameWidth || 0,
          frameHeight: se.frameHeight || 0,
          framesPerSecond: se.framesPerSecond || 0,
          jitter: (($e = se.remoteData) == null ? void 0 : $e.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y),
          packetsLostPercentage: bd({
            packetsSent: (se.packetsSent || 0) - (((Cr = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Cr.packetsSent) || 0),
            packetsLost: (((Rr = se.remoteData) == null ? void 0 : Rr.packetsLost) || 0) - (((Xn = (Fs = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Fs.remoteData) == null ? void 0 : Xn.packetsLost) || 0)
          }),
          bitrate: ((se.bytesSent || 0) - (((Zn = this.videoProducerToStatsMap.get(y)) == null ? void 0 : Zn.bytesSent) || 0)) * 8 / 7,
          cpuLimitations: se.qualityLimitationReason === "cpu",
          bandwidthLimitations: se.qualityLimitationReason === "bandwidth"
        }), this.videoProducerToStatsMap.set(y, se);
      } else if (I.outboundAudioRtpId.length > 0) {
        const ue = d.outboundAudioRtp.get(I.outboundAudioRtpId[0]);
        ue.score = fm({
          packetsSent: (ue.packetsSent || 0) - (((eo = this.audioProducerToStatsMap.get(y)) == null ? void 0 : eo.packetsSent) || 0),
          packetsLost: (((to = ue.remoteData) == null ? void 0 : to.packetsLost) || 0) - (((ro = (so = this.audioProducerToStatsMap.get(y)) == null ? void 0 : so.remoteData) == null ? void 0 : ro.packetsLost) || 0),
          jitter: ((io = ue.remoteData) == null ? void 0 : io.jitter) || 0
        }), T.set(y, {
          score: +(ue.score * 10).toFixed(),
          bitrate: ((ue.bytesSent || 0) - (((ao = this.audioProducerToStatsMap.get(y)) == null ? void 0 : ao.bytesSent) || 0)) * 8 / 7,
          packetsLostPercentage: bd({
            packetsSent: (ue.packetsSent || 0) - (((no = this.audioProducerToStatsMap.get(y)) == null ? void 0 : no.packetsSent) || 0),
            packetsLost: (((oo = ue.remoteData) == null ? void 0 : oo.packetsLost) || 0) - (((lo = (co = this.audioProducerToStatsMap.get(y)) == null ? void 0 : co.remoteData) == null ? void 0 : lo.packetsLost) || 0)
          }),
          jitter: ((uo = ue.remoteData) == null ? void 0 : uo.jitter) || 0,
          isScreenShare: this.screenShareProducers.has(y)
        }), this.audioProducerToStatsMap.set(y, ue);
      }
    }), S.forEach((I) => {
      const y = p.find((U) => U.id === I.localCandidateId ? (I.localCandidateId = U.id, U) : null), C = f.find((U) => U.id === I.remoteCandidateId ? (I.remoteCandidateId = U.id, U) : null);
      y && (I.localCandidateType = y.type, I.localCandidateAddress = Zr(y.address), I.localCandidatePort = y.port, I.localCandidateProtocol = y.protocol, I.localCandidateUrl = y.url, I.localCandidateNetworkType = y.networkType, I.localCandidateRelatedAddress = Zr(y.relatedAddress), I.localCandidateRelatedPort = y.relatedPort), C && (I.remoteCandidateType = C.type, I.remoteCandidateAddress = Zr(C.address), I.remoteCandidatePort = C.port, I.remoteCandidateProtocol = C.protocol, I.remoteCandidateUrl = C.url);
    }), d.candidatePair && (d.transport ? (d.transport.bytesReceived = d.candidatePair.bytesReceived, d.transport.bytesSent = d.candidatePair.bytesSent, d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.availableIncomingBitrate = d.candidatePair.availableIncomingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
      // candidateStats: result.candidatePair,
      bytesReceived: d.candidatePair.bytesReceived,
      bytesSent: d.candidatePair.bytesSent,
      totalRoundTripTime: d.candidatePair.totalRoundTripTime,
      availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
      availableIncomingBitrate: d.candidatePair.availableIncomingBitrate,
      roundTripTime: d.candidatePair.currentRoundTripTime
    }), d.transport && (d.transport.candidatePairs = S), d.transport && !d.transport.roundTripTime) {
      let I = 0, y = 0;
      d.remoteInboundRtp.forEach((C, U) => {
        C.roundTripTime && C.roundTripTime > I && (I = C.roundTripTime, y = C.totalRoundTripTime);
      }), d.transport.roundTripTime = I, d.transport.totalRoundTripTime = y;
    }
    if (_.size > 0)
      try {
        this.observer.emit("consumer_score", _);
      } catch (I) {
      }
    if (T.size > 0)
      try {
        this.observer.emit("producer_score", T);
      } catch (I) {
      }
    return d;
  }
  getProducerStatsFromReport(e) {
    const r = [];
    try {
      e.producerStreamMap.forEach((i, n) => {
        const o = this.producerMap.get(n), c = o.track.getSettings(), d = i.outboundVideoRtpId.map((p) => {
          const f = e.outboundVideoRtp.get(p);
          return f.frameHeight || (f.frameHeight = c.height, f.frameWidth = c.width, f.framesPerSecond = c.frameRate), f;
        }), l = {
          producerId: n,
          appData: o.appData,
          videoStats: d,
          audioStats: i.outboundAudioRtpId.map((p) => e.outboundAudioRtp.get(p))
        };
        r.push(l);
      });
    } catch (i) {
      console.error("getProducersReport: ", i, e);
    }
    return r;
  }
  getConsumerStatsFromParsedConsumerStats(e, r, i) {
    let n;
    try {
      const { peerId: o, producerId: c, appData: d } = this.consumerPeerIdMap.get(i), l = r == null ? void 0 : r.inboundVideoRtpId.map((p) => {
        const S = this.consumerMap.get(i).track.getSettings(), T = e.inboundVideoRtp.get(p);
        return T.frameHeight || (T.frameHeight = S.height, T.frameWidth = S.width, T.framesPerSecond = S.frameRate), T;
      });
      n = {
        consumerId: i,
        peerId: o,
        producerId: c,
        appData: d,
        videoStats: l,
        audioStats: r == null ? void 0 : r.inboundAudioRtpId.map((p) => e.inboundAudioRtp.get(p))
      };
    } catch (o) {
      console.error("getConsumerStatsFromParsedConsumerStats: ", o, e);
    }
    return n;
  }
  getConsumerStatsFromReport(e) {
    const r = [];
    try {
      e.consumerStreamMap.forEach((i, n) => {
        r.push(this.getConsumerStatsFromParsedConsumerStats(e, i, n));
      });
    } catch (i) {
      console.error("getConsumerStatsFromReport: ", i, e);
    }
    return r;
  }
}
class xv extends Cm {
}
function Id(s, t, e, r) {
  if (s != null && s.logger && s.logger.error("Callstats::handleError", { error: r }), typeof e == "function" && r instanceof t)
    e.call(null, r, s);
  else
    throw r;
}
function cp(s, t, e) {
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        Id(this, t, e, o);
      }) : n;
    } catch (n) {
      Id(this, t, e, n);
    }
    return null;
  }, s;
}
const Z = (s, t) => (e, r, i) => {
  const n = i.value;
  return i.value = function(...o) {
    try {
      const c = n.apply(this, o);
      return c && c instanceof Promise ? c.catch((d) => {
        Id(this, s, t, d);
      }) : c;
    } catch (c) {
      Id(this, s, t, c);
    }
    return null;
  }, i;
}, Uv = (s, t) => (e, r, i) => {
  if (i)
    return cp(i, s, t);
  for (const n of Reflect.ownKeys(e.prototype).filter((o) => o !== "constructor")) {
    const o = Object.getOwnPropertyDescriptor(e.prototype, n);
    o.value instanceof Function && Object.defineProperty(e.prototype, n, cp(o, s, t));
  }
};
var Y = globalThis && globalThis.__decorate || function(s, t, e, r) {
  var i = arguments.length, n = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(s, t, e, r);
  else
    for (var c = s.length - 1; c >= 0; c--)
      (o = s[c]) && (n = (i < 3 ? o(n) : i > 3 ? o(t, e, n) : o(t, e)) || n);
  return i > 3 && n && Object.defineProperty(t, e, n), n;
};
const Q = console;
let J = class extends ut {
  constructor(e = "https://api.testingv3.dyte.in", r = "Blink", i = bo.PROD, n, o, c, d) {
    super();
    h(this, "observer");
    h(this, "eventHandler");
    h(this, "measurements");
    h(this, "producingTransport");
    h(this, "consumingTransport");
    h(this, "producers", /* @__PURE__ */ new Map());
    h(this, "consumers", /* @__PURE__ */ new Map());
    h(this, "iceServers");
    h(this, "connectionInfoPromise");
    h(this, "pingStatsTimeout");
    h(this, "logger");
    h(this, "env");
    h(this, "apiHostnames");
    h(this, "peerId");
    h(this, "consumerSharedMediaStatesMap", /* @__PURE__ */ new Map());
    h(this, "currentUserMediaStates", {});
    switch (this.env = i, this.apiHostnames = d, this.logger = o, this.peerId = c, this.eventHandler = new _v({ logger: o, peerId: c, apiHostnames: d }), this.logger.debug("callStats::engineName: ", { engineName: r }), r) {
      case "Blink":
        this.measurements = new Lv();
        break;
      case "Gecko":
        this.measurements = new Cm();
        break;
      case "WebKit":
        this.measurements = new xv();
        break;
      default:
        throw Error(`Unknown engineName! ${r}`);
    }
    this.measurements.callStatsInstance = this, this.registerProducer = this.registerProducer.bind(this), this.registerConsumer = this.registerConsumer.bind(this), this.observer = new ut(), this.measurements.observer.on("consumer_score", (l) => {
      o.debug(`callStats::consumer_score ${[...l.entries()]}`), this.eventHandler.emit("consumer_score", l);
    }), this.measurements.observer.on("producer_score", (l) => {
      o.debug(`callStats::producer_score ${[...l.entries()]}`), this.eventHandler.emit("producer_score", l);
    });
  }
  registerIceServers(e) {
    this.iceServers = e;
  }
  registerConsumer(e) {
    var r;
    this.consumerSharedMediaStatesMap.has(e.id) || this.consumerSharedMediaStatesMap.set(e.id, {}), this.consumers.set(e.id, e), this.measurements.registerConsumer(e), this.logger.debug("callStats::registerConsumer", { consumerId: e.id, consumerkind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterConsumer.bind(this, e));
  }
  registerProducer(e) {
    var r;
    this.producers.set(e.id, e), this.measurements.registerProducer(e), this.logger.debug("callStats::registerProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.on("close", this.deRegisterProducer.bind(this, e));
  }
  sendConsumerSharedMediaStateEvent(e, r) {
    this.consumerSharedMediaStatesMap.has(e) || this.consumerSharedMediaStatesMap.set(e, {});
    const i = this.consumerSharedMediaStatesMap.get(e);
    this.consumerSharedMediaStatesMap.set(e, Object.assign(i, r));
  }
  registerProducingTransport(e) {
    var i;
    this.producingTransport = e, e.on("close", this.disconnectProducingTransport.bind(this, e)), e.on("disconnect", this.disconnectProducingTransport.bind(this, e)), Array.from(
      // eslint-disable-next-line no-underscore-dangle
      ((i = e._producers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerProducer(n);
    }), e.on("newproducer", this.registerProducer);
  }
  registerConsumingTransport(e) {
    var i;
    this.consumingTransport = e, e.on("close", this.disconnectConsumingTransport.bind(this, e)), e.on("disconnect", this.disconnectConsumingTransport.bind(this, e)), Array.from(
      // eslint-disable-next-line no-underscore-dangle
      ((i = e._consumers) == null ? void 0 : i.values()) || []
    ).forEach((n) => {
      this.registerConsumer(n);
    }), e.on("newconsumer", this.registerConsumer);
  }
  deRegisterConsumer(e) {
    this.consumers.delete(e.id);
  }
  deRegisterProducer(e) {
    var r;
    this.producers.delete(e.id), this.logger.debug("callStats::deRegisterProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) });
  }
  disconnectConsumingTransport() {
    this.consumingTransport = void 0;
  }
  disconnectProducingTransport() {
    this.producingTransport = void 0;
  }
  callEvent(e) {
    this.eventHandler.callEvent(e);
  }
  sendPreCallTestBeginEvent(e = !1, r) {
    this.connectionInfoPromise = this.measurements.getNetworkInfo(this.iceServers, e), this.eventHandler.callEvent({
      event: O.PRECALL_TEST_BEGIN,
      timestamp: r
    }), this.connectionInfoPromise && this.connectionInfoPromise.then((i) => {
      this.eventHandler.callEvent({
        event: O.PRECALL_TEST_COMPLETE,
        metaData: {
          connectionInfo: i
        },
        timestamp: r
      });
    });
  }
  sendScreenShareToggleEvent(e, r = null, i) {
    this.currentUserMediaStates.screen = e, this.eventHandler.callEvent({
      event: e ? O.SCREENSHARE_STARTED : O.SCREENSHARE_STOPPED,
      metaData: {
        ssrc: r
      },
      timestamp: i
    });
  }
  sendScreenShareRequestedEvent(e) {
    this.eventHandler.callEvent({
      event: O.SCREENSHARE_START_REQUESTED,
      timestamp: e
    });
  }
  sendActiveSpeakerEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.DOMINANT_SPEAKER,
      metaData: {
        peerId: e
      },
      timestamp: r
    });
  }
  devices(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_DEVICES_UPDATES || e === Jt.VIDEO && O.VIDEO_DEVICES_UPDATES || e === Jt.SPEAKER && O.SPEAKER_DEVICES_UPDATES,
      metaData: {
        deviceList: r
      },
      timestamp: i
    });
  }
  selectedDevice(e, r, i) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.SELECTED_MICROHPONE_UPDATE || e === Jt.VIDEO && O.SELECTED_CAMERA_UPDATE || e === Jt.SPEAKER && O.SELECTED_SPEAKER_UPDATE,
      metaData: {
        device: r
      },
      timestamp: i
    });
  }
  mediaPermission(e, r, i) {
    this.eventHandler.callEvent({
      event: O.MEDIA_PERMISSION,
      metaData: {
        deviceType: e,
        permission: r
      },
      timestamp: i
    });
  }
  mediaPlaybackFailed(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_PLAY_FAILED || e === Jt.VIDEO && O.VIDEO_PLAY_FAILED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  mediaTrackMuted(e, r) {
    this.eventHandler.callEvent({
      event: e === Jt.AUDIO && O.AUDIO_TRACK_MUTED || e === Jt.VIDEO && O.VIDEO_TRACK_MUTED,
      metaData: {
        deviceType: e
      },
      timestamp: r
    });
  }
  tabChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.TAB_CHANGE,
      metaData: { isMeetingsTabActive: e },
      timestamp: r
    });
  }
  browserBackgrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_BACKGROUNDED,
      timestamp: e
    });
  }
  browserForegrounded(e) {
    this.eventHandler.callEvent({
      event: O.BROWSER_FOREGROUNDED,
      timestamp: e
    });
  }
  legacySwitch(e, r) {
    this.eventHandler.callEvent({
      event: O.LEGACY_SWITCH,
      metadata: { on: e },
      timestamp: r
    });
  }
  getPreCallTestResults() {
    return u(this, null, function* () {
      return this.connectionInfoPromise;
    });
  }
  sendCallJoinBeginEvent(e, r) {
    e = B(D({}, e), {
      meetingEnv: this.env
    }), e.deviceInfo = B(D({}, e.deviceInfo), {
      userAgent: navigator.userAgent,
      cpus: navigator.hardwareConcurrency,
      memory: navigator.deviceMemory
    }), this.eventHandler.callEvent({
      event: O.CALL_JOIN_BEGIN,
      metaData: {
        peerMetaData: e
      },
      timestamp: r
    });
  }
  sendNetworkQualityTestBeginEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.NET_QUALITY_TEST_BEGIN,
      timestamp: r
    }), new Promise((n, o) => u(this, null, function* () {
      const c = [];
      try {
        for (const d of e)
          try {
            if (d.iceServers && d.iceServers.length > 0) {
              const l = yield this.measurements.getNetworkQuality(d.iceServers);
              c.push(B(D({}, d), {
                networkResults: l
              }));
            }
          } catch (l) {
            console.warn("Error handling ", l);
          }
        n({
          regionData: c
        });
      } catch (d) {
        console.warn("Error in callstats, ", d), o(d);
      }
    })).then((n) => {
      this.eventHandler.callEvent({
        event: O.NET_QUALITY_TEST_END,
        timestamp: r,
        metaData: n
      });
    });
  }
  sendWebSocketConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.WEBSOCKET_CONNECTED,
      timestamp: e
    });
  }
  sendTransportConnectedEvent(e) {
    this.eventHandler.callEvent({
      event: O.TRANSPORT_CONNECTED,
      timestamp: e
    });
  }
  sendAudioToggleEvent(e, r) {
    this.currentUserMediaStates.audio = e;
    let i;
    e ? i = O.AUDIO_ON : i = O.AUDIO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendVideoToggleEvent(e, r) {
    this.currentUserMediaStates.video = e;
    let i;
    e ? i = O.VIDEO_ON : i = O.VIDEO_OFF, this.eventHandler.callEvent({
      event: i,
      timestamp: r
    });
  }
  sendParticipantRoleToggleEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.PARTICIPANT_ROLE,
      timestamp: r,
      metaData: e
    });
  }
  startPingStats(e = 7e3) {
    this.sendPingStatsEvent(!1, new Date()), this.pingStatsTimeout = setInterval(this.sendPingStatsEvent.bind(this), e);
  }
  stopPingStats() {
    clearInterval(this.pingStatsTimeout);
  }
  sendPingStatsEvent(e = !0, r) {
    return u(this, null, function* () {
      let i, n;
      if (this.producingTransport && (i = yield this.measurements.getProcessedStats(this.producingTransport, !1, !0), !i || !(i != null && i.producerReport))) {
        this.logger.debug("callStats::sendPingStatsEvent::staleProducingTransport", { disclaimer: "Stale producer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getProducersReport([...this.producers.values()]);
        i && c ? i.producerReport = c : (i = yield this.measurements.getProcessedStats(this.producingTransport, !1, !0), (!i || !(i != null && i.producerReport)) && this.logger.debug("callStats::sendPingStatsEvent::noProducingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      if (this.consumingTransport && (n = yield this.measurements.getProcessedStats(this.consumingTransport, !0, !1), !n || !n.consumerReport)) {
        this.logger.debug("callStats::sendPingStatsEvent::staleConsumingTransport", { disclaimer: "Stale consumer? Regenerating Stream Maps!" });
        const c = yield this.measurements.getConsumersReport([...this.consumers.values()]);
        n && c ? n.consumerReport = c : (n = yield this.measurements.getProcessedStats(this.consumingTransport, !0, !1), (!n || !n.consumerReport) && this.logger.debug("callStats::sendPingStatsEvent::noConsumingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
      }
      const o = {
        producingTransportStats: i ? i == null ? void 0 : i.transportReport : void 0,
        consumingTransportStats: n ? n == null ? void 0 : n.transportReport : void 0,
        producerStats: [].concat((i == null ? void 0 : i.producerReport) || []).concat((n == null ? void 0 : n.producerReport) || []),
        consumerStats: [].concat((n == null ? void 0 : n.consumerReport) || []).concat((i == null ? void 0 : i.consumerReport) || [])
      };
      if (e && o.producerStats.length === 0 && o.consumerStats.length === 0) {
        yield this.eventHandler.flush();
        return;
      }
      this.eventHandler.callEvent({
        event: O.PING_STAT,
        metaData: o,
        timestamp: r
      });
    });
  }
  sendIVSPlayerRebufferEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_REBUFFERING,
      timestamp: e
    });
  }
  sendIVSPlayerAudioBlockEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_AUDIO_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerPlaybackBlockedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_BLOCKED,
      timestamp: e
    });
  }
  sendIVSPlayerNetworkUnavailableEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_NETWORK_UNAVAILABLE,
      timestamp: e
    });
  }
  sendIVSPlayerInitializedEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_INITIALIZED,
      timestamp: e
    });
  }
  sendIVSPlayerWorkerErrorEvent(e) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_WORKER_ERROR,
      timestamp: e
    });
  }
  sendIVSPlayerErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerRecoverableErrorEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_RECOVERABLE_ERROR,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerAnalyticsEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_ANALYTICS_EVENT,
      timestamp: r,
      metaData: e
    });
  }
  sendIVSPlayerPlaybackRateChangedEvent(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_PLAYBACK_RATE_CHANGED,
      timestamp: r,
      metaData: {
        updatedPlaybackRate: e
      }
    });
  }
  sendIVSPlayerQualityChanged(e, r) {
    this.eventHandler.callEvent({
      event: O.IVS_PLAYER_QUALITY_CHANGED,
      timestamp: r,
      metaData: e
    });
  }
  sendPlayerLiveLatency(e, r) {
    this.eventHandler.callEvent({
      event: O.LIVESTREAM_LATENCY,
      timestamp: r,
      metaData: {
        latency: e
      }
    });
  }
  sendDisconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.DISCONNECT,
      timestamp: e
    });
  }
  sendReconnectEvent(e) {
    this.eventHandler.callEvent({
      event: O.RECONNECT_ATTEMPT,
      timestamp: e
    });
  }
  expectedVideoResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_VIDEO_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
  expectedScreenshareResolution(e, r, i) {
    this.eventHandler.callEvent({
      event: O.EXPECTED_SCREENSHARE_RESOLUTION,
      timestamp: i,
      metaData: {
        frameWidth: e,
        frameHeight: r
      }
    });
  }
};
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerIceServers", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendConsumerSharedMediaStateEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "registerConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterConsumer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "deRegisterProducer", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectConsumingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "disconnectProducingTransport", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPreCallTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendScreenShareRequestedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendActiveSpeakerEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "devices", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "selectedDevice", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPermission", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaPlaybackFailed", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "mediaTrackMuted", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "tabChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserBackgrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "browserForegrounded", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "legacySwitch", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "getPreCallTestResults", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendCallJoinBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendNetworkQualityTestBeginEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendWebSocketConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendTransportConnectedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendAudioToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendVideoToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendParticipantRoleToggleEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "startPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "stopPingStats", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPingStatsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRebufferEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAudioBlockEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackBlockedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerNetworkUnavailableEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerInitializedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerWorkerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerRecoverableErrorEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerAnalyticsEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerPlaybackRateChangedEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendIVSPlayerQualityChanged", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendPlayerLiveLatency", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendDisconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "sendReconnectEvent", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedVideoResolution", null);
Y([
  Z(TypeError, (s, t) => Q.error(t, s))
], J.prototype, "expectedScreenshareResolution", null);
J = Y([
  Uv(TypeError, (s, t) => Q.error(t, s))
], J);
const $v = J;
class Rm extends ut {
  constructor() {
    super(...arguments);
    h(this, "stats");
    h(this, "peerId");
    h(this, "backend");
    h(this, "iceServers");
    h(this, "initialized", !1);
    h(this, "stalled", !1);
    // Initialization will never occur
    h(this, "ipInformation");
    h(this, "logger");
  }
  initialize(f) {
    return u(this, arguments, function* ({ peerId: e, engineName: r, env: i = bo.PROD, iceServers: n, apiBase: o = "https://api.cluster.dyte.in", flags: c, logger: d = console, apiHostnames: l, skipConnectivityChecks: p = !1 }) {
      var S, T, _;
      try {
        this.peerId = e, this.logger = d, this.ipInformation = yield yh.getIPDetails({ peerId: e, apiHostnames: l, logger: d }), this.backend = new $v(o, r, i, c, d, e, l), this.iceServers = n, (S = this.backend) == null || S.registerIceServers(this.iceServers), this.initialized = !0, (_ = (T = this.backend) == null ? void 0 : T.eventHandler) == null || _.emit("initialized", this.ipInformation), this.emit("initialized", this.ipInformation), this.startPreCallTest(p);
      } catch (P) {
        this.logger.error("callStats::CallStatsIntegration: ", { error: P }), this.stallCallStats();
      }
    });
  }
  configureSendTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerProducingTransport(e);
    });
  }
  configureRecvTransport(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.registerConsumingTransport(e);
    });
  }
  candidateRegionalNetworkQualityTest(e) {
    return u(this, null, function* () {
      const r = new Date();
      this.onSafeInitialization(() => {
        var i;
        try {
          (i = this.backend) == null || i.sendNetworkQualityTestBeginEvent(e, r);
        } catch (n) {
          this.logger.error("callStats::sendNetworkQualityTestBeginEvent", { error: { reason: n.reason } });
        }
      });
    });
  }
  roomJoined(e) {
    return u(this, null, function* () {
      const r = new Date();
      this.onSafeInitialization(() => {
        var i, n;
        (i = this.backend) == null || i.sendCallJoinBeginEvent(e, r), this.backend, (n = this.backend) == null || n.startPingStats();
      });
    });
  }
  audioOff() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(!1, e);
    });
  }
  audioOn() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendAudioToggleEvent(!0, e);
    });
  }
  videoOff() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(!1, e);
    });
  }
  videoOn() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendVideoToggleEvent(!0, e);
    });
  }
  callEnded() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r, i;
      (r = this.backend) == null || r.stopPingStats(), (i = this.backend) == null || i.sendDisconnectEvent(e);
    });
  }
  screenShareStart(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(!0, e, r);
    });
  }
  consumerSharedMediaState(e, r) {
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendConsumerSharedMediaStateEvent(e, r);
    });
  }
  screenShareStop(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendScreenShareToggleEvent(!1, e, r);
    });
  }
  screenShareRequested() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.sendScreenShareRequestedEvent(e);
    });
  }
  activeSpeaker(e) {
    if (e !== this.peerId)
      return;
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendActiveSpeakerEvent(e, r);
    });
  }
  devices(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.devices(e, r, i);
    });
  }
  selectedDevice(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.selectedDevice(e, r, i);
    });
  }
  mediaPermission(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.mediaPermission(e, r, i);
    });
  }
  mediaPlaybackFailed(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaPlaybackFailed(e, r);
    });
  }
  mediaTrackMuted(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.mediaTrackMuted(e, r);
    });
  }
  tabChanged(e = !1) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.tabChanged(e, r);
    });
  }
  browserBackgrounded() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserBackgrounded(e);
    });
  }
  browserForegrounded() {
    const e = new Date();
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.browserForegrounded(e);
    });
  }
  legacySwitch(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.legacySwitch(e, r);
    });
  }
  startPreCallTest(e = !1) {
    return u(this, null, function* () {
      const r = new Date();
      this.onSafeInitialization(() => {
        var i;
        (i = this.backend) == null || i.sendPreCallTestBeginEvent(e, r);
      });
    });
  }
  onPreCallTestResults(e) {
    return this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.once("precall_end", e);
    }), e;
  }
  onReceivingConsumerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_audio_status", e);
    });
  }
  onReceivingConsumerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_video_status", e);
    });
  }
  onReceivingProducerAudioStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_audio_status", e);
    });
  }
  onReceivingProducerVideoStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_video_status", e);
    });
  }
  onReceivingProducingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producing_transport_status", e);
    });
  }
  onReceivingConsumingTransportStatus(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consuming_transport_status", e);
    });
  }
  onProducerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_score", e);
    });
  }
  onConsumerScore(e) {
    this.onSafeInitialization(() => {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_score", e);
    });
  }
  onSafeInitialization(e) {
    if (this.initialized)
      e(this.ipInformation, !1);
    else if (!this.stalled) {
      const r = (i) => {
        e(i, !0);
      };
      return this.once("initialized", r), r;
    }
    return () => {
    };
  }
  removeInitializationListener(e) {
    this.removeListener("initialized", e);
  }
  stallCallStats() {
    this.stalled = !0, this.removeAllListeners("initialized");
  }
  ivsPlayerEvent(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n, o, c, d, l, p, f, S, T, _, P;
      switch (e) {
        case "PlayerRebuffering":
          (n = this.backend) == null || n.sendIVSPlayerRebufferEvent(i);
          break;
        case "PlayerAudioBlocked":
          (o = this.backend) == null || o.sendIVSPlayerAudioBlockEvent(i);
          break;
        case "PlayerPlaybackBlocked":
          (c = this.backend) == null || c.sendIVSPlayerPlaybackBlockedEvent(i);
          break;
        case "PlayerNetworkUnavailable":
          (d = this.backend) == null || d.sendIVSPlayerNetworkUnavailableEvent(i);
          break;
        case "PlayerInitialized":
          (l = this.backend) == null || l.sendIVSPlayerInitializedEvent(i);
          break;
        case "PlayerWorkerError":
          (p = this.backend) == null || p.sendIVSPlayerWorkerErrorEvent(i);
          break;
        case "PlayerError":
          (f = this.backend) == null || f.sendIVSPlayerErrorEvent(r, i);
          break;
        case "PlayerRecoverableError":
          (S = this.backend) == null || S.sendIVSPlayerRecoverableErrorEvent(r, i);
          break;
        case "PlayerAnalyticsEvent":
          (T = this.backend) == null || T.sendIVSPlayerAnalyticsEvent(r, i);
          break;
        case "PlayerPlaybackRateChanged":
          (_ = this.backend) == null || _.sendIVSPlayerPlaybackRateChangedEvent(r, i);
          break;
        case "PlayerQualityChanged":
          (P = this.backend) == null || P.sendIVSPlayerQualityChanged(r, i);
          break;
      }
    });
  }
  livestreamLatency(e) {
    const r = new Date();
    this.onSafeInitialization(() => {
      var i;
      (i = this.backend) == null || i.sendPlayerLiveLatency(e, r);
    });
  }
  expectedVideoResolution(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedVideoResolution(e, r, i);
    });
  }
  expectedScreenshareResolution(e, r) {
    const i = new Date();
    this.onSafeInitialization(() => {
      var n;
      (n = this.backend) == null || n.expectedScreenshareResolution(e, r, i);
    });
  }
}
const Fv = new Rm();
Fv.setMaxListeners(30);
function Hv() {
  this.__data__ = [], this.size = 0;
}
function qc(s, t) {
  return s === t || s !== s && t !== t;
}
function Hl(s, t) {
  for (var e = s.length; e--; )
    if (qc(s[e][0], t))
      return e;
  return -1;
}
var Bv = Array.prototype, qv = Bv.splice;
function jv(s) {
  var t = this.__data__, e = Hl(t, s);
  if (e < 0)
    return !1;
  var r = t.length - 1;
  return e == r ? t.pop() : qv.call(t, e, 1), --this.size, !0;
}
function Gv(s) {
  var t = this.__data__, e = Hl(t, s);
  return e < 0 ? void 0 : t[e][1];
}
function Wv(s) {
  return Hl(this.__data__, s) > -1;
}
function Jv(s, t) {
  var e = this.__data__, r = Hl(e, s);
  return r < 0 ? (++this.size, e.push([s, t])) : e[r][1] = t, this;
}
function Tr(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
Tr.prototype.clear = Hv;
Tr.prototype.delete = jv;
Tr.prototype.get = Gv;
Tr.prototype.has = Wv;
Tr.prototype.set = Jv;
function Kv() {
  this.__data__ = new Tr(), this.size = 0;
}
function zv(s) {
  var t = this.__data__, e = t.delete(s);
  return this.size = t.size, e;
}
function Yv(s) {
  return this.__data__.get(s);
}
function Qv(s) {
  return this.__data__.has(s);
}
var Xv = typeof global == "object" && global && global.Object === Object && global;
const wm = Xv;
var Zv = typeof self == "object" && self && self.Object === Object && self, ey = wm || Zv || Function("return this")();
const Cs = ey;
var ty = Cs.Symbol;
const ti = ty;
var bm = Object.prototype, sy = bm.hasOwnProperty, ry = bm.toString, go = ti ? ti.toStringTag : void 0;
function iy(s) {
  var t = sy.call(s, go), e = s[go];
  try {
    s[go] = void 0;
    var r = !0;
  } catch (n) {
  }
  var i = ry.call(s);
  return r && (t ? s[go] = e : delete s[go]), i;
}
var ay = Object.prototype, ny = ay.toString;
function oy(s) {
  return ny.call(s);
}
var cy = "[object Null]", dy = "[object Undefined]", dp = ti ? ti.toStringTag : void 0;
function ma(s) {
  return s == null ? s === void 0 ? dy : cy : dp && dp in Object(s) ? iy(s) : oy(s);
}
function Ps(s) {
  var t = typeof s;
  return s != null && (t == "object" || t == "function");
}
var ly = "[object AsyncFunction]", uy = "[object Function]", hy = "[object GeneratorFunction]", py = "[object Proxy]";
function Th(s) {
  if (!Ps(s))
    return !1;
  var t = ma(s);
  return t == uy || t == hy || t == ly || t == py;
}
var gy = Cs["__core-js_shared__"];
const nu = gy;
var lp = function() {
  var s = /[^.]+$/.exec(nu && nu.keys && nu.keys.IE_PROTO || "");
  return s ? "Symbol(src)_1." + s : "";
}();
function my(s) {
  return !!lp && lp in s;
}
var fy = Function.prototype, Sy = fy.toString;
function fa(s) {
  if (s != null) {
    try {
      return Sy.call(s);
    } catch (t) {
    }
    try {
      return s + "";
    } catch (t) {
    }
  }
  return "";
}
var vy = /[\\^$.*+?()[\]{}|]/g, yy = /^\[object .+?Constructor\]$/, Ty = Function.prototype, Ey = Object.prototype, _y = Ty.toString, Py = Ey.hasOwnProperty, Cy = RegExp(
  "^" + _y.call(Py).replace(vy, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Ry(s) {
  if (!Ps(s) || my(s))
    return !1;
  var t = Th(s) ? Cy : yy;
  return t.test(fa(s));
}
function wy(s, t) {
  return s == null ? void 0 : s[t];
}
function Sa(s, t) {
  var e = wy(s, t);
  return Ry(e) ? e : void 0;
}
var by = Sa(Cs, "Map");
const Lo = by;
var ky = Sa(Object, "create");
const xo = ky;
function Iy() {
  this.__data__ = xo ? xo(null) : {}, this.size = 0;
}
function Ay(s) {
  var t = this.has(s) && delete this.__data__[s];
  return this.size -= t ? 1 : 0, t;
}
var My = "__lodash_hash_undefined__", Dy = Object.prototype, Oy = Dy.hasOwnProperty;
function Ny(s) {
  var t = this.__data__;
  if (xo) {
    var e = t[s];
    return e === My ? void 0 : e;
  }
  return Oy.call(t, s) ? t[s] : void 0;
}
var Vy = Object.prototype, Ly = Vy.hasOwnProperty;
function xy(s) {
  var t = this.__data__;
  return xo ? t[s] !== void 0 : Ly.call(t, s);
}
var Uy = "__lodash_hash_undefined__";
function $y(s, t) {
  var e = this.__data__;
  return this.size += this.has(s) ? 0 : 1, e[s] = xo && t === void 0 ? Uy : t, this;
}
function ha(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
ha.prototype.clear = Iy;
ha.prototype.delete = Ay;
ha.prototype.get = Ny;
ha.prototype.has = xy;
ha.prototype.set = $y;
function Fy() {
  this.size = 0, this.__data__ = {
    hash: new ha(),
    map: new (Lo || Tr)(),
    string: new ha()
  };
}
function Hy(s) {
  var t = typeof s;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? s !== "__proto__" : s === null;
}
function Bl(s, t) {
  var e = s.__data__;
  return Hy(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function By(s) {
  var t = Bl(this, s).delete(s);
  return this.size -= t ? 1 : 0, t;
}
function qy(s) {
  return Bl(this, s).get(s);
}
function jy(s) {
  return Bl(this, s).has(s);
}
function Gy(s, t) {
  var e = Bl(this, s), r = e.size;
  return e.set(s, t), this.size += e.size == r ? 0 : 1, this;
}
function va(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.clear(); ++t < e; ) {
    var r = s[t];
    this.set(r[0], r[1]);
  }
}
va.prototype.clear = Fy;
va.prototype.delete = By;
va.prototype.get = qy;
va.prototype.has = jy;
va.prototype.set = Gy;
var Wy = 200;
function Jy(s, t) {
  var e = this.__data__;
  if (e instanceof Tr) {
    var r = e.__data__;
    if (!Lo || r.length < Wy - 1)
      return r.push([s, t]), this.size = ++e.size, this;
    e = this.__data__ = new va(r);
  }
  return e.set(s, t), this.size = e.size, this;
}
function Us(s) {
  var t = this.__data__ = new Tr(s);
  this.size = t.size;
}
Us.prototype.clear = Kv;
Us.prototype.delete = zv;
Us.prototype.get = Yv;
Us.prototype.has = Qv;
Us.prototype.set = Jy;
function Ky(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r && t(s[e], e, s) !== !1; )
    ;
  return s;
}
var zy = function() {
  try {
    var s = Sa(Object, "defineProperty");
    return s({}, "", {}), s;
  } catch (t) {
  }
}();
const Ad = zy;
function Eh(s, t, e) {
  t == "__proto__" && Ad ? Ad(s, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : s[t] = e;
}
var Yy = Object.prototype, Qy = Yy.hasOwnProperty;
function km(s, t, e) {
  var r = s[t];
  (!(Qy.call(s, t) && qc(r, e)) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
function jc(s, t, e, r) {
  var i = !e;
  e || (e = {});
  for (var n = -1, o = t.length; ++n < o; ) {
    var c = t[n], d = r ? r(e[c], s[c], c, e, s) : void 0;
    d === void 0 && (d = s[c]), i ? Eh(e, c, d) : km(e, c, d);
  }
  return e;
}
function Xy(s, t) {
  for (var e = -1, r = Array(s); ++e < s; )
    r[e] = t(e);
  return r;
}
function $s(s) {
  return s != null && typeof s == "object";
}
var Zy = "[object Arguments]";
function up(s) {
  return $s(s) && ma(s) == Zy;
}
var Im = Object.prototype, eT = Im.hasOwnProperty, tT = Im.propertyIsEnumerable, sT = up(function() {
  return arguments;
}()) ? up : function(s) {
  return $s(s) && eT.call(s, "callee") && !tT.call(s, "callee");
};
const Md = sT;
var rT = Array.isArray;
const si = rT;
function iT() {
  return !1;
}
var Am = typeof exports == "object" && exports && !exports.nodeType && exports, hp = Am && typeof module == "object" && module && !module.nodeType && module, aT = hp && hp.exports === Am, pp = aT ? Cs.Buffer : void 0, nT = pp ? pp.isBuffer : void 0, oT = nT || iT;
const Bn = oT;
var cT = 9007199254740991, dT = /^(?:0|[1-9]\d*)$/;
function Mm(s, t) {
  var e = typeof s;
  return t = t == null ? cT : t, !!t && (e == "number" || e != "symbol" && dT.test(s)) && s > -1 && s % 1 == 0 && s < t;
}
var lT = 9007199254740991;
function Dm(s) {
  return typeof s == "number" && s > -1 && s % 1 == 0 && s <= lT;
}
var uT = "[object Arguments]", hT = "[object Array]", pT = "[object Boolean]", gT = "[object Date]", mT = "[object Error]", fT = "[object Function]", ST = "[object Map]", vT = "[object Number]", yT = "[object Object]", TT = "[object RegExp]", ET = "[object Set]", _T = "[object String]", PT = "[object WeakMap]", CT = "[object ArrayBuffer]", RT = "[object DataView]", wT = "[object Float32Array]", bT = "[object Float64Array]", kT = "[object Int8Array]", IT = "[object Int16Array]", AT = "[object Int32Array]", MT = "[object Uint8Array]", DT = "[object Uint8ClampedArray]", OT = "[object Uint16Array]", NT = "[object Uint32Array]", ye = {};
ye[wT] = ye[bT] = ye[kT] = ye[IT] = ye[AT] = ye[MT] = ye[DT] = ye[OT] = ye[NT] = !0;
ye[uT] = ye[hT] = ye[CT] = ye[pT] = ye[RT] = ye[gT] = ye[mT] = ye[fT] = ye[ST] = ye[vT] = ye[yT] = ye[TT] = ye[ET] = ye[_T] = ye[PT] = !1;
function VT(s) {
  return $s(s) && Dm(s.length) && !!ye[ma(s)];
}
function _h(s) {
  return function(t) {
    return s(t);
  };
}
var Om = typeof exports == "object" && exports && !exports.nodeType && exports, ko = Om && typeof module == "object" && module && !module.nodeType && module, LT = ko && ko.exports === Om, ou = LT && wm.process, xT = function() {
  try {
    var s = ko && ko.require && ko.require("util").types;
    return s || ou && ou.binding && ou.binding("util");
  } catch (t) {
  }
}();
const qn = xT;
var gp = qn && qn.isTypedArray, UT = gp ? _h(gp) : VT;
const ql = UT;
var $T = Object.prototype, FT = $T.hasOwnProperty;
function Nm(s, t) {
  var e = si(s), r = !e && Md(s), i = !e && !r && Bn(s), n = !e && !r && !i && ql(s), o = e || r || i || n, c = o ? Xy(s.length, String) : [], d = c.length;
  for (var l in s)
    (t || FT.call(s, l)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    n && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    Mm(l, d))) && c.push(l);
  return c;
}
var HT = Object.prototype;
function jl(s) {
  var t = s && s.constructor, e = typeof t == "function" && t.prototype || HT;
  return s === e;
}
function Vm(s, t) {
  return function(e) {
    return s(t(e));
  };
}
var BT = Vm(Object.keys, Object);
const qT = BT;
var jT = Object.prototype, GT = jT.hasOwnProperty;
function Lm(s) {
  if (!jl(s))
    return qT(s);
  var t = [];
  for (var e in Object(s))
    GT.call(s, e) && e != "constructor" && t.push(e);
  return t;
}
function Gc(s) {
  return s != null && Dm(s.length) && !Th(s);
}
function Ph(s) {
  return Gc(s) ? Nm(s) : Lm(s);
}
function WT(s, t) {
  return s && jc(t, Ph(t), s);
}
function JT(s) {
  var t = [];
  if (s != null)
    for (var e in Object(s))
      t.push(e);
  return t;
}
var KT = Object.prototype, zT = KT.hasOwnProperty;
function YT(s) {
  if (!Ps(s))
    return JT(s);
  var t = jl(s), e = [];
  for (var r in s)
    r == "constructor" && (t || !zT.call(s, r)) || e.push(r);
  return e;
}
function Wc(s) {
  return Gc(s) ? Nm(s, !0) : YT(s);
}
function QT(s, t) {
  return s && jc(t, Wc(t), s);
}
var xm = typeof exports == "object" && exports && !exports.nodeType && exports, mp = xm && typeof module == "object" && module && !module.nodeType && module, XT = mp && mp.exports === xm, fp = XT ? Cs.Buffer : void 0, Sp = fp ? fp.allocUnsafe : void 0;
function Um(s, t) {
  if (t)
    return s.slice();
  var e = s.length, r = Sp ? Sp(e) : new s.constructor(e);
  return s.copy(r), r;
}
function $m(s, t) {
  var e = -1, r = s.length;
  for (t || (t = Array(r)); ++e < r; )
    t[e] = s[e];
  return t;
}
function ZT(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length, i = 0, n = []; ++e < r; ) {
    var o = s[e];
    t(o, e, s) && (n[i++] = o);
  }
  return n;
}
function Fm() {
  return [];
}
var eE = Object.prototype, tE = eE.propertyIsEnumerable, vp = Object.getOwnPropertySymbols, sE = vp ? function(s) {
  return s == null ? [] : (s = Object(s), ZT(vp(s), function(t) {
    return tE.call(s, t);
  }));
} : Fm;
const Ch = sE;
function rE(s, t) {
  return jc(s, Ch(s), t);
}
function Hm(s, t) {
  for (var e = -1, r = t.length, i = s.length; ++e < r; )
    s[i + e] = t[e];
  return s;
}
var iE = Vm(Object.getPrototypeOf, Object);
const Rh = iE;
var aE = Object.getOwnPropertySymbols, nE = aE ? function(s) {
  for (var t = []; s; )
    Hm(t, Ch(s)), s = Rh(s);
  return t;
} : Fm;
const Bm = nE;
function oE(s, t) {
  return jc(s, Bm(s), t);
}
function qm(s, t, e) {
  var r = t(s);
  return si(s) ? r : Hm(r, e(s));
}
function Eu(s) {
  return qm(s, Ph, Ch);
}
function cE(s) {
  return qm(s, Wc, Bm);
}
var dE = Sa(Cs, "DataView");
const _u = dE;
var lE = Sa(Cs, "Promise");
const Pu = lE;
var uE = Sa(Cs, "Set");
const Cu = uE;
var hE = Sa(Cs, "WeakMap");
const Ru = hE;
var yp = "[object Map]", pE = "[object Object]", Tp = "[object Promise]", Ep = "[object Set]", _p = "[object WeakMap]", Pp = "[object DataView]", gE = fa(_u), mE = fa(Lo), fE = fa(Pu), SE = fa(Cu), vE = fa(Ru), oi = ma;
(_u && oi(new _u(new ArrayBuffer(1))) != Pp || Lo && oi(new Lo()) != yp || Pu && oi(Pu.resolve()) != Tp || Cu && oi(new Cu()) != Ep || Ru && oi(new Ru()) != _p) && (oi = function(s) {
  var t = ma(s), e = t == pE ? s.constructor : void 0, r = e ? fa(e) : "";
  if (r)
    switch (r) {
      case gE:
        return Pp;
      case mE:
        return yp;
      case fE:
        return Tp;
      case SE:
        return Ep;
      case vE:
        return _p;
    }
  return t;
});
const jn = oi;
var yE = Object.prototype, TE = yE.hasOwnProperty;
function EE(s) {
  var t = s.length, e = new s.constructor(t);
  return t && typeof s[0] == "string" && TE.call(s, "index") && (e.index = s.index, e.input = s.input), e;
}
var _E = Cs.Uint8Array;
const Dd = _E;
function wh(s) {
  var t = new s.constructor(s.byteLength);
  return new Dd(t).set(new Dd(s)), t;
}
function PE(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.byteLength);
}
var CE = /\w*$/;
function RE(s) {
  var t = new s.constructor(s.source, CE.exec(s));
  return t.lastIndex = s.lastIndex, t;
}
var Cp = ti ? ti.prototype : void 0, Rp = Cp ? Cp.valueOf : void 0;
function wE(s) {
  return Rp ? Object(Rp.call(s)) : {};
}
function jm(s, t) {
  var e = t ? wh(s.buffer) : s.buffer;
  return new s.constructor(e, s.byteOffset, s.length);
}
var bE = "[object Boolean]", kE = "[object Date]", IE = "[object Map]", AE = "[object Number]", ME = "[object RegExp]", DE = "[object Set]", OE = "[object String]", NE = "[object Symbol]", VE = "[object ArrayBuffer]", LE = "[object DataView]", xE = "[object Float32Array]", UE = "[object Float64Array]", $E = "[object Int8Array]", FE = "[object Int16Array]", HE = "[object Int32Array]", BE = "[object Uint8Array]", qE = "[object Uint8ClampedArray]", jE = "[object Uint16Array]", GE = "[object Uint32Array]";
function WE(s, t, e) {
  var r = s.constructor;
  switch (t) {
    case VE:
      return wh(s);
    case bE:
    case kE:
      return new r(+s);
    case LE:
      return PE(s, e);
    case xE:
    case UE:
    case $E:
    case FE:
    case HE:
    case BE:
    case qE:
    case jE:
    case GE:
      return jm(s, e);
    case IE:
      return new r();
    case AE:
    case OE:
      return new r(s);
    case ME:
      return RE(s);
    case DE:
      return new r();
    case NE:
      return wE(s);
  }
}
var wp = Object.create, JE = function() {
  function s() {
  }
  return function(t) {
    if (!Ps(t))
      return {};
    if (wp)
      return wp(t);
    s.prototype = t;
    var e = new s();
    return s.prototype = void 0, e;
  };
}();
const KE = JE;
function Gm(s) {
  return typeof s.constructor == "function" && !jl(s) ? KE(Rh(s)) : {};
}
var zE = "[object Map]";
function YE(s) {
  return $s(s) && jn(s) == zE;
}
var bp = qn && qn.isMap, QE = bp ? _h(bp) : YE;
const XE = QE;
var ZE = "[object Set]";
function e_(s) {
  return $s(s) && jn(s) == ZE;
}
var kp = qn && qn.isSet, t_ = kp ? _h(kp) : e_;
const s_ = t_;
var r_ = 1, i_ = 2, a_ = 4, Wm = "[object Arguments]", n_ = "[object Array]", o_ = "[object Boolean]", c_ = "[object Date]", d_ = "[object Error]", Jm = "[object Function]", l_ = "[object GeneratorFunction]", u_ = "[object Map]", h_ = "[object Number]", Km = "[object Object]", p_ = "[object RegExp]", g_ = "[object Set]", m_ = "[object String]", f_ = "[object Symbol]", S_ = "[object WeakMap]", v_ = "[object ArrayBuffer]", y_ = "[object DataView]", T_ = "[object Float32Array]", E_ = "[object Float64Array]", __ = "[object Int8Array]", P_ = "[object Int16Array]", C_ = "[object Int32Array]", R_ = "[object Uint8Array]", w_ = "[object Uint8ClampedArray]", b_ = "[object Uint16Array]", k_ = "[object Uint32Array]", fe = {};
fe[Wm] = fe[n_] = fe[v_] = fe[y_] = fe[o_] = fe[c_] = fe[T_] = fe[E_] = fe[__] = fe[P_] = fe[C_] = fe[u_] = fe[h_] = fe[Km] = fe[p_] = fe[g_] = fe[m_] = fe[f_] = fe[R_] = fe[w_] = fe[b_] = fe[k_] = !0;
fe[d_] = fe[Jm] = fe[S_] = !1;
function pd(s, t, e, r, i, n) {
  var o, c = t & r_, d = t & i_, l = t & a_;
  if (e && (o = i ? e(s, r, i, n) : e(s)), o !== void 0)
    return o;
  if (!Ps(s))
    return s;
  var p = si(s);
  if (p) {
    if (o = EE(s), !c)
      return $m(s, o);
  } else {
    var f = jn(s), S = f == Jm || f == l_;
    if (Bn(s))
      return Um(s, c);
    if (f == Km || f == Wm || S && !i) {
      if (o = d || S ? {} : Gm(s), !c)
        return d ? oE(s, QT(o, s)) : rE(s, WT(o, s));
    } else {
      if (!fe[f])
        return i ? s : {};
      o = WE(s, f, c);
    }
  }
  n || (n = new Us());
  var T = n.get(s);
  if (T)
    return T;
  n.set(s, o), s_(s) ? s.forEach(function(w) {
    o.add(pd(w, t, e, w, s, n));
  }) : XE(s) && s.forEach(function(w, A) {
    o.set(A, pd(w, t, e, A, s, n));
  });
  var _ = l ? d ? cE : Eu : d ? Wc : Ph, P = p ? void 0 : _(s);
  return Ky(P || s, function(w, A) {
    P && (A = w, w = s[A]), km(o, A, pd(w, t, e, A, s, n));
  }), o;
}
var I_ = 1, A_ = 4;
function bh(s) {
  return pd(s, I_ | A_);
}
var M_ = "[object Symbol]";
function D_(s) {
  return typeof s == "symbol" || $s(s) && ma(s) == M_;
}
var O_ = Object.defineProperty, N_ = (s, t) => {
  for (var e in t)
    O_(s, e, { get: t[e], enumerable: !0 });
}, V_ = {};
N_(V_, {
  permissions: () => L_,
  theme: () => x_
});
var Mt = /* @__PURE__ */ ((s) => (s.GroupCall = "GROUP_CALL", s.Webinar = "WEBINAR", s.AudioRoom = "AUDIO_ROOM", s.Livestream = "LIVESTREAM", s.Chat = "CHAT", s))(Mt || {}), j = /* @__PURE__ */ ((s) => (s.Allowed = "ALLOWED", s.NotAllowed = "NOT_ALLOWED", s.CanRequest = "CAN_REQUEST", s))(j || {}), L_ = {
  view_type: "GROUP_CALL",
  accept_waiting_requests: !1,
  accept_present_requests: !1,
  request_produce: !1,
  can_allow_participant_audio: !1,
  can_allow_participant_screensharing: !1,
  can_allow_participant_video: !1,
  can_spotlight: !1,
  request_kick_participant: !1,
  kick_participant: !1,
  pin_participant: !1,
  can_edit_display_name: !1,
  can_record: !1,
  can_livestream: !1,
  can_present: !0,
  waiting_room_type: "SKIP_ON_ACCEPT",
  recorder_type: "NONE",
  plugins: {
    can_close: !0,
    can_start: !0
  },
  polls: {
    can_create: !0,
    can_vote: !0,
    can_view: !0
  },
  produce: {
    video: {
      allow: !0,
      quality: "vga",
      frame_rate: 24
    },
    audio: !0,
    screenshare: {
      allow: !0,
      quality: "hd",
      frame_rate: 5
    }
  },
  chat: {
    public: {
      can_send: !0,
      text: !0,
      files: !0
    },
    private: {
      can_send: !1,
      can_receive: !1,
      text: !1,
      files: !1
    }
  },
  connected_meetings: {
    can_alter_connected_meetings: !1,
    can_switch_connected_meetings: !1,
    can_switch_to_parent_meeting: !1
  },
  reactions: !1,
  hidden_participant: !1,
  is_recorder: !1,
  show_participant_list: !0,
  can_change_participant_role: !1,
  can_change_theme: !1,
  max_screenshare_count: 1
}, x_ = {
  setup_screen: {
    is_enabled: !0
  },
  alone_here: {
    is_enabled: !0
  },
  waiting_room: {
    is_enabled: !1,
    enable_preview: !0
  },
  control_bar: {
    is_enabled: !0,
    elements: {
      plugins: !0,
      screenshare: !0,
      invite: !0,
      participants: !0,
      chat: !0,
      reactions: !1,
      polls: !0,
      fullscreen: !0,
      layout: !0
    }
  },
  header: {
    is_enabled: !0,
    elements: {
      timer: !0,
      title: !0,
      participant_count: !0,
      change_layout: !0
    }
  },
  pip_mode: !0,
  auto_tune: !0,
  grid: {
    multi: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    single: {
      maxVideoCount: 6,
      videoFit: "cover"
    },
    defaultView: "multi"
  },
  controls: {
    pip_toggle: !1
  }
}, zm = "hXgU8Wc8pwuGNq9ms5q9Hh", wg;
typeof process != "undefined" && (wg = process == null ? void 0 : process.env) != null && wg.FLAGSMITH_ENVIRONMENT_KEY && (zm = process.env.FLAGSMITH_ENVIRONMENT_KEY);
function U_(s = []) {
  const t = {};
  return s.forEach((e) => {
    t[e.feature.name] = {
      enabled: e.enabled,
      value: e.feature_state_value
    };
  }), t;
}
var Ym = class {
  constructor(s = zm) {
    h(this, "flags", {});
    h(this, "environmentKey", null);
    this.environmentKey = s;
  }
  identifyAndFetchFlagsWithRetry(c) {
    return u(this, arguments, function* ({
      primaryEndpoint: s,
      secondaryEndpoint: t,
      forceEvaluate: e,
      timeout: r,
      uniqueIdentifier: i,
      traitsObj: n,
      logger: o
    }) {
      const d = JSON.parse(JSON.stringify(n)), l = Object.entries(d).map((f) => ({
        trait_key: f[0],
        trait_value: f[1]
      })), p = [s, t, t];
      for (const f of p)
        try {
          const S = new AbortController(), T = setTimeout(() => S.abort(), r), _ = "_" + (Math.random() + 1).toString(36).substring(2), P = yield fetch(`https://${f}/api/v1/identities/`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Environment-Key": this.environmentKey
            },
            body: JSON.stringify({
              identifier: i + (e ? _ : ""),
              traits: l
            }),
            signal: S.signal
            // Handles the timeout
          });
          if (clearTimeout(T), !P.ok)
            throw new Error(`Request failed with status ${P.status}`);
          const w = yield P.json();
          return U_(w.flags || []);
        } catch (S) {
          o.error("Flagsmith identify failed!!", { error: S, url: f });
        }
      return {};
    });
  }
  identify(o) {
    return u(this, arguments, function* (s, t = {}, e = !1, r = 5e3, i = "edge.api.flagsmith.com", n = console) {
      return this.flags = yield this.identifyAndFetchFlagsWithRetry({
        traitsObj: t,
        uniqueIdentifier: s,
        forceEvaluate: e,
        timeout: r,
        primaryEndpoint: i,
        secondaryEndpoint: "edge.api.flagsmith.com",
        logger: n
      }), this.flags;
    });
  }
  getValue(s) {
    return this.flags && this.flags[s] && this.flags[s].value;
  }
  hasFeature(s) {
    return this.flags && this.flags[s] && this.flags[s].enabled;
  }
  getAllFlags() {
    return this.flags;
  }
}, $_ = new Ym();
function F_(s) {
  return new Ym(s);
}
var Qm = [-2, -1, 0, 1, 2], H_ = [0, 1, 2, 3, 4];
function B_(s) {
  s = s.trim();
  let t = "0", e = "0", r = "0";
  return s.length == 4 ? (t = "0x" + s[1] + s[1], e = "0x" + s[2] + s[2], r = "0x" + s[3] + s[3]) : s.length > 6 && (t = "0x" + s[1] + s[2], e = "0x" + s[3] + s[4], r = "0x" + s[5] + s[6]), [+t, +e, +r];
}
var q_ = (s, t, e) => {
  let r, i, n;
  if (t == 0)
    r = i = n = e;
  else {
    const o = (l, p, f) => (f < 0 && (f += 1), f > 1 && (f -= 1), f < 0.16666666666666666 ? l + (p - l) * 6 * f : f < 0.5 ? p : f < 0.6666666666666666 ? l + (p - l) * (0.6666666666666666 - f) * 6 : l), c = e < 0.5 ? e * (1 + t) : e + t - e * t, d = 2 * e - c;
    r = o(d, c, s + 1 / 3), i = o(d, c, s), n = o(d, c, s - 1 / 3);
  }
  return [Math.round(r * 255), Math.round(i * 255), Math.round(n * 255)];
}, j_ = (s, t, e) => {
  s /= 255, t /= 255, e /= 255;
  const r = Math.max(s, t, e), i = Math.min(s, t, e);
  let n, o;
  const c = (r + i) / 2;
  if (r == i)
    n = o = 0;
  else {
    const d = r - i;
    switch (o = c > 0.5 ? d / (2 - r - i) : d / (r + i), r) {
      case s:
        n = (t - e) / d + (t < e ? 6 : 0);
        break;
      case t:
        n = (e - s) / d + 2;
        break;
      case e:
        n = (s - t) / d + 4;
        break;
    }
    n /= 6;
  }
  return [n, o, c];
}, G_ = (s, t, e) => {
  const r = (i) => i.toString(16).padStart(2, "0");
  return `#${r(s)}${r(t)}${r(e)}`;
}, Xm = (s, t = Qm, e = 0.4) => {
  const r = [], [i, n, o] = B_(s), [c, d, l] = j_(i, n, o), p = Math.round(l * 100);
  p > 70 ? e = 0.8 : p > 60 ? e = 0.9 : p < 10 ? e = 0.075 : p < 42 && (e = 0.3);
  const f = t.findIndex((w) => w === 0);
  if (f === -1)
    throw new Error("Invalid reducer provided, it must contain atleast one zero");
  const S = 5 - f, T = f + 1, _ = (100 - p) / S, P = p / T;
  for (const w of t) {
    let A;
    w < 0 ? A = p + w * P * e : w > 0 ? A = p + w * _ * e : A = p;
    const [N, H, $] = q_(c, d, A / 100);
    r.push(G_(N, H, $));
  }
  return r;
}, Ip = {
  dark: {
    background: {
      1e3: "#252525",
      900: "#2F2F2F",
      800: "#323232",
      700: "#3E3E3E",
      600: "#4A4A4A"
    },
    text: "#F5F5F5",
    "video-bg": "#1C1C1C"
  },
  light: {
    background: {
      1e3: "#FFFFFF",
      900: "#F5F5F5",
      800: "#EBEBEB",
      700: "#E0E0E0",
      600: "#D6D6D6"
    },
    text: "#111111",
    "text-on-brand": "#ffffff",
    "video-bg": "#DADADA"
  }
}, W_ = (s) => {
  const [t, e, r, i, n] = Xm(s, Qm);
  return { 300: t, 400: e, 500: r, 600: i, 700: n };
}, J_ = (s) => {
  if (s === "#FFFFFF")
    return Ip.light.background;
  if (s === "#000000")
    return Ip.dark.background;
  const [t, e, r, i, n] = Xm(s, H_);
  return { 1e3: t, 900: e, 800: r, 700: i, 600: n };
}, K_ = {
  border_radius: "rounded",
  border_width: "thin",
  spacing_base: 4,
  theme: "dark",
  colors: {
    brand: W_("#2160FD"),
    background: J_("#141414"),
    danger: "#FF2D2D",
    text: "#EEEEEE",
    text_on_brand: "#EEEEEE",
    success: "#62A504",
    video_bg: "#191919",
    warning: "#FFCD07"
  }
};
function Zm() {
  return bh(K_);
}
var z_ = {
  permissions: {
    // webinar
    can_accept_production_requests: !1,
    can_edit_display_name: !0,
    accept_waiting_requests: !1,
    disable_participant_audio: !1,
    disable_participant_screensharing: !1,
    disable_participant_video: !1,
    can_spotlight: !1,
    kick_participant: !1,
    pin_participant: !1,
    can_record: !1,
    can_livestream: !1,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: !0,
      can_start: !0,
      can_edit_config: !1,
      config: {}
    },
    polls: {
      can_create: !0,
      can_vote: !0,
      can_view: !0
    },
    media: {
      video: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
        /* Allowed */
      },
      audio: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      screenshare: {
        can_produce: "ALLOWED",
        can_consume: "ALLOWED"
        /* Allowed */
      }
    },
    chat: {
      public: {
        can_send: !0,
        text: !0,
        files: !0
      },
      private: {
        can_send: !1,
        can_receive: !1,
        text: !1,
        files: !1
      },
      channel: {
        // Make sure these are the same in default to ensure consistency in developer portal
        can_create: "ALL",
        can_delete: "ALL",
        can_update: "ALL",
        // end same
        can_read_all: !1
      },
      message: {
        // Make sure these are the same in default to ensure consistency in developer portal
        can_delete: "ALL",
        can_edit: "ALL",
        // end same
        delete_cutoff_time_seconds: 0,
        edit_cutoff_time_seconds: 0
      }
    },
    hidden_participant: !1,
    is_recorder: !1,
    recorder_type: "NONE",
    show_participant_list: !0,
    transcription_enabled: !1,
    can_change_participant_permissions: !1,
    connected_meetings: {
      can_alter_connected_meetings: !1,
      can_switch_connected_meetings: !1,
      can_switch_to_parent_meeting: !1
    },
    stage_enabled: !1,
    stage_access: void 0,
    accept_stage_requests: !1
  },
  ui: {
    oldTheme: {
      setup_screen: {
        is_enabled: !1
      },
      alone_here: {
        is_enabled: !1
      },
      waiting_room: {
        is_enabled: !1,
        enable_preview: !0
      },
      control_bar: {
        is_enabled: !0,
        elements: {
          plugins: !0,
          screenshare: !0,
          invite: !1,
          participants: !0,
          chat: !0,
          reactions: !1,
          polls: !0,
          fullscreen: !0,
          layout: !0
        }
      },
      header: {
        is_enabled: !0,
        elements: {
          timer: !0,
          title: !0,
          participant_count: !0,
          change_layout: !0
        }
      },
      pip_mode: !0,
      auto_tune: !0,
      colors: {
        primary: "#2160FD",
        secondary: "#1A1A1A",
        text: "#EEEEEE",
        background: "#1A1A1A",
        textPrimary: "#EEEEEE",
        videoBackground: "#1A1A1A"
      },
      dimensions: {
        mode: "fillParent"
      },
      grid: {
        multi: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        single: {
          maxVideoCount: 6,
          videoFit: "cover"
        },
        defaultView: "MULTI"
      },
      controls: {
        pip_toggle: !1
      },
      plugins: []
    },
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: !1,
        enable_high_bitrate: !1
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "hybrid"
};
function Y_() {
  return bh(z_);
}
var Q_ = {
  permissions: {
    // webinar
    can_accept_production_requests: !1,
    can_edit_display_name: !0,
    accept_waiting_requests: !1,
    disable_participant_audio: !1,
    disable_participant_screensharing: !1,
    disable_participant_video: !1,
    can_spotlight: !1,
    kick_participant: !1,
    pin_participant: !1,
    can_record: !1,
    can_livestream: !1,
    waiting_room_type: "SKIP",
    plugins: {
      can_close: !0,
      can_start: !0,
      can_edit_config: !1,
      config: {}
    },
    polls: {
      can_create: !0,
      can_vote: !0,
      can_view: !0
    },
    media: {
      video: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      audio: {
        can_produce: "ALLOWED"
        /* Allowed */
      },
      screenshare: {
        can_produce: "ALLOWED"
        /* Allowed */
      }
    },
    chat: {
      public: {
        can_send: !0,
        text: !0,
        files: !0
      },
      private: {
        can_send: !1,
        can_receive: !1,
        text: !1,
        files: !1
      }
    },
    hidden_participant: !1,
    is_recorder: !1,
    recorder_type: "NONE",
    show_participant_list: !0,
    transcription_enabled: !1,
    can_change_participant_permissions: !1,
    connected_meetings: {
      can_alter_connected_meetings: !1,
      can_switch_connected_meetings: !1,
      can_switch_to_parent_meeting: !1
    },
    stage_enabled: !1,
    stage_access: void 0,
    accept_stage_requests: !1
  },
  ui: {
    design_tokens: Zm(),
    config_diff: {}
  },
  config: {
    view_type: "GROUP_CALL",
    media: {
      audio: {
        enable_stereo: !1,
        enable_high_bitrate: !1
      },
      video: {
        quality: "vga",
        frame_rate: 24
      },
      screenshare: {
        quality: "hd",
        frame_rate: 5
      }
    },
    max_video_streams: {
      mobile: 6,
      desktop: 6
    },
    max_screenshare_count: 1,
    track_recording: {
      subscriptions: []
    }
  },
  version: "2.0.0"
};
function kh() {
  return bh(Q_);
}
var $o;
class ef {
  constructor() {
    g(this, $o, void 0);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    var t;
    return (t = a(this, $o)) == null ? void 0 : t.getValue("telemetry");
  }
  init(t) {
    m(this, $o, t);
  }
  info(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "info",
      t,
      e,
      r
    );
  }
  error(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "error",
      t,
      e,
      r
    );
  }
  debug(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "debug",
      t,
      e,
      r
    );
  }
  log(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "log",
      t,
      e,
      r
    );
  }
  warn(t, e, r) {
    var i;
    (i = this.telemetry) == null || i.addLogInCurrentSpan(
      "warn",
      t,
      e,
      r
    );
  }
}
$o = new WeakMap();
var js, Gs;
const zh = class extends ut.EventEmitter {
  constructor(e) {
    super();
    g(this, js, void 0);
    g(this, Gs, void 0);
    h(this, "asyncPromiseTimeout");
    h(this, "logger");
    this.logger = e, m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), this.asyncPromiseTimeout = 8e3;
  }
  emitAsync(e, ...r) {
    return u(this, null, function* () {
      a(this, js).set(e, []);
      const i = a(this, Gs).get(e).map(
        () => new Promise((n) => {
          a(this, js).get(e).push(n);
        })
      );
      tp(zh.prototype, this, "emit").call(this, e, ...r), yield Promise.race([
        Promise.all(i),
        new Promise(
          (n, o) => setTimeout(
            () => o(new Error(`emitAsync failed to resolve for event ${e}.`)),
            this.asyncPromiseTimeout
          )
        )
      ]), a(this, js).delete(e);
    });
  }
  onAsync(e, r) {
    const i = a(this, js), n = (...o) => u(this, null, function* () {
      var d;
      try {
        yield r(...o);
      } catch (l) {
        this.logger.error("[onAsync]", { error: l });
      }
      const c = (d = i.get(e)) == null ? void 0 : d.shift();
      c == null || c();
    });
    return a(this, Gs).get(e) || a(this, Gs).set(e, []), a(this, Gs).get(e).push(n), super.on(e, n);
  }
  /**
   * removes all attached listeners
   */
  reset() {
    m(this, js, /* @__PURE__ */ new Map()), m(this, Gs, /* @__PURE__ */ new Map()), super.removeAllListeners();
  }
};
let wu = zh;
js = new WeakMap(), Gs = new WeakMap();
var X_ = /\s/;
function Z_(s) {
  for (var t = s.length; t-- && X_.test(s.charAt(t)); )
    ;
  return t;
}
var eP = /^\s+/;
function tP(s) {
  return s && s.slice(0, Z_(s) + 1).replace(eP, "");
}
var Ap = 0 / 0, sP = /^[-+]0x[0-9a-f]+$/i, rP = /^0b[01]+$/i, iP = /^0o[0-7]+$/i, aP = parseInt;
function Mp(s) {
  if (typeof s == "number")
    return s;
  if (D_(s))
    return Ap;
  if (Ps(s)) {
    var t = typeof s.valueOf == "function" ? s.valueOf() : s;
    s = Ps(t) ? t + "" : t;
  }
  if (typeof s != "string")
    return s === 0 ? s : +s;
  s = tP(s);
  var e = rP.test(s);
  return e || iP.test(s) ? aP(s.slice(2), e ? 2 : 8) : sP.test(s) ? Ap : +s;
}
function tf(s) {
  return s;
}
function nP(s, t, e) {
  switch (e.length) {
    case 0:
      return s.call(t);
    case 1:
      return s.call(t, e[0]);
    case 2:
      return s.call(t, e[0], e[1]);
    case 3:
      return s.call(t, e[0], e[1], e[2]);
  }
  return s.apply(t, e);
}
var oP = 800, cP = 16, dP = Date.now;
function lP(s) {
  var t = 0, e = 0;
  return function() {
    var r = dP(), i = cP - (r - e);
    if (e = r, i > 0) {
      if (++t >= oP)
        return arguments[0];
    } else
      t = 0;
    return s.apply(void 0, arguments);
  };
}
function uP(s) {
  return function() {
    return s;
  };
}
var hP = Ad ? function(s, t) {
  return Ad(s, "toString", {
    configurable: !0,
    enumerable: !1,
    value: uP(t),
    writable: !0
  });
} : tf;
const pP = hP;
var gP = lP(pP);
const mP = gP;
var Dp = Math.max;
function fP(s, t, e) {
  return t = Dp(t === void 0 ? s.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, n = Dp(r.length - t, 0), o = Array(n); ++i < n; )
      o[i] = r[t + i];
    i = -1;
    for (var c = Array(t + 1); ++i < t; )
      c[i] = r[i];
    return c[t] = e(o), nP(s, this, c);
  };
}
function SP(s, t) {
  return mP(fP(s, t, tf), s + "");
}
function vP(s, t, e) {
  if (!Ps(e))
    return !1;
  var r = typeof t;
  return (r == "number" ? Gc(e) && Mm(t, e.length) : r == "string" && t in e) ? qc(e[t], s) : !1;
}
function yP(s) {
  return SP(function(t, e) {
    var r = -1, i = e.length, n = i > 1 ? e[i - 1] : void 0, o = i > 2 ? e[2] : void 0;
    for (n = s.length > 3 && typeof n == "function" ? (i--, n) : void 0, o && vP(e[0], e[1], o) && (n = i < 3 ? void 0 : n, i = 1), t = Object(t); ++r < i; ) {
      var c = e[r];
      c && s(t, c, r, n);
    }
    return t;
  });
}
var TP = "[object Object]", EP = Function.prototype, _P = Object.prototype, sf = EP.toString, PP = _P.hasOwnProperty, CP = sf.call(Object);
function RP(s) {
  if (!$s(s) || ma(s) != TP)
    return !1;
  var t = Rh(s);
  if (t === null)
    return !0;
  var e = PP.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e instanceof e && sf.call(e) == CP;
}
var wP = "__lodash_hash_undefined__";
function bP(s) {
  return this.__data__.set(s, wP), this;
}
function kP(s) {
  return this.__data__.has(s);
}
function Od(s) {
  var t = -1, e = s == null ? 0 : s.length;
  for (this.__data__ = new va(); ++t < e; )
    this.add(s[t]);
}
Od.prototype.add = Od.prototype.push = bP;
Od.prototype.has = kP;
function IP(s, t) {
  for (var e = -1, r = s == null ? 0 : s.length; ++e < r; )
    if (t(s[e], e, s))
      return !0;
  return !1;
}
function AP(s, t) {
  return s.has(t);
}
var MP = 1, DP = 2;
function rf(s, t, e, r, i, n) {
  var o = e & MP, c = s.length, d = t.length;
  if (c != d && !(o && d > c))
    return !1;
  var l = n.get(s), p = n.get(t);
  if (l && p)
    return l == t && p == s;
  var f = -1, S = !0, T = e & DP ? new Od() : void 0;
  for (n.set(s, t), n.set(t, s); ++f < c; ) {
    var _ = s[f], P = t[f];
    if (r)
      var w = o ? r(P, _, f, t, s, n) : r(_, P, f, s, t, n);
    if (w !== void 0) {
      if (w)
        continue;
      S = !1;
      break;
    }
    if (T) {
      if (!IP(t, function(A, N) {
        if (!AP(T, N) && (_ === A || i(_, A, e, r, n)))
          return T.push(N);
      })) {
        S = !1;
        break;
      }
    } else if (!(_ === P || i(_, P, e, r, n))) {
      S = !1;
      break;
    }
  }
  return n.delete(s), n.delete(t), S;
}
function OP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r, i) {
    e[++t] = [i, r];
  }), e;
}
function NP(s) {
  var t = -1, e = Array(s.size);
  return s.forEach(function(r) {
    e[++t] = r;
  }), e;
}
var VP = 1, LP = 2, xP = "[object Boolean]", UP = "[object Date]", $P = "[object Error]", FP = "[object Map]", HP = "[object Number]", BP = "[object RegExp]", qP = "[object Set]", jP = "[object String]", GP = "[object Symbol]", WP = "[object ArrayBuffer]", JP = "[object DataView]", Op = ti ? ti.prototype : void 0, cu = Op ? Op.valueOf : void 0;
function KP(s, t, e, r, i, n, o) {
  switch (e) {
    case JP:
      if (s.byteLength != t.byteLength || s.byteOffset != t.byteOffset)
        return !1;
      s = s.buffer, t = t.buffer;
    case WP:
      return !(s.byteLength != t.byteLength || !n(new Dd(s), new Dd(t)));
    case xP:
    case UP:
    case HP:
      return qc(+s, +t);
    case $P:
      return s.name == t.name && s.message == t.message;
    case BP:
    case jP:
      return s == t + "";
    case FP:
      var c = OP;
    case qP:
      var d = r & VP;
      if (c || (c = NP), s.size != t.size && !d)
        return !1;
      var l = o.get(s);
      if (l)
        return l == t;
      r |= LP, o.set(s, t);
      var p = rf(c(s), c(t), r, i, n, o);
      return o.delete(s), p;
    case GP:
      if (cu)
        return cu.call(s) == cu.call(t);
  }
  return !1;
}
var zP = 1, YP = Object.prototype, QP = YP.hasOwnProperty;
function XP(s, t, e, r, i, n) {
  var o = e & zP, c = Eu(s), d = c.length, l = Eu(t), p = l.length;
  if (d != p && !o)
    return !1;
  for (var f = d; f--; ) {
    var S = c[f];
    if (!(o ? S in t : QP.call(t, S)))
      return !1;
  }
  var T = n.get(s), _ = n.get(t);
  if (T && _)
    return T == t && _ == s;
  var P = !0;
  n.set(s, t), n.set(t, s);
  for (var w = o; ++f < d; ) {
    S = c[f];
    var A = s[S], N = t[S];
    if (r)
      var H = o ? r(N, A, S, t, s, n) : r(A, N, S, s, t, n);
    if (!(H === void 0 ? A === N || i(A, N, e, r, n) : H)) {
      P = !1;
      break;
    }
    w || (w = S == "constructor");
  }
  if (P && !w) {
    var $ = s.constructor, F = t.constructor;
    $ != F && "constructor" in s && "constructor" in t && !(typeof $ == "function" && $ instanceof $ && typeof F == "function" && F instanceof F) && (P = !1);
  }
  return n.delete(s), n.delete(t), P;
}
var ZP = 1, Np = "[object Arguments]", Vp = "[object Array]", td = "[object Object]", eC = Object.prototype, Lp = eC.hasOwnProperty;
function tC(s, t, e, r, i, n) {
  var o = si(s), c = si(t), d = o ? Vp : jn(s), l = c ? Vp : jn(t);
  d = d == Np ? td : d, l = l == Np ? td : l;
  var p = d == td, f = l == td, S = d == l;
  if (S && Bn(s)) {
    if (!Bn(t))
      return !1;
    o = !0, p = !1;
  }
  if (S && !p)
    return n || (n = new Us()), o || ql(s) ? rf(s, t, e, r, i, n) : KP(s, t, d, e, r, i, n);
  if (!(e & ZP)) {
    var T = p && Lp.call(s, "__wrapped__"), _ = f && Lp.call(t, "__wrapped__");
    if (T || _) {
      var P = T ? s.value() : s, w = _ ? t.value() : t;
      return n || (n = new Us()), i(P, w, e, r, n);
    }
  }
  return S ? (n || (n = new Us()), XP(s, t, e, r, i, n)) : !1;
}
function af(s, t, e, r, i) {
  return s === t ? !0 : s == null || t == null || !$s(s) && !$s(t) ? s !== s && t !== t : tC(s, t, e, r, af, i);
}
function sC(s) {
  return function(t, e, r) {
    for (var i = -1, n = Object(t), o = r(t), c = o.length; c--; ) {
      var d = o[s ? c : ++i];
      if (e(n[d], d, n) === !1)
        break;
    }
    return t;
  };
}
var rC = sC();
const iC = rC;
var aC = function() {
  return Cs.Date.now();
};
const du = aC;
var nC = "Expected a function", oC = Math.max, cC = Math.min;
function Ih(s, t, e) {
  var r, i, n, o, c, d, l = 0, p = !1, f = !1, S = !0;
  if (typeof s != "function")
    throw new TypeError(nC);
  t = Mp(t) || 0, Ps(e) && (p = !!e.leading, f = "maxWait" in e, n = f ? oC(Mp(e.maxWait) || 0, t) : n, S = "trailing" in e ? !!e.trailing : S);
  function T(K) {
    var re = r, Je = i;
    return r = i = void 0, l = K, o = s.apply(Je, re), o;
  }
  function _(K) {
    return l = K, c = setTimeout(A, t), p ? T(K) : o;
  }
  function P(K) {
    var re = K - d, Je = K - l, ks = t - re;
    return f ? cC(ks, n - Je) : ks;
  }
  function w(K) {
    var re = K - d, Je = K - l;
    return d === void 0 || re >= t || re < 0 || f && Je >= n;
  }
  function A() {
    var K = du();
    if (w(K))
      return N(K);
    c = setTimeout(A, P(K));
  }
  function N(K) {
    return c = void 0, S && r ? T(K) : (r = i = void 0, o);
  }
  function H() {
    c !== void 0 && clearTimeout(c), l = 0, r = d = i = c = void 0;
  }
  function $() {
    return c === void 0 ? o : N(du());
  }
  function F() {
    var K = du(), re = w(K);
    if (r = arguments, i = this, d = K, re) {
      if (c === void 0)
        return _(d);
      if (f)
        return clearTimeout(c), c = setTimeout(A, t), T(d);
    }
    return c === void 0 && (c = setTimeout(A, t)), o;
  }
  return F.cancel = H, F.flush = $, F;
}
function bu(s, t, e) {
  (e !== void 0 && !qc(s[t], e) || e === void 0 && !(t in s)) && Eh(s, t, e);
}
function dC(s) {
  return $s(s) && Gc(s);
}
function ku(s, t) {
  if (!(t === "constructor" && typeof s[t] == "function") && t != "__proto__")
    return s[t];
}
function lC(s) {
  return jc(s, Wc(s));
}
function uC(s, t, e, r, i, n, o) {
  var c = ku(s, e), d = ku(t, e), l = o.get(d);
  if (l) {
    bu(s, e, l);
    return;
  }
  var p = n ? n(c, d, e + "", s, t, o) : void 0, f = p === void 0;
  if (f) {
    var S = si(d), T = !S && Bn(d), _ = !S && !T && ql(d);
    p = d, S || T || _ ? si(c) ? p = c : dC(c) ? p = $m(c) : T ? (f = !1, p = Um(d, !0)) : _ ? (f = !1, p = jm(d, !0)) : p = [] : RP(d) || Md(d) ? (p = c, Md(c) ? p = lC(c) : (!Ps(c) || Th(c)) && (p = Gm(d))) : f = !1;
  }
  f && (o.set(d, p), i(p, d, r, n, o), o.delete(d)), bu(s, e, p);
}
function nf(s, t, e, r, i) {
  s !== t && iC(t, function(n, o) {
    if (i || (i = new Us()), Ps(n))
      uC(s, t, o, e, nf, r, i);
    else {
      var c = r ? r(ku(s, o), n, o + "", s, t, i) : void 0;
      c === void 0 && (c = n), bu(s, o, c);
    }
  }, Wc);
}
var hC = "[object Map]", pC = "[object Set]", gC = Object.prototype, mC = gC.hasOwnProperty;
function fC(s) {
  if (s == null)
    return !0;
  if (Gc(s) && (si(s) || typeof s == "string" || typeof s.splice == "function" || Bn(s) || ql(s) || Md(s)))
    return !s.length;
  var t = jn(s);
  if (t == hC || t == pC)
    return !s.size;
  if (jl(s))
    return !Lm(s).length;
  for (var e in s)
    if (mC.call(s, e))
      return !1;
  return !0;
}
function SC(s, t) {
  return af(s, t);
}
var vC = yP(function(s, t, e) {
  nf(s, t, e);
});
const br = vC;
var Iu = /* @__PURE__ */ ((s) => (s.PARTICIPANT = "PARTICIPANT", s.PEER = "PEER", s.CLIENT = "CLIENT", s))(Iu || {});
const X = {
  PROPAGATE_KICK_ALL: "propagate_kick_across_rooms",
  REFRESH_ID_ON_DISCONNECTION: "refresh_id_on_disconnection",
  SIMULCAST: "simulcast",
  CHAT_SOCKET_SERVER: "chat_socket_server",
  POLL_SOCKET_SERVER: "poll_socket_server",
  PLUGIN_SOCKET_SERVER: "plugin_socket_server",
  NR_OTEL_WEB: "nr_otel_web",
  ICE_RESTART_ON_FAILED_STATE: "ice_restart_on_failed_state",
  ICE_RESTART_ON_DISCONNECTED_STATE: "ice_restart_on_disconnected_state",
  ENABLE_ICE_STATE_LOGGING: "enable_ice_state_logging",
  SUPPRESS_PEER_MUTE_UNMUTE_EMITS: "web_core_suppress_peer_mute_unmute_emits",
  SKIP_OTEL_TRACES: "skip_otel_traces",
  USE_USERIDS_IN_CHAT: "use_userids_in_chat",
  CUSTOM_PING_PONG: "custom_ping_pong",
  // NOTE(itzmanish) below flags is added by me
  ENABLE_HIVE_SIMULCAST: "enable_hive_simulcast",
  ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_hive_transport_reconnection_on_ice_failed",
  ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY: "enable_hive_fail_recovery",
  ENABLE_HIVE_INFINITE_RETRIES: "enable_hive_infinite_retries",
  HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "hive_transport_force_relay_on_ice_failed",
  ENABLE_HIVE_CONSUME_OVER_DC: "enable_hive_consume_over_dc",
  // ==========================================
  // NOTE(ravindra-dyte) replicating hive flags for CF, need to remove if not needed
  ENABLE_CF_SIMULCAST: "enable_cf_simulcast",
  ENABLE_CF_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_cf_transport_reconnection_on_ice_failed",
  ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY: "enable_cf_fail_recovery",
  ENABLE_CF_INFINITE_RETRIES: "enable_cf_infinite_retries",
  CF_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "cf_transport_force_relay_on_ice_failed",
  // ==========================================
  BYPASS_LOG_EXCLUSION_LIST: "bypass_log_exclusion_list",
  LOG_LEVEL: "log_level",
  V1_PLUGINS: "v1_plugins",
  SCREENSHARE_DTX: "screenshare_dtx",
  SCREENSHARE_PRIORITY: "screenshare_priority",
  SCREENSHARE_MIN_BITRATE: "screenshare_minbitrate",
  SCREENSHARE_SIMULCAST: "screenshare_simulcast",
  DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE: "disable_webcam_layers_on_screenshare",
  SCREENSHARE_FORCE_GOOG_CONFERENCE: "screenshare_force_goog_conference",
  LIVESTREAM: "feat_livestream",
  FETCH_RETRY: "fetch_retry",
  DISABLE_WEBCAM_SIMULCAST: "webcore_disable_webcam_simulcast",
  OVERRIDE_WEBCAM_SIMULCAST: "override_webcam_simulcast",
  SOCKET_POLLING: "socket_polling",
  FEAT_PAGINATED_CHAT: "feat_paginated_chat",
  VAL_MIN_FRAMERATE: "val_min_framerate",
  SCREEENSHARE_ERR_HACK: "screenshare_err_hack",
  SCREEENSHARE_CONSTRAINTS_RETRY: "screenshare_constraints_retry",
  TROUBLESHOOTING: "feat_troubleshooting",
  VIDEO_CONSTRAINTS: "video_constraints",
  SCREENSHARE_CONSTRAINTS: "screenshare_constraints",
  FEAT_CHAT_SDK: "feat_chat_sdk",
  FEAT_CHAT_SDK_SEARCH: "chat_search",
  OBS_QUALITY: "obs_quality",
  ALLOW_SAFARI_MEDIA_MIDDLEWARES: "allow_safari_media_middlewares",
  DYNAMIC_VIDEO_QUALITY: "dynamic_video_quality",
  EXP_RESHARE: "exp_reshare",
  LEAVE_STAGE_ON_END: "leave_stage_on_end",
  SKIP_SETTING_IN_USE_DEVICE: "skip_setting_in_use_device",
  PRECALL_BANDWIDTH_TEST: "precall_bandwidth_test",
  CONSUMER_BIND_NO_RETRY: "consumer_bind_no_retry",
  DEBUG_SOCKET_JOIN: "debug_socket_join",
  FORCE_RELAY: "force_relay",
  FORCE_VIDEO_CODEC: "force_video_codec",
  USE_EXPERIMENTAL_SFU_HANDLER: "use_experimental_sfu_handler",
  TRACK_HINT: "track_hint",
  OVERRIDE_HIVE_SIMULCAST_DYNAMIC: "override_hive_simulcast_dynamic",
  PRECREATE_PRODUCERS: "precreate_producers",
  DISABLE_OPUS_DTX_CF: "disable_opus_dtx_cf",
  ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS: "enable_audio_activity_debug_logs",
  NEW_SYNC_CONSUMERS: "new_sync_consumers"
};
function gd(s) {
  const t = {};
  return typeof (s == null ? void 0 : s.code) == "number" && (t.code = s.code), typeof (s == null ? void 0 : s.code) == "string" && (t.code = s.code.substring(0, 100)), typeof (s == null ? void 0 : s.name) == "string" && (t.name = s.name.substring(0, 500)), typeof (s == null ? void 0 : s.message) == "string" && (t.message = s.message.substring(0, 500)), typeof (s == null ? void 0 : s.reason) == "string" && (t.reason = s.reason.substring(0, 500)), typeof (s == null ? void 0 : s.stack) == "string" && (t.stack = s.stack.substring(0, 500)), t;
}
function yC(s) {
  var r, i, n, o;
  const t = typeof navigator != "undefined" && !navigator.isReactNative && typeof window != "undefined" && ((r = window.location.host) == null ? void 0 : r.includes("devel")) && ((i = window.location.host) == null ? void 0 : i.includes("dyte.io")), e = !!((o = (n = s == null ? void 0 : s.getValue("modules")) == null ? void 0 : n.devTools) != null && o.logs);
  return t || e;
}
function TC(s, t) {
  var e;
  if (s != null && s.getValue("flagsmith").hasFeature(X.LOG_LEVEL)) {
    let r = ((e = s.getValue("flagsmith").getValue(X.LOG_LEVEL)) == null ? void 0 : e.toString()) || "all";
    if (r = r.toLowerCase().trim(), r === "off")
      return !1;
    if (r !== "all") {
      const i = ["debug", "log", "info", "warn", "error"], n = i.indexOf(
        t
      ), o = i.indexOf(r);
      if (n < o)
        return !1;
    }
  }
  return !0;
}
function of(s, t, e = {}) {
  return Object.getOwnPropertyNames(s).forEach((r) => {
    var n;
    if ([null, void 0, NaN].includes(s[r]) || t && (((n = t.match(/\./g)) == null ? void 0 : n.length) || 0) >= 10)
      return;
    const i = t ? `${t}.${r}` : r;
    typeof s[r] == "object" ? of(s[r], i, e) : ["number", "string", "boolean"].includes(typeof s[r]) && (e[i] = s[r]);
  }), e;
}
function xp(s, t, e = {}, r = "") {
  const i = {};
  try {
    const n = JSON.stringify(e), o = JSON.parse(n), c = of(
      o,
      r
    ), d = JSON.stringify(c);
    return JSON.parse(d);
  } catch (n) {
    const o = gd(n);
    i[`${r}.error.message`] = o.message || "", i[`${r}.error.stack`] = o.stack || "", i[`${r}.error.reason`] = o.reason || "", i[`${r}.error.source`] = "safelyFlattenObjForOpenTelemetry";
  }
  return i;
}
const EC = {
  audio: !0,
  video: !0,
  screenshareAudio: !0,
  screenshareVideo: !0
}, mo = {
  baseURL: "http://localhost:5000",
  createdAt: "2021-08-05T10:49:56.602Z",
  description: "Develop plugins locally",
  id: "09259e3b-7be8-46f6-9801-106bf1866e1c",
  name: "Localhost Dev",
  organizationId: "4ad15a19-80e2-4105-bf43-48039fd2963e",
  picture: "https://dyte-uploads.s3.ap-south-1.amazonaws.com/dyte.png",
  private: !1,
  published: !0,
  staggered: !1,
  tags: ["#localhost", "#dev"],
  type: "self_hosted",
  updatedAt: "2021-08-05T10:50:07.681Z"
}, _C = {
  pip: !0,
  poll: !0,
  chat: !0,
  stage: !0,
  theme: !0,
  plugin: !0,
  tracing: !0,
  internals: !0,
  recording: !0,
  livestream: !0,
  participant: !0,
  connectedMeetings: !0,
  devTools: {
    logs: !1
  }
};
function Gn(s, t) {
  const e = s.getValue("overrides");
  return e && e[t] ? e[t] : !1;
}
function PC({ baseURI: s }) {
  return s.includes("preprod.dyte") || s.includes("preprod.realtime") ? bo.PREPROD : s.includes("devel.dyte") || s.includes("devel.realtime") ? bo.DEVEL : bo.PROD;
}
function da({ servicePrefix: s, baseURI: t }) {
  return `${s}.${t}`;
}
function cf(s) {
  const t = s.getValue("baseURI");
  return {
    location: da({
      servicePrefix: "location",
      baseURI: t
    }),
    locationLegacy: da({
      servicePrefix: "location-legacy",
      baseURI: t
    }),
    daCollector: da({
      servicePrefix: "da-collector",
      /**
       * FIXME(ravindra-dyte): Need to port da-collector to CF.
       * For now, using dyte one.
       * Remove the replace logic once realtime da-collector is up.
       * * */
      baseURI: t.replace("realtime.cloudflare.com", "dyte.io")
    })
  };
}
const CC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>', RC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 12.02c0 1.06.2 2.1.6 3.08l.6 1.42c.22.55.64 1.01 1.17 1.29.27.14.56.21.86.21h2.55c.77 0 1.49-.41 1.87-1.08.5-.87 1.02-1.7 1.72-2.43l1.32-1.39c.44-.46.97-.84 1.49-1.23l.59-.45a.6.6 0 0 0 .23-.47c0-.75-.54-1.57-1.22-1.79a3.34 3.34 0 0 0-2.78.29V4.5a1.5 1.5 0 0 0-2.05-1.4 1.5 1.5 0 0 0-2.9 0A1.5 1.5 0 0 0 6 4.5v.09A1.5 1.5 0 0 0 4 6v6.02ZM8 4.5v4a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0v5a.5.5 0 0 0 1 0v-4a.5.5 0 0 1 1 0v6a.5.5 0 0 0 .85.37h.01c.22-.22.44-.44.72-.58.7-.35 2.22-.57 2.4.5l-.53.4c-.52.4-1.04.78-1.48 1.24l-1.33 1.38c-.75.79-1.31 1.7-1.85 2.63-.21.36-.6.58-1.01.58H7.23a.87.87 0 0 1-.4-.1 1.55 1.55 0 0 1-.71-.78l-.59-1.42a7.09 7.09 0 0 1-.53-2.7V6a.5.5 0 0 1 1 0v3.5a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0Z" fill="currentColor"></path></svg>', sd = (s) => {
  if (!s)
    return;
  if (!s.startsWith("<svg"))
    return new Promise((n) => {
      n(s);
    });
  const e = new Blob([s], { type: "image/svg+xml" }), r = new Image(), i = window.URL.createObjectURL(e);
  return new Promise((n, o) => {
    r.onload = () => {
      n(r), window.URL.revokeObjectURL(i);
    }, r.onerror = () => {
      o(), window.URL.revokeObjectURL(i);
    }, r.src = i;
  });
}, Yh = class {
  constructor() {
    h(this, "logsCache", []);
    h(this, "logsProcessorTimer");
    h(this, "tracingEnabled", !0);
    h(this, "initialized", !1);
    /**
     * NOTE(ravindra-dyte)
     * Periodically send logs to Log Aggregator. Current period: 7 secs
     */
    h(this, "logsProcessingInterval", 7e3);
    h(this, "logExclusionList", [
      "message",
      "websocket/message",
      "roomMessage",
      "websocket/room-message",
      "websocket/room-legacy-mode",
      "chatMessage",
      "websocket/new-chat-message",
      "websocket/no-active-speaker",
      "websocket/selected-peers",
      "websocket/active-speaker",
      "ping",
      "websocket/new-consumer",
      "websocket/producer-score",
      "websocket/consumer-score",
      "websocket/plugin-event",
      "websocket/plugin-data",
      "websocket/plugin-internal-data"
    ]);
    h(this, "meetingMetadata", {});
  }
  get logsEndpoint() {
    const t = mr.getContext(this.meetingMetadata.peerId);
    return `https://${da({
      servicePrefix: "api-silos",
      baseURI: t.getValue("baseURI")
    })}/otel/logs`;
  }
  resetPeerId(t) {
    this.meetingMetadata.peerId = t;
  }
  init(t, e, r) {
    this.tracingEnabled = !0, this.initialized = !1, this.logsCache = [];
    const i = t.getValue("peerId");
    this.meetingMetadata = e, this.tracingEnabled = r, this.meetingMetadata.peerId = i, this.meetingMetadata.sdkVersion = t.getValue("sdkVersion");
    const { RNDeviceInfoImpl: n } = navigator;
    this.meetingMetadata.deviceInfo = navigator.isReactNative ? n == null ? void 0 : n.getDeviceInfo() : Te.getDeviceInfo(), this.meetingMetadata.visitedUrl = !navigator.isReactNative && typeof window != "undefined" && window.location.href, this.logsProcessorTimer = setInterval(
      this.processCachedLogs.bind(this),
      this.logsProcessingInterval
    ), r && (this.initialized = !0);
  }
  static trace(t, e = void 0) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var S;
        const l = this == null ? void 0 : this.telemetry;
        if (!l || !l.initialized || navigator.isReactNative || !l.tracingEnabled || (S = mr.getContext(l.meetingMetadata.peerId)) != null && S.getValue("flagsmith").hasFeature(X.SKIP_OTEL_TRACES))
          return o.apply(this, d);
        l.addLogInCurrentSpan("info", t, e);
        const p = performance.now(), f = o.apply(this, d);
        return Promise.resolve(f).then(() => {
          const T = performance.now();
          T - p > 10 && l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p,
            country: Yh.location.country
          });
        }).catch(() => {
          const T = performance.now();
          l.addLogInCurrentSpan("info", `${t}_timing`, {
            execTime: T - p
          });
        }), f;
      }, n;
    };
  }
  injectContext(t) {
    var i;
    const e = ua().replace(/-/g, "").substring(0, 16), r = (i = this.meetingMetadata.peerId) == null ? void 0 : i.replace(/-/g, "");
    t.TRACEPARENT = `00-${r}-${e}-01`;
  }
  /**
   * Adds event into the current span or the main span.
   * Event(or this method) is not a replacement for a log.
   * Tip :: Heavy objects should be logged.
   * Tip :: Light objects with `to the point` info should be added as events.
   * @param eventSeverity severity of the passed event to create better dashboards
   * @param eventName name of event in format
   *	fileName::functionName::eventName or functionName::eventName or whatever seems fit
   * @param metadata pass any information which makes sense for analytics or debugging
   * @param noCache optionally pass if log can be cached in FE or it has to be sent instantly
   * @returns nothing
   */
  addLogInCurrentSpan(t, e, r = {}, i = !1) {
    r != null && r.error && Object.assign(r, { error: gd(r.error) });
    const n = mr.getContext(this.meetingMetadata.peerId);
    if (yC(n) && (fC(r) ? console[t]("DyteInternalLogs:: ", t, e) : console[t](
      "DyteInternalLogs:: ",
      t,
      e,
      r
    )), !!TC(n, t))
      try {
        const c = xp(
          n,
          e,
          r,
          "metadata"
        ), d = new Date(), l = B(D({
          message: e,
          level: t
        }, c), {
          loggedAt: d.toISOString(),
          loggedAtTzOffset: d.getTimezoneOffset()
        });
        i ? this.sendOtelLogsToNewRelic([l]) : this.logsCache.push(l);
      } catch (c) {
        this.addLogInCurrentSpan(
          "error",
          "opentelemetry::addLogInCurrentSpan_failed",
          {
            error: gd(c)
          }
        );
      }
  }
  sendOtelLogsToNewRelic(t) {
    const e = mr.getContext(this.meetingMetadata.peerId);
    fetch(this.logsEndpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        meetingMetadata: xp(
          e,
          "sendOtelLogsToNewRelic",
          this.meetingMetadata,
          "meetingMetadata"
        ),
        serviceName: e.getValue("sdkName"),
        logs: t
      })
    }).catch((r) => {
      this.addLogInCurrentSpan(
        "error",
        "opentelemetry::sendOtelLogToNewRelic_failed",
        {
          error: gd(r)
        }
      ), this.logsCache.push(...t);
    });
  }
  processCachedLogs() {
    const t = this.logsCache.splice(0, 25);
    t != null && t.length && this.sendOtelLogsToNewRelic(t);
  }
  destruct() {
    clearInterval(this.logsProcessorTimer), this.processCachedLogs();
  }
};
let E = Yh;
h(E, "location", {
  country: void 0
});
function wC(s) {
  const t = D({}, s), e = /* @__PURE__ */ new Map(), r = (l, p) => (e.has(l) || e.set(l, /* @__PURE__ */ new Set()), e.get(l).add(p), () => {
    var f;
    return (f = e.get(l)) == null ? void 0 : f.delete(p);
  }), i = (l, p) => {
    var f;
    (f = e.get(l)) == null || f.delete(p);
  }, n = (l) => {
    var p;
    (p = e.get(l)) == null || p.forEach((f) => {
      try {
        f(t[l]);
      } catch (S) {
      }
    });
  };
  return {
    subscribe: r,
    unsubscribe: i,
    notify: n,
    setValue: (l, p, f = !0) => {
      t[l] = p, f && n(l);
    },
    getValue: (l) => t[l],
    getAllValues: () => t
  };
}
class bC {
  constructor() {
    h(this, "contexts", /* @__PURE__ */ new Map());
    /**
     * @deprecated
     * Returns the most recent peer id with which DyteClient.init was called
     */
    h(this, "mostRecentPeerId", null);
  }
  createContext(t, e) {
    if (this.contexts.has(t))
      return this.contexts.get(t);
    const r = new E(), i = new ef();
    this.contexts.set(t, wC(e)), this.contexts.get(t).setValue("peerSessionStore", new wu(i));
    const n = new Rm();
    return n.setMaxListeners(50), this.contexts.get(t).setValue("logger", i), this.contexts.get(t).setValue("telemetry", r), this.contexts.get(t).setValue("callstats", n), this.contexts.get(t).setValue("flagsmith", F_()), this.mostRecentPeerId = t, this.contexts.get(t);
  }
  /**
   * NOTE(ishita1805): Used to remap the context
   * when we regnerate a peerId during reconnection.
   */
  remapContext(t, e) {
    const r = e.getValue("peerId");
    r !== t && (e.setValue("peerId", t), this.mostRecentPeerId = t, this.contexts.set(t, e), this.contexts.delete(r));
  }
  getContext(t) {
    return this.contexts.get(t);
  }
  /**
   * @deprecated
   * This is currently done as a hack to expose the current peer Id.
   * However this would not work in future, if we want to support multiple ongoing meetings per page
   * This hack works for now, because a lot more components will fail, before this,
   * if someone decides to initialize multiple meetings on the same page.
   */
  getMostRecentPeerId() {
    return this.mostRecentPeerId;
  }
}
const mr = new bC(), kC = {
  "00": "DyteClient",
  "01": "Controller",
  "02": "RoomNodeClient",
  "03": "HiveNodeClient",
  "04": "SocketService",
  "05": "Chat",
  "06": "Plugin",
  "07": "Polls",
  "08": "Meta",
  "09": "Preset",
  10: "Recording",
  11: "Self",
  12: "Participant",
  13: "Spotlight",
  14: "Remote Request",
  15: "Webinar",
  16: "LocalMediaHandler",
  17: "End-End Encryption",
  18: "AI",
  19: "Livestream",
  20: "Stage"
}, md = {
  "0000": "Internal exception.",
  "0001": "Failed to initialize.",
  "0002": "Failed to join room.",
  "0003": "Failed to leave room.",
  "0004": "Invalid auth token",
  "0010": "Browser not supported",
  "0011": "HTTP Network Error",
  "0012": "Websocket Network Error",
  "0013": "Rate Limited",
  "0100": "Internal exception",
  "0101": "Permission denied",
  "0102": "Prerequisite module missing",
  "0200": "Internal exception.",
  "0300": "Internal exception",
  "0400": "Internal exception",
  "0404": "Missing prerequisites to establish a websocket connection",
  "0500": "Internal exception",
  "0501": "Permission denied.",
  "0502": "Invalid message body.",
  "0503": "Text Message is too large",
  "0504": "Message not found by the given id",
  "0505": "Action not permitted without joining room",
  "0506": "Message search is disabled",
  "0510": "Invalid channel name.",
  "0600": "Internal exception",
  "0601": "Permission denied.",
  "0602": "Auth token not set for plugin",
  "0603": "Iframe was not provided",
  "0700": "Internal exception",
  "0705": "Action not permitted without joining room",
  "0800": "Internal exception",
  "0801": "Permission denied",
  "0900": "Internal exception",
  "0904": "Could not load preset",
  1e3: "Internal exception",
  1001: "Permission denied",
  1004: "Could not find specified recording",
  1005: "Action not permitted in given recording state",
  1100: "Internal exception",
  1101: "Permission denied",
  1102: "Unsupported",
  1103: "Name cannot be empty",
  1104: "No device selected while calling meeting.self.setDevice",
  1105: "Action not permitted without joining room",
  1106: "Can't set currently used device",
  1200: "Internal exception",
  1201: "Permission denied",
  1202: "Invalid page number was requested",
  1203: "Invalid participant count per page was requested",
  1204: "No participants exists with the given UserIds",
  1205: "Action not permitted without joining room",
  1206: "Manual Subscription Mode was not ACTIVATED",
  1207: "Invalid view mode",
  1208: "Manual Subscription not enabled for organization",
  1209: "Broadcast message type must be a non-empty string",
  1300: "Internal exception",
  1400: "Internal exception",
  1402: "No existing remote requests",
  1403: "No peer exists with given id",
  1500: "Internal exception",
  1600: "Internal exception",
  1601: "Failed to get audio track",
  1602: "Failed to get video track",
  1603: "Incorrect device",
  1604: "Failed to change device",
  1605: "Failed to get audio & video track",
  1606: "No audio input devices are available",
  1607: "No video input devices are available",
  1608: "No audio output devices (speakers) are available",
  1609: "Failed to fetch list of media devices",
  1610: "No media track exists",
  1611: "Failed to unmute track",
  1612: "Failed to get screenshare tracks",
  1701: "Crypto error",
  // 18xx is for AI
  1800: "Internal exception",
  1801: "Can't fetch transcript file",
  // 19xx for livestream
  1900: "Internal exception",
  1901: "Permission denied.",
  1902: "Livestream that has not yet started, can't be stopped",
  2e3: "Internal exception",
  2001: "Permission denied",
  2002: "Unsupported",
  2003: "Stage is disabled",
  2004: "Method not implemented",
  2005: "Action not permitted without joining room",
  2006: "Action not permitted in current stage status",
  9900: "Internal exception"
};
Object.keys(md).forEach((s) => {
  md[s] = `{${kC[s.slice(0, 2)]}} ${md[s]}`;
});
class R extends Error {
  constructor(e, r, i = void 0, n = !1) {
    super(e);
    h(this, "code");
    this.code = r, this.name = "DyteError", this.message = `[ERR${this.code}]: ${md[this.code]}
${this.message}`;
    try {
      let o = n && !!i;
      r && r.endsWith("00") && i && (o = !0), o && i.error("DyteError", {
        error: { message: this.message, name: this.name, code: r }
      });
      const c = mr.getContext(mr.getMostRecentPeerId());
      if (c) {
        const d = c.getValue("onError");
        try {
          d(this);
        } catch (l) {
        }
      }
      typeof window != "undefined" && window.dispatchEvent(new CustomEvent("dyteError", {
        detail: this
      }));
    } catch (o) {
    }
  }
}
function rd(s, t, e, r) {
  if (r instanceof R)
    throw r;
  if (r instanceof t) {
    const i = new R(r.message, e);
    throw i.stack = r.stack, i;
  } else
    throw r;
}
function Up(s, t, e) {
  if (!s.value) {
    const i = s.get, n = s.set;
    return i && (s.get = function() {
      try {
        return i.apply(this);
      } catch (o) {
        rd(this, t, e, o);
      }
    }), n && (s.set = function(o) {
      try {
        return n.apply(this, [o]);
      } catch (c) {
        rd(this, t, e, c);
      }
    }), s;
  }
  const r = s.value;
  return s.value = function(...i) {
    try {
      const n = r.apply(this, i);
      return n && n instanceof Promise ? n.catch((o) => {
        rd(this, t, e, o);
      }) : n;
    } catch (n) {
      rd(this, t, e, n);
    }
  }, s;
}
function IC(s, t) {
  return (e, r, i) => {
    if (i)
      return Up(i, s, t);
    for (const n of Reflect.ownKeys(e.prototype).filter(
      (o) => o !== "constructor"
    )) {
      const o = Object.getOwnPropertyDescriptor(
        e.prototype,
        n
      );
      (o.value instanceof Function || o.get instanceof Function || o.set instanceof Function) && Object.defineProperty(
        e.prototype,
        n,
        Up(o, s, t)
      );
    }
  };
}
const ht = (s) => IC(Error, s);
function AC(s) {
  let t = 0, e, r;
  if (!s)
    return t;
  for (e = 0; e < s.length; e += 1)
    r = s.charCodeAt(e), t = (t << 5) - t + r, t |= 0;
  return Math.abs(t) % 100 + 1;
}
function MC() {
  Te.isElectron() && window.dyteElectronGetDisplayMediaSource && (navigator.mediaDevices.getDisplayMedia = () => u(this, null, function* () {
    const s = yield window.dyteElectronGetDisplayMediaSource(
      {
        types: ["window", "screen"]
      }
    );
    let t = [];
    if (s && (Array.isArray(s) ? t = s : t = [s]), !(t != null && t.length))
      throw new Error("Couldn't find any media source for screen share.");
    let e = t.find(
      (n) => {
        var o;
        return (o = n.id) == null ? void 0 : o.includes("screen");
      }
    );
    e = e != null ? e : t[0];
    const r = {
      audio: !1,
      video: {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: e.id
        }
      }
    };
    return yield navigator.mediaDevices.getUserMedia(
      r
    );
  }));
}
var k = /* @__PURE__ */ ((s) => (s.NEW_PRODUCER = "NEW_PRODUCER", s.PRODUCER_TRACK_ENDED = "PRODUCER_TRACK_ENDED", s.ROOM_NODE_CONNECTION_ERROR = "ROOM_NODE_CONNECTION_ERROR", s.SOCKET_SERVICE_ROOM_JOINED = "SOCKET_SERVICE_ROOM_JOINED", s.SOCKET_SERVICE_RECONNECTED = "SOCKET_SERVICE_RECONNECTED", s.SOCKET_SERVICE_DISCONNECTED = "SOCKET_SERVICE_DISCONNECTED", s.SOCKET_SERVICE_FAILED = "SOCKET_SERVICE_FAILED", s.SOCKET_STATE_UPDATE = "SOCKET_STATE_UPDATE", s.ROOM_NODE_RECONNECTED = "ROOM_NODE_RECONNECTED", s.ROOM_NODE_DISCONNECTED = "ROOM_NODE_DISCONNECTED", s.ROOM_NODE_FAILED = "ROOM_NODE_FAILED", s.TRANSPORT_STATE_UPDATE = "TRANSPORT_STATE_UPDATE", s.PRODUCER_SCORE_UPDATE = "PRODUCER_SCORE_UPDATE", s.CONSUMER_SCORE_UPDATE = "CONSUMER_SCORE_UPDATE", s.PRODUCER_STATUS_UPDATE = "PRODUCER_STATUS_UPDATE", s.CONSUMER_STATUS_UPDATE = "CONSUMER_STATUS_UPDATE", s.LOW_PRODUCER_SCORE = "LOW_PRODUCER_SCORE", s.LOW_CONSUMER_SCORE = "LOW_CONSUMER_SCORE", s.MEDIA_PERMISSION_ERROR = "MEDIA_PERMISSION_ERROR", s.MEDIA_PERMISSION_UPDATE = "MEDIA_PERMISSION_UPDATE", s.WAITLISTED = "WAIT_LISTED", s.MESSAGE = "websocket/message", s.ROOM_MESSAGE = "websocket/room-message", s.PEER_JOINED_INTERNAL = "peer/joined-internal", s.PEER_CLOSED = "websocket/peer-closed", s.CONSUMER_CLOSED = "websocket/consumer-closed", s.CONSUMER_PAUSED = "websocket/consumer-paused", s.CONSUMER_RESUMED = "websocket/consumer-resumed", s.PRODUCER_CLOSED = "websocket/producer-closed", s.NEW_CONSUMER = "websocket/new-consumer", s.PRODUCER_SCORE = "websocket/producer-score", s.CONSUMER_SCORE = "websocket/consumer-score", s.PRODUCER_TOGGLE = "hive/producer-toggle", s.CONSUMER_TOGGLE = "hive/consumer-toggle", s.SELECTED_PEERS_DIFF = "hive/selected-peers-diff", s.UPDATE_ACTIVE = "media/update-active", s.RESET_PRODUCER_STATE = "hive/reset-producer-state", s.CF_TRANSPORT_STATE_CHANGED = "cf/transport-state-changed", s.CF_ROOM_REJOINING = "cf/room-rejoining", s.CF_ROOM_REJOIN_FAILED = "cf/room-rejoining-failed", s.CF_ROOM_REJOINED = "cf/room-rejoined", s.CF_TRANPSORT_RECONNECTING = "cf/transport-reconnecting", s.ROOM_STATE = "sockethub/room-state", s.PEER_DISPLAY_NAME_CHANGED = "hive/display-name-changed", s.GET_STAGE_REQUESTS = "GET_STAGE_REQUESTS", s.UPDATE_STAGE_REQUESTS = "UPDATE_STAGE_REQUESTS", s.KICK_PEER = "KICK_PEER", s.UPDATE_PEER_STAGE_STATUS = "UPDATE_PEER_STAGE_STATUS", s.JOIN_MEDIA_ROOM = "JOIN_MEDIA_ROOM", s.LEAVE_MEDIA_ROOM = "LEAVE_MEDIA_ROOM", s.PIP_HANGUP = "PIP_HANGUP", s.E2EE_ACTIVE_PRODUCER = "E2EE_ACTIVE_PRODUCER", s.E2EE_INACTIVE_PRODUCER = "E2EE_INACTIVE_PRODUCER", s.E2EE_ACTIVE_CONSUMER = "E2EE_ACTIVE_CONSUMER", s.E2EE_INACTIVE_CONSUMER = "E2EE_INACTIVE_CONSUMER", s.SOCKET_PEERS = "SOCKET_PEERS", s.UPDATE_PERMISSIONS = "UPDATE_PERMISSIONS", s.MAX_SPATIAL_LAYER_CHANGE = "MAX_SPATIAL_LAYER_CHANGE", s.MUTE_SELF = "MUTE_SELF", s.MUTE_SELF_VIDEO = "MUTE_SELF_VIDEO", s))(k || {});
class Jn extends ut.EventEmitter {
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
}
class qt extends ut.EventEmitter {
  constructor(e) {
    super();
    h(this, "logger");
    this.logger = e, super.setMaxListeners(25);
  }
  emit(e, ...r) {
    return super.emit("*", e, ...r), super.emit(e, ...r);
  }
  on(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.on(e, r);
  }
  addListener(e, r) {
    var i;
    try {
      const n = this.listenerCount(e);
      n > 25 && n % 25 === 0 && ((i = this.logger) == null || i.warn("DyteEventEmitter::maxListenersExceeded", {
        eventListener: {
          eventName: e.toString(),
          listenerCount: this.listenerCount(e)
        }
      }));
    } catch (n) {
    }
    return super.addListener(e, r);
  }
  off(e, r) {
    return super.off(e, r);
  }
  once(e, r) {
    return super.once(e, r);
  }
  prependListener(e, r) {
    return super.prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return super.prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return super.removeListener(e, r);
  }
  removeAllListeners(e) {
    return super.removeAllListeners(e);
  }
  listeners(e) {
    return super.listeners(e);
  }
  listenerCount(e) {
    return super.listenerCount(e);
  }
}
function DC(s, t = 2) {
  return s.replace(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/g, "").trim().split(/\s+/).slice(0, t).map((i) => i.charAt(0)).join("").toUpperCase();
}
const $p = 1080, Fp = 1920, OC = (s, t, e, r, i, n) => {
  let o = 0.5, c = 0.5;
  const d = i, l = n, p = Math.min(e / d, r / l);
  let f = d * p, S = l * p, T, _, P, w, A = 1;
  return f < e && (A = e / f), Math.abs(A - 1) < 1e-14 && S < r && (A = r / S), f *= A, S *= A, P = d / (f / e), w = l / (S / r), T = (d - P) * o, _ = (l - w) * c, T < 0 && (T = 0), _ < 0 && (_ = 0), P > d && (P = d), w > l && (w = l), [T, _, P, w, s, t, e, r];
};
var Kt, Si, rt, zt, be, ds, Ws, mt, Oe, Fa, Ha, Js, Ba;
const Qh = class extends qt {
  constructor(e, r, i, n) {
    const o = e.getValue("logger");
    super(o);
    g(this, Kt, void 0);
    g(this, Si, void 0);
    g(this, rt, void 0);
    g(this, zt, void 0);
    g(this, be, {
      height: $p,
      width: Fp
    });
    g(this, ds, {
      brand: "#2160FD",
      background: "#141414",
      text: "#000000",
      videoBackground: "#191919",
      textOnBrand: "#EEEEEE"
    });
    g(this, Ws, void 0);
    g(this, mt, {});
    g(this, Oe, void 0);
    g(this, Fa, void 0);
    g(this, Ha, void 0);
    g(this, Js, void 0);
    g(this, Ba, !1);
    h(this, "cleanupEventListeners", () => {
      a(this, Si).unsubscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).removeListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).removeListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).removeListener("roomLeft", () => this.disable());
    });
    h(this, "enablePipMediaControls", () => {
      this.mountAudioEvents(), this.mountVideoEvents();
    });
    h(this, "onSelfVideoUpdateListener", ({ videoEnabled: e }) => {
      this.updateMediaSession("CAMERA", e);
    });
    h(this, "onSelfAudioUpdateListener", ({ audioEnabled: e }) => {
      this.updateMediaSession("MIC", e);
    });
    h(this, "handlePipMediaControls", (e) => {
      e === "ON_STAGE" ? this.enablePipMediaControls() : this.unmountEvents();
    });
    h(this, "eventCallback", (e) => {
      e === "CAMERA" && (a(this, Oe).videoEnabled ? a(this, Oe).disableVideo() : a(this, Oe).enableVideo(), this.emit("cameraToggled")), e === "MIC" && (a(this, Oe).audioEnabled ? a(this, Oe).disableAudio() : a(this, Oe).enableAudio(), this.emit("micToggled")), e === "END" && (a(this, Si).getValue("peerSessionStore").emit(k.PIP_HANGUP), this.cleanupEventListeners(), this.emit("hangup"), this.cleanup());
    });
    h(this, "unmountEvents", () => {
      navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("togglemicrophone", void 0), navigator.mediaSession.setActionHandler("togglecamera", void 0));
    });
    h(this, "animate", () => {
      if (!this.isActive && a(this, Js) === "active") {
        this.disable(!0);
        return;
      }
      a(this, mt) !== void 0 && this.paintCanvas(), a(this, Ws) !== void 0 && m(this, Ws, requestAnimationFrame(() => this.animate()));
    });
    /**
    	 * Disable PiP
    	 */
    h(this, "disable", (e = !1) => {
      m(this, Js, "idle"), this.cleanupEventListeners(), cancelAnimationFrame(a(this, Ws)), e !== !0 && document.body.removeChild(a(this, rt)), m(this, Ws, void 0), document.pictureInPictureElement && document.exitPictureInPicture();
    });
    m(this, Si, e), m(this, Js, "idle"), m(this, Oe, r), m(this, ds, {
      brand: r.config.designTokens.colors.brand[500],
      background: r.config.designTokens.colors.background[1e3],
      text: r.config.designTokens.colors.text,
      videoBackground: r.config.designTokens.colors.videoBg,
      textOnBrand: r.config.designTokens.colors.textOnBrand
    }), i && this.setupIcon("pin", i), n && this.setupIcon("handRaise", n);
  }
  static _init(e, r) {
    return u(this, null, function* () {
      let i, n;
      try {
        i = yield sd(CC), n = yield sd(RC);
      } catch (o) {
      }
      return new Qh(e, r, i, n);
    });
  }
  setupIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, r);
          break;
        case "pin":
          m(this, Fa, r);
          break;
      }
    });
  }
  overrideIcon(e, r) {
    return u(this, null, function* () {
      switch (e) {
        case "handRaise":
          m(this, Ha, yield sd(r));
          break;
        case "pin":
          m(this, Fa, yield sd(r));
          break;
      }
    });
  }
  constructImage(e) {
    const r = new Image(), i = new Blob([e], { type: "image/svg+xml" }), n = window.URL.createObjectURL(i);
    return new Promise((o) => {
      r.onload = () => {
        o(r), window.URL.revokeObjectURL(n);
      }, r.src = n;
    });
  }
  createVideoContainer() {
    m(this, rt, document.createElement("div")), a(this, rt).style.width = "0.1px", a(this, rt).style.height = "0.1px", a(this, rt).style.overflow = "hidden", a(this, rt).style.position = "absolute", a(this, rt).style.bottom = "0", a(this, rt).style.right = "0", a(this, rt).style.opacity = "0", a(this, rt).appendChild(a(this, zt));
  }
  setupEventListeners() {
    a(this, Si).subscribe("stageStatus", this.handlePipMediaControls), a(this, Oe).addListener("videoUpdate", this.onSelfVideoUpdateListener), a(this, Oe).addListener("audioUpdate", this.onSelfAudioUpdateListener), a(this, Oe).addListener("roomLeft", () => this.disable());
  }
  createCanvas() {
    const e = document.createElement("canvas");
    e.height = a(this, be).height, e.width = a(this, be).width, m(this, Kt, e);
  }
  setupMediaSessionEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || (navigator.mediaSession.setActionHandler("hangup", () => {
      this.eventCallback("END");
    }), this.mountAudioEvents(), this.mountVideoEvents());
  }
  mountAudioEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setMicrophoneActive === void 0 || a(this, Oe).permissions.canProduceAudio && navigator.mediaSession.setActionHandler("togglemicrophone", () => {
      this.eventCallback("MIC");
    });
  }
  mountVideoEvents() {
    navigator.mediaSession === void 0 || navigator.mediaSession.setCameraActive === void 0 || a(this, Oe).permissions.canProduceVideo && navigator.mediaSession.setActionHandler("togglecamera", () => {
      this.eventCallback("CAMERA");
    });
  }
  getSources() {
    const r = Object.values(a(this, mt)).reduce(
      (i, n) => (i[n.pinned ? "pinned" : "regular"].push(n), i),
      { pinned: [], regular: [] }
    );
    return [...r.pinned, ...r.regular];
  }
  drawEmptyTile(e, r, i, n) {
    if (a(this, Kt) === void 0)
      return;
    const o = a(this, Kt).getContext("2d"), c = a(this, Kt).width, d = 0, l = 0, p = r - d * 2, f = i - d * 2, S = Math.floor(c / p), T = Math.floor(e / S), P = e % S * (p + d) + d, w = T * (f + d) + d, { displayText: A, image: N } = n != null ? n : {};
    o.fillStyle = A || N ? a(this, ds).videoBackground : a(this, ds).background, o.strokeStyle = a(this, ds).brand, o.beginPath(), o.moveTo(P + l, w), o.arcTo(P + p, w, P + p, w + l, l), o.arcTo(
      P + p,
      w + f,
      P + p - l,
      w + f,
      l
    ), o.arcTo(P, w + f, P, w + f - l, l), o.arcTo(P, w, P + l, w, l), o.closePath(), o.fill(), o.stroke();
    const H = p / 6, $ = p / 2 + P, F = f / 2 + w;
    o.save(), (A || N) && (o.beginPath(), o.arc($, F, H, 0, Math.PI * 2), o.fillStyle = a(this, ds).brand, o.fill(), N ? (o.clip(), o.drawImage(
      N,
      $ - H,
      F - H,
      H * 2,
      H * 2
    ), o.restore()) : A && (o.fillStyle = a(this, ds).textOnBrand, o.font = `${H / 2}px sans-serif`, o.textAlign = "center", o.textBaseline = "middle", o.fillText(A, $, F)), this.drawIcons(n, P, w, Math.max(p, f)));
  }
  drawIcons(e, r, i, n) {
    const o = Math.min(Math.max(n * 0.15, 100), 200), c = o * 0.2, d = o * 0.2;
    let l = r + c;
    const p = i + c, f = (S) => {
      const T = a(this, Kt).getContext("2d");
      T.save(), T.fillStyle = a(this, ds).background, T.beginPath(), T.moveTo(l + d, p), T.arcTo(l + o, p, l + o, p + d, d), T.arcTo(
        l + o,
        p + o,
        l + o - d,
        p + o,
        d
      ), T.arcTo(l, p + o, l, p + o - d, d), T.arcTo(l, p, l + d, p, d), T.closePath(), T.fill(), typeof S == "string" ? (T.font = `${o / 1.5}px sans-serif`, T.fillStyle = a(this, ds).text, T.textAlign = "center", T.textBaseline = "top", T.fillText(S, o / 2 + l, p + c)) : T.drawImage(
        S,
        l + c,
        p + c,
        o - c * 2,
        o - c * 2
      ), l += o + c, T.restore();
    };
    e.pinned && f(a(this, Fa)), e.handRaised && f(a(this, Ha));
  }
  drawTile(e, r, i) {
    var l, p;
    if (a(this, Kt) === void 0)
      return;
    const n = a(this, Kt).getContext("2d"), o = this.getSources();
    let c = 0, d = 0;
    for (; c < a(this, be).height - 5; ) {
      let f = 0;
      for (; f < a(this, be).width - 5 && d < i; ) {
        if ((l = o[d]) != null && l.enabled) {
          const S = o[d].element, [T, _, P, w, A, N, H, $] = OC(
            f,
            c,
            e,
            r,
            S.videoWidth,
            S.videoHeight
          );
          ((p = S == null ? void 0 : S.classList) == null ? void 0 : p.contains("mirror")) ? (n.save(), n.scale(-1, 1), n.drawImage(S, T, _, P, w, -1 * A, N, -1 * H, $), n.restore()) : n.drawImage(S, T, _, P, w, A, N, H, $), this.drawIcons(o[d], A, N, Math.max(H, $));
        } else
          this.drawEmptyTile(d, e, r, o[d]);
        d += 1, f += e;
      }
      c += r;
    }
  }
  calcGridElemSize(e) {
    switch (e) {
      case 0:
      case 1:
        return [a(this, be).width, a(this, be).height];
      case 2:
        return [Math.floor(a(this, be).width / 2), a(this, be).height];
      case 3:
      case 4:
        return [Math.floor(a(this, be).width / 2), Math.floor(a(this, be).height / 2)];
      case 5:
      case 6:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
      case 7:
      case 8:
      case 9:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 3)];
      default:
        return [Math.floor(a(this, be).width / 3), Math.floor(a(this, be).height / 2)];
    }
  }
  paintCanvas() {
    let e = this.getSources().length;
    e !== 1 && (e = e % 2 > 0 ? e + 1 : e);
    const [r, i] = this.calcGridElemSize(e);
    this.drawTile(r, i, e);
  }
  isSupported() {
    var e;
    return !!window.chrome && document.pictureInPictureEnabled && ((e = a(this, Oe).config) == null ? void 0 : e.viewType) !== "LIVESTREAM";
  }
  get isActive() {
    return document.pictureInPictureElement !== null;
  }
  cleanup() {
    if (m(this, Ba, !1), this.isSupported() && document.exitPictureInPicture !== void 0 && document.pictureInPictureElement !== null && document.exitPictureInPicture(), a(this, rt))
      try {
        document.body.removeChild(a(this, rt));
      } catch (e) {
      }
    this.removeAllSources(), m(this, Kt, void 0), m(this, zt, void 0), m(this, Ws, void 0);
  }
  /**
  	 * Initialize PiP and prepare sources
  	 */
  init({ height: e, width: r } = {}) {
    if (!this.isSupported())
      throw this.logger.error("DytePip.unsupported"), new Error("Picture-in-picture is not available in this environment");
    if (a(this, Ba))
      return;
    m(this, Ba, !0), this.createCanvas(), this.setupMediaSessionEvents();
    const i = document.createElement("video");
    m(this, be, {
      height: e != null ? e : $p,
      width: r != null ? r : Fp
    }), i.height = a(this, be).height, i.width = a(this, be).width, i.autoplay = !0, i.muted = !0, i.srcObject = a(this, Kt).captureStream(24), m(this, zt, i), a(this, zt).onloadedmetadata = () => {
      try {
        this.emit("pipStarted"), a(this, zt).onleavepictureinpicture = () => {
          this.emit("pipEnded");
        };
      } catch (n) {
        this.emit("pipEnded");
      }
    }, this.createVideoContainer(), this.paintCanvas();
  }
  updateMediaSession(e, r) {
    navigator.mediaSession !== void 0 && (e === "CAMERA" && navigator.mediaSession.setCameraActive !== void 0 && navigator.mediaSession.setCameraActive(r), e === "MIC" && navigator.mediaSession.setMicrophoneActive !== void 0 && navigator.mediaSession.setMicrophoneActive(r));
  }
  enableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = !0);
  }
  disableSource(e) {
    a(this, mt)[e] !== void 0 && (a(this, mt)[e].enabled = !1);
  }
  generateAvatar(e, r) {
    return u(this, null, function* () {
      if (!r)
        return;
      const i = new Image();
      try {
        const n = yield (yield fetch(r)).blob(), o = window.URL.createObjectURL(n);
        i.onload = () => {
          this.updateSource(e, { image: i }), window.URL.revokeObjectURL(o);
        }, i.src = o;
      } catch (n) {
        this.logger.error("DytePip::GenerateAvatar", {
          error: n
        });
      }
    });
  }
  /**
   * Add a video source from the participant grid
   * @param {string} id id for the source (ex. participant id)
   * @param {HTMLVideoElement} element HTMLVideoElement for the video source
   * @param {boolean} enabled if source is enabled
   * @param {?string} [displayText] two character display text
   */
  addSource(e, r, i, n = !1, o = void 0, c = void 0, d = !1) {
    this.logger.debug("DytePIP::AddSource", {
      pip: {
        id: e,
        handRaised: d
      }
    }), a(this, mt)[e] = {
      id: e,
      element: r,
      enabled: i,
      pinned: n,
      displayText: o ? DC(o) : void 0,
      imageUrl: c,
      handRaised: d
    }, c && this.generateAvatar(e, c);
  }
  /** Update a video source */
  updateSource(e, r) {
    this.logger.info("DytePIP::UpdateSource", {
      pip: {
        id: e,
        handRaised: r.handRaised
      }
    });
    const i = a(this, mt)[e];
    i && (a(this, mt)[e] = D(D({}, i), r));
  }
  /**
  	 * Remove the video source for the participant
  	 * @param id id for the source (ex. participant id)
  	 */
  removeSource(e) {
    delete a(this, mt)[e];
  }
  /**
  	 * Remove the pinned source
  	 * @param id id for the source (ex. participant id)
  	 */
  removePinnedSource() {
    Object.values(a(this, mt)).forEach((r) => {
      r.pinned && this.removeSource(r.id);
    });
  }
  /**
  	 * Remove all sources
  	 */
  removeAllSources() {
    m(this, mt, {});
  }
  /**
  	 * Enable PiP
  	 */
  enable() {
    m(this, Js, "activating"), this.setupEventListeners(), this.updateMediaSession("CAMERA", a(this, Oe).videoEnabled), this.updateMediaSession("MIC", a(this, Oe).audioEnabled), document.body.appendChild(a(this, rt)), m(this, Ws, requestAnimationFrame(() => this.animate())), a(this, zt).onloadedmetadata = () => {
      a(this, zt).requestPictureInPicture().then(() => {
        m(this, Js, "active");
      });
    }, a(this, zt).readyState === 4 && a(this, zt).requestPictureInPicture().then(() => {
      m(this, Js, "active");
    });
  }
};
let Au = Qh;
Kt = new WeakMap(), Si = new WeakMap(), rt = new WeakMap(), zt = new WeakMap(), be = new WeakMap(), ds = new WeakMap(), Ws = new WeakMap(), mt = new WeakMap(), Oe = new WeakMap(), Fa = new WeakMap(), Ha = new WeakMap(), Js = new WeakMap(), Ba = new WeakMap();
var vr;
(function(s) {
  s[s.PUBLISHER = 0] = "PUBLISHER", s[s.SUBSCRIBER = 1] = "SUBSCRIBER";
})(vr || (vr = {}));
var xs;
(function(s) {
  s[s.AUDIO = 0] = "AUDIO", s[s.VIDEO = 1] = "VIDEO";
})(xs || (xs = {}));
class NC extends v {
  constructor() {
    super("media.Codec", [
      {
        no: 1,
        name: "channels",
        kind: "scalar",
        opt: !0,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "clock_rate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "mime_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "sdp_fmtp_line",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "payload_type",
        kind: "scalar",
        opt: !0,
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
}
const df = new NC();
class VC extends v {
  constructor() {
    super("media.HeaderExtension", [
      {
        no: 1,
        name: "direction",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "uri",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const LC = new VC();
class xC extends v {
  constructor() {
    super("media.Fingerprint", [
      {
        no: 1,
        name: "algorithm",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new xC();
class UC extends v {
  constructor() {
    super("media.SessionDescription", [
      { no: 1, name: "target", kind: "enum", T: () => ["media.Target", vr] },
      {
        no: 2,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Rs = new UC();
class $C extends v {
  constructor() {
    super("media.ProducerPayload", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "msid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "mime_type",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const FC = new $C();
class HC extends v {
  constructor() {
    super("media.CreateTransportRequest", [
      {
        no: 1,
        name: "consuming",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "force_tcp",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 3, name: "description", kind: "message", T: () => Rs },
      {
        no: 4,
        name: "private_ice",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 5, name: "producers", kind: "message", repeat: 1, T: () => FC }
    ]);
  }
}
const BC = new HC();
class qC extends v {
  constructor() {
    super("media.AudioActivityRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "energy",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "silent",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const jC = new qC();
class GC extends v {
  constructor() {
    super("media.CreateTransportResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "transcription_enabled",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const lf = new GC();
class WC extends v {
  constructor() {
    super("media.RenegotiateRequest", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
const JC = new WC();
class KC extends v {
  constructor() {
    super("media.RenegotiateResponse", [
      {
        no: 1,
        name: "transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
new KC();
class zC extends v {
  constructor() {
    super("media.NestedScore", [
      {
        no: 1,
        name: "encoding_idx",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "rid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "ssrc",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
}
const YC = new zC();
class QC extends v {
  constructor() {
    super("media.ProducerTrack", [
      {
        no: 1,
        name: "track_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "stream_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const XC = new QC();
class ZC extends v {
  constructor() {
    super("media.ProducerEntry", [
      {
        no: 1,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new ZC();
class eR extends v {
  constructor() {
    super("media.ConsumerEntry", [
      {
        no: 1,
        name: "consuming_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new eR();
class tR extends v {
  constructor() {
    super("media.ProducerState", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "kind", kind: "enum", T: () => ["media.ProducerKind", xs] },
      {
        no: 3,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "app_data",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "producing_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "codec", kind: "message", T: () => df }
    ]);
  }
}
const Jc = new tR();
class sR extends v {
  constructor() {
    super("media.ConsumerState", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc },
      { no: 3, name: "producer_track", kind: "message", T: () => XC },
      {
        no: 4,
        name: "error_code",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const rR = new sR();
class iR extends v {
  constructor() {
    super("media.ProducerIdToConsumerMap", [
      { no: 1, name: "map", kind: "map", K: 9, V: { kind: "message", T: () => rR } }
    ]);
  }
}
const uf = new iR();
class aR extends v {
  constructor() {
    super("media.PeerRtpCapabilitites", [
      { no: 1, name: "sender", kind: "message", T: () => Bp },
      { no: 2, name: "receiver", kind: "message", T: () => Bp }
    ]);
  }
}
const hf = new aR();
class nR extends v {
  constructor() {
    super("media.RtpCapability", [
      { no: 1, name: "codecs", kind: "message", repeat: 1, T: () => df },
      { no: 2, name: "header_extensions", kind: "message", repeat: 1, T: () => LC }
    ]);
  }
}
const Hp = new nR();
class oR extends v {
  constructor() {
    super("media.RtpCapabilitites", [
      { no: 1, name: "audio", kind: "message", T: () => Hp },
      { no: 2, name: "video", kind: "message", T: () => Hp }
    ]);
  }
}
const Bp = new oR();
class cR extends v {
  constructor() {
    super("media.PreferredCodec", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const dR = new cR();
class lR extends v {
  constructor() {
    super("media.Simulcast", [
      {
        no: 1,
        name: "preferred_rid",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "priority_ordering",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "rid_not_available",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const pf = new lR();
class uR extends v {
  constructor() {
    super("media.edge.GeoLocation", [
      {
        no: 1,
        name: "latitude",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 2,
        name: "longitude",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 3,
        name: "region",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const hR = new uR();
class pR extends v {
  constructor() {
    super("media.edge.PeerJoinRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "prejoined",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "preset",
        kind: "scalar",
        opt: !0,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 6,
        name: "user_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "organization_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "location", kind: "message", T: () => hR },
      { no: 9, name: "capabilities", kind: "message", T: () => hf }
    ]);
  }
}
const gR = new pR();
class mR extends v {
  constructor() {
    super("media.edge.PeerJoinCompleteRequest", []);
  }
}
const fR = new mR();
class SR extends v {
  constructor() {
    super("media.edge.PeerLeaveRequest", [
      {
        no: 1,
        name: "close_room",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const vR = new SR();
class yR extends v {
  constructor() {
    super("media.edge.ConsumeMultipleProducerRequest", [
      {
        no: 1,
        name: "producer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
new yR();
class TR extends v {
  constructor() {
    super("media.edge.ConsumePeerRequest", [
      {
        no: 1,
        name: "producing_peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "producer_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "preferred_codec", kind: "message", T: () => dR },
      {
        no: 5,
        name: "producing_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "simulcast", kind: "message", T: () => pf }
    ]);
  }
}
const ER = new TR();
class _R extends v {
  constructor() {
    super("media.edge.ConsumePeersRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => ER },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const PR = new _R();
class CR extends v {
  constructor() {
    super("media.edge.UpdateConsumerSimulcastConfigRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "simulcast", kind: "message", T: () => pf },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "mid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const RR = new CR();
class wR extends v {
  constructor() {
    super("media.edge.UpdateConsumersSimulcastConfigRequest", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => RR },
      {
        no: 2,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const bR = new wR();
class kR extends v {
  constructor() {
    super("media.edge.ProducerCreateRequest", [
      {
        no: 1,
        name: "kind",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "paused",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "description", kind: "message", T: () => Rs },
      {
        no: 5,
        name: "msid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "app_data",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "mime_type",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "producing_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const IR = new kR();
class AR extends v {
  constructor() {
    super("media.edge.SelectedPeersRequest", []);
  }
}
new AR();
class MR extends v {
  constructor() {
    super("media.edge.GlobalPeerPinningRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const DR = new MR();
class OR extends v {
  constructor() {
    super("media.edge.ProducerToggleRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const id = new OR();
class NR extends v {
  constructor() {
    super("media.edge.ConsumerToggleRequest", [
      {
        no: 1,
        name: "consumer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
new NR();
class VR extends v {
  constructor() {
    super("media.edge.ProducerCloseRequest", [
      {
        no: 1,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "producing_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const LR = new VR();
class xR extends v {
  constructor() {
    super("media.edge.ConsumerCloseRequest", [
      {
        no: 1,
        name: "consumer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "description", kind: "message", T: () => Rs },
      {
        no: 3,
        name: "consuming_transport_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const UR = new xR();
class $R extends v {
  constructor() {
    super("media.edge.KickPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new $R();
class FR extends v {
  constructor() {
    super("media.edge.KickAllPeersRequest", [
      {
        no: 1,
        name: "propagate_kick_across_rooms",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const gf = new FR();
class HR extends v {
  constructor() {
    super("media.edge.PeerDisplayNameEditRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const BR = new HR();
class qR extends v {
  constructor() {
    super("media.edge.HostMediaControlForPeerRequest", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "scree_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const jR = new qR();
class GR extends v {
  constructor() {
    super("media.edge.HostMediaControlForAllPeerRequest", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "screen_share",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const WR = new GR();
class JR extends v {
  constructor() {
    super("media.edge.GetRoomStateResponse", [
      {
        no: 1,
        name: "display_title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "locked_mode",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "current_peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "is_recording",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "recorder_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "pinned_peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const KR = new JR();
class zR extends v {
  constructor() {
    super("media.edge.ErrorResponse", [
      {
        no: 1,
        name: "error_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "event_id",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
}
const YR = new zR();
class QR extends v {
  constructor() {
    super("media.edge.EmptyResponse", []);
  }
}
new QR();
class XR extends v {
  constructor() {
    super("media.edge.RoomParticipants", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_states", kind: "message", repeat: 1, T: () => Jc },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "user_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "capabilities", kind: "message", T: () => hf }
    ]);
  }
}
const mf = new XR();
class ZR extends v {
  constructor() {
    super("media.edge.SelectedPeersResponse", [
      {
        no: 1,
        name: "audio_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "compulsory_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Mu = new ZR();
class ew extends v {
  constructor() {
    super("media.edge.SelectedPeersDiffEntry", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "priority",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
}
const tw = new ew();
class sw extends v {
  constructor() {
    super("media.edge.SelectedPeersDiffResponse", [
      { no: 1, name: "entries", kind: "message", repeat: 1, T: () => tw }
    ]);
  }
}
const qp = new sw();
class rw extends v {
  constructor() {
    super("media.edge.PeerJoinResponse", []);
  }
}
new rw();
class iw extends v {
  constructor() {
    super("media.edge.PeerJoinCompleteResponse", [
      { no: 1, name: "room_state", kind: "message", T: () => KR },
      { no: 2, name: "participants", kind: "message", repeat: 1, T: () => mf },
      { no: 3, name: "selected_peers", kind: "message", T: () => Mu },
      {
        no: 4,
        name: "max_preferred_streams",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
}
const Du = new iw();
class aw extends v {
  constructor() {
    super("media.edge.PeerLeaveResponse", [
      {
        no: 1,
        name: "closed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const nw = new aw();
class ow extends v {
  constructor() {
    super("media.edge.ConsumeMultipleProducerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: () => uf }
    ]);
  }
}
new ow();
class cw extends v {
  constructor() {
    super("media.edge.ConsumePeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 2, name: "consumer_ids_map", kind: "message", T: () => uf },
      { no: 3, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
const dw = new cw();
class lw extends v {
  constructor() {
    super("media.edge.ProducerCreateResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "producer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
const uw = new lw();
class hw extends v {
  constructor() {
    super("media.edge.ProducerScoreResponse", [
      {
        no: 1,
        name: "responseid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "score", kind: "message", T: () => YC }
    ]);
  }
}
new hw();
class pw extends v {
  constructor() {
    super("media.edge.ActiveSpeakerResponse", [
      {
        no: 1,
        name: "responsepeer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "volume",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
}
new pw();
class gw extends v {
  constructor() {
    super("media.edge.NoActiveSpeakerResponse", []);
  }
}
new gw();
class mw extends v {
  constructor() {
    super("media.edge.ProducerToggleResponse", []);
  }
}
new mw();
class fw extends v {
  constructor() {
    super("media.edge.ConsumerToggleResponse", []);
  }
}
new fw();
class Sw extends v {
  constructor() {
    super("media.edge.ProducerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
const vw = new Sw();
class yw extends v {
  constructor() {
    super("media.edge.ConsumerClosingResponse", [
      { no: 1, name: "description", kind: "message", T: () => Rs }
    ]);
  }
}
const Tw = new yw();
class Ew extends v {
  constructor() {
    super("media.edge.GlobalPeerPinningResponse", []);
  }
}
new Ew();
class _w extends v {
  constructor() {
    super("media.edge.KickPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new _w();
class Pw extends v {
  constructor() {
    super("media.edge.KickAllPeersResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new Pw();
class Cw extends v {
  constructor() {
    super("media.edge.HostMediaControlForPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Rw = new Cw();
class ww extends v {
  constructor() {
    super("media.edge.HostMediaControlForAllPeerResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const bw = new ww();
class kw extends v {
  constructor() {
    super("media.edge.PeerDisplayNameEditResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Iw = new kw();
class Aw extends v {
  constructor() {
    super("media.edge.PeerJoinBroadcastResponse", [
      { no: 1, name: "participant", kind: "message", T: () => mf }
    ]);
  }
}
const jp = new Aw();
class Mw extends v {
  constructor() {
    super("media.edge.TrackSubscriptionKind", [
      {
        no: 1,
        name: "audio",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "video",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const Gp = new Mw();
class Dw extends v {
  constructor() {
    super("media.edge.TrackSubscription", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "webcam", kind: "message", T: () => Gp },
      { no: 3, name: "screenshare", kind: "message", T: () => Gp }
    ]);
  }
}
const Ow = new Dw();
class Nw extends v {
  constructor() {
    super("media.edge.PeerProducingTransportCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "transport_details", kind: "message", T: () => lf },
      { no: 3, name: "track_subscriptions", kind: "message", repeat: 1, T: () => Ow }
    ]);
  }
}
new Nw();
class Vw extends v {
  constructor() {
    super("media.edge.PeerProducerCreateBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc }
    ]);
  }
}
const Lw = new Vw();
class xw extends v {
  constructor() {
    super("media.edge.PeerProducerToggleBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc },
      {
        no: 3,
        name: "initiator_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Wp = new xw();
class Uw extends v {
  constructor() {
    super("media.edge.PeerProducerCloseBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "producer_state", kind: "message", T: () => Jc }
    ]);
  }
}
const $w = new Uw();
class Fw extends v {
  constructor() {
    super("media.edge.PeerLeaveBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Ou = new Fw();
class Hw extends v {
  constructor() {
    super("media.edge.GlobalPeerPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Jp = new Hw();
class Bw extends v {
  constructor() {
    super("media.edge.GlobalPeerUnPinningBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new Bw();
class qw extends v {
  constructor() {
    super("media.edge.RecordingStartedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new qw();
class jw extends v {
  constructor() {
    super("media.edge.RecordingStoppedBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new jw();
class Gw extends v {
  constructor() {
    super("media.edge.PeerDisplayNameEditBroadcastResponse", [
      {
        no: 1,
        name: "participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new Gw();
class Ww extends v {
  constructor() {
    super("media.edge.PeerPingRequestBroadcastResponse", [
      {
        no: 1,
        name: "password",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new Ww();
class Jw extends v {
  constructor() {
    super("media.edge.MediaRoomTerminationBroadcastResponse", [
      {
        no: 1,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new Jw();
class Kw extends v {
  constructor() {
    super("socket.ai.MeetingTranscript", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "transcript",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "is_partial",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const lu = new Kw();
class zw extends v {
  constructor() {
    super("socket.api.BaseSocketHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new zw();
class Yw extends v {
  constructor() {
    super("socket.api.ErrorMessage", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        opt: !0,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Qw = new Yw();
var la;
(function(s) {
  s[s.BROWSER = 0] = "BROWSER", s[s.TRACK = 1] = "TRACK", s[s.COMPOSITE = 2] = "COMPOSITE";
})(la || (la = {}));
var pr;
(function(s) {
  s[s.UNSPECIFIED = 0] = "UNSPECIFIED", s[s.ON_STAGE = 1] = "ON_STAGE", s[s.APPROVED_STAGE = 2] = "APPROVED_STAGE", s[s.REQUESTED_STAGE = 3] = "REQUESTED_STAGE", s[s.OFF_STAGE = 4] = "OFF_STAGE";
})(pr || (pr = {}));
var Nu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.RECORDER = 1] = "RECORDER", s[s.LIVESTREAMER = 2] = "LIVESTREAMER";
})(Nu || (Nu = {}));
var Vu;
(function(s) {
  s[s.PEERS = 0] = "PEERS", s[s.ROOMS = 1] = "ROOMS";
})(Vu || (Vu = {}));
var Nd;
(function(s) {
  s[s.HIVE = 0] = "HIVE", s[s.CHAT = 1] = "CHAT", s[s.PING = 2] = "PING";
})(Nd || (Nd = {}));
class Xw extends v {
  constructor() {
    super("socket.room.PeerFlags", [
      {
        no: 1,
        name: "preset_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "recorder_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "hidden_participant",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const Zw = new Xw();
class eb extends v {
  constructor() {
    super("socket.room.Peer", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "stage_type", kind: "enum", opt: !0, T: () => ["socket.room.StageType", pr, "STAGE_TYPE_"] },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "preset_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "display_picture_url",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "waitlisted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 9, name: "flags", kind: "message", T: () => Zw }
    ]);
  }
}
const Gl = new eb();
class tb extends v {
  constructor() {
    super("socket.room.PeerInfoResponse", [
      { no: 1, name: "peer", kind: "message", T: () => Gl }
    ]);
  }
}
const Ca = new tb();
class sb extends v {
  constructor() {
    super("socket.room.PeerStatusUpdate", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "stage_type", kind: "enum", opt: !0, T: () => ["socket.room.StageType", pr, "STAGE_TYPE_"] }
    ]);
  }
}
const Kp = new sb();
class rb extends v {
  constructor() {
    super("socket.room.RoomPeersInfoRequest", [
      {
        no: 1,
        name: "seach_query",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "limit",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "offset",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
}
const ib = new rb();
class ab extends v {
  constructor() {
    super("socket.room.RoomPeersInfoResponse", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Gl }
    ]);
  }
}
const uu = new ab();
class nb extends v {
  constructor() {
    super("socket.room.RoomPeerCountResponse", [
      {
        no: 1,
        name: "count",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
}
const zp = new nb();
class ob extends v {
  constructor() {
    super("socket.room.Room", [
      {
        no: 1,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      { no: 5, name: "active_recordings", kind: "message", repeat: 1, T: () => db },
      {
        no: 6,
        name: "room_uuid",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ff = new ob();
class cb extends v {
  constructor() {
    super("socket.room.ActiveRecording", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", la] },
      {
        no: 3,
        name: "recording_status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const db = new cb();
class lb extends v {
  constructor() {
    super("socket.room.RoomInfoResponse", [
      { no: 1, name: "room", kind: "message", T: () => ff }
    ]);
  }
}
const Yp = new lb();
class ub extends v {
  constructor() {
    super("socket.room.GetPeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Sf = new ub();
class hb extends v {
  constructor() {
    super("socket.room.UpdatePeerInfoRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new hb();
class pb extends v {
  constructor() {
    super("socket.room.JoinRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: () => Gl },
      {
        no: 3,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "organization_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "use_hive",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "preset",
        kind: "scalar",
        opt: !0,
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 7, name: "capabilities", kind: "enum", repeat: 1, T: () => ["socket.room.Capabilities", Nd, "CAPABILITIES_"] },
      {
        no: 8,
        name: "timestamp",
        kind: "scalar",
        opt: !0,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
}
const gb = new pb();
class mb extends v {
  constructor() {
    super("socket.room.LeaveRoomRequest", [
      { no: 1, name: "peer", kind: "message", T: () => Gl },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        opt: !0,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
}
const fb = new mb();
class Sb extends v {
  constructor() {
    super("socket.room.UpdateRoomInfoRequest", [
      { no: 1, name: "room", kind: "message", T: () => ff }
    ]);
  }
}
new Sb();
class vb extends v {
  constructor() {
    super("socket.room.GetConnectedRoomsDumpRequest", []);
  }
}
new vb();
class yb extends v {
  constructor() {
    super("socket.room.ServiceError", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "code",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Ah = new yb();
class Tb extends v {
  constructor() {
    super("socket.room.ConnectedMeetingPeer", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "custom_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "preset_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "display_picture_url",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Eb = new Tb();
class _b extends v {
  constructor() {
    super("socket.room.ConnectedMeetingDump", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: () => Eb }
    ]);
  }
}
const Qp = new _b();
class Pb extends v {
  constructor() {
    super("socket.room.GetConnectedRoomsDumpResponse", [
      { no: 1, name: "parent_meeting", kind: "message", T: () => Qp },
      { no: 2, name: "meetings", kind: "message", repeat: 1, T: () => Qp }
    ]);
  }
}
const Cb = new Pb();
class Rb extends v {
  constructor() {
    super("socket.room.CreateRoomRequestPayload", [
      {
        no: 1,
        name: "title",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const wb = new Rb();
class bb extends v {
  constructor() {
    super("socket.room.CreateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => wb }
    ]);
  }
}
const kb = new bb();
class Ib extends v {
  constructor() {
    super("socket.room.CreateRoomResponsePayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "error", kind: "message", T: () => Ah }
    ]);
  }
}
const Ab = new Ib();
class Mb extends v {
  constructor() {
    super("socket.room.CreateConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Ab }
    ]);
  }
}
const Xp = new Mb();
class Db extends v {
  constructor() {
    super("socket.room.UpdateRoomRequestPayload", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "title",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Ob = new Db();
class Nb extends v {
  constructor() {
    super("socket.room.UpdateConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Ob }
    ]);
  }
}
new Nb();
class Vb extends v {
  constructor() {
    super("socket.room.DisableRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Lb = new Vb();
class xb extends v {
  constructor() {
    super("socket.room.DisableConnectedRoomsRequest", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Lb }
    ]);
  }
}
const Ub = new xb();
class $b extends v {
  constructor() {
    super("socket.room.DisableConnectedRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => Bb }
    ]);
  }
}
const Fb = new $b();
class Hb extends v {
  constructor() {
    super("socket.room.DisableConnectedRoomPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "status",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "title",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "error", kind: "message", T: () => Ah }
    ]);
  }
}
const Bb = new Hb();
class qb extends v {
  constructor() {
    super("socket.room.MovePeerPayload", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "preset_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const jb = new qb();
class Gb extends v {
  constructor() {
    super("socket.room.MovePeersBetweenRoomsRequest", [
      {
        no: 1,
        name: "source_meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "destination_meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "participants", kind: "message", repeat: 1, T: () => jb }
    ]);
  }
}
const Wb = new Gb();
class Jb extends v {
  constructor() {
    super("socket.room.MovedPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "custom_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "error", kind: "message", T: () => Ah }
    ]);
  }
}
const vf = new Jb();
class Kb extends v {
  constructor() {
    super("socket.room.MovePeersBetweenRoomsResponse", [
      { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => vf }
    ]);
  }
}
new Kb();
class zb extends v {
  constructor() {
    super("socket.room.TransferPeer", [
      {
        no: 1,
        name: "meeting_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "auth_token",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Yb = new zb();
class Qb extends v {
  constructor() {
    super("socket.room.GetAllAddedParticipantsResponse", [
      { no: 1, name: "participants", kind: "message", repeat: 1, T: () => ek }
    ]);
  }
}
const Xb = new Qb();
class Zb extends v {
  constructor() {
    super("socket.room.AddedParticipant", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ek = new Zb();
class tk extends v {
  constructor() {
    super("socket.room.RemoveParticipantsRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const yf = new tk();
class sk extends v {
  constructor() {
    super("socket.room.BroadcastMessage", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "timestamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 4,
        name: "ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "broadcast_type", kind: "enum", opt: !0, T: () => ["socket.room.BroadcastType", Vu, "BROADCAST_TYPE_"] }
    ]);
  }
}
const fo = new sk();
class rk extends v {
  constructor() {
    super("socket.room.AcceptWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ik = new rk();
class ak extends v {
  constructor() {
    super("socket.room.DenyWaitingRoomRequests", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const nk = new ak();
class ok extends v {
  constructor() {
    super("socket.room.WaitingRoomRequest", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "picture",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "custom_participant_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "preset_name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ck = new ok();
class dk extends v {
  constructor() {
    super("socket.room.GetWaitingRoomRequests", [
      { no: 1, name: "requests", kind: "message", repeat: 1, T: () => ck }
    ]);
  }
}
const Zp = new dk();
class lk extends v {
  constructor() {
    super("socket.room.GetRoomStageStateResponse", [
      {
        no: 1,
        name: "on_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "approved_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "requested_stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const eg = new lk();
var Lu;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SKIP = 1] = "SKIP", s[s.ON_PRIVILEGED_USER_ENTRY = 2] = "ON_PRIVILEGED_USER_ENTRY", s[s.SKIP_ON_ACCEPT = 3] = "SKIP_ON_ACCEPT";
})(Lu || (Lu = {}));
var Qr;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.ALLOWED = 1] = "ALLOWED", s[s.NOT_ALLOWED = 2] = "NOT_ALLOWED", s[s.CAN_REQUEST = 3] = "CAN_REQUEST";
})(Qr || (Qr = {}));
class uk extends v {
  constructor() {
    super("socket.preset.PollsPermissionUpdate", [
      {
        no: 1,
        name: "can_create",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_vote",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "can_view",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const hk = new uk();
class pk extends v {
  constructor() {
    super("socket.preset.PluginsPermissionsUpdate", [
      {
        no: 1,
        name: "can_close",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_start",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const gk = new pk();
class mk extends v {
  constructor() {
    super("socket.preset.PublicChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "text",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "files",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const fk = new mk();
class Sk extends v {
  constructor() {
    super("socket.preset.PrivateChatPermission", [
      {
        no: 1,
        name: "can_send",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_receive",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "text",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "files",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const vk = new Sk();
class yk extends v {
  constructor() {
    super("socket.preset.ChatPermissionUpdate", [
      { no: 1, name: "public", kind: "message", T: () => fk },
      { no: 2, name: "private", kind: "message", T: () => vk }
    ]);
  }
}
const Tk = new yk();
class Ek extends v {
  constructor() {
    super("socket.preset.ConnectedMeetingPermissionUpdate", [
      {
        no: 1,
        name: "can_alter_connected_meetings",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "can_switch_to_parent_meeting",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "can_switch_connected_meetings",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const _k = new Ek();
class Pk extends v {
  constructor() {
    super("socket.preset.StreamPermission", [
      { no: 1, name: "can_produce", kind: "enum", opt: !0, T: () => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"] },
      { no: 2, name: "can_consume", kind: "enum", opt: !0, T: () => ["socket.preset.StreamPermissionType", Qr, "STREAM_PERMISSION_TYPE_"] }
    ]);
  }
}
const hu = new Pk();
class Ck extends v {
  constructor() {
    super("socket.preset.MediaPermissionUpdate", [
      { no: 1, name: "video", kind: "message", T: () => hu },
      { no: 2, name: "audio", kind: "message", T: () => hu },
      { no: 3, name: "screenshare", kind: "message", T: () => hu }
    ]);
  }
}
const Rk = new Ck();
class wk extends v {
  constructor() {
    super("socket.preset.PresetUpdates", [
      { no: 1, name: "polls", kind: "message", T: () => hk },
      { no: 2, name: "plugins", kind: "message", T: () => gk },
      { no: 3, name: "chat", kind: "message", T: () => Tk },
      {
        no: 4,
        name: "accept_waiting_requests",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "can_accept_production_requests",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "can_edit_display_name",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "can_record",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "can_livestream",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "can_spotlight",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "disable_participant_audio",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "disable_participant_screensharing",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 12,
        name: "disable_participant_video",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: "kick_participant",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "pin_participant",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "transcription_enabled",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 16, name: "waiting_room_type", kind: "enum", opt: !0, T: () => ["socket.preset.WaitingRoomType", Lu, "WAITING_ROOM_TYPE_"] },
      {
        no: 17,
        name: "is_recorder",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 18, name: "recorder_type", kind: "enum", opt: !0, T: () => ["socket.room.RecorderType", Nu, "RECORDER_TYPE_"] },
      {
        no: 19,
        name: "hidden_participant",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 20,
        name: "show_participant_list",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 21,
        name: "can_change_participant_permissions",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 22, name: "connected_meetings", kind: "message", T: () => _k },
      { no: 23, name: "media", kind: "message", T: () => Rk }
    ]);
  }
}
const Mh = new wk();
class bk extends v {
  constructor() {
    super("socket.preset.ReadPeersPresetRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const kk = new bk();
class Ik extends v {
  constructor() {
    super("socket.preset.PeerPreset", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "preset",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const Ak = new Ik();
class Mk extends v {
  constructor() {
    super("socket.preset.ReadPeersPresetResponse", [
      { no: 1, name: "peer_presets", kind: "message", repeat: 1, T: () => Ak }
    ]);
  }
}
const Dk = new Mk();
class Ok extends v {
  constructor() {
    super("socket.preset.UpdatePeerPreset", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
}
const Tf = new Ok();
class Nk extends v {
  constructor() {
    super("socket.preset.UpdatePeersPresetRequest", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Tf }
    ]);
  }
}
const Vk = new Nk();
class Lk extends v {
  constructor() {
    super("socket.preset.UpdatePeersPresetResponse", [
      { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Tf }
    ]);
  }
}
const tg = new Lk();
class xk extends v {
  constructor() {
    super("socket.preset.PeerUserIDMap", [
      {
        no: 1,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Uk = new xk();
class $k extends v {
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetRequest", [
      { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Uk },
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
}
new $k();
class Fk extends v {
  constructor() {
    super("socket.preset.BulkUpdatePeerPresetResponse", [
      { no: 2, name: "patch", kind: "message", T: () => Mh }
    ]);
  }
}
new Fk();
class Hk extends v {
  constructor() {
    super("socket.chat.ChatMessage", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "is_edited",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "created_at",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 12,
        name: "created_at_ms",
        kind: "scalar",
        opt: !0,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 13,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "channel_index",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ya = new Hk();
class Bk extends v {
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const qk = new Bk();
class jk extends v {
  constructor() {
    super("socket.chat.GetPaginatedChatMessageRoomResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => ya },
      {
        no: 2,
        name: "next",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const Gk = new jk();
class Wk extends v {
  constructor() {
    super("socket.chat.GetChatMessagesResponse", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => ya }
    ]);
  }
}
const Ef = new Wk();
class Jk extends v {
  constructor() {
    super("socket.chat.SendChatMessageToRoomRequest", [
      {
        no: 1,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Kk = new Jk();
class zk extends v {
  constructor() {
    super("socket.chat.SendChatMessageToRoomResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
}
const pu = new zk();
class Yk extends v {
  constructor() {
    super("socket.chat.SendChatMessageToPeersRequest", [
      {
        no: 1,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const Qk = new Yk();
class Xk extends v {
  constructor() {
    super("socket.chat.SendChatMessageToPeersResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
}
const gu = new Xk();
class Zk extends v {
  constructor() {
    super("socket.chat.SendChatMessageToChannelRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const eI = new Zk();
class tI extends v {
  constructor() {
    super("socket.chat.SendChatMessageToChannelResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
}
new tI();
class sI extends v {
  constructor() {
    super("socket.chat.EditChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload_type",
        kind: "scalar",
        opt: !0,
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "pinned",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const rI = new sI();
class iI extends v {
  constructor() {
    super("socket.chat.PinChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const aI = new iI();
class nI extends v {
  constructor() {
    super("socket.chat.PinChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pinned",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const ad = new nI();
class oI extends v {
  constructor() {
    super("socket.chat.EditChatMessageResponse", [
      { no: 1, name: "message", kind: "message", T: () => ya }
    ]);
  }
}
const nd = new oI();
class cI extends v {
  constructor() {
    super("socket.chat.DeleteChatMessageRequest", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const dI = new cI();
class lI extends v {
  constructor() {
    super("socket.chat.DeleteChatMessageResponse", [
      {
        no: 1,
        name: "chat_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const od = new lI();
class uI extends v {
  constructor() {
    super("socket.chat.SearchChatMessagesRequest", [
      {
        no: 1,
        name: "time_stamp",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      {
        no: 2,
        name: "size",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "reversed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "channel_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "search_term",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const hI = new uI();
class pI extends v {
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadRequest", [
      {
        no: 1,
        name: "channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "channel_index",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const gI = new pI();
class mI extends v {
  constructor() {
    super("socket.chat.MarkChannelIndexAsReadResponse", [
      {
        no: 1,
        name: "channel_index",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const fI = new mI();
class SI extends v {
  constructor() {
    super("socket.chat.CreateChatChannelRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const vI = new SI();
class yI extends v {
  constructor() {
    super("socket.chat.UpdateChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "display_picture_url",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "visibility",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "is_direct_message",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const TI = new yI();
class EI extends v {
  constructor() {
    super("socket.chat.CreateChatChannelResponse", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
new EI();
class _I extends v {
  constructor() {
    super("socket.chat.GetChatChannelRequest", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const PI = new _I();
class CI extends v {
  constructor() {
    super("socket.chat.LatestMessageAndUnreadCount", [
      { no: 1, name: "message", kind: "message", T: () => ya },
      {
        no: 2,
        name: "unread_count",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
}
const RI = new CI();
class wI extends v {
  constructor() {
    super("socket.chat.ChatChannel", [
      {
        no: 1,
        name: "chat_channel_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "display_picture_url",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "visibility",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "is_direct_message",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 6, name: "latest_message_and_unread_count", kind: "message", T: () => RI },
      {
        no: 7,
        name: "target_user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const bI = new wI();
class kI extends v {
  constructor() {
    super("socket.chat.GetChatChannelResponse", [
      { no: 1, name: "chat_channels", kind: "message", repeat: 1, T: () => bI }
    ]);
  }
}
const Hs = new kI();
class II extends v {
  constructor() {
    super("socket.chat.ChannelMember", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "picture",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "custom_participant_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const AI = new II();
class MI extends v {
  constructor() {
    super("socket.chat.GetChatChannelMembersResponse", [
      { no: 1, name: "channel_members", kind: "message", repeat: 1, T: () => AI }
    ]);
  }
}
const DI = new MI();
class OI extends v {
  constructor() {
    super("socket.plugin.AddPluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const NI = new OI();
class VI extends v {
  constructor() {
    super("socket.plugin.RemovePluginRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "staggered",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const LI = new VI();
class xI extends v {
  constructor() {
    super("socket.plugin.EnablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const UI = new xI();
class $I extends v {
  constructor() {
    super("socket.plugin.DisablePluginForRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const FI = new $I();
class HI extends v {
  constructor() {
    super("socket.plugin.EnablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const BI = new HI();
class qI extends v {
  constructor() {
    super("socket.plugin.DisablePluginForPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const jI = new qI();
class GI extends v {
  constructor() {
    super("socket.plugin.PluginEventToRoomRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const WI = new GI();
class JI extends v {
  constructor() {
    super("socket.plugin.PluginEventToPeersRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const KI = new JI();
class zI extends v {
  constructor() {
    super("socket.plugin.StoreKeys", [
      {
        no: 1,
        name: "store_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "payload",
        kind: "scalar",
        opt: !0,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const Dh = new zI();
class YI extends v {
  constructor() {
    super("socket.plugin.PluginStoreInsertKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "insert_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
}
const sg = new YI();
class QI extends v {
  constructor() {
    super("socket.plugin.PluginStoreGetKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "get_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
}
const XI = new QI();
class ZI extends v {
  constructor() {
    super("socket.plugin.PluginStoreDeleteKeysRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "delete_keys", kind: "message", repeat: 1, T: () => Dh }
    ]);
  }
}
const eA = new ZI();
class tA extends v {
  constructor() {
    super("socket.plugin.PluginStoreDeleteRequest", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const sA = new tA();
class rA extends v {
  constructor() {
    super("socket.plugin.EnablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "enabled_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const xu = new rA();
class iA extends v {
  constructor() {
    super("socket.plugin.EnablePluginsResponse", [
      { no: 1, name: "plugins", kind: "message", repeat: 1, T: () => xu }
    ]);
  }
}
const aA = new iA();
class nA extends v {
  constructor() {
    super("socket.plugin.DisablePluginResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "disabled_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const rg = new nA();
class oA extends v {
  constructor() {
    super("socket.plugin.PluginStoreItem", [
      {
        no: 1,
        name: "timestamp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "store_key",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const cA = new oA();
class dA extends v {
  constructor() {
    super("socket.plugin.PluginStoreResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "store_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "store_items", kind: "message", repeat: 1, T: () => cA }
    ]);
  }
}
const ig = new dA();
class lA extends v {
  constructor() {
    super("socket.plugin.PluginEventResponse", [
      {
        no: 1,
        name: "plugin_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "plugin_data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const ag = new lA();
class uA extends v {
  constructor() {
    super("socket.livestreaming.LiveStreamingEvent", [
      {
        no: 1,
        name: "livestream_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "meeting_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "playback_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "org_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "room_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "room_uuid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "manual_ingest",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const ng = new uA();
class hA extends v {
  constructor() {
    super("socket.livestreaming.GetStagePeersResponse", [
      {
        no: 1,
        name: "stage_peers",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const og = new hA();
class pA extends v {
  constructor() {
    super("socket.livestreaming.StageRequest", [
      {
        no: 1,
        name: "display_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const gA = new pA();
class mA extends v {
  constructor() {
    super("socket.livestreaming.GetStageRequestsResponse", [
      { no: 1, name: "stage_requests", kind: "message", repeat: 1, T: () => gA }
    ]);
  }
}
const mu = new mA();
class fA extends v {
  constructor() {
    super("socket.livestreaming.GrantStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const SA = new fA();
class vA extends v {
  constructor() {
    super("socket.livestreaming.DenyStageAccessRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const yA = new vA();
class TA extends v {
  constructor() {
    super("socket.livestreaming.LeaveStageRequest", [
      {
        no: 1,
        name: "user_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const cg = new TA();
class EA extends v {
  constructor() {
    super("socket.polls.Poll", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "created_by",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "created_by_user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "question",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "options", kind: "message", repeat: 1, T: () => PA },
      {
        no: 6,
        name: "hide_votes",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "anonymous",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "votes",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const _f = new EA();
class _A extends v {
  constructor() {
    super("socket.polls.PollOption", [
      {
        no: 1,
        name: "text",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "count",
        kind: "scalar",
        opt: !0,
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      },
      { no: 3, name: "votes", kind: "message", repeat: 1, T: () => RA }
    ]);
  }
}
const PA = new _A();
class CA extends v {
  constructor() {
    super("socket.polls.PollVote", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const RA = new CA();
class wA extends v {
  constructor() {
    super("socket.polls.NewPollRequest", [
      {
        no: 1,
        name: "question",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "options",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "anonymous",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "hide_votes",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 5,
        name: "created_by",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "created_by_user_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
}
const bA = new wA();
class kA extends v {
  constructor() {
    super("socket.polls.VotePollRequest", [
      {
        no: 1,
        name: "poll_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "index",
        kind: "scalar",
        T: 4,
        L: 2
        /*LongType.NUMBER*/
      }
    ]);
  }
}
const IA = new kA();
class AA extends v {
  constructor() {
    super("socket.polls.UpdatePollResponse", [
      { no: 1, name: "poll", kind: "message", T: () => _f }
    ]);
  }
}
const fu = new AA();
class MA extends v {
  constructor() {
    super("socket.polls.GetPollsResponse", [
      { no: 1, name: "polls", kind: "message", repeat: 1, T: () => _f }
    ]);
  }
}
const DA = new MA();
class OA extends v {
  constructor() {
    super("socket.recording.RecordingEvent", [
      {
        no: 1,
        name: "recording_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "err_message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", la] }
    ]);
  }
}
const dg = new OA();
class NA extends v {
  constructor() {
    super("google.protobuf.Timestamp", [
      {
        no: 1,
        name: "seconds",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "nanos",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  /**
   * Creates a new `Timestamp` for the current time.
   */
  now() {
    const t = this.create(), e = Date.now();
    return t.seconds = po.from(Math.floor(e / 1e3)).toBigInt(), t.nanos = e % 1e3 * 1e6, t;
  }
  /**
   * Converts a `Timestamp` to a JavaScript Date.
   */
  toDate(t) {
    return new Date(po.from(t.seconds).toNumber() * 1e3 + Math.ceil(t.nanos / 1e6));
  }
  /**
   * Converts a JavaScript Date to a `Timestamp`.
   */
  fromDate(t) {
    const e = this.create(), r = t.getTime();
    return e.seconds = po.from(Math.floor(r / 1e3)).toBigInt(), e.nanos = r % 1e3 * 1e6, e;
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonWrite(t, e) {
    let r = po.from(t.seconds).toNumber() * 1e3;
    if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (t.nanos < 0)
      throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
    let i = "Z";
    if (t.nanos > 0) {
      let n = (t.nanos + 1e9).toString().substring(1);
      n.substring(3) === "000000" ? i = "." + n.substring(0, 3) + "Z" : n.substring(6) === "000" ? i = "." + n.substring(0, 6) + "Z" : i = "." + n + "Z";
    }
    return new Date(r).toISOString().replace(".000Z", i);
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonRead(t, e, r) {
    if (typeof t != "string")
      throw new Error("Unable to parse Timestamp from JSON " + sv(t) + ".");
    let i = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!i)
      throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
    let n = Date.parse(i[1] + "-" + i[2] + "-" + i[3] + "T" + i[4] + ":" + i[5] + ":" + i[6] + (i[8] ? i[8] : "Z"));
    if (Number.isNaN(n))
      throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
    if (n < Date.parse("0001-01-01T00:00:00Z") || n > Date.parse("9999-12-31T23:59:59Z"))
      throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    return r || (r = this.create()), r.seconds = po.from(n / 1e3).toBigInt(), r.nanos = 0, i[7] && (r.nanos = parseInt("1" + i[7] + "0".repeat(9 - i[7].length)) - 1e9), r;
  }
}
new NA();
class VA extends v {
  constructor() {
    super("common.BaseHubMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "peer_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "room_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "payload",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 7,
        name: "error",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "sid",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "room_object_id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "preset",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "use_start_session",
        kind: "scalar",
        opt: !0,
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
}
const Uu = new VA();
class LA extends v {
  constructor() {
    super("common.BulkedHubMessage", [
      { no: 1, name: "messages", kind: "message", repeat: 1, T: () => Uu }
    ]);
  }
}
new LA();
class xA extends v {
  constructor() {
    super("common.CFWorkersResponse", [
      { no: 1, name: "responses", kind: "message", repeat: 1, T: () => Uu },
      { no: 2, name: "broadcast_responses", kind: "message", repeat: 1, T: () => Uu }
    ]);
  }
}
new xA();
const UA = 0, $A = 1, FA = 2, HA = 3, BA = 4, qA = 5, jA = {
  getPeerInfo: 0,
  updatePeerInfo: 1,
  getRoomPeersInfo: 2,
  joinRoom: 3,
  leaveRoom: 4,
  getRoomInfo: 5,
  updateRoomInfo: 6,
  closeRoom: 7,
  startedLivestream: 8,
  stoppedLivestream: 9,
  erroredLivestream: 10,
  getStagePeers: 11,
  getStageRequests: 12,
  requestStageAccess: 13,
  cancelStageRequest: 14,
  grantStageAccess: 15,
  denyStageAccess: 16,
  roomPeerCount: 17,
  joinStage: 18,
  leaveStage: 19,
  // getConnectedRoomsDump returns entire dump for a breakout rooms meeting
  // This details which peer is in which meeting currently, and which is the parent meeting
  getConnectedRoomsDump: 20,
  // createConnectedRooms to create breakout rooms
  createConnectedRooms: 21,
  // deleteConnectedRooms to delete breakout rooms
  deleteConnectedRooms: 22,
  // move peers between breakout rooms
  movePeers: 23,
  // transfer peer to new room
  transferPeer: 24,
  // message sent by socket service to inform client of a participant joining a breakout room
  movedPeer: 25,
  // message sent by socket service to inform client of updates in connected rooms
  connectedRoomsUpdated: 26,
  // message sent by socket service to inform client of deletion in connected rooms
  connectedRoomsDeleted: 27,
  // get all participants that have been added to the meeting irrespective of their live status
  getAllAddedParticipants: 28,
  // broadcast api
  broadcastMessage: 29,
  kick: 30,
  kickAll: 31,
  transcript: 32,
  // waitlist events
  getWaitingRoomRequests: 33,
  acceptWaitingRoomRequests: 34,
  waitingRoomRequestAccepted: 35,
  denyWaitingRoomRequests: 36,
  waitingRoomRequestDenied: 37,
  peerStageStatusUpdate: 38,
  broadcastToEntity: 39,
  recordingStarted: 40,
  recordingStopped: 41,
  recordingPaused: 42,
  getRoomStageState: 43,
  livestreamingInvoked: 44
}, GA = {
  getMessages: 0,
  sendMessageToRoom: 1,
  sendMessageToPeers: 2,
  editMessage: 3,
  deleteMessage: 4,
  getPaginatedMessages: 5,
  sendMessageToChannel: 6,
  searchChannelMessages: 7,
  getAllChatChannels: 8,
  markChannelIndexAsRead: 9,
  pinMessage: 10
}, WA = {
  getPlugins: 0,
  addPlugin: 1,
  enablePluginForRoom: 2,
  disablePluginForPeers: 3,
  enablePluginForPeers: 4,
  disablePluginForRoom: 5,
  removePlugin: 6,
  customPluginEventToRoom: 7,
  customPluginEventToPeers: 8,
  storeInsertKeys: 9,
  storeGetKeys: 10,
  storeDeleteKeys: 11,
  storeDelete: 12
}, JA = {
  createPoll: 0,
  getPolls: 1,
  votePoll: 2,
  updatePoll: 3
}, Pf = {
  unknown: 0,
  createWebRTCTransport: 1,
  produce: 2,
  consume: 3,
  toggleProducer: 4,
  toggleConsumer: 5,
  closeProducer: 6,
  closeConsumer: 7,
  updateConsumersSimulcastConfig: 8,
  // adding some buffers for new media events.
  joinRoom: 16,
  leaveRoom: 17,
  selectedPeer: 18,
  globalPinPeer: 19,
  selfJoinComplete: 20,
  // some additional buffer for broadcast events.
  peerJoinedBroadcast: 25,
  peerLeaveBroadcast: 26,
  peerProducerCreateBroadcast: 27,
  peerProducerToggleBroadcast: 28,
  peerProducerCloseBroadcast: 29,
  globalPeerPinBroadcast: 30,
  recordingStartedBroadcast: 31,
  recordingStoppedBroadcast: 32,
  peerDisplayNameEditBroadcast: 33,
  mediaRoomTerminationBroadcastResponse: 36,
  selectedPeerDiff: 40,
  renegotiateSessionDescription: 50,
  errorResponse: 60,
  kickPeer: 90,
  kickAll: 91,
  changeDisplayName: 92,
  hostControlPeer: 93,
  hostControlAllPeers: 94,
  // only for CF
  audioActivity: 100
}, KA = {
  createChatChannel: 0,
  getChatChannel: 1,
  deprecatedGetAllChatChannels: 2,
  getChannelMembers: 3,
  updateChatChannel: 4
}, zA = {
  getUserPresets: 0,
  updateUserPreset: 1
};
function Kn(s, t) {
  return Object.keys(t).reduce((e, r) => (e[r] = (s << 16) + t[r], e), {});
}
function Cf(s, t) {
  return Object.keys(s).reduce((e, r) => (e[r] = t | s[r], e), {});
}
const x = Kn(UA, jA), Re = Kn($A, GA), W = Kn(
  FA,
  WA
), qs = Kn(HA, JA), pi = Kn(
  BA,
  KA
), is = Cf(Pf, 16777216), Ts = Cf(Pf, 50331648), fd = Kn(
  qA,
  zA
);
var YA = Object.defineProperty, QA = Object.getOwnPropertyDescriptor, Oh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? QA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && YA(t, e, i), i;
}, Mr, qa, bg;
const $u = (bg = class {
  constructor(s, t) {
    g(this, Mr, void 0);
    g(this, qa, void 0);
    m(this, Mr, t), m(this, qa, s);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, qa).getValue("telemetry");
  }
  /**
   * @private access
   * Not for external use
   */
  get logger() {
    return a(this, qa).getValue("logger");
  }
  createChannel(s, t, e, r = "public", i = !1) {
    return u(this, null, function* () {
      const n = {
        displayName: s,
        targetUserIds: t,
        displayPictureUrl: e,
        visibility: r,
        isDirectMessage: i
      };
      i && (n.visibility = "private");
      const o = yield a(this, Mr).sendMessagePromise(
        pi.createChatChannel,
        vI.toBinary(n)
      ), c = Hs.fromBinary(
        o.payload
      ).chatChannels;
      return $u.formatChannel(c[0]);
    });
  }
  updateChannel(s, t) {
    return u(this, null, function* () {
      const e = yield a(this, Mr).sendMessagePromise(
        pi.updateChatChannel,
        TI.toBinary({
          chatChannelId: s,
          targetUserIds: t.memberIds,
          displayName: t.displayName,
          displayPictureUrl: t.displayPictureUrl,
          visibility: t.visibility
        })
      ), r = Hs.fromBinary(
        e.payload
      ).chatChannels;
      return $u.formatChannel(r[0]);
    });
  }
  static formatChannel(s) {
    var r;
    const { latestMessageAndUnreadCount: t } = s, e = B(D({}, s), {
      id: s.chatChannelId,
      memberIds: s.targetUserIds,
      unreadCount: (r = t == null ? void 0 : t.unreadCount) != null ? r : 0
    });
    return t != null && t.message && (e.latestMessage = Es.formatSocketServiceMessage(
      t.message
    )), delete e.chatChannelId, delete e.targetUserIds, delete e.latestMessageAndUnreadCount, e;
  }
  getChannelMembers(s) {
    return u(this, null, function* () {
      try {
        const t = yield a(this, Mr).sendMessagePromise(
          pi.getChannelMembers,
          PI.toBinary({ chatChannelId: s })
        );
        return DI.fromBinary(t.payload).channelMembers.map((i) => {
          var n = i, { id: e } = n, r = ho(n, ["id"]);
          return B(D({}, r), { userId: e });
        });
      } catch (t) {
        return [];
      }
    });
  }
  on(s, t) {
    let e, r;
    switch (s) {
      case pi.createChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
      case pi.updateChatChannel: {
        e = Hs.fromBinary.bind(
          Hs
        ), r = Hs.create();
        break;
      }
    }
    if (!e) {
      this.logger.warn(
        `ChatChannelSocketHandler::Event ${s} is not recognized`
      );
      return;
    }
    a(this, Mr).on(s, ({ payload: i }) => {
      let n = r;
      try {
        n = e(i);
      } catch (o) {
        this.logger.error("ChatChannelSocketHandler::on::binary_decode_error", {
          error: o
        });
      }
      return t(n);
    });
  }
}, Mr = new WeakMap(), qa = new WeakMap(), bg);
let pa = $u;
Oh([
  E.trace("ChatChannelHandler.createChannel")
], pa.prototype, "createChannel", 1);
Oh([
  E.trace("ChatChannelHandler.updateChannel")
], pa.prototype, "updateChannel", 1);
Oh([
  E.trace("ChatChannelHandler.getChannelMembers")
], pa.prototype, "getChannelMembers", 1);
var XA = Object.defineProperty, ZA = Object.getOwnPropertyDescriptor, ws = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? ZA(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && XA(t, e, i), i;
}, _t = /* @__PURE__ */ ((s) => (s[s.TEXT = 0] = "TEXT", s[s.IMAGE = 1] = "IMAGE", s[s.FILE = 2] = "FILE", s[s.CUSTOM = 3] = "CUSTOM", s))(_t || {}), it, ja;
class as {
  constructor(t, e) {
    g(this, it, void 0);
    g(this, ja, void 0);
    m(this, it, e), m(this, ja, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ja).getValue("telemetry");
  }
  /**
   * @private access
   * Not available for external use
   */
  get logger() {
    return a(this, ja).getValue("logger");
  }
  getChatMessages() {
    return a(this, it).sendMessagePromise(Re.getMessages);
  }
  getChatMessagesPaginated(t, e, r, i = 0, n = "") {
    return u(this, null, function* () {
      const o = {
        timeStamp: t,
        size: e,
        from: i,
        reversed: r,
        channelId: n
      }, c = yield a(this, it).sendMessagePromise(
        Re.getPaginatedMessages,
        qk.toBinary(o)
      );
      return c.payload ? Gk.fromBinary(
        c.payload
      ) : {
        messages: [],
        next: !1
      };
    });
  }
  sendMessageToRoom(t, e) {
    const r = {
      payloadType: e,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToRoom,
      Kk.toBinary(r)
    );
  }
  sendMessageToPeers(t, e, r) {
    const i = {
      payloadType: e,
      peerIds: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToPeers,
      Qk.toBinary(i)
    );
  }
  sendMessageToChannel(t, e, r) {
    const i = {
      payloadType: e,
      channelId: r,
      payload: t
    };
    a(this, it).sendMessage(
      Re.sendMessageToChannel,
      eI.toBinary(i)
    );
  }
  sendMessage(t, e, r, i) {
    if (i && this.sendMessageToChannel(t, e, i), r && r.length > 0) {
      this.sendMessageToPeers(t, e, r);
      return;
    }
    this.sendMessageToRoom(t, e);
  }
  editMessage(t, e, r, i, n) {
    return u(this, null, function* () {
      const o = {
        chatId: t,
        payloadType: r,
        payload: e
      };
      i && (o.channelId = i), n !== void 0 && (o.pinned = n);
      const c = yield a(this, it).sendMessagePromise(
        Re.editMessage,
        rI.toBinary(o)
      );
      return nd.fromBinary(c.payload).message;
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t
      };
      e && (r.channelId = e);
      const i = yield a(this, it).sendMessagePromise(
        Re.deleteMessage,
        dI.toBinary(r)
      ), n = od.fromBinary(i.payload);
      return D({
        id: n.chatId
      }, n.channelId ? { channelId: n.channelId } : {});
    });
  }
  searchMessages(t, e) {
    return u(this, null, function* () {
      var i, n, o;
      const r = {
        searchTerm: t,
        timeStamp: (i = e.timestamp) != null ? i : Date.now(),
        size: (n = e.size) != null ? n : 75,
        from: 0,
        reversed: (o = e.reversed) != null ? o : !0
      };
      e.channelId && (r.channelId = e.channelId);
      try {
        const c = yield a(this, it).sendMessagePromise(
          Re.searchChannelMessages,
          hI.toBinary(r)
        );
        return Ef.fromBinary(c.payload).messages;
      } catch (c) {
        return [];
      }
    });
  }
  getAllChannels() {
    return u(this, null, function* () {
      try {
        const t = yield a(this, it).sendMessagePromise(
          Re.getAllChatChannels
        );
        return Hs.fromBinary(t.payload).chatChannels.map(pa.formatChannel);
      } catch (t) {
        return [];
      }
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      const r = yield a(this, it).sendMessagePromise(
        Re.markChannelIndexAsRead,
        gI.toBinary({
          channelId: t,
          userId: e.userId,
          channelIndex: e.channelIndex
        })
      );
      return fI.fromBinary(r.payload).channelIndex;
    });
  }
  setPinState(t, e) {
    return u(this, null, function* () {
      const r = {
        chatId: t.id,
        pinned: e,
        channelId: t.channelId
      }, i = yield a(this, it).sendMessagePromise(
        Re.pinMessage,
        aI.toBinary(r)
      );
      return ad.fromBinary(i.payload);
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case Re.sendMessageToRoom: {
        r = pu.fromBinary.bind(
          pu
        ), i = pu.create();
        break;
      }
      case Re.sendMessageToPeers: {
        r = gu.fromBinary.bind(
          gu
        ), i = gu.create();
        break;
      }
      case Re.editMessage: {
        r = nd.fromBinary.bind(
          nd
        ), i = nd.create();
        break;
      }
      case Re.pinMessage: {
        r = ad.fromBinary.bind(
          ad
        ), i = ad.create();
        break;
      }
      case Re.deleteMessage: {
        r = od.fromBinary.bind(
          od
        ), i = od.create();
        break;
      }
    }
    if (!r) {
      this.logger.warn(`ChatSocketHandler::Event ${t} is not recognized`);
      return;
    }
    a(this, it).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
}
it = new WeakMap(), ja = new WeakMap();
ws([
  E.trace("SocketService.getChatMessages")
], as.prototype, "getChatMessages", 1);
ws([
  E.trace("SocketService.getChatMessagesPaginated")
], as.prototype, "getChatMessagesPaginated", 1);
ws([
  E.trace("SocketService.sendMessageToRoom")
], as.prototype, "sendMessageToRoom", 1);
ws([
  E.trace("SocketService.sendMessageToPeers")
], as.prototype, "sendMessageToPeers", 1);
ws([
  E.trace("SocketService.sendMessageToChannel")
], as.prototype, "sendMessageToChannel", 1);
ws([
  E.trace("SocketService.sendMessage")
], as.prototype, "sendMessage", 1);
ws([
  E.trace("SocketService.editMessage")
], as.prototype, "editMessage", 1);
ws([
  E.trace("SocketService.deleteMessage")
], as.prototype, "deleteMessage", 1);
ws([
  E.trace("SocketService.searchMessages")
], as.prototype, "searchMessages", 1);
ws([
  E.trace("SocketService.getAllChannels")
], as.prototype, "getAllChannels", 1);
ws([
  E.trace("SocketService.markLastReadMessage")
], as.prototype, "markLastReadMessage", 1);
function eM(s) {
  return s.replace(
    /([-_]\w)/g,
    (t) => t[1].toUpperCase()
  );
}
function _s(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => _s(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = Jg(e) ? e : eM(e);
    t[r] = _s(s[e]);
  }), t;
}
function tM(s) {
  return s.replace(
    /[A-Z]/g,
    (t) => `_${t.toLowerCase()}`
  );
}
function Rf(s) {
  if (!s || typeof s != "object")
    return s;
  if (Array.isArray(s))
    return s.map(
      (e) => Rf(e)
    );
  const t = {};
  return Object.keys(s).forEach((e) => {
    const r = Jg(e) ? e : tM(e);
    t[r] = s[e];
  }), t;
}
function Vd(s, t = {}) {
  return s == null ? {} : (Object.getOwnPropertyNames(s).forEach((e) => {
    if (typeof s[e] != "function") {
      if (typeof s[e] == "object") {
        Vd(s[e], t[e] = {});
        return;
      }
      t[e] = s[e];
    }
  }), t);
}
class lg {
  constructor(t) {
    h(this, "defaults");
    this.defaults = {
      baseURL: t.baseURL,
      headers: { common: {} },
      timeout: t.timeout,
      retry: t.retry,
      retryDelay: t.retryDelay
    };
  }
  buildURL(t, e) {
    const { baseURL: r } = this.defaults, i = t.startsWith("http") ? t : `${r}${t.startsWith("/") ? t : `/${t}`}`;
    if (e) {
      const n = new URLSearchParams();
      return Object.entries(e).forEach(([o, c]) => {
        n.append(o, c);
      }), `${i}${i.includes("?") ? "&" : "?"}${n.toString()}`;
    }
    return i;
  }
  request(t) {
    return u(this, null, function* () {
      var f;
      const e = ((f = t.method) == null ? void 0 : f.toUpperCase()) || "GET", r = this.buildURL(t.url || "", t.params), i = D(D({}, this.defaults.headers.common), t.headers);
      e !== "GET" && e !== "HEAD" && t.data && !i["Content-Type"] && (i["Content-Type"] = "application/json");
      const o = i["Content-Type"] === "application/json" ? JSON.stringify(t.data) : t.data, c = {
        method: e,
        headers: i,
        body: e !== "GET" && e !== "HEAD" && t.data ? o : void 0
      }, d = t.timeout || this.defaults.timeout, l = t.retry !== void 0 ? t.retry : this.defaults.retry, p = t.retryDelay || this.defaults.retryDelay;
      try {
        const S = new AbortController(), T = setTimeout(() => S.abort(), d);
        c.signal = S.signal;
        const _ = yield fetch(r, c);
        clearTimeout(T);
        let P = null;
        const w = _.headers.get("content-type");
        w && w.includes("application/json") ? P = yield _.json() : P = yield _.text();
        const A = {};
        _.headers.forEach((H, $) => {
          A[$] = H;
        });
        const N = {
          data: P,
          status: _.status,
          statusText: _.statusText,
          headers: A,
          config: t
        };
        if (!_.ok)
          throw N;
        return N;
      } catch (S) {
        if (S instanceof Error && l > 0)
          return yield new Promise((T) => setTimeout(T, p)), this.defaults.baseURL === "https://api.dyte.io" ? this.defaults.baseURL = "https://api.cluster.dyte.in" : this.defaults.baseURL === "https://api.cluster.dyte.in" && (this.defaults.baseURL = "https://api.dyte.io"), this.request(B(D({}, t), {
            retry: l - 1
          }));
        throw S;
      }
    });
  }
  get(r) {
    return u(this, arguments, function* (t, e = {}) {
      return this.request(B(D({}, e), {
        method: "GET",
        url: t
      }));
    });
  }
  post(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "POST",
        url: t,
        data: e
      }));
    });
  }
  put(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.request(B(D({}, r), {
        method: "PUT",
        url: t,
        data: e
      }));
    });
  }
}
const sM = 3, rM = 30, iM = 8e3;
class aM {
  constructor(t, e) {
    h(this, "ipInfo");
    h(this, "fetchClient");
    h(this, "requests");
    h(this, "roomName");
    h(this, "roomUUID");
    h(this, "authToken");
    h(this, "organizationId");
    h(this, "iceServers");
    h(this, "pluginInformation");
    h(this, "userDetails");
    h(this, "roomDetails");
    h(this, "context");
    this.context = t;
    const {
      timeout: r = iM,
      retry: i = sM,
      retryDelay: n = rM,
      baseURL: o = "https://api.dyte.io",
      authToken: c,
      cachedUserDetails: d
    } = e || {};
    this.iceServers = d == null ? void 0 : d.iceServers, this.pluginInformation = d == null ? void 0 : d.pluginInformation, this.userDetails = d == null ? void 0 : d.userDetails, this.roomDetails = d == null ? void 0 : d.roomDetails, this.requests = new lg({
      baseURL: o,
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.fetchClient = new lg({
      baseURL: "",
      // Empty baseURL for direct fetch calls
      timeout: r,
      retry: i,
      retryDelay: n,
      responseType: "json"
    }), this.setAuthToken(c, { bearer: !0 });
    const l = this.requests.request.bind(this.requests);
    this.requests.request = (p) => u(this, null, function* () {
      var S, T, _, P, w;
      const f = t.getValue("telemetry");
      try {
        f.injectContext(this.requests.defaults.headers.common);
        const A = yield l(p);
        return p.url !== f.logsEndpoint && this.logger.debug("xhr::fetch", {
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: p.baseURL || this.requests.defaults.baseURL,
            url: p.url,
            method: p.method
          }
        }), A;
      } catch (A) {
        throw A ? (((S = A.config) == null ? void 0 : S.url) !== f.logsEndpoint && this.logger.error("xhr::fetch", {
          error: A,
          networkCall: {
            status: A.status,
            statusText: A.statusText,
            baseURL: ((T = A.config) == null ? void 0 : T.baseURL) || this.requests.defaults.baseURL,
            url: (_ = A.config) == null ? void 0 : _.url,
            retries: (P = A.config) == null ? void 0 : P.retry,
            method: (w = A.config) == null ? void 0 : w.method,
            isOnline: navigator.onLine ? "online" : "offline"
          }
        }), new R(A.message || "Network request failed", "0011")) : new R("Unknown network error occurred", "0011");
      }
    });
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  get logger() {
    return this.context.getValue("logger");
  }
  setAuthToken(t, e) {
    const { bearer: r } = e || {};
    this.authToken = t, this.requests.defaults.headers.common.Authorization = r ? `Bearer ${t}` : t;
  }
  setHeader(t, e) {
    this.requests.defaults.headers.common[t] = e;
  }
  setRoomName(t) {
    this.roomName = t;
  }
  setRoomUUID(t) {
    this.roomUUID = t;
  }
  setOrganizationId(t) {
    this.organizationId = t;
  }
}
var nM = Object.defineProperty, oM = Object.getOwnPropertyDescriptor, ns = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? oM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && nM(t, e, i), i;
};
class jt extends aM {
  constructor(e, r) {
    super(e, r);
    /**
     * @access private
     * Not for external use
     */
    h(this, "telemetry");
    this.telemetry = e.getValue("telemetry"), this.setHeader("x-dyte-web-core-version", e.getValue("sdkVersion"));
  }
  getIPDetails() {
    return u(this, null, function* () {
      var r;
      const { peerId: e } = this;
      try {
        const i = yield yh.getIPDetails({
          peerId: e,
          apiHostnames: cf(this.context),
          logger: ef
        });
        if (this.logger.log("ipInfo", { ipInfo: i }), ((r = i == null ? void 0 : i.loc) == null ? void 0 : r.length) > 5)
          return i;
        throw Error("Insufficient data");
      } catch (i) {
        this.logger.warn(
          "ApiClient.getRoomNodeLinkAndTitleV1 Failed to get ip details",
          { error: { name: i.name, message: i.message } }
        );
        return;
      }
    });
  }
  getICEServers() {
    return u(this, null, function* () {
      if (this.iceServers)
        return this.iceServers;
      const { success: e, iceServers: r } = (yield this.requests.get("/iceservers")).data;
      if (e)
        return (r == null ? void 0 : r.length) > 0 && (this.iceServers = r), r;
    });
  }
  getPlugins() {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f;
      if (this.pluginInformation)
        return this.pluginInformation;
      const { plugins: e } = (yield this.requests.get("/v2/plugins/user")).data.data, r = ((o = (n = this.context.getValue("flagsmith").getValue(X.V1_PLUGINS)) == null ? void 0 : n.toString()) == null ? void 0 : o.split(",")) || [], i = e.reduce(
        (S, T) => (S[r.includes(T.id) ? "v1" : "v2"].push(B(D({}, T), { name: T.name.replace("v2", "") })), S),
        { v1: [], v2: [] }
      );
      return (l = (d = (c = this.context.getValue("modules")) == null ? void 0 : c.devTools) == null ? void 0 : d.plugins) != null && l.length && ((f = (p = this.context.getValue("modules")) == null ? void 0 : p.devTools) == null || f.plugins.forEach((S) => {
        var _, P, w;
        const T = B(D({}, mo), {
          tags: [...mo.tags],
          baseUrl: `http://localhost:${S.port}`,
          name: S.name,
          picture: (_ = S.picture) != null ? _ : mo.picture,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          id: S.id,
          organizationId: this.organizationId,
          description: (P = S.description) != null ? P : mo.description,
          staggered: (w = S.staggered) != null ? w : mo.staggered
        });
        i.v2.push(T);
      })), i.v2;
    });
  }
  getPluginDetails(e) {
    return u(this, null, function* () {
      const { plugin: r } = (yield this.requests.get(`/v2/plugins/view/${e}`)).data.data;
      return r;
    });
  }
  getPluginConfig(e) {
    return u(this, null, function* () {
      return (yield this.fetchClient.get(`${e}/dyte-config.json`)).data;
    });
  }
  authorizePlugin(e) {
    return u(this, null, function* () {
      const r = {
        peerId: this.peerId
      }, { token: i } = (yield this.requests.post(`/v2/plugins/authorize/${e}`, r)).data.data;
      return i;
    });
  }
  getPresignedUrls(e, r) {
    return u(this, null, function* () {
      const i = Gn(this.context, "chat_upload_expiry"), n = {
        roomUUID: this.roomUUID,
        filename: e,
        expiry: typeof i == "number" ? i : void 0
      };
      this.context.getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK) && (n.viewType = r);
      const { getLocation: o, putLocation: c } = (yield this.requests.post("/v1/meetings/genPreSignedUploadUrl", n)).data.data;
      return {
        getLocation: o,
        putLocation: c
      };
    });
  }
  uploadFile(e, r) {
    return u(this, null, function* () {
      if (navigator.isReactNative && "uri" in e)
        try {
          yield fetch(r, {
            method: "PUT",
            headers: {
              "Content-Type": "application/octet-stream"
            },
            body: {
              uri: e.uri,
              name: e.name
            }
          });
        } catch (i) {
          this.logger.error(`sendFileMessage::${i}`);
        }
      else
        yield this.fetchClient.put(r, e, {
          headers: {
            "Content-Type": e.type
          }
        });
    });
  }
  // eslint-disable-next-line class-methods-use-this
  startLivestreaming(r) {
    return u(this, arguments, function* ({
      manualIngestion: e
    }) {
      const i = _s(
        yield this.requests.post(
          `/v2/meetings/${this.context.getValue("meetingId")}/livestreams`,
          {
            manual_ingest: !!e
          }
        )
      ).data.data;
      return {
        playbackUrl: i.playbackUrl,
        status: i.status,
        manualIngest: i.manualIngest,
        ingestionCredentials: i.streamKey ? {
          ingestionServer: i.ingestServer,
          streamKey: i.streamKey
        } : null
      };
    });
  }
  // eslint-disable-next-line class-methods-use-this
  stopLivestreaming() {
    return u(this, null, function* () {
      return this.requests.post(
        `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream/stop`
      );
    });
  }
  getActiveLivestream() {
    return u(this, null, function* () {
      const e = _s(
        (yield this.requests.get(
          `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream`
        )).data.data
      );
      return {
        playbackUrl: e.playbackUrl,
        status: e.status,
        manualIngest: e.manualIngest,
        ingestionCredentials: e.streamKey ? {
          ingestionServer: e.ingestServer,
          streamKey: e.streamKey
        } : null
      };
    });
  }
  getUserDetails() {
    return u(this, null, function* () {
      if (this.userDetails)
        return this.userDetails;
      const e = (yield this.requests.get("v2/internals/participant-details")).data.data;
      return _s(e);
    });
  }
  startRecording(e, r) {
    return u(this, null, function* () {
      return (yield this.requests.post("/v2/recordings", B(D({}, Rf(e)), {
        meeting_id: this.context.getValue("meetingId"),
        allow_multiple_recordings: !!r
      }))).data.data.id;
    });
  }
  updateRecording(e, r) {
    return u(this, null, function* () {
      return this.requests.put(`v2/recordings/${e}`, {
        action: r
      });
    });
  }
  getActiveRecording() {
    return u(this, null, function* () {
      const { status: e, id: r } = (yield this.requests.get(
        `v2/recordings/active-recording/${this.context.getValue("meetingId")}`
      )).data.data;
      return { status: e, id: r };
    });
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      const { transcript_download_url: e } = (yield this.requests.get(
        `v2/meetings/${this.context.getValue("meetingId")}/active-transcript`
      )).data.data;
      try {
        return { transcript: (yield this.fetchClient.get(e)).data };
      } catch (r) {
        throw new R("Cant fetch transcript s3 url", "1801");
      }
    });
  }
  getRoomNodeData() {
    return u(this, null, function* () {
      const e = yield this.getIPDetails();
      if (this.ipInfo = e, this.roomDetails)
        return this.roomDetails;
      const {
        roomNodeLink: r,
        title: i,
        useHiveMedia: n,
        sfu: o
      } = _s(
        (yield this.requests.post("v2/internals/rooms", {
          ip_information: e
        })).data.data
      );
      return {
        roomNodeUrl: r,
        meetingTitle: i,
        useHiveMedia: n != null ? n : !1,
        sfu: o
      };
    });
  }
}
ns([
  E.trace("APIClient.getIPDetails")
], jt.prototype, "getIPDetails", 1);
ns([
  E.trace("APIClient.getICEServers")
], jt.prototype, "getICEServers", 1);
ns([
  E.trace("APIClient.getPlugins")
], jt.prototype, "getPlugins", 1);
ns([
  E.trace("APIClient.startLivestreaming")
], jt.prototype, "startLivestreaming", 1);
ns([
  E.trace("APIClient.stopLivestreaming")
], jt.prototype, "stopLivestreaming", 1);
ns([
  E.trace("APIClient.getActiveLivestream")
], jt.prototype, "getActiveLivestream", 1);
ns([
  E.trace("APIClient.getUserDetails")
], jt.prototype, "getUserDetails", 1);
ns([
  E.trace("APIClient.startRecording")
], jt.prototype, "startRecording", 1);
ns([
  E.trace("APIClient.stopRecording")
], jt.prototype, "updateRecording", 1);
ns([
  E.trace("APIClient.getActiveRecording")
], jt.prototype, "getActiveRecording", 1);
ns([
  E.trace("APIClient.getActiveTranscript")
], jt.prototype, "getActiveTranscript", 1);
ns([
  E.trace("APIClient.getRoomNodeData")
], jt.prototype, "getRoomNodeData", 1);
let Fu;
function cM(s, t) {
  return Fu = new jt(s, t), Fu;
}
function lt() {
  return Fu;
}
function dM(s, t) {
  return `<blockquote>${t.replace(/<blockquote>[.\s\S]*<\/blockquote>\n\n/m, "")}</blockquote>

${s}`;
}
const zn = {
  maxInvocations: 5,
  period: 1
};
function Dt(s, t) {
  return function(e, r, i) {
    const n = i.value;
    let o = 0, c = Date.now();
    return i.value = function(...d) {
      const l = Date.now(), p = t ? this[t] : s;
      if (l - c > p.period * 1e3 && (c = l, o = 0), o >= p.maxInvocations)
        throw new R(`Method rate limit ${p.maxInvocations} invocations/${p.period}sec exceeded`, "0013");
      return o += 1, n.apply(this, d);
    }, i;
  };
}
var lM = Object.defineProperty, uM = Object.getOwnPropertyDescriptor, pt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? uM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && lM(t, e, i), i;
};
const hM = ["text", "image", "file", "custom", "poll"], Sd = { maxInvocations: 180, period: 60 };
var ee, vi, Fe, yi, Ti, jd, wf, Fo, Hu, kg;
let Qe = (kg = class extends qt {
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    // eslint-disable-next-line class-methods-use-this
    g(this, jd);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, Fo);
    /**
     * An array of chat messages.
     */
    h(this, "messages");
    /**
     * An Array of all available channels.
     */
    h(this, "channels", []);
    g(this, ee, void 0);
    g(this, vi, void 0);
    g(this, Fe, void 0);
    g(this, yi, void 0);
    g(this, Ti, void 0);
    h(this, "maxTextLimit", 2e3);
    m(this, Ti, t), m(this, Fe, e), m(this, yi, r), m(this, ee, i), m(this, vi, n), this.messages = [];
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ti).getValue("telemetry");
  }
  /**
  	Set the max character limit of a text message
  */
  setMaxTextLimit(t) {
    this.maxTextLimit = t;
  }
  sendMessageInternal(n, o, c) {
    return u(this, arguments, function* (t, e, r, i = {}) {
      switch (t.type) {
        case "text": {
          const d = i.replyTo && i.replyTo.type === "text" ? dM(t.message, i.replyTo.message) : t.message;
          yield this.sendTextMessageInternal(d, e, r);
          break;
        }
        case "image":
          yield this.sendImageMessageInternal(t.image, e, r);
          break;
        case "file":
          yield this.sendFileMessageInternal(t.file, e, r);
          break;
        default:
          this.logger.error("sendMessage::message_type_not_supported", {
            dyteChat: { messageType: t.type }
          });
          break;
      }
    });
  }
  sendTextMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (t.length > this.maxTextLimit)
        throw new R("Max character limit breached", "0503");
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.text))
          throw this.logger.error("sendTextMessage::private_chat_permission_denied"), new R("Could not send message to private chat.", "0501");
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.text))
        throw this.logger.error("sendTextMessage::public_chat_permission_denied"), new R("Could not send message to public chat.", "0501");
      if (!t)
        throw this.logger.error("sendTextMessage::message_can_not_be_empty"), new R("Message can not be empty.", "0502");
      if (r) {
        a(this, Fe).sendMessageToChannel(t, _t.TEXT, r);
        return;
      }
      let i = [];
      e && e.length > 0 && (e.push(a(this, ee).id), i = a(this, vi).joined.toArray().filter((f) => e.includes(f.id)).map((f) => f.userId), i.push(a(this, ee).userId)), a(this, Fe).sendMessage(
        t,
        _t.TEXT,
        e
      );
    });
  }
  sendImageMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d, l, p;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files)) {
          this.logger.error("sendImageMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.canSend) || !((p = (l = a(this, ee).permissions) == null ? void 0 : l.chatPublic) != null && p.files)) {
        this.logger.error("sendImageMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(t.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", { dyteChat: { imageType: t.type } });
        return;
      }
      try {
        const f = lt(), { getLocation: S, putLocation: T } = yield f.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield f.uploadFile(t, T), r) {
          a(this, Fe).sendMessageToChannel(
            S,
            _t.IMAGE,
            r
          );
          return;
        }
        let _ = [];
        e && e.length > 0 && (e.push(a(this, ee).id), _ = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), _.push(a(this, ee).userId)), a(this, Fe).sendMessage(
          S,
          _t.IMAGE,
          e
        );
      } catch (f) {
        throw new R("Error sending image message.", "0500", this.logger);
      }
    });
  }
  sendFileMessageInternal(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (e && e.length > 0) {
        if (!((i = a(this, ee).permissions) != null && i.chatPrivate.canSend) || !((n = a(this, ee).permissions) != null && n.chatPrivate.files)) {
          this.logger.error("sendFileMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!t) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const p = lt(), { getLocation: f, putLocation: S } = yield p.getPresignedUrls(
          t.name,
          a(this, ee).config.viewType
        );
        if (yield p.uploadFile(t, S), r) {
          a(this, Fe).sendMessageToChannel(
            JSON.stringify({
              link: f,
              name: t.name,
              size: "size" in t ? t.size : 0
            }),
            _t.FILE,
            r
          );
          return;
        }
        let T = [];
        e && e.length > 0 && (e.push(a(this, ee).id), T = a(this, vi).joined.toArray().filter((P) => e.includes(P.id)).map((P) => P.userId), T.push(a(this, ee).userId));
        const _ = JSON.stringify({
          link: f,
          name: t.name,
          size: "size" in t ? t.size : 0
        });
        a(this, Fe).sendMessage(
          _,
          _t.FILE,
          e
        );
      } catch (p) {
        throw new R("Error sending file message.", "0500", this.logger);
      }
    });
  }
  // eslint-disable-next-line class-methods-use-this
  get rateLimits() {
    return Sd;
  }
  // eslint-disable-next-line class-methods-use-this
  updateRateLimits(t, e) {
    Sd.maxInvocations = t, Sd.period = e;
  }
  sendTextMessage(t, e) {
    return u(this, null, function* () {
      return this.sendTextMessageInternal(t, e);
    });
  }
  sendCustomMessage(t, e) {
    return u(this, null, function* () {
      var n, o, c, d, l, p, f, S, T, _, P, w, A, N, H;
      if (e && e.length > 0) {
        if (!((n = a(this, ee).permissions) != null && n.chatPrivate.canSend) || !((o = a(this, ee).permissions) != null && o.chatPrivate.files) || !((c = a(this, ee).permissions) != null && c.chatPrivate.text)) {
          this.logger.error("sendCustomMessage::private_chat_permission_denied");
          return;
        }
      } else if (!((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.canSend) || !((f = (p = a(this, ee).permissions) == null ? void 0 : p.chatPublic) != null && f.files) || !((T = (S = a(this, ee).permissions) == null ? void 0 : S.chatPublic) != null && T.text)) {
        this.logger.error("sendCustomMessage::permission_denied");
        return;
      }
      const r = ($) => u(this, null, function* () {
        try {
          if (typeof $ == "string")
            return { link: $ };
          const F = lt(), { getLocation: K, putLocation: re } = yield F.getPresignedUrls(
            $.name,
            a(this, ee).config.viewType
          );
          return yield F.uploadFile($, re), {
            link: K,
            type: $.type,
            name: $.name,
            size: $.size
          };
        } catch (F) {
          throw new R("Error sending image message.", "0500", this.logger);
        }
      }), i = B(D({}, t), {
        files: yield Promise.all((P = (_ = t.files) != null ? _ : []) == null ? void 0 : P.map(($) => u(this, null, function* () {
          return r($);
        }))),
        images: yield Promise.all((A = (w = t.images) != null ? w : []) == null ? void 0 : A.map(($) => u(this, null, function* () {
          return r($);
        }))),
        videos: yield Promise.all((H = (N = t.videos) != null ? N : []) == null ? void 0 : H.map(($) => u(this, null, function* () {
          return r($);
        })))
      });
      a(this, Fe).sendMessage(
        JSON.stringify(i),
        _t.CUSTOM,
        e
      );
    });
  }
  sendImageMessage(t, e) {
    return u(this, null, function* () {
      return this.sendImageMessageInternal(t, e);
    });
  }
  sendFileMessage(t, e) {
    return u(this, null, function* () {
      return this.sendFileMessageInternal(t, e);
    });
  }
  sendMessage(t, e) {
    return u(this, null, function* () {
      return this.sendMessageInternal(t, e);
    });
  }
  editTextMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c, d, l;
      if (((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatMessage) == null ? void 0 : n.canEdit) === "NONE")
        throw new R("Not permitted to edit messages", "0501");
      if (!((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.canSend) || !((l = (d = a(this, ee).permissions) == null ? void 0 : d.chatPublic) != null && l.text)) {
        this.logger.error("editTextMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editTextMessage::message_can_not_be_empty");
        return;
      }
      a(this, Fe).editMessage(
        t,
        e,
        _t.TEXT,
        r
      );
    });
  }
  editImageMessage(t, e, r) {
    return u(this, null, function* () {
      var n, o, c, d;
      if (!((o = (n = a(this, ee).permissions) == null ? void 0 : n.chatPublic) != null && o.canSend) || !((d = (c = a(this, ee).permissions) == null ? void 0 : c.chatPublic) != null && d.files)) {
        this.logger.error("editImageMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("editImageMessage::required_argument_image_can_not_be_empty");
        return;
      }
      if (!["image/gif", "image/jpeg", "image/png"].includes(e.type)) {
        this.logger.error("sendImageMessage::image_type_not_supported", {
          dyteChat: { imageType: e.type }
        });
        return;
      }
      try {
        const l = lt(), { getLocation: p, putLocation: f } = yield l.getPresignedUrls(e.name, a(this, ee).config.viewType);
        yield l.uploadFile(e, f), a(this, Fe).editMessage(
          t,
          p,
          _t.IMAGE,
          r
        );
      } catch (l) {
        throw new R("Error editing image message.", "0500", this.logger);
      }
    });
  }
  editFileMessage(t, e, r) {
    return u(this, null, function* () {
      var i, n, o, c;
      if (!((n = (i = a(this, ee).permissions) == null ? void 0 : i.chatPublic) != null && n.canSend) || !((c = (o = a(this, ee).permissions) == null ? void 0 : o.chatPublic) != null && c.files)) {
        this.logger.error("sendFileMessage::permission_denied");
        return;
      }
      if (!e) {
        this.logger.error("sendFileMessage::required_argument_file_can_not_be_empty");
        return;
      }
      try {
        const d = lt(), { getLocation: l, putLocation: p } = yield d.getPresignedUrls(
          e.name,
          a(this, ee).config.viewType
        );
        yield d.uploadFile(e, p), a(this, Fe).editMessage(
          t,
          JSON.stringify({
            link: l,
            name: e.name,
            size: "size" in e ? e.size : 0
          }),
          _t.FILE,
          r
        );
      } catch (d) {
        throw new R("Error editing file message.", "0500", this.logger);
      }
    });
  }
  editMessage(t, e, r) {
    return u(this, null, function* () {
      switch (e.type) {
        case "text": {
          this.editTextMessage(t, e.message, r);
          break;
        }
        case "image": {
          this.editImageMessage(t, e.image, r);
          break;
        }
        case "file": {
          this.editFileMessage(t, e.file, r);
          break;
        }
        default: {
          this.logger.error("editMessage::message_type_not_supported", {
            dyteChat: { messageType: e.type }
          });
          break;
        }
      }
    });
  }
  deleteMessage(t, e) {
    return u(this, null, function* () {
      var r, i;
      if (((i = (r = a(this, ee).permissions) == null ? void 0 : r.chatMessage) == null ? void 0 : i.canDelete) === "NONE")
        throw new R("Not permitted to delete messages", "0501");
      a(this, Fe).deleteMessage(t, e);
    });
  }
  /**
   * Returns an array of messages sent by a specific userId.
   * @param userId The user id of the user that sent the message.
   */
  getMessagesByUser(t) {
    return this.messages.filter((e) => e.userId === t);
  }
  /**
   * Returns an array of 'text', 'image' or 'file' messages.
   * @param type 'text', 'image', or 'file'.
   */
  getMessagesByType(t) {
    return this.messages.filter((e) => e.type === t);
  }
  /**
   * Pins a chat message
   * @param id ID of the message to be pinned
   */
  pin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t pin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to pin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, !0);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  /**
   * Unpins a chat message
   * @param id ID of the message to be unpinned
   */
  unpin(t) {
    return u(this, null, function* () {
      if (!a(this, Fo, Hu))
        throw new R("Can`t unpin message without joining room", "0505");
      if (!a(this, ee).permissions.pinParticipant)
        throw new R("You do not have permission to unpin messages.", "0501");
      const e = this.messages.find((r) => r.id === t);
      if (e) {
        a(this, Fe).setPinState(e, !1);
        return;
      }
      throw new R(`No message found with id: ${t}`, "0504");
    });
  }
  /**
   * Gets chat messages in a paginated manner
   */
  getMessages(t, e, r, i = 0, n = void 0) {
    return u(this, null, function* () {
      const o = yield a(this, Fe).getChatMessagesPaginated(t, e, r, i, n);
      return {
        messages: o.messages.map(
          (c) => Es.formatSocketServiceMessage(c)
        ),
        next: o.next
      };
    });
  }
  createChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      var l;
      const o = (l = a(this, ee).permissions) == null ? void 0 : l.chatChannel;
      if (o) {
        if (o.canCreate === "NONE")
          throw new R("Not permitted to create channels", "0501");
        if (r.visibility === "public" && !(o.canCreate === "PUBLIC" || o.canCreate === "ALL"))
          throw new R("Not permitted to create public channels", "0501");
        if (r.visibility === "private" && !(o.canCreate === "PRIVATE" || o.canCreate === "ALL"))
          throw new R("Not permitted to create private channels", "0501");
      }
      if (!t || t.trim().length === 0)
        throw new R("channel name cannot be empty.", "0510");
      const c = [.../* @__PURE__ */ new Set([...e, a(this, ee).userId])];
      return yield a(this, yi).createChannel(
        t.trim(),
        c,
        r.displayPictureUrl,
        r.visibility,
        r.isDirectMessage
      );
    });
  }
  updateChannel(t, e) {
    var o, c, d, l, p;
    const r = this.channels.find((f) => f.id === t), i = (o = a(this, ee).permissions) == null ? void 0 : o.chatChannel;
    if (i) {
      if (i.canUpdate === "NONE")
        throw new R("Not permitted to update channels", "0501");
      if (r.visibility === "public" && !(i.canUpdate === "PUBLIC" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update public channels", "0501");
      if (r.visibility === "private" && !(i.canUpdate === "PRIVATE" || i.canUpdate === "ALL"))
        throw new R("Not permitted to update private channels", "0501");
    }
    const n = {
      memberIds: (c = e.memberIds) != null ? c : r.memberIds,
      displayName: (d = e.displayName) != null ? d : r.displayName,
      displayPictureUrl: (l = e.displayPictureUrl) != null ? l : r.displayPictureUrl,
      visibility: (p = e.visibility) != null ? p : r.visibility
    };
    return a(this, yi).updateChannel(t, n);
  }
  sendMessageToChannel(i, n) {
    return u(this, arguments, function* (t, e, r = {}) {
      return this.sendMessageInternal(t, null, e, r);
    });
  }
  getChannelMembers(t) {
    return u(this, null, function* () {
      return a(this, yi).getChannelMembers(t);
    });
  }
  searchMessages(r) {
    return u(this, arguments, function* (t, e = {}) {
      if (!a(this, Ti).getValue("flagsmith").hasFeature(X.FEAT_CHAT_SDK_SEARCH))
        throw new R("searchMessages is temporarily disabled!", "0506");
      return (yield a(this, Fe).searchMessages(t, e)).map(Es.formatSocketServiceMessage);
    });
  }
  markLastReadMessage(t, e) {
    return u(this, null, function* () {
      yield a(this, Fe).markLastReadMessage(t, e);
      const r = this.channels.find((i) => i.id === t);
      if (r) {
        const i = B(D({}, r), { unreadCount: 0 });
        this.channels = this.channels.map((n) => n.id === t ? i : n), this.emit("channelMessageUpdate", i);
      }
    });
  }
  /**
   * Returns an array of pinned messages.
   */
  get pinned() {
    return this.messages.filter((t) => t.pinned);
  }
}, ee = new WeakMap(), vi = new WeakMap(), Fe = new WeakMap(), yi = new WeakMap(), Ti = new WeakMap(), jd = new WeakSet(), wf = function() {
  return a(this, Ti).getValue("connectionHandler");
}, Fo = new WeakSet(), Hu = function() {
  return a(this, jd, wf).socketJoined === !0;
}, kg);
pt([
  E.trace("DyteChat.sendTextMessage"),
  Dt(Sd)
], Qe.prototype, "sendTextMessage", 1);
pt([
  E.trace("DyteChat.sendImageMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendImageMessage", 1);
pt([
  E.trace("DyteChat.sendFileMessage"),
  Dt({ maxInvocations: 20, period: 60 })
], Qe.prototype, "sendFileMessage", 1);
pt([
  E.trace("DyteChat.sendMessage"),
  Dt({ maxInvocations: 180, period: 60 })
], Qe.prototype, "sendMessage", 1);
pt([
  E.trace("DyteChat.editTextMessage")
], Qe.prototype, "editTextMessage", 1);
pt([
  E.trace("DyteChat.editImageMessage")
], Qe.prototype, "editImageMessage", 1);
pt([
  E.trace("DyteChat.editFileMessage")
], Qe.prototype, "editFileMessage", 1);
pt([
  E.trace("DyteChat.editMessage")
], Qe.prototype, "editMessage", 1);
pt([
  E.trace("DyteChat.deleteMessage")
], Qe.prototype, "deleteMessage", 1);
pt([
  E.trace("DyteChat.createChannel")
], Qe.prototype, "createChannel", 1);
pt([
  E.trace("DyteChat.updateChannel")
], Qe.prototype, "updateChannel", 1);
pt([
  E.trace("DyteChat.sendMessageToChannel")
], Qe.prototype, "sendMessageToChannel", 1);
pt([
  E.trace("DyteChat.getChannelMembers")
], Qe.prototype, "getChannelMembers", 1);
pt([
  E.trace("DyteChat.searchMessages")
], Qe.prototype, "searchMessages", 1);
pt([
  E.trace("DyteChat.markLastReadMessage")
], Qe.prototype, "markLastReadMessage", 1);
Qe = pt([
  ht("0500")
], Qe);
var pM = Object.defineProperty, gM = Object.getOwnPropertyDescriptor, mM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? gM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && pM(t, e, i), i;
}, Dr, Ig;
const ci = (Ig = class {
  constructor(s, t, e, r, i) {
    h(this, "chat");
    h(this, "chatSocketHandler");
    h(this, "chatChannelSocketHandler");
    h(this, "self");
    g(this, Dr, void 0);
    m(this, Dr, s), this.chatSocketHandler = t, this.chatChannelSocketHandler = e, this.chat = new Qe(
      s,
      t,
      e,
      r,
      i
    ), this.self = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Dr).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Dr).getValue("logger");
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      return new ci(
        s,
        t,
        e,
        r,
        i
      );
    });
  }
  static formatMessage(s) {
    return B(D({}, s), {
      time: new Date(s.time),
      type: hM[s.type]
    });
  }
  /**
   * @access private
   * This function formates the chat message coming from
   * socket service. This is not meant for external use.
   */
  static formatSocketServiceMessage(s) {
    const t = s.createdAt * 1e3, e = {
      displayName: s.displayName,
      id: s.chatId,
      time: t,
      timeMs: s.createdAtMs,
      type: s.payloadType,
      isEdited: s.isEdited,
      userId: s.userId,
      targetUserIds: s.targetUserIds,
      channelId: s.channelId,
      channelIndex: s.channelIndex,
      message: "",
      link: "",
      name: "",
      html: "",
      images: [],
      videos: [],
      files: [],
      size: 0,
      pinned: s.pinned
    };
    switch (e.type) {
      case _t.TEXT: {
        e.message = s.payload;
        break;
      }
      case _t.IMAGE: {
        e.link = s.payload;
        break;
      }
      case _t.FILE: {
        const { link: r, name: i, size: n } = JSON.parse(s.payload);
        e.link = r, e.name = i, e.size = n;
        break;
      }
      case _t.CUSTOM: {
        const {
          html: r,
          images: i,
          message: n,
          videos: o,
          files: c
        } = JSON.parse(s.payload);
        e.message = n, e.html = r, e.images = i, e.videos = o, e.files = c;
        break;
      }
    }
    return ci.formatMessage(e);
  }
  getChatMessages() {
    return u(this, null, function* () {
      if (this.self.config.viewType === "LIVESTREAM" || this.self.config.viewType === "CHAT" || a(this, Dr).getValue("flagsmith").hasFeature(X.FEAT_PAGINATED_CHAT))
        return;
      const s = yield this.chatSocketHandler.getChatMessages();
      if (!(s != null && s.payload))
        return;
      const t = Ef.fromBinary(
        s.payload
      ).messages;
      this.chat.messages = t.map(
        (e) => ci.formatSocketServiceMessage(e)
      );
    });
  }
  setupEvents() {
    a(this, Dr).getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => u(this, null, function* () {
        this.getChatMessages();
      })
    ), this.chatSocketHandler.on(
      Re.sendMessageToRoom,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (!t.channelId)
          this.chat.messages = [...this.chat.messages, t];
        else {
          const e = this.chat.channels.find((r) => r.id === t.channelId);
          e && (e.latestMessage = t, e.unreadCount += 1, this.chat.emit("channelMessageUpdate", e));
        }
        this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.sendMessageToPeers,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        this.chat.messages = [...this.chat.messages, t], this.chat.emit("chatUpdate", {
          action: "add",
          message: t,
          messages: this.chat.messages
        });
      }
    ), this.chatSocketHandler.on(
      Re.editMessage,
      (s) => {
        const t = ci.formatSocketServiceMessage(
          s.message
        );
        if (t.channelId) {
          this.chat.emit("chatUpdate", {
            action: "edit",
            message: t,
            messages: this.chat.messages
          });
          return;
        }
        const e = this.chat.messages.findIndex((r) => r.id === t.id);
        e !== -1 && (this.chat.messages[e] = t, this.chat.emit("chatUpdate", {
          action: "edit",
          message: t,
          messages: this.chat.messages
        }));
      }
    ), this.chatSocketHandler.on(
      Re.deleteMessage,
      (s) => {
        if (s.channelId) {
          this.chat.emit("chatUpdate", {
            action: "delete",
            message: { id: s.chatId, channelId: s.channelId },
            messages: this.chat.messages
          });
          return;
        }
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const [e] = this.chat.messages.splice(t, 1);
        this.chat.emit("chatUpdate", {
          action: "delete",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.createChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels.push(e), this.chat.emit("channelCreate", e);
      }
    ), this.chatSocketHandler.on(
      Re.pinMessage,
      (s) => {
        const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
        if (t === -1)
          return;
        const e = this.chat.messages[t];
        e.pinned = s.pinned, this.chat.messages[t] = e, this.chat.emit("chatUpdate", {
          action: "edit",
          message: e,
          messages: this.chat.messages
        });
      }
    ), this.chatChannelSocketHandler.on(
      pi.updateChatChannel,
      (s) => {
        const [t] = s.chatChannels, e = pa.formatChannel(t);
        this.chat.channels = this.chat.channels.map((r) => r.id === e.id ? e : r), this.chat.emit("channelUpdate", e);
      }
    );
  }
}, Dr = new WeakMap(), Ig);
let Es = ci;
mM([
  E.trace("ChatController.setupEvents")
], Es.prototype, "setupEvents", 1);
var fM = Object.defineProperty, SM = Object.getOwnPropertyDescriptor, vM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? SM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && fM(t, e, i), i;
}, Gd, bf, Wd, kf, Ga, Wa, Ho, Ag;
let Bu = (Ag = class extends qt {
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    // eslint-disable-next-line class-methods-use-this
    g(this, Gd);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, Wd);
    /**
     * An array of poll items.
     */
    h(this, "items");
    g(this, Ga, void 0);
    g(this, Wa, void 0);
    g(this, Ho, void 0);
    m(this, Ho, t), m(this, Ga, e), m(this, Wa, r), this.items = [];
  }
  /**
   * Creates a poll in the meeting.
   * @param question The question that is to be voted for.
   * @param options The options of the poll.
   * @param anonymous If true, the poll votes are anonymous.
   * @param hideVotes If true, the votes on the poll are hidden.
   */
  create(t, e, r = !1, i = !1) {
    return u(this, null, function* () {
      if (!a(this, Wd, kf))
        throw new R("Can't create polls without joining room", "0705");
      if (!a(this, Ga).permissions.polls.canCreate) {
        this.logger.error("DytePolls::create::permission_denied");
        return;
      }
      if (!t || !e) {
        this.logger.error("DytePolls::question_and_options_can_not_be_empty", {
          dytePolls: {
            hasQuestion: !!t,
            optionsLength: e == null ? void 0 : e.length
          }
        });
        return;
      }
      if (e.length < 2) {
        this.logger.error("DytePolls::there_must_be_at_least_two_options", {
          dytePolls: { hasQuestion: !!t, optionsLength: e.length }
        });
        return;
      }
      yield a(this, Wa).createPoll(
        t,
        e,
        r,
        i
      );
    });
  }
  /**
   * Casts a vote on an existing poll.
   * @param pollId The ID of the poll that is to be voted on.
   * @param index The index of the option.
   */
  vote(t, e) {
    return u(this, null, function* () {
      if (!a(this, Ga).permissions.polls.canVote) {
        this.logger.error("DytePolls::vote::permission_denied");
        return;
      }
      yield a(this, Wa).votePoll(t, e);
    });
  }
}, Gd = new WeakSet(), bf = function() {
  return a(this, Ho).getValue("connectionHandler");
}, Wd = new WeakSet(), kf = function() {
  var t;
  return ((t = a(this, Gd, bf)) == null ? void 0 : t.socketJoined) === !0;
}, Ga = new WeakMap(), Wa = new WeakMap(), Ho = new WeakMap(), Ag);
Bu = vM([
  ht("0700")
], Bu);
var yM = Object.defineProperty, TM = Object.getOwnPropertyDescriptor, EM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yM(t, e, i), i;
}, Or, Ja, Ei, Mg;
const Ra = (Mg = class {
  constructor(s, t, e) {
    h(this, "polls");
    g(this, Or, void 0);
    g(this, Ja, void 0);
    g(this, Ei, void 0);
    this.polls = new Bu(s, t, e), m(this, Ja, t), m(this, Or, s), m(this, Ei, e), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Or).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Or).getValue("logger");
  }
  static init(s, t, e) {
    return u(this, null, function* () {
      return new Ra(s, t, e);
    });
  }
  canViewPolls() {
    return a(this, Ja).permissions.polls.canView;
  }
  setupEvents() {
    const s = {
      [qs.createPoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.updatePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      },
      [qs.votePoll]: (r) => {
        r.poll && this.updatePoll(Ra.formatSocketServicePoll(r.poll));
      }
    }, t = () => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).on(r, s[r]);
      });
    }, e = () => {
      a(this, Or).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => {
        this.getPolls();
      }), Object.keys(s).map(Number).forEach((r) => {
        a(this, Ei).removeListeners(r);
      });
    };
    a(this, Ja).permissions.on("permissionsUpdate", (r) => u(this, null, function* () {
      var i;
      r != null && r.polls && ((i = r == null ? void 0 : r.polls) != null && i.canView ? (yield this.getPolls(), t()) : (this.polls.items = [], e()));
    })), this.canViewPolls() && t();
  }
  updatePoll(s) {
    if (!this.canViewPolls())
      return;
    const t = this.polls.items.findIndex((e) => e.id === s.id);
    if (t > -1) {
      const e = JSON.stringify(this.polls.items[t]);
      this.polls.items[t] = s, e !== JSON.stringify(s) && this.polls.emit("pollsUpdate", {
        polls: this.polls.items,
        newPoll: !1
      });
      return;
    }
    this.polls.items = [...this.polls.items, s], this.polls.emit("pollsUpdate", { polls: this.polls.items, newPoll: !0 });
  }
  getPolls() {
    return u(this, null, function* () {
      const s = yield a(this, Ei).getPolls();
      if (!(s != null && s.payload))
        return;
      const { polls: t } = DA.fromBinary(s.payload);
      this.polls.items = t.map(
        (e) => Ra.formatSocketServicePoll(e)
      );
    });
  }
  static formatSocketServicePoll(s) {
    const t = s.options.map((e) => ({
      count: e.count,
      text: e.text,
      votes: e.votes.map((r) => ({
        id: r.userId,
        name: r.name
      }))
    }));
    return {
      anonymous: s.anonymous,
      createdBy: s.createdBy,
      createdByUserId: s.createdByUserId,
      hideVotes: s.hideVotes,
      id: s.pollId,
      options: t,
      question: s.question,
      voted: s.votes
    };
  }
}, Or = new WeakMap(), Ja = new WeakMap(), Ei = new WeakMap(), Mg);
let If = Ra;
EM([
  E.trace("PollController.setupEvents")
], If.prototype, "setupEvents", 1);
var _M = Object.defineProperty, PM = Object.getOwnPropertyDescriptor, CM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? PM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && _M(t, e, i), i;
}, Af = /* @__PURE__ */ ((s) => (s[s.User = 0] = "User", s[s.Meeting = 1] = "Meeting", s))(Af || {}), Ka, Bo, ju, _i, qo, Dg;
let qu = (Dg = class extends qt {
  constructor(t, e, r, i, n) {
    const o = t.getValue("logger");
    super(o);
    g(this, Bo);
    /**
     *	Represents the current active tab
    */
    h(this, "selfActiveTab");
    /**
     * Represents whether current user is spotlighted
    */
    h(this, "broadcastTabChanges");
    g(this, Ka, void 0);
    g(this, _i, void 0);
    g(this, qo, void 0);
    /**
     * The `viewType` tells the type of the meeting
     * possible values are: GROUP_CALL| LIVESTREAM | CHAT | AUDIO_ROOM
     */
    h(this, "viewType");
    /**
     * The timestamp of the time when the meeting started.
     */
    h(this, "meetingStartedTimestamp");
    /**
     * The title of the meeting.
     */
    h(this, "meetingTitle");
    /**
     * (Experimental) The sessionId this meeting object is part of.
     */
    h(this, "sessionId");
    m(this, Ka, t), m(this, _i, e), this.viewType = r, m(this, qo, i), this.meetingTitle = n, this.broadcastTabChanges = e.permissions.canSpotlight;
  }
  get socketState() {
    return a(this, Bo, ju).socketState;
  }
  get mediaState() {
    return a(this, Bo, ju).mediaState;
  }
  /**
   * The room name of the meeting.
   */
  get meetingId() {
    return a(this, Ka).getValue("meetingId");
  }
  /**
   * Sets current user as broadcasting tab changes
   * @param broadcastTabChanges
   */
  setBroadcastTabChanges(t) {
    if (!a(this, _i).permissions.canSpotlight)
      throw this.logger.error("DyteSpotlight::setSpotlighted::permission_denied"), new R("User does not have permission to toggle spotlight", "0801");
    this.broadcastTabChanges = t, this.emit("broadcastTabChangesUpdate", this.broadcastTabChanges), this.broadcastTabChanges && this.assertActiveTabToRoom();
  }
  /**
   * Sets current active tab for user
   * @param spotlightTab
   */
  setSelfActiveTab(t, e) {
    var r;
    this.logger.info("DyteSpotlight::setActiveTab", {
      spotlight: {
        currentTab: {
          id: t.id,
          type: t.type
        }
      }
    }), this.selfActiveTab = t, e === 0 && this.emit("selfTabUpdate", t), (r = a(this, _i).permissions) != null && r.canSpotlight && this.broadcastTabChanges && e === 0 && this.assertActiveTabToRoom();
  }
  assertActiveTabToRoom() {
    a(this, qo).broadcastMessage("spotlight", {
      userId: a(this, _i).userId,
      currentTab: this.selfActiveTab
    });
  }
}, Ka = new WeakMap(), Bo = new WeakSet(), ju = function() {
  return a(this, Ka).getValue("connectionHandler");
}, _i = new WeakMap(), qo = new WeakMap(), Dg);
qu = CM([
  ht("0800")
], qu);
function RM(s) {
  let t = "", e = [""];
  const r = [e];
  let i = 0, n = 0, o = !0, c;
  for (c of s)
    c === '"' ? (o && c === t && (e[i] += c), o = !o) : c === "," && o ? c = e[++i] = "" : c === `
` && o ? (t === "\r" && (e[i] = e[i].slice(0, -1)), e = r[++n] = [c = ""], i = 0) : e[i] += c, t = c;
  return r;
}
var wM = Object.defineProperty, bM = Object.getOwnPropertyDescriptor, Mf = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? bM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && wM(t, e, i), i;
}, jo, Og;
let ei = (Og = class extends qt {
  constructor(t) {
    const e = t.getValue("logger");
    super(e);
    h(this, "transcripts");
    g(this, jo, void 0);
    m(this, jo, t), this.transcripts = [];
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, jo).getValue("telemetry");
  }
  static init(t, e) {
    return u(this, null, function* () {
      const r = new ei(t), i = t.getValue("logger");
      try {
        e && r.getActiveTranscript();
      } catch (n) {
        i.error("Error fetching active transcriptions ", n);
      }
      return r;
    });
  }
  /**
  * Parse a single line transcript
  */
  static parseTranscript(t, e = !1) {
    if (!t)
      return;
    const [[
      r,
      i,
      n,
      o,
      c,
      d
    ]] = RM(t);
    return {
      id: ua(),
      name: c,
      peerId: i,
      userId: n,
      customParticipantId: o,
      transcript: d,
      isPartialTranscript: e,
      date: new Date(parseInt(r, 10) * 1e3)
    };
  }
  /**
  * Parse a multi-line transcript
  */
  static parseTranscripts(t) {
    return t ? t.split(`
`).map((e) => ei.parseTranscript(e, !1)).filter(Boolean) : [];
  }
  getActiveTranscript() {
    return u(this, null, function* () {
      try {
        const t = lt(), { transcript: e } = yield t.getActiveTranscript();
        this.transcripts = ei.parseTranscripts(e);
      } catch (t) {
      }
    });
  }
  onTranscript(t) {
    return u(this, null, function* () {
      var r;
      const e = this.transcripts.filter(({ peerId: i }) => i === t.peerId);
      if ((r = e == null ? void 0 : e.at(-1)) != null && r.isPartialTranscript) {
        const i = e.at(-1);
        i.transcript = t.transcript, i.isPartialTranscript = t.isPartialTranscript, this.emit("transcript", i);
        return;
      }
      this.transcripts = [...this.transcripts, t], this.emit("transcript", t);
    });
  }
}, jo = new WeakMap(), Og);
Mf([
  E.trace("DyteAi.getActiveTranscript")
], ei.prototype, "getActiveTranscript", 1);
ei = Mf([
  ht("0000")
], ei);
var kM = Object.defineProperty, IM = Object.getOwnPropertyDescriptor, AM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? IM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && kM(t, e, i), i;
}, Nr, za, xt, Ng;
const Df = (Ng = class {
  constructor(s, t, e, r, i, n) {
    h(this, "meta");
    h(this, "ai");
    g(this, Nr, void 0);
    g(this, za, void 0);
    h(this, "aiSocketHandler");
    g(this, xt, void 0);
    m(this, xt, s), this.meta = new qu(
      s,
      t,
      t.config.viewType,
      e,
      n
    ), this.ai = r, m(this, Nr, t), m(this, za, e), this.aiSocketHandler = i, t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, xt).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, xt).getValue("logger");
  }
  /**
   *
   */
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = yield ei.init(s, t.permissions.transcriptionEnabled);
      return new Df(
        s,
        t,
        e,
        n,
        r,
        i
      );
    });
  }
  conditionallySetActiveTab(s) {
    var t;
    s != null && s.currentTab && ((t = this.meta.selfActiveTab) == null ? void 0 : t.id) !== s.currentTab.id && (this.meta.setSelfActiveTab(
      s.currentTab,
      Af.Meeting
    ), this.meta.emit(
      "activeTabUpdate",
      s.currentTab
    ));
  }
  setupEvents() {
    a(this, xt).getValue("peerSessionStore").on(
      k.TRANSPORT_STATE_UPDATE,
      (s) => {
        this.meta.emit("mediaConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.SOCKET_STATE_UPDATE,
      (s) => {
        this.meta.emit("socketConnectionUpdate", s);
      }
    ), a(this, xt).getValue("peerSessionStore").on(k.ROOM_STATE, ({ createdAt: s, roomUuid: t }) => {
      const e = this.meta.meetingStartedTimestamp;
      if (t && (this.meta.sessionId = t), s && !e) {
        const r = new Date(s * 1e3);
        this.meta.meetingStartedTimestamp = r, this.meta.emit("meetingStartTimeUpdate", {
          meetingStartedTimestamp: this.meta.meetingStartedTimestamp
        });
      }
    }), a(this, xt).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({ score: s }) => {
        s < 5 && this.meta.emit("poorConnection", { score: s });
      }
    ), a(this, Nr).permissions.canSpotlight && (this.logger.info("DyteMetaController::Asserting Spotlight"), this.meta.selfActiveTab && a(this, za).broadcastMessage("spotlight", {
      userId: a(this, Nr).userId,
      currentTab: this.meta.selfActiveTab
    })), a(this, xt).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (s) => u(this, null, function* () {
        a(this, Nr).permissions.canSpotlight && this.meta.selfActiveTab && a(this, za).broadcastToPeers("spotlight", [s.id], {
          userId: a(this, Nr).userId,
          currentTab: this.meta.selfActiveTab
        });
      })
    ), a(this, xt).getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), a(this, xt).getValue("peerSessionStore").on(
      k.MESSAGE,
      (s) => {
        var e, r;
        let t;
        if ("type" in s) {
          if (s.type !== "spotlight")
            return;
          t = D(D({}, s), s.payload);
        } else if ("roomMessageType" in s) {
          if (s.roomMessageType !== "spotlight")
            return;
          t = s;
        } else
          return;
        this.logger.info("Spotlight Assertion Received", {
          spotlight: {
            spotlighter: { id: t.userId },
            currentTab: {
              id: (e = t.currentTab) == null ? void 0 : e.id,
              type: (r = t.currentTab) == null ? void 0 : r.type
            }
          }
        }), this.conditionallySetActiveTab(t);
      }
    ), this.aiSocketHandler.on(x.transcript, (s) => {
      const {
        meetingId: t,
        transcript: e,
        isPartial: r
      } = s;
      let i;
      try {
        i = ei.parseTranscript(e, r);
      } catch (d) {
        this.logger.error(`Failed to parse transcript: ${e}`, d);
      }
      if (!i) {
        this.logger.warn("Received empty transcript data");
        return;
      }
      this.ai.onTranscript(i), this.meta.emit("transcript", i);
      const { peerId: n, name: o, transcript: c } = i;
      this.logger.debug(`${t} Received transcript for peer ${n} - ${o}: ${c}`);
    });
  }
}, Nr = new WeakMap(), za = new WeakMap(), xt = new WeakMap(), Ng);
let Of = Df;
AM([
  E.trace("MetaController.setupEvents")
], Of.prototype, "setupEvents", 1);
const So = {}, Er = {
  /**
   * Lock a method to prevent concurrency
   * @param config - configuration for the lock
   * @param config.methodName - config.methodName Name of method to expose in logs
   *	and to the user (if necessary).
   * @param config.lockName - Unique string to differentiate the method from others.
   * @param config.timeout - Release lock in given milliseconds if method doesn't get resolved.
   *
   *	Do not use common function names such as joinRoom as the lockName,
   *	instead use filename.functionname, if a suitable name couldn't be found.
   * @returns locked instance.
   *
   * It will throw error with name `UnsupportedConcurrentMethodExecution`,
   *	if lock couldn't be acquired.
   *
   * Note:
   *	Make sure that the methodName is explanatory on its own, if exposed to end users.
   * Eg: `meeting.joinRoom` is a much better choice than `joinRoom`.
   */
  executeWithLock({
    methodName: s,
    lockName: t,
    timeout: e
  }) {
    return (r, i, n) => {
      const o = n.value;
      return n.value = function(...d) {
        var _, P;
        const l = (P = (this == null ? void 0 : this.peerId) || ((_ = d[0]) == null ? void 0 : _.authToken)) != null ? P : "", p = `${t}-${l}`, f = this == null ? void 0 : this.logger;
        if (So[p]) {
          const w = new Error(
            `Unsupported concurrent calls on Dyte method: ${s}.`
          );
          throw w.name = "UnsupportedConcurrentMethodExecution", f == null || f.error("DyteLocker::UnsupportedConcurrentMethodExecution", {
            error: {
              stack: w.stack
            },
            dyteLocker: {
              methodName: s,
              lockName: p
            }
          }), w;
        }
        So[p] = !0;
        const S = setTimeout(
          () => delete So[p],
          e
        ), T = o.apply(this, d);
        return Promise.resolve(T).then(() => {
          delete So[p], clearTimeout(S);
        }).catch(() => {
          delete So[p], clearTimeout(S);
        }), T;
      }, n;
    };
  }
};
var MM = Object.defineProperty, DM = Object.getOwnPropertyDescriptor, Ta = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? DM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && MM(t, e, i), i;
}, Yt, Jd, ae, Go, Is, Ke, Wo, Gu, Ya, vd;
class ii extends qt {
  constructor(e, r, i, n, o) {
    const c = e.getValue("logger");
    super(c);
    // eslint-disable-next-line class-methods-use-this
    g(this, Wo);
    g(this, Ya);
    g(this, Yt, void 0);
    g(this, Jd, void 0);
    g(this, ae, void 0);
    g(this, Go, void 0);
    g(this, Is, void 0);
    g(this, Ke, void 0);
    m(this, Ke, e), m(this, Yt, n), m(this, Jd, o), m(this, ae, r), m(this, Go, i), m(this, Is, []), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ke).getValue("telemetry");
  }
  get status() {
    return a(this, Ke).getValue("stageStatus");
  }
  setupEvents() {
    const e = {
      /**
       * NOTE(ishita1805): Update stageRequests when socket sends them.
       */
      [k.GET_STAGE_REQUESTS]: (n) => u(this, null, function* () {
        m(this, Is, n);
      }),
      /**
       * NOTE(ishita1805): Update stageRequests when a peer
       * who has requested leaves/joins the meeting
       */
      [k.UPDATE_STAGE_REQUESTS]: (o) => u(this, [o], function* ({ add: n }) {
        const c = a(this, Is).length, { stageRequests: d } = this.getAccessRequests();
        (n || d.length > c) && this.emit("newStageRequest", { count: d.length }), this.emit("stageAccessRequestUpdate", d);
      })
    }, r = () => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").onAsync(
          n,
          o
        );
      });
    }, i = () => {
      Object.entries(e).forEach(([n, o]) => {
        a(this, Ke).getValue("peerSessionStore").removeListener(
          n,
          o
        );
      });
    };
    a(this, ae).permissions.on("permissionsUpdate", (n) => {
      const { canAcceptProductionRequests: o } = n;
      o !== void 0 && (a(this, ae).permissions.acceptStageRequests ? (r(), a(this, Yt).getStageRequests()) : (i(), m(this, Is, []), this.emit("stageAccessRequestUpdate", a(this, Is))));
    }), a(this, ae).permissions.acceptStageRequests && r();
  }
  getAccessRequests() {
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::get_access_request::permission_denied"), new R("You do not have permission to perform this action", "2001");
    const e = a(this, Go).joined.toArray().filter(
      (r) => r.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((r) => ({
      displayName: r.name,
      userId: r.userId,
      peerId: r.id
    }));
    return m(this, Is, e), { stageRequests: a(this, Is) };
  }
  requestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (this.status !== "OFF_STAGE")
        throw new R(
          `Unable to request access you are currently ${this.status}`,
          "2006"
        );
      if (a(this, ae).permissions.stageAccess === j.Allowed) {
        L(this, Ya, vd).call(this, "ACCEPTED_TO_JOIN_STAGE");
        return;
      }
      a(this, Yt).requestAccess(), L(this, Ya, vd).call(this, "REQUESTED_TO_JOIN_STAGE");
    });
  }
  cancelRequestAccess() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      a(this, Yt).cancelRequestAccess(), L(this, Ya, vd).call(this, "OFF_STAGE");
    });
  }
  grantAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t grant for participant without joining room"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::grant_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).grantAccess(e);
  }
  denyAccess(e) {
    if (!a(this, ae).roomJoined)
      throw new R(
        "Can`t rejectRequestToJoinStage for participant without joining room",
        "2005"
      );
    if (!a(this, ae).permissions.stageEnabled)
      throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
    if (!a(this, ae).permissions.acceptStageRequests)
      throw this.logger.error("DyteStage::deny_access::permission_denied"), new R("You do not have permission to perform this action", "2001");
    return a(this, Yt).denyAccess(e);
  }
  /**
   * Returns the peerId of the current user
   */
  get peerId() {
    return a(this, Ke).getValue("peerId");
  }
  join() {
    return u(this, null, function* () {
      const e = a(this, Ke).getValue("viewType");
      if (this.status === "ON_STAGE")
        throw new R("You are already on stage.", "2006");
      if (this.status !== "ACCEPTED_TO_JOIN_STAGE" || a(this, ae).permissions.stageAccess === j.NotAllowed)
        throw new R(`Unable to join stage you are currently ${this.status}`, "2006");
      if (a(this, Ke).setValue("stageStatus", "ON_STAGE", !1), yield a(this, Yt).joinStage(), e === Mt.Livestream) {
        yield a(this, Ke).getValue("selfController").joinRoom();
        return;
      }
      a(this, Ke).notify("stageStatus"), a(this, ae).audioEnabled && a(this, Wo, Gu).shareMic(a(this, ae).audioTrack), a(this, ae).videoEnabled && a(this, Wo, Gu).shareWebcam(a(this, ae).videoTrack);
    });
  }
  leave() {
    return u(this, null, function* () {
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!(this.status === "ON_STAGE" || this.status === "ACCEPTED_TO_JOIN_STAGE"))
        throw new R(`Unable to leave stage you are currently ${this.status}`, "2006");
      a(this, ae).setIsPinned(!1), a(this, Ke).setValue("stageStatus", "OFF_STAGE", !1), yield a(this, Yt).leaveStage(a(this, ae).userId);
      try {
        yield a(this, Ke).getValue("peerSessionStore").emitAsync(k.LEAVE_MEDIA_ROOM, "stageLeft");
      } catch (e) {
        this.logger.error("DyteStage::leave::emitAsync::failed", { error: e });
      }
      a(this, Ke).notify("stageStatus");
    });
  }
  /**
   * Method to kick a user off the stage
   *
   * `permissions.acceptStageRequests` privilege required
   */
  kick(e) {
    return u(this, null, function* () {
      if (!a(this, ae).roomJoined)
        throw new R(
          "Can`t kick participant without joining room",
          "2005"
        );
      if (!a(this, ae).permissions.stageEnabled)
        throw this.logger.error("DyteStage::stage_disabled"), new R("Stage is disabled", "2003");
      if (!a(this, ae).permissions.acceptStageRequests)
        throw this.logger.error("DyteStage::kick::permission_denied"), new R("You do not have permissions for kick", "2001");
      return a(this, Yt).kick(e);
    });
  }
}
Yt = new WeakMap(), Jd = new WeakMap(), ae = new WeakMap(), Go = new WeakMap(), Is = new WeakMap(), Ke = new WeakMap(), Wo = new WeakSet(), Gu = function() {
  return a(this, Ke).getValue("roomNodeClient");
}, Ya = new WeakSet(), vd = function(e) {
  return u(this, null, function* () {
    this.status !== e && a(this, Ke).setValue("stageStatus", e);
  });
};
Ta([
  E.trace("DyteStage.getStageRequests")
], ii.prototype, "getAccessRequests", 1);
Ta([
  E.trace("DyteStage.requestAccess")
], ii.prototype, "requestAccess", 1);
Ta([
  E.trace("DyteStage.cancelRequestAccess")
], ii.prototype, "cancelRequestAccess", 1);
Ta([
  E.trace("DyteStage.grantAccess")
], ii.prototype, "grantAccess", 1);
Ta([
  E.trace("DyteStage.denyAccess")
], ii.prototype, "denyAccess", 1);
Ta([
  Er.executeWithLock({
    methodName: "joinStage",
    lockName: "DyteStage.join",
    timeout: 5e3
  }),
  E.trace("DyteStage.joinStage")
], ii.prototype, "join", 1);
Ta([
  E.trace("DyteStage.leaveStage")
], ii.prototype, "leave", 1);
function OM(s) {
  return !(s.viewType === "LIVESTREAM" || s.viewType === "CHAT");
}
function Nh(s) {
  switch (s) {
    case pr.UNSPECIFIED:
      return "OFF_STAGE";
    case pr.REQUESTED_STAGE:
      return "REQUESTED_TO_JOIN_STAGE";
    case pr.APPROVED_STAGE:
      return "ACCEPTED_TO_JOIN_STAGE";
    case pr.OFF_STAGE:
      return "OFF_STAGE";
    case pr.ON_STAGE:
      return "ON_STAGE";
    default:
      return "OFF_STAGE";
  }
}
var NM = Object.defineProperty, VM = Object.getOwnPropertyDescriptor, LM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? VM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && NM(t, e, i), i;
}, Vr, Pi, Lr, Jo, ft;
class Nf {
  constructor(t, e, r, i, n) {
    h(this, "stage");
    g(this, Vr, void 0);
    g(this, Pi, void 0);
    g(this, Lr, void 0);
    g(this, Jo, 0);
    g(this, ft, void 0);
    m(this, ft, t), this.stage = new ii(
      t,
      i,
      n,
      e,
      r
    ), m(this, Lr, e), m(this, Vr, i), m(this, Pi, n), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ft).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, ft).getValue("logger");
  }
  setupEvents() {
    a(this, ft).subscribe("stageStatus", (t) => {
      this.stage.emit("stageStatusUpdate", t);
    }), a(this, Lr).on(x.grantStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestApproved"), this.setStageStatus("ACCEPTED_TO_JOIN_STAGE"));
    }), a(this, Lr).on(x.peerStageStatusUpdate, (t) => {
      t !== void 0 && (t.peerId === a(this, Vr).id ? this.selfStageStatusHandler(t) : this.peerStageStatusHandler(t));
    }), a(this, Lr).on(x.denyStageAccess, () => {
      a(this, Vr).permissions.stageAccess !== j.Allowed && (this.stage.emit("stageRequestRejected"), this.setStageStatus("OFF_STAGE"));
    }), a(this, Lr).on(
      x.getStageRequests,
      (t) => u(this, null, function* () {
        var r;
        if (a(this, Vr).permissions.stageAccess !== j.Allowed)
          return;
        const e = (r = t == null ? void 0 : t.stageRequests) != null ? r : [];
        yield a(this, ft).getValue("peerSessionStore").emitAsync(k.GET_STAGE_REQUESTS, e), a(this, Jo) < e.length && e.length > 0 && this.stage.emit("newStageRequest", { count: e.length }), m(this, Jo, e.length), this.stage.emit("stageAccessRequestUpdate", e);
      })
    );
  }
  getCurrentStageRequests() {
    return a(this, Pi).joined.toArray().filter(
      (e) => e.stageStatus === "REQUESTED_TO_JOIN_STAGE"
    ).map((e) => ({
      displayName: e.name,
      userId: e.userId,
      peerId: e.id
    }));
  }
  setStageStatus(t) {
    return u(this, null, function* () {
      this.stage.status !== t && a(this, ft).setValue("stageStatus", t);
    });
  }
  /**
   * NOTE(ishita1805): Runs for cases like:
   * - Being kicked from stage
   * - Socket-Client inconsistency
   */
  selfStageStatusHandler(t) {
    const e = Nh(t.stageType), r = a(this, ft).getValue("stageStatus");
    if (r !== e)
      switch (t.stageType) {
        case 1:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", !1), this.stage.join();
          break;
        case 2:
        case 3:
          this.setStageStatus(r);
          break;
        case 0:
        case 4:
        default:
          a(this, ft).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", !1), this.stage.leave();
          break;
      }
  }
  /**
   * NOTE(ishita1805): Source of truth for updating peer stage status
   */
  peerStageStatusHandler(t) {
    return u(this, null, function* () {
      const e = a(this, Pi).joined.get(t.peerId), r = a(this, Pi).viewMode === "ACTIVE_GRID";
      if (!e) {
        this.logger.warn("err::peerStageStatusUpdate: participant not found");
        return;
      }
      switch (t.stageType) {
        case 1:
          e.setStageStatus("ON_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
        case 2:
          e.setStageStatus("ACCEPTED_TO_JOIN_STAGE");
          break;
        case 3:
          e.setStageStatus("REQUESTED_TO_JOIN_STAGE");
          break;
        case 0:
        case 4:
        default:
          e.setStageStatus("OFF_STAGE"), r && a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
          break;
      }
      a(this, ft).getValue("peerSessionStore").emit(k.UPDATE_PEER_STAGE_STATUS, {
        id: e.id,
        status: e.stageStatus
      });
    });
  }
}
Vr = new WeakMap(), Pi = new WeakMap(), Lr = new WeakMap(), Jo = new WeakMap(), ft = new WeakMap();
LM([
  E.trace("DyteStage.setupEvents")
], Nf.prototype, "setupEvents", 1);
var xM = Object.defineProperty, UM = Object.getOwnPropertyDescriptor, Wl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? UM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && xM(t, e, i), i;
};
const Ie = {
  getPeer: 14,
  getPeers: 15,
  chatMessage: 16,
  getRoomName: 17,
  getDisplayTitle: 18,
  getPluginInitiator: 19,
  customPluginEventToParent: 20,
  peerJoined: 22,
  peerLeft: 23,
  sendData: 24,
  stageStatusUpdate: 25,
  peerStageStatusUpdate: 26
};
var at, Ut, Qa, Xa, Ks, Za, xr, en, Vg;
let Wn = (Vg = class extends Jn {
  constructor(t, {
    baseURL: e,
    createdAt: r,
    description: i,
    id: n,
    name: o,
    organizationId: c,
    picture: d,
    private: l,
    published: p,
    staggered: f,
    tags: S,
    type: T,
    updatedAt: _
  }, P, w, A, N, H) {
    const $ = t.getValue("logger");
    super($);
    g(this, at, void 0);
    h(this, "baseURL");
    h(this, "createdAt");
    h(this, "description");
    h(this, "id");
    h(this, "name");
    g(this, Ut, void 0);
    g(this, Qa, void 0);
    g(this, Xa, void 0);
    h(this, "organizationId");
    h(this, "picture");
    h(this, "private");
    h(this, "published");
    h(this, "staggered");
    h(this, "tags");
    h(this, "type");
    h(this, "updatedAt");
    g(this, Ks, void 0);
    h(this, "config");
    g(this, Za, void 0);
    h(this, "active");
    h(this, "iframes");
    h(this, "enabledBy");
    g(this, xr, void 0);
    g(this, en, void 0);
    m(this, xr, t), this.baseURL = e, this.createdAt = new Date(r), this.description = i, this.id = n, this.name = o, m(this, Ut, w), this.organizationId = c, this.picture = d, this.private = l, this.published = p, this.staggered = f, this.tags = S, this.type = T, this.updatedAt = new Date(_), this.active = !1, this.iframes = /* @__PURE__ */ new Map(), m(this, at, P), m(this, Qa, A), m(this, Xa, N), this.enabledBy = "", m(this, en, H);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, xr).getValue("telemetry");
  }
  /**
   * @access private
   * This function forwards events to plugin. This is not meant for external use.
   * @param message Socket message forwarded to this plugin.
   */
  sendIframeEvent(t) {
    this.iframes.size && this.iframes.forEach((e) => {
      const { iframe: r } = e;
      r && (navigator.isReactNative ? r.postMessage(JSON.stringify(t)) : r.contentWindow.postMessage(t, "*"));
    });
  }
  handleIframeMessage(t) {
    return u(this, null, function* () {
      var o;
      if (!this.active)
        return;
      const e = t, { payload: r, uuid: i, type: n } = e;
      switch (n) {
        case W.customPluginEventToRoom: {
          a(this, at).customPluginEventToRoom(
            this.id,
            r,
            i
          );
          break;
        }
        case W.customPluginEventToPeers: {
          a(this, at).customPluginEventToPeers(
            this.id,
            r.peerIds,
            r,
            i
          );
          break;
        }
        case W.enablePluginForRoom: {
          a(this, at).enablePluginForRoom(this.id, i);
          break;
        }
        case W.enablePluginForPeers: {
          a(this, at).enablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.disablePluginForRoom: {
          a(this, at).disablePluginForRoom(this.id, i);
          break;
        }
        case W.disablePluginForPeers: {
          a(this, at).disablePluginForPeers(
            this.id,
            r.peerIds,
            i
          );
          break;
        }
        case W.storeInsertKeys: {
          a(this, at).storeInsertKeys(
            this.id,
            r.store,
            r.insertKeys,
            i
          );
          break;
        }
        case W.storeGetKeys: {
          a(this, at).storeGetKeys(
            this.id,
            r.store,
            r.getKeys,
            i
          );
          break;
        }
        case W.storeDeleteKeys: {
          a(this, at).storeDeleteKeys(
            this.id,
            r.store,
            r.deleteKeys,
            i
          );
          break;
        }
        case W.storeDelete: {
          a(this, at).storeDelete(this.id, r.store, i);
          break;
        }
        case Ie.chatMessage: {
          const {
            messagePayload: c,
            peerIds: d
          } = r;
          if (!a(this, Xa)) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { error: "Chat is disabled for this room." }
            });
            return;
          }
          try {
            yield a(this, Xa).sendMessage(c, d), this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: { success: !0 }
            });
          } catch (l) {
            this.sendIframeEvent({
              type: Ie.chatMessage,
              uuid: e.uuid,
              payload: {
                error: l
              }
            });
          }
          break;
        }
        case Ie.getPeer: {
          let c;
          const { peerId: d } = r, l = B(D({}, a(this, Ut)), {
            id: a(this, Ut).id,
            isRecorder: (o = a(this, Ut).permissions) == null ? void 0 : o.isRecorder,
            isHidden: a(this, Ut).permissions.hiddenParticipant,
            stageStatus: a(this, Ut).stageStatus
          });
          d ? (c = a(this, Qa).joined.get(r.peerId), a(this, Ut).id === d && (c = l)) : c = l, this.sendIframeEvent({
            type: Ie.getPeer,
            payload: { peer: c && Vd(c) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPeers: {
          const c = a(this, Qa).joined.toArray().map((d) => Vd(d));
          this.sendIframeEvent({
            type: Ie.getPeers,
            payload: { peers: c },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getPluginInitiator: {
          this.sendIframeEvent({
            type: Ie.getPluginInitiator,
            payload: { enabledBy: this.enabledBy },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getDisplayTitle: {
          this.sendIframeEvent({
            type: Ie.getDisplayTitle,
            payload: { displayTitle: a(this, en) },
            uuid: e.uuid
          });
          break;
        }
        case Ie.getRoomName: {
          this.sendIframeEvent({
            type: Ie.getRoomName,
            payload: { roomName: a(this, xr).getValue("meetingId") },
            uuid: e.uuid
          });
          break;
        }
        case Ie.customPluginEventToParent: {
          this.emit(e.payload.eventName, e.payload.data);
          break;
        }
      }
    });
  }
  sendData(t) {
    this.active && (this.logger.info("DytePlugin::SendData", {
      plugin: {
        id: this.id,
        name: this.name,
        data: {
          eventName: t.eventName
        }
      }
    }), this.sendIframeEvent({
      type: Ie.sendData,
      uuid: "",
      payload: t
    }));
  }
  /**
   * This method is used for cleaning up event listeners attached to an iframe. It must
   * be used before the iframe is removed from the DOM.
   * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
   */
  removePluginView(t = "default") {
    var i;
    const { iframe: e, listener: r } = (i = this.iframes.get(t)) != null ? i : {};
    (e || r) && (navigator.isReactNative ? e.props.onMessage = void 0 : window.removeEventListener("message", r), this.iframes.delete(t));
  }
  /**
   * This method adds the communcation layer between the plugin inside the iframe
   * and the core application (meeting object) in the main window.
   * @param iframe Iframe element to display this plugin.
   * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
   */
  addPluginView(t, e = "default") {
    var o;
    if (!a(this, Za))
      throw this.logger.error(
        "DytePlugin::addPluginView::no_auth_token_set_for_plugin"
      ), new R("No auth token set for plugin.", "0602");
    if (!t)
      throw this.logger.error("DytePlugin::addPluginView::iframe_was_not_provided"), new R("Iframe was not provided.", "0603");
    this.removePluginView(e);
    const r = t, i = new URL(this.baseURL), n = {
      auth: a(this, Za),
      parent: navigator.isReactNative ? this.baseURL : window.location.origin,
      backend: a(this, xr).getValue("apiBase"),
      pluginId: this.id,
      roomName: (o = a(this, xr).getValue("meetingId")) != null ? o : "",
      displayTitle: a(this, en)
    };
    if (Object.keys(n).forEach((c) => {
      i.searchParams.set(c, n[c]);
    }), r.src = i.href, r.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", r.title = e, navigator.isReactNative)
      r.props.onMessage = (c) => {
        this.handleIframeMessage(JSON.parse(c.nativeEvent.data));
      }, this.iframes.set(e, { iframe: r });
    else {
      const c = (d) => u(this, null, function* () {
        d.source === t.contentWindow && (yield this.handleIframeMessage(d.data));
      });
      window.addEventListener("message", c), this.iframes.set(e, { iframe: r, listener: c });
    }
  }
  setActive(t) {
    var e, r;
    if (this.active = t, t) {
      this.emit("stateUpdate", {
        active: this.active,
        pluginId: this.id,
        bind: this.addPluginView.bind(this),
        views: (e = this.config) == null ? void 0 : e.views
      });
      return;
    }
    this.active = !1, this.emit("stateUpdate", {
      active: this.active,
      pluginId: this.id,
      views: (r = this.config) == null ? void 0 : r.views
    });
  }
  /**
   * @access private
   * Not for external use
   */
  // NOTE(roerohan): Enable this plugin for the current user.
  activateForSelf() {
    return u(this, null, function* () {
      const t = lt(), e = yield t.authorizePlugin(this.id);
      m(this, Za, e), m(this, Ks, new Date());
      try {
        const r = yield t.getPluginConfig(this.baseURL);
        this.config = r;
      } catch (r) {
        this.logger.error("DytePlugin::activateForSelf", { error: r });
      }
      this.setActive(!0), this.emit("enabled");
    });
  }
  /**
   * @access private
   * Not for external use
   */
  // NOTE(roerohan): Disable this plugin for the current user.
  deactivateForSelf() {
    Array.from(this.iframes.keys()).forEach((t) => {
      this.removePluginView(t);
    }), m(this, Ks, void 0), this.iframes.clear(), this.setActive(!1), this.emit("closed");
  }
  /**
   * @deprecated
   */
  enable() {
    return u(this, null, function* () {
      return this.activateForSelf();
    });
  }
  /**
   * @deprecated
   */
  disable() {
    return this.deactivateForSelf();
  }
  activate() {
    return u(this, null, function* () {
      var t, e;
      this.active || (e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canStart && (a(this, at).addPlugin(this.id, this.staggered), m(this, Ks, new Date()), this.logger.info("plugin::activated", {
        plugin: {
          id: this.id,
          enabledBy: this.enabledBy,
          name: this.name
        }
      }));
    });
  }
  deactivate() {
    return u(this, null, function* () {
      var t, e;
      this.active && (!((e = (t = a(this, Ut).permissions) == null ? void 0 : t.plugins) != null && e.canClose) && this.enabledBy !== a(this, Ut).id || (a(this, at).removePlugin(this.id), this.logger.info("plugin::deactivated", {
        plugin: {
          id: this.id,
          name: this.name,
          duration: a(this, Ks) ? new Date().getTime() - a(this, Ks).getTime() : 0
        }
      }), m(this, Ks, void 0)));
    });
  }
}, at = new WeakMap(), Ut = new WeakMap(), Qa = new WeakMap(), Xa = new WeakMap(), Ks = new WeakMap(), Za = new WeakMap(), xr = new WeakMap(), en = new WeakMap(), Vg);
Wl([
  Dt({ maxInvocations: 5, period: 1 })
], Wn.prototype, "sendData", 1);
Wl([
  E.trace("DytePlugin.activatePlugin")
], Wn.prototype, "activate", 1);
Wl([
  E.trace("DytePlugin.deactivatePlugin")
], Wn.prototype, "deactivate", 1);
Wn = Wl([
  ht("0600")
], Wn);
var Ne, Ci;
class Vf extends Map {
  constructor(e, r = void 0) {
    const {
      onAddEvent: i,
      onDeleteEvent: n,
      onClearEvent: o
    } = e;
    super();
    g(this, Ne, void 0);
    g(this, Ci, void 0);
    h(this, "onAddEvent");
    h(this, "onDeleteEvent");
    h(this, "onClearEvent");
    m(this, Ne, new Jn(r)), this.onAddEvent = i, this.onDeleteEvent = n, this.onClearEvent = o, m(this, Ci, /* @__PURE__ */ new Map());
  }
  emit(e, ...r) {
    return a(this, Ne).emit(e, ...r);
  }
  on(e, r) {
    return a(this, Ne).on(e, r);
  }
  addListener(e, r) {
    return a(this, Ne).addListener(e, r);
  }
  off(e, r) {
    return a(this, Ne).off(e, r);
  }
  once(e, r) {
    return a(this, Ne).once(e, r);
  }
  prependListener(e, r) {
    return a(this, Ne).prependListener(e, r);
  }
  prependOnceListener(e, r) {
    return a(this, Ne).prependOnceListener(e, r);
  }
  removeListener(e, r) {
    return a(this, Ne).removeListener(e, r);
  }
  removeAllListeners(e) {
    return a(this, Ne).removeAllListeners(e);
  }
  listeners(e) {
    return a(this, Ne).listeners(e);
  }
  listenerCount(e) {
    return a(this, Ne).listenerCount(e);
  }
  getMaxListeners() {
    return a(this, Ne).getMaxListeners();
  }
  setMaxListeners(e) {
    return a(this, Ne).setMaxListeners(e);
  }
  eventNames() {
    return a(this, Ne).eventNames();
  }
  add(e, r = !0) {
    return this.set(e.id, e, r);
  }
  set(e, r, i = !0) {
    const n = super.set(e, r), o = (c, ...d) => {
      this.emit(c, r, ...d);
    };
    return a(this, Ci).set(e, o), r.on("*", o), i && a(this, Ne).emit(this.onAddEvent, r), n;
  }
  delete(e, r = !0, i = !1) {
    const n = this.get(e);
    if (!n)
      return !1;
    n.removeListener("*", a(this, Ci).get(e));
    const o = super.delete(e);
    return i && n.removeAllListeners(), r && a(this, Ne).emit(this.onDeleteEvent, n), o;
  }
  clear(e = !0, r = !1) {
    this.forEach((n) => {
      n.removeListener("*", a(this, Ci).get(n.id)), r && n.removeAllListeners();
    });
    const i = super.clear();
    return e && a(this, Ne).emit(this.onClearEvent), i;
  }
  toArray() {
    return Array.from(this.values());
  }
}
Ne = new WeakMap(), Ci = new WeakMap();
class ug extends Vf {
  constructor(t) {
    super({
      onAddEvent: "pluginAdded",
      onDeleteEvent: "pluginDeleted"
    }, t);
  }
  add(t, e = !0) {
    return super.add(t, e);
  }
  delete(t, e = !0, r = !1) {
    return super.delete(t, e, r);
  }
}
var $M = Object.defineProperty, FM = Object.getOwnPropertyDescriptor, HM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? FM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && $M(t, e, i), i;
};
let Wu = class {
  constructor(s) {
    /**
     * All plugins accessible by the current user.
     */
    h(this, "all");
    /**
     * All plugins that are currently enabled in the room.
     */
    h(this, "active");
    this.all = new ug(s), this.active = new ug(s);
  }
};
Wu = HM([
  ht("0600")
], Wu);
var BM = Object.defineProperty, qM = Object.getOwnPropertyDescriptor, Jl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? qM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && BM(t, e, i), i;
}, Qt, tn, ls, Lg;
const Lf = (Lg = class {
  constructor(s, t, e, r) {
    h(this, "plugins");
    g(this, Qt, void 0);
    g(this, tn, void 0);
    g(this, ls, void 0);
    m(this, Qt, t), m(this, tn, e), m(this, ls, s), this.plugins = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ls).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, ls).getValue("logger");
  }
  static init(s, t, e, r, i, n, o, c) {
    return u(this, null, function* () {
      const d = s.getValue("logger"), l = new Wu(d);
      return t.forEach((p) => {
        const f = new Wn(
          s,
          p,
          e,
          n,
          o,
          i,
          c
        );
        l.all.add(f);
      }), new Lf(
        s,
        e,
        r,
        l
      );
    });
  }
  getRoomPlugins() {
    return u(this, null, function* () {
      var t;
      const { plugins: s } = yield a(this, Qt).getActivePlugins();
      (t = this.plugins.active) == null || t.toArray().forEach((e) => {
        this.disablePlugin({ id: e.id });
      }), yield Promise.all(
        s.map(
          (e) => this.enablePlugin({
            id: e.pluginId,
            enabledBy: e.enabledBy
          })
        )
      );
    });
  }
  enablePlugin(e) {
    return u(this, arguments, function* ({
      id: s,
      enabledBy: t
    }) {
      const r = this.plugins.all.get(s);
      r && (yield r.activateForSelf(), r.enabledBy = t);
    });
  }
  disablePlugin(t) {
    return u(this, arguments, function* ({ id: s }) {
      const e = this.plugins.all.get(s);
      e && e.deactivateForSelf();
    });
  }
  sendIframeEvent(s, t, e, r) {
    const i = this.plugins.all.get(t);
    i && i.sendIframeEvent({ type: s, uuid: e, payload: r });
  }
  broadcastIframeEvent(s, t) {
    this.plugins.active.forEach((e) => {
      this.sendIframeEvent(s, e.id, "", t);
    });
  }
  setupEvents() {
    this.plugins.all.on(
      "stateUpdate",
      ({ active: s, id: t }) => {
        if (s) {
          this.plugins.active.add(this.plugins.all.get(t));
          return;
        }
        this.plugins.active.delete(t);
      }
    ), a(this, ls).getValue("peerSessionStore").onAsync(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      yield this.getRoomPlugins(), this.logger.debug("[SOCKET_SERVICE_ROOM_JOINED] resolved request to fetch plugins.");
    })), a(this, Qt).on(
      W.addPlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active || (yield this.enablePlugin({ id: t, enabledBy: s.enabledBy }));
      })
    ), a(this, Qt).on(
      W.removePlugin,
      (s) => u(this, null, function* () {
        var e;
        const t = s.pluginId;
        (e = this.plugins.all.get(t)) != null && e.active && (yield this.disablePlugin({ id: t }));
      })
    ), [
      W.enablePluginForPeers,
      W.enablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            enabledBy: t.enabledBy
          });
        })
      );
    }), [
      W.disablePluginForPeers,
      W.disablePluginForRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            disabledBy: t.disabledBy
          });
        })
      );
    }), [
      W.customPluginEventToPeers,
      W.customPluginEventToRoom
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          this.sendIframeEvent(s, t.pluginId, e, {
            data: JSON.parse(
              new TextDecoder().decode(t.pluginData)
            )
          });
        })
      );
    }), [
      W.storeInsertKeys,
      W.storeGetKeys,
      W.storeDeleteKeys
    ].forEach((s) => {
      a(this, Qt).on(
        s,
        (t, e) => u(this, null, function* () {
          var i;
          const r = (i = t.storeItems) == null ? void 0 : i.map((n) => {
            var o;
            return {
              timestamp: n.timestamp,
              peerId: n.peerId,
              payload: JSON.parse(
                (o = n.payload) != null && o.length ? new TextDecoder().decode(n.payload) : "{}"
              ),
              key: n.storeKey
            };
          });
          this.sendIframeEvent(s, t.pluginId, e, {
            storeName: t.storeName,
            storeItems: r
          });
        })
      );
    }), a(this, Qt).on(
      W.storeDelete,
      (s, t) => u(this, null, function* () {
        this.sendIframeEvent(W.storeDelete, s.pluginId, t, {
          storeName: s.storeName
        });
      })
    ), a(this, tn).on(
      Re.sendMessageToPeers,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, tn).on(
      Re.sendMessageToRoom,
      (s) => {
        const t = Es == null ? void 0 : Es.formatSocketServiceMessage(
          s.message
        );
        this.broadcastIframeEvent(Ie.chatMessage, { message: t });
      }
    ), a(this, ls).getValue("peerSessionStore").on(k.PEER_JOINED_INTERNAL, (s) => {
      const t = Vd(s);
      this.broadcastIframeEvent(Ie.peerJoined, t);
    }), a(this, ls).getValue("peerSessionStore").on(k.PEER_CLOSED, (s) => {
      this.broadcastIframeEvent(Ie.peerLeft, s);
    }), a(this, ls).getValue("peerSessionStore").on(k.UPDATE_PEER_STAGE_STATUS, (s) => {
      this.broadcastIframeEvent(Ie.peerStageStatusUpdate, s);
    }), a(this, ls).subscribe("stageStatus", (s) => {
      this.broadcastIframeEvent(Ie.stageStatusUpdate, s);
    });
  }
}, Qt = new WeakMap(), tn = new WeakMap(), ls = new WeakMap(), Lg);
let Kc = Lf;
Jl([
  E.trace("PluginController.getRoomPlugins")
], Kc.prototype, "getRoomPlugins", 1);
Jl([
  E.trace("PluginController.enableForSelf")
], Kc.prototype, "enablePlugin", 1);
Jl([
  E.trace("PluginController.disableForSelf")
], Kc.prototype, "disablePlugin", 1);
Jl([
  E.trace("PluginController.setupEvents")
], Kc.prototype, "setupEvents", 1);
var Ko;
class jM {
  constructor(t) {
    h(this, "mediaJoined");
    h(this, "socketJoined");
    h(this, "socketJoinAttempted");
    h(this, "mediaJoinAttempted");
    h(this, "socketState");
    h(this, "mediaState");
    g(this, Ko, void 0);
    this.mediaJoined = !1, this.socketJoined = !1, this.socketJoinAttempted = !1, this.mediaJoinAttempted = !1, this.socketState = {
      state: void 0,
      reconnected: !1,
      reconnectionAttempt: void 0
    }, this.mediaState = {
      recv: void 0,
      send: void 0
    }, m(this, Ko, t);
  }
  get joinAttempted() {
    return this.mediaJoinAttempted || this.socketJoinAttempted;
  }
  get roomJoined() {
    return this.mediaJoined && this.socketJoined;
  }
  updateSocketConnectionState(t, e) {
    let r;
    const { reconnected: i } = this.socketState;
    switch (t) {
      case "connected":
        r = {
          state: "connected",
          reconnected: i,
          reconnectionAttempt: void 0
        };
        break;
      case "disconnected":
        r = {
          state: "disconnected",
          reconnected: !1,
          reconnectionAttempt: 0
        }, this.socketJoined = !1;
        break;
      case "reconnected":
        r = {
          state: "connected",
          reconnected: !0,
          reconnectionAttempt: void 0
        };
        break;
      case "reconnecting":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: 0
        };
        break;
      case "reconnectAttempt":
        r = {
          state: "reconnecting",
          reconnected: i,
          reconnectionAttempt: e
        };
        break;
      case "failed":
        r = {
          state: "failed",
          reconnected: i,
          reconnectionAttempt: void 0
        }, this.socketJoined = !1;
        break;
    }
    r && (a(this, Ko).getValue("peerSessionStore").emit(k.SOCKET_STATE_UPDATE, r), this.socketState = r);
  }
}
Ko = new WeakMap();
var GM = Object.defineProperty, WM = Object.getOwnPropertyDescriptor, zc = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? WM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && GM(t, e, i), i;
}, sn, rn, an, yd, xg;
let ga = (xg = class extends qt {
  constructor(t, e) {
    const r = t.getValue("logger");
    super(r);
    g(this, an);
    g(this, sn, void 0);
    g(this, rn, void 0);
    h(this, "recordingPeerIds", []);
    h(this, "recordings", []);
    m(this, rn, t), m(this, sn, e);
  }
  get recordingState() {
    return this.recordings.some((t) => t.state === "RECORDING") ? "RECORDING" : this.recordings.some((t) => t.state === "PAUSED") ? "PAUSED" : this.recordings.some((t) => t.state === "STARTING") ? "STARTING" : this.recordings.some((t) => t.state === "STOPPING") ? "STOPPING" : "IDLE";
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, rn).getValue("telemetry");
  }
  updateRecordings(t) {
    this.recordings = t, this.emit("recordingUpdate", this.recordingState);
  }
  start(t) {
    return u(this, null, function* () {
      if (!a(this, sn).permissions.canRecord)
        throw this.logger.error("DyteRecording::start::permission_denied"), new R("User does not have permission to start recording", "1001");
      if ((t == null ? void 0 : t.allowMultiple) !== !0 && (this.recordingState === "STARTING" || this.recordingState === "RECORDING" || this.recordingState === "STOPPING"))
        throw this.logger.error("DyteRecording::start::recording_in_progress", {
          recording: {
            state: this.recordingState
          }
        }), new R(
          `Cant start recording, recordingState irregular: ${this.recordingState}`,
          "1005"
        );
      try {
        const e = lt(), { recording: r = {} } = a(this, rn).getValue("defaults"), i = yield e.startRecording(r, t == null ? void 0 : t.allowMultiple);
        this.updateRecordings([...this.recordings, {
          id: i,
          state: "STARTING",
          type: "BROWSER"
        }]);
      } catch (e) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_start", {
          error: e
        }), new R("Error while starting recording", "1000", this.logger);
      }
    });
  }
  stop(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "stop", ["RECORDING", "PAUSED"], t);
    });
  }
  pause(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "pause", ["RECORDING"], t);
    });
  }
  resume(t) {
    return u(this, null, function* () {
      yield L(this, an, yd).call(this, "resume", ["PAUSED"], t);
    });
  }
}, sn = new WeakMap(), rn = new WeakMap(), an = new WeakSet(), yd = function(t, e, r) {
  return u(this, null, function* () {
    if (!a(this, sn).permissions.canRecord)
      throw this.logger.error("DyteRecording::stop::permission_denied"), new R("User does not have permission to stop recording", "1001");
    let i = [];
    if (r !== void 0) {
      const n = this.recordings.find((o) => o.id === r);
      if (n === void 0)
        throw new R("Could not find the specified recording", "1004");
      if (e.includes(n.state)) {
        this.logger.error("DyteRecording::stop::recording_not_in_expected_state", {
          recording: {
            state: n.state
          }
        });
        return;
      }
      i.push(n);
    } else
      i = this.recordings.filter((n) => e.includes(n.state));
    i.forEach((n) => u(this, null, function* () {
      const o = n.state;
      t === "stop" && (n.state = "STOPPING", this.emit("recordingUpdate", "STOPPING"));
      try {
        yield lt().updateRecording(n.id, t);
      } catch (c) {
        throw this.logger.error("DyteRecording::stop::recording_failed_to_stop", {
          error: c
        }), n.state !== o && (n.state = o, this.emit("recordingUpdate", o)), new R("Error while stopping recording", "1000", this.logger);
      }
    }));
  });
}, xg);
zc([
  E.trace("DyteRecording.start")
], ga.prototype, "start", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "stop", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "pause", 1);
zc([
  E.trace("DyteRecording.stop")
], ga.prototype, "resume", 1);
ga = zc([
  ht("1000")
], ga);
var JM = Object.defineProperty, KM = Object.getOwnPropertyDescriptor, zM = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JM(t, e, i), i;
}, Ri;
class xf {
  constructor(t, e, r) {
    h(this, "recording");
    h(this, "room");
    g(this, Ri, void 0);
    m(this, Ri, t), this.recording = new ga(t, e), this.room = r, this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ri).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ri).getValue("logger");
  }
  // eslint-disable-next-line class-methods-use-this
  getRecordingTypeFromProtoType(t) {
    let e;
    switch (t) {
      case la.BROWSER:
        e = "BROWSER";
        break;
      case la.COMPOSITE:
        e = "COMPOSITE";
        break;
      case la.TRACK:
        e = "TRACK";
        break;
      default:
        e = "BROWSER";
    }
    return e;
  }
  setupEvents() {
    a(this, Ri).getValue("peerSessionStore").on(k.ROOM_STATE, (t) => {
      t.activeRecordings.length !== 0 ? this.recording.updateRecordings(
        t.activeRecordings.map((e) => {
          const r = this.getRecordingTypeFromProtoType(e.recordingType);
          return { id: e.recordingId, state: e.recordingStatus, type: r };
        })
      ) : this.recording.recordings.length && this.recording.updateRecordings([]);
    }), this.room.on(x.recordingStarted, (t) => {
      let e = !1;
      const r = [...this.recording.recordings];
      if (r.forEach((i) => {
        i.id === t.recordingId && (e = !0, i.state = "RECORDING");
      }), e === !1) {
        const i = this.getRecordingTypeFromProtoType(t.recordingType);
        r.push({
          id: t.recordingId,
          state: "RECORDING",
          type: i
        });
      }
      this.recording.updateRecordings(r);
    }), this.room.on(x.recordingPaused, (t) => {
      const e = [...this.recording.recordings];
      e.forEach((r) => {
        r.id === t.recordingId && (r.state = "PAUSED");
      }), this.recording.updateRecordings(e);
    }), this.room.on(x.recordingStopped, (t) => {
      const e = [...this.recording.recordings.filter((r) => r.id !== t.recordingId)];
      this.recording.updateRecordings(e);
    });
  }
}
Ri = new WeakMap();
zM([
  E.trace("RecordingController.setupEvents")
], xf.prototype, "setupEvents", 1);
var wi;
class YM {
  constructor(t) {
    g(this, wi, void 0);
    m(this, wi, t);
  }
  hasFeature(t) {
    var e;
    return (e = a(this, wi).getValue("flagsmith").hasFeature(t)) != null ? e : !1;
  }
  getFeatureValue(t) {
    return a(this, wi).getValue("flagsmith").getValue(t);
  }
  getAllFeatures() {
    return a(this, wi).getValue("flagsmith").getAllFlags();
  }
}
wi = new WeakMap();
class Vh {
  constructor(t, e, r) {
    h(this, "logger");
    h(this, "features");
    h(this, "browserSpecs");
    h(this, "callStats");
    this.logger = t, this.features = e, this.browserSpecs = Te, this.callStats = r;
  }
  static init(t) {
    return new Vh(t.getValue("logger"), new YM(t), t.getValue("callstats"));
  }
}
class Lh {
  constructor(t) {
    h(this, "internals");
    this.internals = t;
  }
  static init(t) {
    return u(this, null, function* () {
      const e = Vh.init(t);
      return new Lh(e);
    });
  }
}
var QM = Object.defineProperty, XM = Object.getOwnPropertyDescriptor, Gt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XM(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QM(t, e, i), i;
}, qe, ve, ge, zs, Xt, zo, ke;
class Ot extends Jn {
  constructor(e, r, i = Ju, n = !0) {
    const o = e.getValue("logger");
    super(o);
    g(this, qe, void 0);
    g(this, ve, void 0);
    g(this, ge, void 0);
    g(this, zs, void 0);
    g(this, Xt, void 0);
    g(this, zo, void 0);
    g(this, ke, void 0);
    h(this, "audioUpdateInProgress");
    h(this, "videoUpdateInProgress");
    m(this, ke, e), this.audioUpdateInProgress = !1, this.videoUpdateInProgress = !1, m(this, qe, new Uf(e, r)), m(this, ve, new T0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, ge, new b0(
      e,
      a(this, qe),
      void 0,
      i
    )), m(this, Xt, new C0(
      a(this, ke),
      a(this, qe)
    )), m(this, zs, new _0(
      a(this, qe)
    )), m(this, zo, n), a(this, ve).on("trackMuted", this.onAudioTrackMuted.bind(this)), a(this, ve).on(
      "trackChanged",
      this.onAudioTrackChanged.bind(this)
    ), a(this, ge).on(
      "trackChanged",
      this.onVideoTrackChanged.bind(this)
    ), a(this, ge).on("trackEnded", this.onVideoTrackEnded.bind(this)), a(this, Xt).on(
      "trackEnded",
      this.onScreenShareEnded.bind(this)
    ), this.onVisibilityChange = this.onVisibilityChange.bind(this), document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ke).getValue("telemetry");
  }
  set context(e) {
    m(this, ke, e);
  }
  // eslint-disable-next-line class-methods-use-this
  onVisibilityChange() {
    return u(this, null, function* () {
      a(this, ke).getValue("callstats").tabChanged(document.visibilityState === "visible"), document.visibilityState !== "visible" ? a(this, ke).getValue("callstats").browserBackgrounded() : (a(this, ke).getValue("callstats").browserForegrounded(), yield this.setupSpeaker());
    });
  }
  // eslint-disable-next-line class-methods-use-this
  repopulateAvailableDevices() {
    return u(this, null, function* () {
      return !0;
    });
  }
  setupStreams(i) {
    return u(this, arguments, function* ({
      audio: e,
      video: r
    }) {
      var c;
      e ? a(this, ke).getValue("callstats").audioOn() : a(this, ke).getValue("callstats").audioOff(), r ? a(this, ke).getValue("callstats").videoOn() : a(this, ke).getValue("callstats").videoOff();
      let n, o;
      if (e && r)
        try {
          const d = yield a(this, qe).getAudioAndVideoTrack(
            a(this, ve).userSelectedDevice,
            a(this, ge).userSelectedDevice
          );
          n = d.audioTrack, o = d.videoTrack;
        } catch (d) {
          this.logger.error(
            "LocalMediaHandler::init::Failed to get audio video tracks",
            {
              error: d
            }
          );
        }
      if (!n && e)
        try {
          n = yield a(this, qe).getAudioTrack(
            !1,
            a(this, ve).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get audio track", {
            error: d
          });
        }
      if (!o && r)
        try {
          o = yield a(this, qe).getVideoTrack(
            a(this, ge).userSelectedDevice
          );
        } catch (d) {
          this.logger.error("LocalMediaHandler::init::Failed to get video track", {
            error: d
          });
        }
      e && !n && a(this, ke).getValue("callstats").audioOff(), r && !o && a(this, ke).getValue("callstats").videoOff(), yield a(this, ve).setMediaTrack(n), yield a(this, ge).setMediaTrack(o);
      try {
        this.setupSpeaker();
      } catch (d) {
      }
      if (o) {
        const d = yield this.getDeviceById(o.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("VIDEO", d);
      }
      if (n) {
        const d = yield this.getDeviceById(n.getSettings().deviceId);
        a(this, ke).getValue("callstats").selectedDevice("AUDIO", d);
      }
      (c = a(this, zs).currentDevice) != null && c.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", a(this, zs).currentDevice), a(this, qe).onDeviceChange((d, l, p) => {
        this.onDeviceChange(l, p);
      });
    });
  }
  getCurrentDevices() {
    return {
      audio: a(this, ve).currentDevice,
      video: a(this, ge).currentDevice,
      speaker: a(this, zs).currentDevice
    };
  }
  get permissions() {
    return a(this, qe).permissions;
  }
  getAllDevices() {
    return a(this, qe).getAvailableDevices();
  }
  getDeviceById(e, r) {
    return a(this, qe).getDevice(e);
  }
  /**
   * Audio Input Handler
   */
  onAudioTrackMuted() {
    this.emit("AUDIO_TRACK_SILENT");
  }
  onAudioTrackChanged() {
    this.emit("AUDIO_TRACK_CHANGE");
  }
  get rawAudioTrack() {
    return a(this, ve).mediaTrack;
  }
  get audioTrack() {
    return a(this, ve).transformedMediaTrack;
  }
  get audioEnabled() {
    return a(this, ve).trackEnabled;
  }
  enableAudio(e) {
    return u(this, null, function* () {
      if (!this.audioUpdateInProgress) {
        this.audioUpdateInProgress = !0;
        try {
          e ? yield a(this, ve).enableTrack(!1, e) : yield a(this, ve).unmuteTrack();
        } catch (r) {
        } finally {
          this.audioUpdateInProgress = !1;
        }
      }
    });
  }
  disableAudio() {
    a(this, ve).mediaTrack && !a(this, ve).isCustomTrack ? a(this, ve).muteTrack() : a(this, ve).disableTrack();
  }
  getAudioDevices(e) {
    return a(this, qe).getAudioInputDevices(e);
  }
  setAudioDevice(e) {
    return u(this, null, function* () {
      yield a(this, ve).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("AUDIO", e), this.emit("AUDIO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  /**
   * Audio Output Handler
   */
  setupSpeaker() {
    return u(this, null, function* () {
      const { speaker: e } = this.getCurrentDevices();
      yield a(this, zs).setupSpeaker();
      const { speaker: r } = this.getCurrentDevices();
      (e == null ? void 0 : e.deviceId) !== (r == null ? void 0 : r.deviceId) && r && this.emit("DEVICE_CHANGE", { device: r });
    });
  }
  setSpeakerDevice(e) {
    return u(this, null, function* () {
      yield a(this, zs).setupSpeaker(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("SPEAKER", e), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  /**
   * Video Handler
   */
  onVideoTrackChanged() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  onVideoTrackEnded() {
    this.emit("VIDEO_TRACK_CHANGE");
  }
  get rawVideoTrack() {
    return a(this, ge).mediaTrack;
  }
  get videoTrack() {
    return a(this, ge).transformedMediaTrack;
  }
  get videoEnabled() {
    return a(this, ge).trackEnabled;
  }
  enableVideo(e) {
    return u(this, null, function* () {
      if (!this.videoUpdateInProgress) {
        this.videoUpdateInProgress = !0;
        try {
          e ? yield a(this, ge).enableTrack(!1, e) : yield a(this, ge).unmuteTrack();
        } catch (r) {
        } finally {
          this.videoUpdateInProgress = !1;
        }
      }
    });
  }
  disableVideo() {
    a(this, ge).disableTrack();
  }
  getVideoDevices(e) {
    return a(this, qe).getVideoInputDevices(e);
  }
  setVideoDevice(e) {
    return u(this, null, function* () {
      yield a(this, ge).setDevice(e), e != null && e.deviceId && a(this, ke).getValue("callstats").selectedDevice("VIDEO", e), this.emit("VIDEO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
    });
  }
  updateVideoConstraints(e) {
    return u(this, null, function* () {
      yield a(this, ge).updateConstraints(e);
    });
  }
  /**
   * Screen Share Handler
   */
  onScreenShareEnded() {
    this.emit("SCREENSHARE_ENDED");
  }
  get screenShareTracks() {
    return {
      audio: a(this, Xt).audioMediaTrack,
      video: a(this, Xt).videoMediaTrack
    };
  }
  get screenShareEnabled() {
    return a(this, Xt).trackEnabled;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield a(this, Xt).enableScreenShare();
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      a(this, Xt).disableScreenShare();
    });
  }
  updateScreenshareConstraints(e) {
    return u(this, null, function* () {
      yield a(this, Xt).updateConstraints(e);
    });
  }
  getSpeakerDevices(e) {
    return a(this, qe).getAudioOutputDevices(e);
  }
  /**
   * Middleware Utility
   */
  addAudioMiddleware(e) {
    return a(this, ve).addMiddleware(e);
  }
  removeAudioMiddleware(e) {
    return a(this, ve).removeMiddleware(e);
  }
  removeAllAudioMiddlewares() {
    return a(this, ve).removeAllMiddlewares();
  }
  addVideoMiddleware(e) {
    return a(this, ge).addMiddleware(e);
  }
  removeVideoMiddleware(e) {
    return a(this, ge).removeMiddleware(e);
  }
  removeAllVideoMiddlewares() {
    return a(this, ge).removeAllMiddlewares();
  }
  setVideoMiddlewareGlobalConfig(e) {
    return a(this, ge).setVideoMiddlewareGlobalConfig(e);
  }
  destruct() {
    a(this, ve).disableTrack(), a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker(), a(this, Xt).disableScreenShare(), a(this, qe).destruct();
  }
  onDeviceChange(e, r) {
    return u(this, null, function* () {
      var i, n;
      this.emit("DEVICE_LIST_UPDATED", e), !(r || !a(this, zo)) && ((i = e == null ? void 0 : e.added) == null || i.forEach((o) => u(this, null, function* () {
        var c;
        o && !Ju(o) && (o.kind === "audioinput" && ((c = this.audioTrack) == null ? void 0 : c.enabled) === !0 ? yield this.setAudioDevice(o) : o.kind === "audiooutput" && (yield this.setSpeakerDevice(o)));
      })), (n = e == null ? void 0 : e.removed) == null || n.forEach((o) => u(this, null, function* () {
        var c;
        if (o.kind === "audiooutput" && ((c = this.getCurrentDevices().speaker) == null ? void 0 : c.deviceId) === o.deviceId) {
          const d = (yield this.getSpeakerDevices()).find((l) => l.deviceId !== o.deviceId);
          d && (yield this.setSpeakerDevice(d));
        }
      })));
    });
  }
  /**
   * Backward Compatibility
   */
  removeAllTracks() {
    this.destruct();
  }
  /**
   * NOTE(ravindra-dyte):
   * Purpose of this function is to ensure a way to reset tracks.
   * Our EdTech clients also call getUserMedia for their own proctoring systems,
   * which can cause our tracks to be blank despite having enabled true.
   *
   * To ensure that they can cleanup our tracks and re-request tracks,
   *  we need to remove the existing tracks.
   */
  removeAudioTrack() {
    a(this, ve).disableTrack();
  }
  /**
   * NOTE(ravindra-dyte):
   * Purpose of this function is to ensure a way to reset tracks.
   * Our EdTech clients also call getUserMedia for their own proctoring systems,
   * which can cause our tracks to be blank despite having enabled true.
   *
   * To ensure that they can cleanup our tracks and re-request tracks,
   *  we need to remove the existing tracks.
   */
  removeVideoTrack() {
    a(this, ge).disableTrack(), a(this, ge).terminateMiddlewareWebWorker();
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      document.removeEventListener("visibilitychange", this.onVisibilityChange);
    });
  }
}
qe = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), zs = new WeakMap(), Xt = new WeakMap(), zo = new WeakMap(), ke = new WeakMap();
Gt([
  E.trace("MediaHandler.setupStreams")
], Ot.prototype, "setupStreams", 1);
Gt([
  E.trace("MediaHandler.enableAudio")
], Ot.prototype, "enableAudio", 1);
Gt([
  E.trace("MediaHandler.disableAudio")
], Ot.prototype, "disableAudio", 1);
Gt([
  E.trace("MediaHandler.setAudioDevice")
], Ot.prototype, "setAudioDevice", 1);
Gt([
  E.trace("MediaHandler.enableVideo")
], Ot.prototype, "enableVideo", 1);
Gt([
  E.trace("MediaHandler.disableVideo")
], Ot.prototype, "disableVideo", 1);
Gt([
  E.trace("MediaHandler.setVideoDevice")
], Ot.prototype, "setVideoDevice", 1);
Gt([
  E.trace("MediaHandler.updateVideoConstraints")
], Ot.prototype, "updateVideoConstraints", 1);
Gt([
  E.trace("MediaHandler.enableScreenShare")
], Ot.prototype, "enableScreenShare", 1);
Gt([
  E.trace("MediaHandler.disableScreenShare")
], Ot.prototype, "disableScreenShare", 1);
Gt([
  E.trace("MediaHandler.updateScreenshareConstraints")
], Ot.prototype, "updateScreenshareConstraints", 1);
Gt([
  E.trace("MediaHandler.destruct")
], Ot.prototype, "destruct", 1);
Gt([
  E.trace("MediaHandler.onDeviceChange")
], Ot.prototype, "onDeviceChange", 1);
function cd(s, t, e) {
  switch (!0) {
    case Te.isChromiumBased():
      switch (t) {
        case "NotAllowedError":
          return e.includes("by system") ? "SYSTEM_DENIED" : s === "screenshare" ? "CANCELED" : "DENIED";
        case "NotReadableError":
        default:
          return "COULD_NOT_START";
      }
    case Te.isSafari():
      switch (t) {
        case "NotAllowedError":
          return "DENIED";
        default:
          return "COULD_NOT_START";
      }
    case Te.isFirefox():
      switch (t) {
        case "NotFoundError":
        case "NotReadableError":
          return "SYSTEM_DENIED";
        case "NotAllowedError":
          return "DENIED";
        case "AbortError":
        default:
          return "COULD_NOT_START";
      }
    default:
      return "COULD_NOT_START";
  }
}
const ZM = [
  "virtual",
  "emulator",
  "krisp",
  "solstice conference",
  "teams",
  "loom",
  "zoom",
  "manycam",
  "blackhole",
  "displayport",
  "xsplit",
  // XSplit virtual camera
  "wirecast",
  // Wirecast virtual camera
  "vMix",
  // vMix virtual camera
  "elgato",
  // Elgato virtual camera
  "epiphan",
  // Epiphan virtual camera
  "voice changer",
  // Some voice changer software
  "voicemod",
  // Voicemod virtual audio device
  "morphvoxx"
  // MorphVOXX virtual audio device
];
function Ju(s) {
  var e, r;
  const t = (e = s.label) == null ? void 0 : e.toLowerCase();
  return ((r = Te._bowser) == null ? void 0 : r.getOSName()) === "macOS" && t.includes("iphone") ? !0 : ZM.some(
    (i) => t == null ? void 0 : t.includes(i)
  );
}
function e0(s, t, e) {
  return u(this, null, function* () {
    if (!(t != null && t.length))
      return e;
    const r = s.getValue("logger"), i = new AudioContext(), n = yield Promise.all(
      t == null ? void 0 : t.map((d) => d(i))
    ), o = i.createMediaStreamSource(
      new MediaStream([e])
    ), c = i.createMediaStreamDestination();
    try {
      let d = o;
      for (let l = 0; l < n.length; l += 1)
        d.connect(n[l]), d = n[l];
      d.connect(c);
    } catch (d) {
      return r.error("getTransformedAudioTrack::middleware_execution_failed", {
        error: d
      }), e;
    }
    return c.stream.getAudioTracks()[0];
  });
}
var bi, Yo;
class t0 {
  constructor(t) {
    g(this, bi, void 0);
    g(this, Yo, void 0);
    m(this, Yo, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Yo).getValue("logger");
  }
  terminateMiddlewareWebWorker() {
    if (a(this, bi))
      try {
        ud.clearInterval(a(this, bi)), m(this, bi, void 0);
      } catch (t) {
        this.logger.debug("WorkerTimers::terminateMiddlewareWebWorker::failed");
      }
  }
  getTransformedVideoTrack(t, e, r) {
    return u(this, null, function* () {
      if (!(t != null && t.length))
        return e;
      const i = document.createElement("canvas"), n = yield Promise.all(
        t == null ? void 0 : t.map((S) => S({
          canvas: i,
          WorkerTimers: ud
        }))
      );
      if (r.disablePerFrameCanvasRendering) {
        const T = i.captureStream().getVideoTracks()[0];
        return Object.defineProperty(T, "originalSettings", {
          value: e.getSettings()
        }), T;
      }
      const o = document.createElement("video"), c = new MediaStream();
      c.addTrack(e);
      const d = i.getContext("2d");
      o.srcObject = c, o.autoplay = !0, this.terminateMiddlewareWebWorker();
      const l = () => u(this, null, function* () {
        if (e.enabled === !1 || e.readyState === "ended") {
          this.terminateMiddlewareWebWorker(), o.remove(), i.remove();
          return;
        }
        try {
          d.drawImage(o, 0, 0);
          for (let S = 0; S < n.length; S += 1)
            typeof n[S] == "function" && (yield n[S](
              i,
              d
            ));
        } catch (S) {
          this.logger.error(
            "getTransformedVideoTrack::middleware_execution_failed",
            { error: S }
          );
        }
      });
      try {
        o.play();
      } catch (S) {
      }
      o.addEventListener(
        "play",
        () => {
          i.width = o.width || e.getSettings().width, i.height = o.width || e.getSettings().height, m(this, bi, ud.setInterval(
            l,
            50
          ));
        },
        !1
      );
      const f = i.captureStream().getVideoTracks()[0];
      return Object.defineProperty(f, "originalSettings", {
        value: e.getSettings()
      }), f;
    });
  }
}
bi = new WeakMap(), Yo = new WeakMap();
const hg = {
  gross: { width: { ideal: 192 }, height: { ideal: 144 } },
  qvga: { width: { ideal: 384 }, height: { ideal: 288 } },
  pvga: { width: { ideal: 480 }, height: { ideal: 360 } },
  vga: { width: { ideal: 640 }, height: { ideal: 480 } },
  hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
  hd_cropped: { width: { ideal: 900 }, height: { ideal: 720 } },
  fhd: { width: { ideal: 1920 }, height: { ideal: 1080 } }
}, s0 = [
  [320, [
    {
      rid: "q",
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    }
  ]],
  [640, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 25e4,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 7e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1280, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 5e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 13e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]],
  [1920, [
    {
      rid: "q",
      scaleResolutionDownBy: 2,
      maxBitrate: 9e5,
      maxFramerate: 24,
      scalabilityMode: "L1T1"
    },
    {
      rid: "h",
      maxBitrate: 15e5,
      maxFramerate: 30,
      scalabilityMode: "L1T1"
    }
  ]]
], r0 = (s, t) => {
  var c;
  const e = "getSettings" in t && t.getSettings().width || "getConstraints" in t && t.getConstraints().width || "originalSettings" in t && ((c = t.originalSettings) == null ? void 0 : c.width);
  let r = s0;
  s.getValue("flagsmith").hasFeature(X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC) && (r = JSON.parse(s.getValue("flagsmith").getValue(
    X.OVERRIDE_HIVE_SIMULCAST_DYNAMIC
  )));
  const i = r.map(([d]) => d).sort((d, l) => d - l);
  let n = Number.MAX_VALUE, o = 0;
  return i.forEach((d, l) => {
    Math.abs(d - e) < n && (n = Math.abs(d - e), o = l);
  }), r[o][1];
};
var pe = /* @__PURE__ */ ((s) => (s.WEBCAM = "webcam", s.WEBCAM_BACKUP = "webcam_backup", s.MIC = "mic", s.SCREENSHARE_VIDEO = "screenshare_video", s.SCREENSHARE_AUDIO = "screenshare_audio", s))(pe || {});
const i0 = Y_(), Pa = _s(
  i0.config.media
);
function a0(s) {
  var e, r;
  const t = {};
  return s.audio && (t.audio = {
    enableStereo: (e = s.audio.enableStereo) != null ? e : !1,
    enableHighBitrate: (r = s.audio.enableHighBitrate) != null ? r : !1
  }), t.video = s.video.quality, t;
}
var ki, As;
class n0 {
  constructor(t, e) {
    g(this, ki, void 0);
    g(this, As, void 0);
    // eslint-disable-next-line class-methods-use-this
    h(this, "getScreenShareConstraints", () => {
      var l, p, f, S, T, _, P, w, A, N, H;
      const t = (l = a(this, ki)) == null ? void 0 : l.screenshare, e = (f = (p = t == null ? void 0 : t.width) == null ? void 0 : p.max) != null ? f : 1920, r = (T = (S = t == null ? void 0 : t.height) == null ? void 0 : S.max) != null ? T : 1080, i = (P = (_ = t == null ? void 0 : t.frameRate) == null ? void 0 : _.max) != null ? P : 5;
      let n = (A = (w = t == null ? void 0 : t.frameRate) == null ? void 0 : w.ideal) != null ? A : 5;
      const o = t == null ? void 0 : t.displaySurface, c = t == null ? void 0 : t.selfBrowserSurface;
      a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE) && (n = parseInt(
        (N = a(this, As).getValue("flagsmith").getValue(X.VAL_MIN_FRAMERATE)) == null ? void 0 : N.toString(),
        10
      ));
      let d = {
        width: { max: e },
        height: { max: r },
        frameRate: {
          ideal: n,
          max: i
        }
      };
      if (a(this, As).getValue("flagsmith").hasFeature(X.SCREENSHARE_CONSTRAINTS)) {
        const $ = (H = a(this, As).getValue("flagsmith").getValue(
          X.SCREENSHARE_CONSTRAINTS
        )) == null ? void 0 : H.toString();
        d = JSON.parse($);
      }
      return o !== void 0 && ["monitor", "browser", "window"].includes(o) && (d = B(D({}, d), { displaySurface: o })), c !== void 0 && (d = B(D({}, d), { selfBrowserSurface: c })), {
        audio: !0,
        video: d
      };
    });
    // eslint-disable-next-line class-methods-use-this
    h(this, "getAudioConstraints", (t) => {
      var n, o, c, d, l, p, f;
      const e = {}, r = (n = a(this, ki)) == null ? void 0 : n.audio, i = r != null && r.enableStereo ? 2 : 1;
      return Te.isFirefox() || Te.isWebKitBased() ? (e.audio = {
        deviceId: t,
        autoGainControl: (o = r == null ? void 0 : r.autoGainControl) != null ? o : !0,
        echoCancellation: (c = r == null ? void 0 : r.echoCancellation) != null ? c : !0,
        noiseSuppression: (d = r == null ? void 0 : r.noiseSupression) != null ? d : !0,
        channelCount: i
      }, e) : (e.audio = {
        autoGainControl: (l = r == null ? void 0 : r.autoGainControl) != null ? l : !0,
        echoCancellation: (p = r == null ? void 0 : r.echoCancellation) != null ? p : !0,
        noiseSuppression: (f = r == null ? void 0 : r.noiseSupression) != null ? f : !0,
        channelCount: i
      }, t && t !== "default" && (e.audio.deviceId = { exact: t }), e);
    });
    h(this, "getVideoConstraints", (t) => {
      var n, o, c, d;
      const e = {}, r = (n = a(this, ki)) == null ? void 0 : n.video;
      let i = hg.vga;
      if (typeof r == "string" ? i = hg[r] : r !== void 0 && (i.height.ideal = r.height.ideal, i.width.ideal = r.width.ideal), i.frameRate = {
        ideal: (c = (o = i.frameRate) == null ? void 0 : o.ideal) != null ? c : 24
      }, Te.isChromiumBased() && (i.frameRate.max = 30), a(this, As).getValue("flagsmith").hasFeature(X.VIDEO_CONSTRAINTS)) {
        const l = (d = a(this, As).getValue("flagsmith").getValue(
          X.VIDEO_CONSTRAINTS
        )) == null ? void 0 : d.toString();
        i = JSON.parse(l);
      }
      return e.video = i, typeof e.video == "boolean" || (t ? e.video.deviceId = { exact: t } : e.video.facingMode = "user"), e;
    });
    m(this, As, t), m(this, ki, e);
  }
  // eslint-disable-next-line class-methods-use-this
  getUpdatedVideoConstraints(t) {
    return t;
  }
}
ki = new WeakMap(), As = new WeakMap();
class Su extends Error {
  constructor(e, r, i) {
    super(r);
    h(this, "constraints");
    h(this, "name");
    this.name = e, this.constraints = i;
  }
}
class o0 {
  constructor() {
    h(this, "permissions");
    this.permissions = {
      audio: "NOT_REQUESTED",
      video: "NOT_REQUESTED",
      screenshare: "NOT_REQUESTED"
    };
  }
  getAudioInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audioinput");
    });
  }
  getVideoInputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "videoinput");
    });
  }
  getAudioOutputDevices(t) {
    return u(this, null, function* () {
      let e = t;
      return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audiooutput");
    });
  }
}
var c0 = Object.defineProperty, d0 = Object.getOwnPropertyDescriptor, bs = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? d0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && c0(t, e, i), i;
}, nn, Zt, Ve, Ug;
let Bt = (Ug = class extends o0 {
  constructor(t, e) {
    super();
    /**
    	 * Only used for recognising device change
    	 */
    h(this, "availableDevices");
    g(this, nn, void 0);
    g(this, Zt, void 0);
    g(this, Ve, void 0);
    m(this, Ve, t), m(this, Zt, new n0(t, e)), m(this, nn, new AbortController()), this.availableDevices = [], this.getAvailableDevices();
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ve).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ve).getValue("logger");
  }
  get constraintsBuilder() {
    return a(this, Zt);
  }
  destruct() {
    return u(this, null, function* () {
      var t;
      (t = a(this, nn)) == null || t.abort();
    });
  }
  handlePermissionErrors(t, e) {
    const r = cd(t, e.name, e.message);
    return this.permissions[t] = r, a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, {
      message: r,
      constraints: e.constraints,
      kind: t
    }), r;
  }
  getAudioAndVideoTrack(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: a(this, Zt).getAudioConstraints(t).audio,
        video: a(this, Zt).getVideoConstraints(e).video
      };
      try {
        this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
          constraints: JSON.stringify(r)
        });
        const i = yield navigator.mediaDevices.getUserMedia(
          r
        );
        this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
          constraints: JSON.stringify(r)
        });
        const n = i.getAudioTracks()[0];
        let o = i.getVideoTracks()[0];
        if (this.permissions.audio = "ACCEPTED", this.permissions.video = "ACCEPTED", a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY) && o.label.includes("OBS Virtual")) {
          const l = (yield this.getVideoInputDevices()).find((p) => p.label.includes("OBS Virtual"));
          o = yield this.getVideoTrack(l.deviceId);
        }
        return a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), { audioTrack: n, videoTrack: o };
      } catch (i) {
        throw this.logger.error("WebMediaInterface.getAudioAndVideoTrack", { error: i }), new R("Couldnt fetch audio and video track", "1605");
      }
    });
  }
  getAudioTrack(t, e) {
    return u(this, null, function* () {
      let r = yield this.getAudioInputDevices();
      if (r.length === 0)
        throw this.permissions.audio = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        }), new R("No audio devices available", "1606");
      const i = (n) => u(this, null, function* () {
        let o;
        try {
          r = r.filter((d) => d.deviceId !== n), o = a(this, Zt).getAudioConstraints(n), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(o)
          });
          const [c] = (yield navigator.mediaDevices.getUserMedia(o)).getAudioTracks();
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(o)
          }), c;
        } catch (c) {
          const d = cd(
            "audio",
            c.name,
            c.message
          ), l = new Su(c.name, c.message, o);
          if (d === "COULD_NOT_START") {
            const p = r.shift();
            if (!p)
              throw l;
            this.logger.info("getAudioTrack::gum_failed", {
              constraints: JSON.stringify(o),
              error: c
            });
            const f = a(this, Zt).getAudioConstraints(
              p.deviceId
            );
            return this.logger.info("getAudioTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(f)
            }), i(p.deviceId);
          }
          throw l;
        }
      });
      try {
        const n = yield i(e);
        return n.enabled = !t, this.permissions.audio !== "ACCEPTED" && (this.permissions.audio = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.audio,
          kind: "audio"
        })), n;
      } catch (n) {
        throw n.constraints && this.handlePermissionErrors("audio", n), new R(n.message, "1601");
      }
    });
  }
  getVideoTrack(t) {
    return u(this, null, function* () {
      var c;
      const e = a(this, Ve).getValue("flagsmith").hasFeature(X.OBS_QUALITY), r = (c = yield this.getCurrentDeviceLabel(t)) == null ? void 0 : c.includes("OBS Virtual"), i = e && r, n = yield this.getVideoInputDevices();
      if (n.length === 0)
        throw this.permissions.video = "NO_DEVICES_AVAILABLE", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        }), new R("No video devices available", "1607");
      const o = (d) => u(this, null, function* () {
        try {
          let l = d;
          const { video: p } = l;
          i && typeof p != "boolean" && (l = {
            video: { deviceId: p.deviceId }
          }), this.logger.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(l)
          });
          const [f] = (yield navigator.mediaDevices.getUserMedia(l)).getVideoTracks();
          if (i && typeof p != "boolean" && typeof p.width == "object") {
            const { width: S, height: T } = f.getSettings(), { ideal: _ } = p.width;
            f.applyConstraints({
              width: { ideal: _ },
              height: { ideal: Math.floor(T * _ / S) },
              frameRate: p.frameRate
            });
          }
          return this.logger.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(l)
          }), f;
        } catch (l) {
          const p = cd(
            "video",
            l.name,
            l.message
          ), f = new Su(l.name, l.message, d);
          if (p === "COULD_NOT_START") {
            const S = n.shift();
            if (!S)
              throw f;
            this.logger.info("getVideoTrack::gum_failed", {
              constraints: JSON.stringify(d),
              error: l
            });
            const T = a(this, Zt).getVideoConstraints(
              S.deviceId
            );
            return this.logger.info("getVideoTrack::retrying_gum_for_next_device", {
              constraints: JSON.stringify(T)
            }), o({ video: T.video });
          }
          throw f;
        }
      });
      try {
        const d = a(this, Zt).getVideoConstraints(t), l = yield o(d);
        return this.permissions.video !== "ACCEPTED" && (this.permissions.video = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.video,
          kind: "video"
        })), l;
      } catch (d) {
        throw d.constraints && this.handlePermissionErrors("video", d), new R(d.message, "1602");
      }
    });
  }
  getScreenShareTracks() {
    return u(this, null, function* () {
      const t = (e) => u(this, null, function* () {
        try {
          this.logger.info("getDisplayMediaWithoutTimeout::requesting_display_media", {
            constraints: JSON.stringify(e)
          }), a(this, Ve).getValue("callstats").screenShareRequested();
          const r = yield navigator.mediaDevices.getDisplayMedia(
            e
          );
          return this.logger.info("getDisplayMediaWithoutTimeout::received_display_media", {
            constraints: JSON.stringify(e)
          }), r;
        } catch (r) {
          const i = cd(
            "video",
            r.name,
            r.message
          ), n = new Su(r.name, r.message, e), o = { video: !0 };
          if (SC(e, o) || !a(this, Ve).getValue("flagsmith").hasFeature(X.SCREEENSHARE_CONSTRAINTS_RETRY))
            throw n;
          if (i === "COULD_NOT_START")
            return t(o);
          throw n;
        }
      });
      try {
        const e = a(this, Zt).getScreenShareConstraints(), r = yield t(e);
        return this.permissions.screenshare !== "ACCEPTED" && (this.permissions.screenshare = "ACCEPTED", a(this, Ve).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.permissions.screenshare,
          kind: "screenshare"
        })), {
          audioTrack: r.getAudioTracks()[0],
          videoTrack: r.getVideoTracks()[0]
        };
      } catch (e) {
        throw e.constraints && this.handlePermissionErrors("screenshare", e), new R(e.message, "1612");
      }
    });
  }
  getCurrentDeviceLabel(t) {
    return u(this, null, function* () {
      const e = yield this.getDevice(t || "default");
      return e == null ? void 0 : e.label;
    });
  }
  getAvailableDevices() {
    return u(this, null, function* () {
      try {
        const t = yield navigator.mediaDevices.enumerateDevices();
        return this.availableDevices = t, t;
      } catch (t) {
        throw this.logger.error("enumerate_devices_failed", {
          error: t
        }), new R("Failed to get available devices", "1609");
      }
    });
  }
  getAvailableDevicesByKind(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter(
          ({ kind: e }) => t === e
        );
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get available devices by kind", "1609");
      }
    });
  }
  getDevice(t) {
    return u(this, null, function* () {
      try {
        return (yield navigator.mediaDevices.enumerateDevices()).filter((r) => r.deviceId === t)[0];
      } catch (e) {
        throw this.logger.error("enumerate_devices_failed", {
          error: e
        }), new R("Failed to get device", "1609");
      }
    });
  }
  onDeviceChange(t) {
    return u(this, null, function* () {
      Te.supportsDeviceChangeEvent() && navigator.mediaDevices.addEventListener(
        "devicechange",
        (e) => u(this, null, function* () {
          var l, p;
          const r = (f) => `${f.kind}-${f.deviceId}-${f.groupId}`, i = this.availableDevices, n = new Set(
            i.map((f) => r(f))
          ), o = yield this.getAvailableDevices(), c = new Set(
            o.map((f) => r(f))
          ), d = {
            added: o.filter(
              (f) => !n.has(r(f))
            ),
            removed: i.filter(
              (f) => !c.has(r(f))
            ),
            devices: o
          };
          if ((l = d.added) != null && l.length || (p = d.removed) != null && p.length) {
            this.logger.info("repopulated_full_device_list", {
              devices: JSON.stringify(o)
            });
            const f = [...d.added, ...d.removed];
            f.some((S) => S.kind === "audioinput") && a(this, Ve).getValue("callstats").devices("AUDIO", o == null ? void 0 : o.filter((S) => S.kind === "audioinput")), f.some((S) => S.kind === "videoinput") && a(this, Ve).getValue("callstats").devices("VIDEO", o == null ? void 0 : o.filter((S) => S.kind === "videoinput")), f.some((S) => S.kind === "audiooutput") && a(this, Ve).getValue("callstats").devices("SPEAKER", o == null ? void 0 : o.filter((S) => S.kind === "audiooutput")), t(e, d, !1);
          }
        }),
        { signal: a(this, nn).signal }
      );
    });
  }
}, nn = new WeakMap(), Zt = new WeakMap(), Ve = new WeakMap(), Ug);
bs([
  E.trace("WebMediaInterface.destruct")
], Bt.prototype, "destruct", 1);
bs([
  E.trace("WebMediaInterface.handlePermissionErrors")
], Bt.prototype, "handlePermissionErrors", 1);
bs([
  E.trace("WebMediaInterface.getAudioAndVideoTrack")
], Bt.prototype, "getAudioAndVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getAudioTrack")
], Bt.prototype, "getAudioTrack", 1);
bs([
  E.trace("WebMediaInterface.getVideoTrack")
], Bt.prototype, "getVideoTrack", 1);
bs([
  E.trace("WebMediaInterface.getScreenShareTracks")
], Bt.prototype, "getScreenShareTracks", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevices")
], Bt.prototype, "getAvailableDevices", 1);
bs([
  E.trace("WebMediaInterface.getAvailableDevicesByKind")
], Bt.prototype, "getAvailableDevicesByKind", 1);
bs([
  E.trace("WebMediaInterface.getDevice")
], Bt.prototype, "getDevice", 1);
bs([
  E.trace("WebMediaInterface.onDeviceChange")
], Bt.prototype, "onDeviceChange", 1);
Bt = bs([
  ht("1600")
], Bt);
const Uf = Bt, Io = {
  setItem: (s, t, e) => {
    try {
      localStorage.setItem(s, t);
    } catch (r) {
      e == null || e.error("LocalStorage::setItem::crashed", {
        error: r,
        localStorage: { key: s, value: t }
      });
    }
  },
  getItem: (s, t) => {
    try {
      return localStorage.getItem(s);
    } catch (e) {
      t == null || t.error("LocalStorage::getItem::crashed", {
        error: e,
        localStorage: { key: s }
      });
    }
    return null;
  }
}, l0 = (s = 0) => new Promise(
  (t) => setTimeout(t, s)
), u0 = (s, t, e) => {
  const r = typeof e == "number" ? e : 250, i = s.createMediaStreamSource(t), n = s.createAnalyser();
  n.fftSize = 2048, i.connect(n);
  const o = new Uint8Array(n.fftSize);
  let c = !1;
  setTimeout(() => {
    c = !0;
  }, r);
  function d() {
    return c ? Promise.resolve(!0) : (n.getByteTimeDomainData(o), o.some((l) => l !== 128 && l !== 0) ? Promise.resolve(!1) : l0().then(d));
  }
  return d().then(
    (l) => (i.disconnect(), l),
    (l) => {
      throw i.disconnect(), l;
    }
  );
}, h0 = typeof AudioContext != "undefined" ? AudioContext : null;
class xh {
  constructor(t) {
    h(this, "_AudioContext");
    h(this, "audioContext");
    h(this, "_audioContextRefContainers");
    const e = D({ AudioContext: h0 }, t);
    Object.defineProperties(this, {
      _AudioContext: {
        value: e.AudioContext
      },
      audioContext: {
        value: null,
        writable: !0
      },
      _audioContextRefContainers: {
        value: /* @__PURE__ */ new Set()
      },
      AudioContextProvider: {
        enumerable: !0,
        value: xh
      }
    });
  }
  getOrCreate(t) {
    if (!this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.add(t), this._AudioContext && !this.audioContext))
      try {
        this.audioContext = new this._AudioContext();
      } catch (e) {
      }
    return this.audioContext;
  }
  release(t) {
    this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.delete(t), !this._audioContextRefContainers.size && this.audioContext && (this.audioContext.close(), this.audioContext = null));
  }
}
const pg = new xh(), p0 = 3, g0 = 250;
function m0(s) {
  const t = {}, e = pg.getOrCreate(
    t
  );
  let r = p0;
  function i() {
    return r -= 1, u0(e, s.srcObject, g0).then((n) => n ? r > 0 ? i() : !0 : !1).catch(() => !0);
  }
  return i().finally(() => {
    pg.release(t);
  });
}
function gg(s, t) {
  return u(this, null, function* () {
    const e = new Audio(), r = new MediaStream();
    r.addTrack(t), e.srcObject = r;
    let i = !1;
    try {
      const n = e.play();
      n && (yield n), i = yield m0(e), i && s.info("checkIfAudioTrackIsSilent::silence_detected");
    } catch (n) {
      s.error("checkIfAudioTrackIsSilent::failed_to_detect_silence", {
        error: n
      });
    } finally {
      e.pause(), e.remove();
    }
    return i;
  });
}
var f0 = Object.defineProperty, S0 = Object.getOwnPropertyDescriptor, $f = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? S0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && f0(t, e, i), i;
};
let Ld = class extends Jn {
  /**
   * Allows creation of an instance of BaseMediaHandler with a track.
   * We initialize it with a track when we want to enable streams on init.
   * @param mediaInterface
   * @param mediaTrack
   */
  constructor(t, e, r, i) {
    var o;
    const n = t.getValue("logger");
    super(n);
    h(this, "constructorName", this.constructor.name);
    // Will be set in case user has explicity used Self.setDevice
    // to set the device.
    h(this, "userSelectedDevice");
    h(this, "mediaInterface");
    h(this, "isNonPreferredDevice");
    h(this, "_mediaTrack");
    h(this, "transformedMediaTrack");
    h(this, "middlewares", []);
    h(this, "currentDevice");
    h(this, "userPreferredDeviceKey", `Dyte::${this.constructorName}::UserDeviceID`);
    h(this, "setUserPreferredDevice", (t) => Io.setItem(
      this.userPreferredDeviceKey,
      t,
      this.logger
    ));
    h(this, "getUserPreferredDevice", () => Io.getItem(
      this.userPreferredDeviceKey,
      this.logger
    ));
    h(this, "isCustomTrack", !1);
    h(this, "context");
    this.context = t, this.mediaInterface = e, r && this.setMediaTrack(r), this.userSelectedDevice = (o = this.getUserPreferredDevice()) != null ? o : void 0, this.isNonPreferredDevice = i, this.onTrackEnded = this.onTrackEnded.bind(this), this.onTrackMuted = this.onTrackMuted.bind(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * NOTE(roerohan): DO NOT use this.#mediaTrack anywhere else,
   * except for these 3 functions below.
   */
  /**
   * Cleans up all acquired tracks.
   */
  disableTrack() {
    var t, e;
    this.removeMediaTrackListeners(), this.isCustomTrack || (t = this._mediaTrack) == null || t.stop(), this._mediaTrack = void 0, (e = this.transformedMediaTrack) == null || e.stop(), this.transformedMediaTrack = void 0;
  }
  get mediaTrack() {
    return this._mediaTrack;
  }
  setMediaTrack(t, e = !1) {
    return u(this, null, function* () {
      const r = (i) => {
        this.logger.error(`${this.constructorName}.setMediaTrack.error`, {
          error: i
        });
      };
      try {
        this.disableTrack();
      } catch (i) {
        r(i);
      }
      this._mediaTrack = yield this.conditionallyChangeTrack(t, e), yield this.setTransformedTrack();
      try {
        this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        r(i);
      }
    });
  }
  /**
   * Represents current audio/video state according to track status
   */
  get trackEnabled() {
    return !!this.mediaTrack && this.mediaTrack.readyState === "live" && this.mediaTrack.enabled;
  }
  /**
   * Mutes track if it's present, DOES NOT STOP IT!
   * Only used for audio streams
   */
  muteTrack() {
    if (!this.mediaTrack) {
      this.logger.warn(
        "BaseMediaHandler.muteTrack Tried muting with no track present"
      );
      return;
    }
    this.transformedMediaTrack && (this.transformedMediaTrack.enabled = !1), this.mediaTrack.enabled = !1;
  }
  unmuteTrack() {
    return u(this, null, function* () {
      try {
        this.mediaTrack ? this.mediaTrack.enabled = !0 : yield this.enableTrack(!1);
      } catch (t) {
        throw this.logger.error(`${this.constructorName}.unmuteTrack.error`, {
          error: t
        }), this.disableTrack(), new R("Failed to unmute track", "1611");
      }
    });
  }
  // NOTE(ishita1805): Not to be used for screenshare or audiooutput
  getCurrentDeviceId() {
    var e;
    const { kind: t } = this.mediaTrack;
    switch (t) {
      case "audio": {
        const { deviceId: r } = this.mediaTrack.getSettings();
        if (r)
          return r;
        const i = this.mediaTrack.getConstraints();
        return this.userSelectedDevice ? (i && typeof i.deviceId == "object" && "exact" in i.deviceId ? i.deviceId.exact : i.deviceId) || ((e = i == null ? void 0 : i.advanced) == null ? void 0 : e[0].deviceId) || "default" : this.mediaTrack.getSettings().deviceId;
      }
      default:
        return this.mediaTrack.getSettings().deviceId;
    }
  }
  /**
   * Called after every track switch, maintains local state of current
   * selected device for this particular stream.
   */
  setCurrentDevice() {
    return u(this, null, function* () {
      var e;
      if (!this.mediaTrack) {
        this.currentDevice = void 0;
        return;
      }
      const t = this.getCurrentDeviceId();
      ((e = this.currentDevice) == null ? void 0 : e.deviceId) !== t && (this.currentDevice = yield this.mediaInterface.getDevice(t));
    });
  }
  setDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn(`${this.constructorName}.setDevice No device received`), new R("No device received!", "1603");
      this.userSelectedDevice = t.deviceId, this.setUserPreferredDevice(t.deviceId), yield this.onSetDevice(t);
    });
  }
  /**
   * Middleware Utility
   */
  addMiddleware(t) {
    return u(this, null, function* () {
      if (Te.isWebKitBased() && !$_.hasFeature(X.ALLOW_SAFARI_MEDIA_MIDDLEWARES))
        return {
          success: !1,
          message: "Middlewares are not supported in this WebKit engine based browser."
        };
      if (this.middlewares.includes(t))
        return {
          success: !1,
          message: "This middleware has been applied, already. Skipping."
        };
      try {
        return this.middlewares.push(t), this.trackEnabled && (yield this.setTransformedTrack()), { success: !0, message: "Successfully added the middleware." };
      } catch (e) {
        return this.logger.error("While adding middleware", { error: e }), this.removeMiddleware(t), { success: !1, message: e == null ? void 0 : e.message };
      }
    });
  }
  removeMiddleware(t) {
    return u(this, null, function* () {
      const e = this.middlewares.indexOf(t, 0);
      if (e > -1)
        try {
          return this.middlewares.splice(e, 1), yield this.setTransformedTrack(!0), {
            success: !0,
            message: "Successfully removed the middleware."
          };
        } catch (r) {
          return this.logger.error("While removing middleware", { error: r }), { success: !1, message: r == null ? void 0 : r.message };
        }
      return {
        success: !1,
        message: "No such middleware was found. Skipping."
      };
    });
  }
  removeAllMiddlewares() {
    return u(this, null, function* () {
      var t;
      if ((t = this.middlewares) != null && t.length)
        try {
          return this.middlewares = [], yield this.setTransformedTrack(!0), {
            success: !0,
            message: "Successfully removed all the middlewares."
          };
        } catch (e) {
          return this.logger.error("While removing all the middlewares", { error: e }), { success: !1, message: e == null ? void 0 : e.message };
        }
      return {
        success: !1,
        message: "No middlewares were found. Skipping."
      };
    });
  }
  addMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.addMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.mediaTrack.addEventListener("ended", this.onTrackEnded), this.mediaTrack.addEventListener("mute", this.onTrackMuted));
  }
  removeMediaTrackListeners() {
    var t, e, r;
    this.mediaTrack && (this.logger.info(
      `${this.constructorName}.removeMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? void 0 : t.getSettings()) == null ? void 0 : e.deviceId} of type ${(r = this.mediaTrack) == null ? void 0 : r.kind}`
    ), this.logger.info(`${this.constructorName}.removeMediaTrackListeners`), this.mediaTrack.removeEventListener("ended", this.onTrackEnded), this.mediaTrack.removeEventListener("mute", this.onTrackMuted));
  }
};
$f([
  E.trace("BaseMediaHandler.unmuteTrack")
], Ld.prototype, "unmuteTrack", 1);
Ld = $f([
  ht("1600")
], Ld);
const Ff = Ld;
var v0 = Object.defineProperty, y0 = Object.getOwnPropertyDescriptor, Uh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? y0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && v0(t, e, i), i;
};
const vu = "[Dyte]nonSilentDeviceLabels";
class Kl extends Ff {
  onSetDevice(t) {
    return u(this, null, function* () {
      if (!t)
        throw this.logger.warn("AudioMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (t.kind !== "audioinput")
        throw this.logger.warn("AudioMediaHandler.setDevice Received non audio device"), new R(
          "Non audio device received while setting device!",
          "1603"
        );
      try {
        const e = this.trackEnabled;
        yield this.setMediaTrack(
          yield this.mediaInterface.getAudioTrack(
            !e,
            this.userSelectedDevice
          )
        );
      } catch (e) {
        throw this.logger.error("AudioMediaHandler.setDevice.error", {
          error: e
        }), this.disableTrack(), new R(e.message, "1604");
      }
    });
  }
  enableTrack(t, e) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("AudioMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (e) {
        this.isCustomTrack = !0, yield this.setMediaTrack(e, !0);
        return;
      }
      this.isCustomTrack = !1;
      const r = yield this.mediaInterface.getAudioTrack(
        t,
        this.userSelectedDevice
      );
      yield this.setMediaTrack(r);
    });
  }
  setTransformedTrack(t) {
    return u(this, null, function* () {
      var e;
      if (!t && !((e = this.middlewares) != null && e.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield e0(
          this.context,
          this.middlewares,
          this.mediaTrack
        ), this.emit("trackChanged");
      } catch (r) {
        this.logger.error("AudioMediaHandler.setTransformedTrack", {
          error: r
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("AudioMediaHandler.TrackEnded"), this.emit("trackEnded");
      const t = this.mediaTrack.enabled;
      this.disableTrack(), yield this.enableTrack(!t), yield this.setTransformedTrack(), this.emit("trackChanged");
    });
  }
  onTrackMuted() {
    this.logger.info("AudioMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(t, e = !1) {
    return u(this, null, function* () {
      var d;
      if (!t || this.userSelectedDevice || e)
        return t;
      let r = t;
      const i = yield this.mediaInterface.getAudioInputDevices(), n = this.isNonPreferredDevice ? i.filter((l) => l && !this.isNonPreferredDevice(l)) : i;
      if (!(n != null && n.length))
        return r;
      n.find(
        (l) => l.deviceId === t.getSettings().deviceId
      ) || (r.stop(), this.logger.info("localmediahandler::setupstreams::found_audio_non_preferred"), r = yield this.mediaInterface.getAudioTrack(
        !1,
        n[0].deviceId
      ));
      const o = JSON.parse(
        Io.getItem(vu, this.logger)
      );
      if (o != null && o.devices.some(
        (l) => l.label === r.label
      ))
        return r;
      if (!(yield gg(this.logger, r))) {
        const l = (d = o == null ? void 0 : o.devices.concat({
          label: r.label
        })) != null ? d : [{ label: r.label }];
        return Io.setItem(vu, JSON.stringify({
          devices: l
        }), this.logger), r;
      }
      this.logger.info("AudioMediaHandler.conditionallyChangeTrack.DetectedSilentTrack");
      const c = r.getSettings().deviceId;
      return n.filter((l) => l.deviceId !== c).some((l) => u(this, null, function* () {
        if (r = yield this.mediaInterface.getAudioTrack(
          !1,
          l.deviceId
        ), !(yield gg(this.logger, r))) {
          const p = o.devices.concat({
            label: r.label
          });
          return Io.setItem(vu, JSON.stringify({
            devices: p
          }), this.logger), this.logger.info("AudioMediaHandler.conditionallyChangeTrack.SuccesfullyChangedTrack"), !0;
        }
        return this.logger.info("AudioMediaHandler.conditionallyChangeTrack.AnotherSilentTrackFound"), !1;
      })), r;
    });
  }
}
Uh([
  E.trace("AudioMediaHandler.setTransformedTrack")
], Kl.prototype, "setTransformedTrack", 1);
Uh([
  E.trace("AudioMediaHandler.onTrackEnded")
], Kl.prototype, "onTrackEnded", 1);
Uh([
  E.trace("AudioMediaHandler.conditionallyChangeTrack")
], Kl.prototype, "conditionallyChangeTrack", 1);
const T0 = Kl;
var on;
class E0 {
  constructor(t) {
    g(this, on, void 0);
    h(this, "currentDevice");
    m(this, on, t);
  }
  setupSpeaker(t) {
    return u(this, null, function* () {
      var i, n;
      if (!(a(this, on) instanceof Uf))
        return;
      let e = t;
      if (t || ([e] = (yield a(this, on).getAvailableDevicesByKind(
        "audiooutput"
      )).filter((c) => !Ju(c))), !e)
        throw new R("No speaker found", "1608");
      if (((i = this.currentDevice) == null ? void 0 : i.deviceId) === e.deviceId)
        return;
      this.currentDevice = e;
      const r = document.querySelectorAll("audio");
      (n = r[0]) != null && n.setSinkId && r.forEach((o) => u(this, null, function* () {
        if (typeof o.sinkId != "undefined" && this.currentDevice.deviceId && o.sinkId !== this.currentDevice.deviceId)
          try {
            yield o.setSinkId(this.currentDevice.deviceId);
          } catch (c) {
          }
      }));
    });
  }
}
on = new WeakMap();
const _0 = E0;
var Qo;
class P0 extends Jn {
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    h(this, "mediaInterface");
    h(this, "audioMediaTrack");
    h(this, "videoMediaTrack");
    g(this, Qo, void 0);
    m(this, Qo, e), this.mediaInterface = r;
  }
  get trackEnabled() {
    return !!this.videoMediaTrack;
  }
  enableScreenShare() {
    return u(this, null, function* () {
      var e, r;
      try {
        const { audioTrack: i, videoTrack: n } = yield this.mediaInterface.getScreenShareTracks();
        if (this.audioMediaTrack = i, this.videoMediaTrack = n, this.addMediaTrackListeners(), ((r = (e = this.mediaInterface) == null ? void 0 : e.permissions) == null ? void 0 : r.screenshare) === "ACCEPTED")
          return;
        this.mediaInterface.permissions && (this.mediaInterface.permissions.screenshare = "ACCEPTED", a(this, Qo).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, {
          message: this.mediaInterface.permissions.screenshare,
          kind: "screenshare"
        }));
      } catch (i) {
      }
    });
  }
  disableScreenShare() {
    var e, r;
    this.removeMediaTrackListeners(), (e = this.audioMediaTrack) == null || e.stop(), (r = this.videoMediaTrack) == null || r.stop(), this.videoMediaTrack = void 0, this.audioMediaTrack = void 0;
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this.videoMediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this.videoMediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), this.addMediaTrackListeners();
      } catch (i) {
        this.logger.error("ScreenShareHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  addMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.addEventListener(
      "ended",
      this.onTrackEnded.bind(this)
    ), Te.isWebKitBased() && ((r = this.videoMediaTrack) == null || r.addEventListener(
      "mute",
      this.onTrackEnded.bind(this)
    ));
  }
  removeMediaTrackListeners() {
    var e, r;
    (e = this.videoMediaTrack) == null || e.removeEventListener("ended", this.onTrackEnded), (r = this.videoMediaTrack) == null || r.removeEventListener("mute", this.onTrackEnded);
  }
  onTrackEnded() {
    this.emit("trackEnded");
  }
}
Qo = new WeakMap();
const C0 = P0;
var R0 = Object.defineProperty, w0 = Object.getOwnPropertyDescriptor, zl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? w0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && R0(t, e, i), i;
}, cn, Xo;
class Yc extends Ff {
  constructor(e, r, i, n) {
    super(e, r, i, n);
    g(this, cn, void 0);
    g(this, Xo, {
      disablePerFrameCanvasRendering: !1
    });
    m(this, cn, new t0(e));
  }
  onSetDevice(e) {
    return u(this, null, function* () {
      if (!e)
        throw this.logger.warn("VideoMediaHandler.setDevice No device received"), new R("No device received!", "1603");
      if (e.kind !== "videoinput")
        throw this.logger.warn("VideoMediaHandler.setDevice Received non video device", {
          devices: [e]
        }), new R(
          "Non video device received while setting video device!",
          "1603"
        );
      if (!(this.mediaTrack && this.mediaTrack.enabled)) {
        this.logger.warn(
          "VideoMediaHandler.setDevice Tried switching device with video disabled",
          {
            devices: [e]
          }
        ), this.currentDevice = e;
        return;
      }
      try {
        yield this.setMediaTrack(
          yield this.mediaInterface.getVideoTrack(this.userSelectedDevice)
        );
      } catch (r) {
        throw this.logger.error("VideoMediaHandler.setDevice.error", {
          error: r
        }), this.disableTrack(), new R("Failed to change device", "1600", this.logger);
      }
    });
  }
  enableTrack(e, r) {
    return u(this, null, function* () {
      if (this.trackEnabled) {
        this.logger.warn("VideoMediaHandler.enableTrack Track already enabled!");
        return;
      }
      if (r) {
        this.isCustomTrack = !0, yield this.setMediaTrack(r, !0);
        return;
      }
      this.isCustomTrack = !1;
      const i = yield this.mediaInterface.getVideoTrack(
        this.userSelectedDevice
      );
      yield this.setMediaTrack(i);
    });
  }
  setTransformedTrack(e) {
    return u(this, null, function* () {
      var r;
      if (!e && !((r = this.middlewares) != null && r.length)) {
        this.transformedMediaTrack = this.mediaTrack;
        return;
      }
      try {
        this.transformedMediaTrack = yield a(this, cn).getTransformedVideoTrack(
          this.middlewares,
          this.mediaTrack,
          a(this, Xo)
        ), this.emit("trackChanged");
      } catch (i) {
        this.logger.error("VideoMediaHandler.setTransformedTrack", {
          error: i
        }), this.transformedMediaTrack = this.mediaTrack;
      }
    });
  }
  setVideoMiddlewareGlobalConfig(e) {
    return u(this, null, function* () {
      m(this, Xo, e);
    });
  }
  updateConstraints(e) {
    return u(this, null, function* () {
      if (!this._mediaTrack)
        throw new R("No media track enabled!", "1610");
      const r = this.mediaInterface;
      if (!r.constraintsBuilder)
        throw new R("update constraints not supported for non web clients", "1100", this.logger);
      try {
        this._mediaTrack.applyConstraints(
          r.constraintsBuilder.getUpdatedVideoConstraints(e)
        ), yield this.setTransformedTrack(), this.addMediaTrackListeners(), yield this.setCurrentDevice();
      } catch (i) {
        this.logger.error("VideoMediaHandler.updateConstraints.error", {
          error: i
        });
      }
    });
  }
  terminateMiddlewareWebWorker() {
    a(this, cn).terminateMiddlewareWebWorker();
  }
  onTrackEnded() {
    return u(this, null, function* () {
      this.logger.info("VideoMediaHandler.TrackEnded"), this.disableTrack(), this.emit("trackEnded");
    });
  }
  onTrackMuted() {
    this.logger.info("VideoMediaHandler.TrackMuted"), this.emit("trackMuted");
  }
  conditionallyChangeTrack(e, r = !1) {
    return u(this, null, function* () {
      if (!e || this.userSelectedDevice || r)
        return e;
      let i = e;
      const n = yield this.mediaInterface.getVideoInputDevices(), o = this.isNonPreferredDevice ? n.filter((c) => !this.isNonPreferredDevice(
        c
      )) : n;
      return !(o != null && o.length) || window.FAST_DYTE || o.find(
        (c) => c.deviceId === e.getSettings().deviceId
      ) || (i.stop(), this.logger.info("localmediahandler::setupstreams::found_video_non_preferred"), i = yield this.mediaInterface.getVideoTrack(
        o[0].deviceId
      )), i;
    });
  }
}
cn = new WeakMap(), Xo = new WeakMap();
zl([
  E.trace("VideoMediaHandler.setTransformedTrack")
], Yc.prototype, "setTransformedTrack", 1);
zl([
  E.trace("VideoMediaHandler.setVideoMiddlewareGlobalConfig")
], Yc.prototype, "setVideoMiddlewareGlobalConfig", 1);
zl([
  E.trace("VideoMediaHandler.onTrackEnded")
], Yc.prototype, "onTrackEnded", 1);
zl([
  E.trace("VideoMediaHandler.conditionallyChangeTrack")
], Yc.prototype, "conditionallyChangeTrack", 1);
const b0 = Yc, mg = _s(
  kh()
);
var Rt, Ii, Zo, dn;
const Da = class {
  constructor(t) {
    g(this, Rt, void 0);
    g(this, Ii, void 0);
    g(this, Zo, void 0);
    g(this, dn, void 0);
    if (!t)
      throw new R("Could not load preset.", "0904");
    m(this, Rt, t.config), m(this, Zo, t.name), m(this, Ii, t.ui || _s(kh().ui)), m(this, dn, t.permissions.plugins.config);
  }
  /** @deprecated. Use init() */
  static fromResponse(t) {
    return new Da(t);
  }
  /** @deprecated. Use init() */
  static default() {
    return new Da(mg);
  }
  static init(t, e = !0) {
    return !t || e ? new Da(mg) : new Da(t);
  }
  /**
   * @deprecated
   * The `setupScreen` represents the setup screen for the meeting.
   */
  get setupScreen() {
    return {
      isEnabled: !0
    };
  }
  /**
   * @deprecated
   * The `waitingRoom` contains the properties to show a layout when
   * the participant is in waiting to join the meeting.
   */
  get waitingRoom() {
    return {
      isEnabled: !0
    };
  }
  /**
   * @deprecated
   * The `controlBar` contains the properties to show the meeting control bar with
   * various action buttons for the meeting.
   * The `elements` key contains the various action buttons.
   */
  get controlBar() {
    return {
      isEnabled: !0,
      elements: {
        chat: !0,
        fullscreen: !0,
        invite: !1,
        layout: !1,
        participants: !0,
        plugins: !0,
        polls: !0,
        reactions: !1,
        screenshare: !0
      }
    };
  }
  /**
   * @deprecated
   * The `header` contains the properties to show the meeting header with various elements.
   * The `elements` key contains the following properties
   * `logo` - string value representing the public URL for the logo
   * `timer` - boolean value suggesting if the timer should be shown
   * `title` - boolean value suggesting if the meeting title should be shown
   * `participantCount` - boolean value suggesting if the participant count shuld be shown
   * `changeLayout` - boolean value suggesting if the participant can change layout
   */
  get header() {
    return {
      isEnabled: !0,
      elements: {
        logo: a(this, Ii).designTokens.logo,
        timer: !0,
        title: !0,
        participantCount: !0,
        changeLayout: !1
      }
    };
  }
  /**
   * @deprecated
   * The `pipMode` property returns a boolean value
   * If true, picture-in-picture mode is enabled for the participant.
   */
  get pipMode() {
    return !0;
  }
  /**
   * The `viewType` tells the type of the meeting
   * possible values are: GROUP_CALL| LIVESTREAM | CHAT | AUDIO_ROOM
   */
  get viewType() {
    return a(this, Rt).viewType;
  }
  /**
   * The `livestreamViewerQualities` specifies the allowed qualities of a stream,
   * that can be viewed by a livestream viewer
   * */
  get livestreamViewerQualities() {
    return a(this, Rt).livestreamViewerQualities || [];
  }
  /**
   * The `maxVideoStreams` contains the maximum video
   * streams for mobile and desktop
   */
  get maxVideoStreams() {
    return a(this, Rt).maxVideoStreams;
  }
  /**
   * The `maxScreenShareCount` contains the maximum
   * possible concurrent screen shares
   */
  get maxScreenShareCount() {
    return a(this, Rt).maxScreenshareCount;
  }
  /**
   * @deprecated in favour of permissions.plugins.config
   */
  get plugins() {
    return [];
  }
  /**
   * The `disabledPlugins` property returns id of all disabled plugins
   */
  get disabledPlugins() {
    return Object.keys(a(this, dn)).filter((t) => a(this, dn)[t].disabled);
  }
  get designTokens() {
    return a(this, Ii).designTokens;
  }
  get configDiff() {
    return a(this, Ii).configDiff;
  }
  get mediaConstraints() {
    var t, e, r, i, n, o, c, d, l, p, f, S, T, _, P, w, A, N, H, $, F, K, re, Je;
    return {
      audio: {
        enableStereo: (i = (r = (e = (t = a(this, Rt)) == null ? void 0 : t.media) == null ? void 0 : e.audio) == null ? void 0 : r.enableStereo) != null ? i : Pa.audio.enableStereo,
        enableHighBitrate: (d = (c = (o = (n = a(this, Rt)) == null ? void 0 : n.media) == null ? void 0 : o.audio) == null ? void 0 : c.enableHighBitrate) != null ? d : Pa.audio.enableHighBitrate
      },
      video: {
        quality: (S = (f = (p = (l = a(this, Rt)) == null ? void 0 : l.media) == null ? void 0 : p.video) == null ? void 0 : f.quality) != null ? S : Pa.video.quality,
        frameRate: (w = (P = (_ = (T = a(this, Rt)) == null ? void 0 : T.media) == null ? void 0 : _.video) == null ? void 0 : P.frameRate) != null ? w : Pa.video.frameRate
      },
      screenshare: {
        quality: ($ = (H = (N = (A = a(this, Rt)) == null ? void 0 : A.media) == null ? void 0 : N.screenshare) == null ? void 0 : H.quality) != null ? $ : Pa.screenshare.quality,
        frameRate: (Je = (re = (K = (F = a(this, Rt)) == null ? void 0 : F.media) == null ? void 0 : K.screenshare) == null ? void 0 : re.frameRate) != null ? Je : Pa.screenshare.frameRate
      }
    };
  }
  get name() {
    return a(this, Zo);
  }
};
let Ku = Da;
Rt = new WeakMap(), Ii = new WeakMap(), Zo = new WeakMap(), dn = new WeakMap();
var k0 = Object.defineProperty, I0 = Object.getOwnPropertyDescriptor, Hf = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? I0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && k0(t, e, i), i;
}, ln, ec;
class $h extends qt {
  constructor(e, r) {
    const i = e.getValue("logger");
    super(i);
    g(this, ln, void 0);
    h(this, "state", "IDLE");
    h(this, "playbackUrl");
    h(this, "ingestionCredentials");
    h(this, "viewerCount");
    g(this, ec, void 0);
    m(this, ln, r), m(this, ec, e), this.viewerCount = 0;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, ec).getValue("telemetry");
  }
  setLivestreamState(e) {
    const r = this.state;
    this.state = e, r !== e && this.emitCurrentLivestreamState();
  }
  emitCurrentLivestreamState() {
    this.emit("livestreamUpdate", this.state);
  }
  start() {
    return u(this, arguments, function* (e = {
      manualIngestion: !1
    }) {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::start::permission_denied"), new R(
          "User does not have permission to start livestreaming",
          "1901"
        );
      this.setLivestreamState("STARTING");
      try {
        const r = lt(), {
          playbackUrl: i,
          ingestionCredentials: n
        } = yield r.startLivestreaming(e);
        this.playbackUrl = i, this.ingestionCredentials = n, e != null && e.manualIngestion && this.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
      } catch (r) {
        throw this.logger.error("DyteRecording::stop::livestream_failed_to_start", {
          error: r
        }), this.setLivestreamState("IDLE"), new R("Error while starting livestream", "1900", this.logger);
      }
    });
  }
  stop() {
    return u(this, null, function* () {
      if (!a(this, ln).permissions.canLivestream)
        throw this.logger.error("DyteLivestream::stop::permission_denied"), new R(
          "User does not have permission to stop livestreaming",
          "1901"
        );
      if (this.state !== "LIVESTREAMING" && this.state !== "WAITING_ON_MANUAL_INGESTION")
        throw this.logger.error("DyteLivestream::stop::inconsistent_state"), new R("Livestream not started yet", "1902");
      try {
        this.setLivestreamState("STOPPING"), yield lt().stopLivestreaming();
      } catch (e) {
        throw this.logger.error("DyteLivestream::stop::livestream_failed_to_stop", {
          error: e
        }), this.setLivestreamState("STOPPING"), new R("Error while stopping livestream", "1900", this.logger);
      }
    });
  }
}
ln = new WeakMap(), ec = new WeakMap();
Hf([
  E.trace("livestream.start")
], $h.prototype, "start", 1);
Hf([
  E.trace("livestream.stop")
], $h.prototype, "stop", 1);
var A0 = Object.defineProperty, M0 = Object.getOwnPropertyDescriptor, D0 = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? M0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && A0(t, e, i), i;
}, un, hn, Ys, Ms;
class Bf {
  constructor(t, e, r) {
    h(this, "livestream");
    g(this, un, void 0);
    g(this, hn, void 0);
    g(this, Ys, void 0);
    g(this, Ms, void 0);
    m(this, Ms, t), m(this, hn, e), this.livestream = new $h(t, e), m(this, Ys, r), this.setupEvents();
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ms).getValue("logger");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ms).getValue("telemetry");
  }
  fetchInitialLivestreamingState() {
    return u(this, null, function* () {
      const t = lt(), {
        status: e,
        playbackUrl: r,
        manualIngest: i,
        ingestionCredentials: n
      } = yield t.getActiveLivestream();
      this.livestream.playbackUrl = r, this.livestream.ingestionCredentials = n, e === "LIVE" && this.livestream.setLivestreamState("LIVESTREAMING"), e === "INVOKED" && i && this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
    });
  }
  setupEvents() {
    a(this, Ys).on(
      x.startedLivestream,
      (t) => u(this, null, function* () {
        this.livestream.playbackUrl = t.playbackUrl, this.livestream.setLivestreamState("LIVESTREAMING");
        try {
          a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
        } catch (e) {
          this.logger.error("Error: LivestreamController.fetchLivestream during startedLivestream re-fetch");
        }
      })
    ), a(this, Ys).on(
      x.livestreamingInvoked,
      (t) => u(this, null, function* () {
        if (t.manualIngest) {
          this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
          try {
            a(this, hn).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
          } catch (e) {
            this.logger.error("Error: LivestreamController.fetchLivestream during livestreamingInvoked re-fetch");
          }
        }
      })
    ), a(this, Ys).on(x.stoppedLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0, this.livestream.ingestionCredentials = void 0;
    }), a(this, Ys).on(x.erroredLivestream, () => {
      this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = void 0;
    }), a(this, Ys).on(
      x.roomPeerCount,
      (t) => {
        this.livestream.viewerCount = t.count, this.livestream.emit("viewerCountUpdate", t.count);
      }
    ), a(this, Ms).getValue("peerSessionStore").on(
      k.PEER_JOINED_INTERNAL,
      (t) => u(this, null, function* () {
        var e;
        ((e = t.flags) == null ? void 0 : e.hiddenParticipant) === !0 && t.recorderType === "LIVESTREAMER" && (m(this, un, t.id), this.livestream.setLivestreamState("LIVESTREAMING"));
      })
    ), a(this, Ms).getValue("peerSessionStore").on(k.PEER_CLOSED, (t) => {
      t.id === a(this, un) && (m(this, un, void 0), this.livestream.setLivestreamState("IDLE"));
    }), a(this, Ms).getValue("peerSessionStore").onAsync(k.LEAVE_MEDIA_ROOM, () => u(this, null, function* () {
      if (!this.livestream.playbackUrl) {
        this.logger.info("Fetching livestreaming state on leave stage");
        try {
          yield this.fetchInitialLivestreamingState();
        } catch (t) {
          this.logger.error("Failed to fetch livestreaming state on leave stage", { error: t });
        }
      }
    })), a(this, Ms).getValue("peerSessionStore").on(k.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
      try {
        yield this.fetchInitialLivestreamingState();
      } catch (t) {
        this.logger.error("Error: LivestreamController.fetchLivestream");
      }
    }));
  }
}
un = new WeakMap(), hn = new WeakMap(), Ys = new WeakMap(), Ms = new WeakMap();
D0([
  E.trace("LivestreamController.setupEvents")
], Bf.prototype, "setupEvents", 1);
var O0 = Object.defineProperty, N0 = Object.getOwnPropertyDescriptor, Qc = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? N0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && O0(t, e, i), i;
}, nt, Ur, $r, Kd, qf;
class Yn {
  constructor({ name: t, socketHandler: e, meetingId: r }) {
    g(this, Kd);
    h(this, "name", "");
    g(this, nt, {});
    g(this, Ur, "");
    g(this, $r, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "bulkRateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    h(this, "listeners", {});
    this.name = t, m(this, $r, e), m(this, Ur, r);
  }
  /**
     * @description Sets a value in the store.
     * @param {string} key - Unique identifier used to store value.
     * @param {any} value - Data to be set.
     * @returns {Promise<void>} A promise.
     */
  set(t, e, r = !0, i = !1) {
    return u(this, null, function* () {
      a(this, nt)[t] = e, r && this.remoteSet(t, e), i && (this.listeners[t] && this.listeners[t].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ), this.listeners["*"] && this.listeners["*"].forEach(
        (n) => n({ [t]: a(this, nt)[t] })
      ));
    });
  }
  remoteSet(t, e) {
    a(this, $r).storeInsertKeys(a(this, Ur), this.name, [{ key: t, payload: e }]);
  }
  bulkSet(t) {
    return u(this, null, function* () {
      t.forEach(({ key: e, payload: r }) => {
        a(this, nt)[e] = r;
      }), a(this, $r).storeInsertKeys(a(this, Ur), this.name, t);
    });
  }
  update(t, e, r = !0) {
    return u(this, null, function* () {
      L(this, Kd, qf).call(this, t, e, r);
    });
  }
  // eslint-disable-next-line consistent-return
  delete(t, e = !0, r = !1) {
    return u(this, null, function* () {
      if (a(this, nt)[t] && delete a(this, nt)[t], e)
        return a(this, $r).storeDeleteKeys(
          a(this, Ur),
          this.name,
          [{ key: t }]
        );
      r && (this.listeners[t] && (this.listeners[t].forEach((i) => i({ [t]: void 0 })), delete this.listeners[t]), this.listeners["*"] && this.listeners["*"].forEach((i) => i({ [t]: void 0 })));
    });
  }
  bulkDelete(t) {
    return u(this, null, function* () {
      return t.forEach(({ key: e }) => {
        a(this, nt)[e] && delete a(this, nt)[e];
      }), a(this, $r).storeDeleteKeys(
        a(this, Ur),
        this.name,
        t
      );
    });
  }
  /**
   * @description Returns value for the given key.
   * @param {string} key - Unique identifier used to store value.
   * @returns {any} Value for the given key.
   */
  get(t) {
    if (a(this, nt)[t])
      return a(this, nt)[t];
  }
  /**
   * @description Returns the entire store.
   * @returns {StoreData} An instance of StoreData.
   */
  getAll() {
    return a(this, nt);
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  get bulkRateLimits() {
    return this.bulkRateLimitConfig;
  }
  // eslint-disable-next-line class-methods-use-this
  updateBulkRateLimits(t, e) {
    this.bulkRateLimitConfig.maxInvocations = t, this.bulkRateLimitConfig.period = e;
  }
  /**
   * @description Listens for data change on a store key.
   * @param {string} key - Unique identifier used to store value.
   * @param {Function} cb - The callback function that gets executed
   * when data is modified.
   * @returns {void} void
   */
  subscribe(t, e) {
    if (this.listeners[t]) {
      this.listeners[t].push(e);
      return;
    }
    this.listeners[t] = [e];
  }
  /**
     * @description Removes all listeners for a key on the store.
     * @param {string} key - Unique identifier used to store value.
  * * @param {Function} cb - Callback to be removed.
     * @returns {void} void
     */
  unsubscribe(t, e) {
    var r;
    if (e) {
      this.listeners[t] = ((r = this.listeners[t]) == null ? void 0 : r.filter((i) => i !== e)) || [];
      return;
    }
    this.listeners[t] && delete this.listeners[t];
  }
  populate(t) {
    m(this, nt, t);
  }
}
nt = new WeakMap(), Ur = new WeakMap(), $r = new WeakMap(), Kd = new WeakSet(), qf = function(t, e, r = !0) {
  let i;
  const n = a(this, nt)[t], o = Object.prototype.toString.call(e), c = Object.prototype.toString.call(n);
  if (o !== c) {
    this.set(t, e);
    return;
  }
  switch (c) {
    case "[object Array]":
      i = [...n, ...e];
      break;
    case "[object Object]":
      i = D(D({}, n), e);
      break;
    case "[object Map]":
      i = new Map([...n, ...e]);
      break;
    case "[object Set]":
      i = /* @__PURE__ */ new Set([...n, ...e]);
      break;
    default:
      i = e;
      break;
  }
  this.set(t, i, r);
};
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "remoteSet", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkSet", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "update", 1);
Qc([
  Dt(zn, "rateLimitConfig")
], Yn.prototype, "delete", 1);
Qc([
  Dt(zn, "bulkRateLimitConfig")
], Yn.prototype, "bulkDelete", 1);
var Ai, Mi, tc, zu, sc, Fr, zd, jf;
class V0 {
  constructor(t, e) {
    g(this, tc);
    g(this, zd);
    h(this, "stores", /* @__PURE__ */ new Map());
    g(this, Ai, void 0);
    g(this, Mi, "");
    g(this, sc, void 0);
    g(this, Fr, /* @__PURE__ */ new Map());
    m(this, Ai, e), m(this, Mi, t.getValue("meetingId")), m(this, sc, t), L(this, zd, jf).call(this);
  }
  create(t) {
    const e = new Yn(
      { name: t, socketHandler: a(this, Ai), meetingId: a(this, Mi) }
    );
    return a(this, Ai).storeGetKeys(a(this, Mi), t, []), new Promise((i, n) => {
      const o = setTimeout(() => n(Error("Failed")), 3e3);
      a(this, Fr).set(t, { rejectTimeout: o, resolve: i, store: e });
    });
  }
}
Ai = new WeakMap(), Mi = new WeakMap(), tc = new WeakSet(), zu = function() {
  return a(this, sc).getValue("peerId");
}, sc = new WeakMap(), Fr = new WeakMap(), zd = new WeakSet(), jf = function() {
  [
    W.storeInsertKeys,
    W.storeGetKeys,
    W.storeDeleteKeys
  ].forEach((t) => {
    a(this, Ai).on(
      t,
      (e) => u(this, null, function* () {
        var n, o;
        if (e.pluginId !== a(this, Mi))
          return;
        const r = (n = e.storeItems) == null ? void 0 : n.map((c) => {
          var d;
          return {
            timestamp: c.timestamp,
            peerId: c.peerId,
            payload: JSON.parse(
              (d = c.payload) != null && d.length ? new TextDecoder().decode(c.payload) : "{}"
            ),
            key: c.storeKey
          };
        });
        if (t === W.storeGetKeys) {
          const c = a(this, Fr).get(e.storeName), d = this.stores.get(e.storeName) || (c == null ? void 0 : c.store);
          a(this, Fr).get(e.storeName) && (this.stores.set(e.storeName, c.store), c.resolve(d), clearTimeout(c.rejectTimeout), a(this, Fr).delete(e.storeName)), r.forEach((l) => {
            d.set(l.key, l.payload, !1, !1);
          });
          return;
        }
        const i = this.stores.get(e.storeName) || ((o = a(this, Fr).get(e.storeName)) == null ? void 0 : o.store);
        i !== void 0 && (t === W.storeInsertKeys && r.forEach(({ key: c, peerId: d, payload: l }) => {
          d !== a(this, tc, zu) && i.set(c, l, !1, !0);
        }), t === W.storeDeleteKeys && r.forEach(({ key: c, peerId: d }) => {
          d !== a(this, tc, zu) && i.delete(c, !1, !0);
        }));
      })
    );
  });
};
function gi(s) {
  var t, e, r, i, n, o, c, d, l, p, f, S, T;
  return s ? {
    media: {
      audio: {
        enabled: s.audioEnabled,
        trackId: (t = s.audioTrack) == null ? void 0 : t.id,
        permission: "mediaPermissions" in s ? (e = s.mediaPermissions) == null ? void 0 : e.audio : null
      },
      video: {
        enabled: s.videoEnabled,
        trackId: (r = s.videoTrack) == null ? void 0 : r.id,
        permission: "mediaPermissions" in s ? (i = s.mediaPermissions) == null ? void 0 : i.video : null
      },
      screenshare: {
        enabled: s.screenShareEnabled,
        permission: "mediaPermissions" in s ? (n = s.mediaPermissions) == null ? void 0 : n.screenshare : null,
        audio: {
          enabled: (c = (o = s.screenShareTracks) == null ? void 0 : o.audio) == null ? void 0 : c.enabled,
          trackId: (l = (d = s.screenShareTracks) == null ? void 0 : d.audio) == null ? void 0 : l.id
        },
        video: {
          enabled: (f = (p = s.screenShareTracks) == null ? void 0 : p.video) == null ? void 0 : f.enabled,
          trackId: (T = (S = s.screenShareTracks) == null ? void 0 : S.video) == null ? void 0 : T.id
        }
      }
    }
  } : {};
}
var L0 = Object.defineProperty, x0 = Object.getOwnPropertyDescriptor, Qn = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? x0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && L0(t, e, i), i;
};
const U0 = 0.8, $0 = 1.2;
var pn, gn, $t, Di, vo, Hr, wa, Oi, yo, Yd, Gf, Qs, rc, Br, Ni, To, Xs, Qd, ic, Yu, Xd, Wf, Zd, Jf, $g;
let yr = ($g = class extends qt {
  constructor(t, e, r, i) {
    const n = t.getValue("logger");
    super(n);
    // eslint-disable-next-line class-methods-use-this
    g(this, Di);
    g(this, Hr);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, Oi);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, Yd);
    g(this, Ni);
    g(this, ic);
    g(this, Xd);
    g(this, Zd);
    /**
     * The peer ID of the participant.
     * The participants are indexed by this ID in the participant map.
     */
    h(this, "id");
    /**
     * The user ID of the participant.
     */
    h(this, "userId");
    /**
     * The name of the participant.
     */
    h(this, "name");
    /**
     * The picture of the participant.
     */
    h(this, "picture");
    h(this, "isHost");
    /**
     * The custom id of the participant set during Add Participant REST API
     */
    h(this, "customParticipantId");
    h(this, "flags");
    /**
     * The device configuration of the participant.
     */
    h(this, "device");
    /**
     * The participant's video track.
     */
    h(this, "videoTrack");
    /**
     * The participant's audio track.
     */
    h(this, "audioTrack");
    /**
     * The participant's screenshare video and audio track.
     */
    h(this, "screenShareTracks");
    /**
     * This is true if the participant's video is enabled.
     */
    h(this, "videoEnabled");
    /**
     * This is true if the participant's audio is enabled.
     */
    h(this, "audioEnabled");
    /**
     * This is true if the participant is screensharing.
     */
    h(this, "screenShareEnabled");
    /**
     * producers created by participant
     */
    h(this, "producers");
    /**
     * producer config passed during manual subscription
     */
    h(this, "manualProducerConfig");
    /**
     * This is true if the participant is pinned.
     */
    g(this, pn, void 0);
    /**
     * This is true if the dyte participant supports remote control.
     */
    h(this, "supportsRemoteControl", !1);
    /**
     * Represents the participants current stage status
     */
    g(this, gn, void 0);
    /**
     * The preset of the participant.
     */
    h(this, "presetName");
    g(this, $t, void 0);
    g(this, Qs, void 0);
    g(this, rc, void 0);
    g(this, Br, /* @__PURE__ */ new Map());
    /*
    * Specifies the currently set max spatial layer
    * Assuming a two layer simulcast, 0 being the lower layer
    * default = 1
    */
    g(this, Xs, 1);
    g(this, Qd, Ih((t) => {
      if (!this.videoTrack)
        return;
      const { clientWidth: e, clientHeight: r } = t, { width: i, height: n } = this.videoTrack.getSettings();
      if (!i || !n)
        return;
      const o = n / r, c = i / e, d = Math.max(o, c);
      d > $0 && a(this, Xs) === 1 ? (m(this, Xs, 0), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      })) : d < U0 && a(this, Xs) === 0 && (m(this, Xs, 1), a(this, $t).getValue("peerSessionStore").emit(k.MAX_SPATIAL_LAYER_CHANGE, {
        peerId: this.id,
        maxSpatialLayer: a(this, Xs)
      }));
    }, 2e3));
    m(this, $t, t);
    const {
      id: o,
      userId: c,
      displayName: d,
      device: l,
      picture: p,
      isHost: f,
      flags: S,
      clientSpecificId: T,
      stageStatus: _,
      customParticipantId: P,
      audioMuted: w,
      audioTrack: A,
      videoEnabled: N = !1,
      videoTrack: H,
      producers: $,
      metadata: F
    } = e;
    this.id = o, this.userId = c, this.name = d, this.device = l, this.picture = p, this.isHost = f, this.flags = S, this.manualProducerConfig = EC, m(this, gn, _ != null ? _ : "ON_STAGE"), this.customParticipantId = P != null ? P : T, this.audioEnabled = !w, this.audioTrack = A, this.videoEnabled = N, this.videoTrack = H, this.screenShareTracks = {
      audio: void 0,
      video: void 0
    }, this.producers = $ != null ? $ : [], this.presetName = F == null ? void 0 : F.preset_name, m(this, pn, !1), m(this, Qs, r), m(this, rc, i), this.setupEvents(), this.updateVideo = this.updateVideo.bind(this), L(this, ic, Yu).call(this);
  }
  /**
   * @deprecated
   * Use `customParticipantId`
   */
  get clientSpecificId() {
    return this.customParticipantId;
  }
  /** Denotes the participants's current stage status. */
  get stageStatus() {
    return a(this, gn);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, $t).getValue("telemetry");
  }
  setVideoEnabled(t, e = !0) {
    this.videoEnabled = t, e && (this.logger.info("DyteParticipant::setVideoEnabled::videoUpdate", D({}, gi(this))), this.emit("videoUpdate", {
      videoEnabled: this.videoEnabled,
      videoTrack: this.videoTrack
    }));
  }
  setAudioEnabled(t, e = !0) {
    this.audioEnabled = t, e && (this.logger.info("DyteParticipant::setAudioEnabled::audioUpdate", D({}, gi(this))), this.emit("audioUpdate", {
      audioEnabled: this.audioEnabled,
      audioTrack: this.audioTrack
    }));
  }
  setScreenShareEnabled(t, e = !0) {
    this.screenShareEnabled = t, e && this.emit("screenShareUpdate", {
      screenShareEnabled: this.screenShareEnabled,
      screenShareTracks: this.screenShareTracks
    });
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ic, Yu)), a(this, Hr, wa) && (this.on("audioUpdate", L(this, Xd, Wf)), this.on("screenShareUpdate", L(this, Zd, Jf)));
  }
  /**
   * Returns `participant.id` if user has permission
   * to pin participants.
   */
  pin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t pin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to pin participants.", "1201");
      return a(this, Di, vo).pinPeer(this.id);
    });
  }
  /**
   * Returns `participant.id` if user has permission
   * to unpin participants.
   */
  unpin() {
    return u(this, null, function* () {
      if (!a(this, Oi, yo))
        throw new R("Can`t unpin participant without joining room", "1205");
      if (!a(this, Qs).permissions.pinParticipant)
        throw new R("You do not have permission to unpin participants.", "1201");
      return a(this, Di, vo).pinPeer(null);
    });
  }
  /**
   * @access private
   * Not for external use
   */
  setIsPinned(t, e = !0) {
    var i;
    m(this, pn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, Ni, To)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  disableAudio() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_audio", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant audio without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantAudio)
        return a(this, Di, vo).disableAudio(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_audio", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant audio.",
        "1201"
      );
    });
  }
  kick() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::kick", {
        dyteParticipant: { id: t }
      }), !a(this, Yd, Gf))
        throw new R("Can`t kick participant without joining room", "1205");
      if (a(this, Qs).permissions.kickParticipant) {
        yield a(this, $t).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
          peerId: t
        });
        return;
      }
      throw this.logger.error("DyteParticipant::unauthorized_kick", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to kick participants.",
        "1201"
      );
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      const t = this.id;
      if (this.logger.info("DyteParticipant::disable_video", {
        dyteParticipant: { id: t }
      }), !a(this, Oi, yo))
        throw new R(
          "Can`t disable participant video without joining room",
          "1205"
        );
      if (a(this, Qs).permissions.canDisableParticipantVideo)
        return a(this, Di, vo).disableVideo(t);
      throw this.logger.error("DyteParticipant::unauthorized_disable_video", {
        dyteParticipant: { id: t }
      }), new R(
        "Unauthorized: User does not have permission to disable participant video.",
        "1201"
      );
    });
  }
  getPermissions() {
    return u(this, null, function* () {
      return a(this, rc).getUserPermissions(this.userId);
    });
  }
  setStageStatus(t) {
    m(this, gn, t), this.emit("stageStatusUpdate", this);
  }
  /**
   * Returns true if the participant is pinned.
   */
  get isPinned() {
    return a(this, pn);
  }
  registerVideoElement(t) {
    var r, i, n, o;
    if (!t)
      return;
    let e;
    (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), "ResizeObserver" in window && (e = new ResizeObserver(() => a(this, Qd).call(this, t)), e.observe(t)), a(this, Br).set(t, { observer: e }), this.updateVideo(t), (o = a(this, Ni, To)) == null || o.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (n = this.raised) != null ? n : !1
    );
  }
  deregisterVideoElement(t) {
    var e, r, i, n;
    if (!t) {
      (e = a(this, Ni, To)) == null || e.removeSource(this.id);
      return;
    }
    t.srcObject = void 0, (i = (r = a(this, Br).get(t)) == null ? void 0 : r.observer) == null || i.disconnect(), a(this, Br).delete(t), (n = a(this, Ni, To)) == null || n.removeSource(this.id);
  }
  /**
   * Internal method, do not use
   */
  updateVideo(t) {
    var e;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const r = (e = t.srcObject) == null ? void 0 : e.getTracks()[0];
      if ((r == null ? void 0 : r.id) === this.videoTrack.id)
        return;
      const i = new MediaStream();
      i.addTrack(this.videoTrack), t.srcObject = i;
    } else
      t.srcObject = void 0;
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, pn = new WeakMap(), gn = new WeakMap(), $t = new WeakMap(), Di = new WeakSet(), vo = function() {
  return a(this, $t).getValue("roomNodeClient");
}, Hr = new WeakSet(), wa = function() {
  return a(this, $t).getValue("audioPlayback");
}, Oi = new WeakSet(), yo = function() {
  return a(this, $t).getValue("connectionHandler").mediaJoined;
}, Yd = new WeakSet(), Gf = function() {
  return a(this, $t).getValue("connectionHandler").socketJoined;
}, Qs = new WeakMap(), rc = new WeakMap(), Br = new WeakMap(), Ni = new WeakSet(), To = function() {
  return a(this, $t).getValue("pip");
}, Xs = new WeakMap(), Qd = new WeakMap(), ic = new WeakSet(), Yu = function() {
  Array.from(a(this, Br).keys()).forEach(this.updateVideo);
}, Xd = new WeakSet(), Wf = function() {
  var t, e;
  this.audioEnabled && this.audioTrack ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(this.id, this.audioTrack) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(this.id);
}, Zd = new WeakSet(), Jf = function() {
  var t, e;
  this.screenShareEnabled && this.screenShareTracks.audio ? (t = a(this, Hr, wa)) == null || t.addParticipantTrack(`screenshare-${this.id}`, this.screenShareTracks.audio) : (e = a(this, Hr, wa)) == null || e.removeParticipantTrack(`screenshare-${this.id}`);
}, $g);
Qn([
  E.trace("DyteParticipant.disableAudio")
], yr.prototype, "disableAudio", 1);
Qn([
  E.trace("DyteParticipant.kick")
], yr.prototype, "kick", 1);
Qn([
  E.trace("DyteParticipant.disableVideo")
], yr.prototype, "disableVideo", 1);
Qn([
  E.trace("DyteParticipant.getPermissions")
], yr.prototype, "getPermissions", 1);
Qn([
  E.trace("DyteParticipant.setStageStatus")
], yr.prototype, "setStageStatus", 1);
yr = Qn([
  ht("1200")
], yr);
class mi extends Vf {
  constructor(t, e) {
    const {
      onAddEvent: r = "participantJoined",
      onDeleteEvent: i = "participantLeft",
      onClearEvent: n = "participantsCleared"
    } = e != null ? e : {};
    super({
      onAddEvent: r,
      onDeleteEvent: i,
      onClearEvent: n
    }, t);
  }
  add(t, e = !0) {
    return this.has(t.id) && Object.is(this.get(t.id), t) === !1 && this.delete(t.id), super.add(t, e);
  }
  clear(t = !0, e = !1) {
    return super.clear(t, e);
  }
  delete(t, e = !0, r = !1) {
    return super.delete(t, e, r);
  }
}
var qr;
class F0 extends Jn {
  constructor(e) {
    super(e);
    g(this, qr, void 0);
    m(this, qr, /* @__PURE__ */ new Map());
  }
  /**
   * @private
   */
  __set(e, r) {
    return a(this, qr).set(e, r);
  }
  /**
   * @private
   */
  __clear() {
    return a(this, qr).clear();
  }
  get(e) {
    return a(this, qr).get(e);
  }
  toArray() {
    return Array.from(a(this, qr).values());
  }
}
qr = new WeakMap();
class H0 {
  constructor() {
    h(this, "_orderedArray");
    h(this, "_map");
    this._map = /* @__PURE__ */ new Map(), this._orderedArray = [];
  }
  add(t, e) {
    if (!this._map.has(t))
      return this._map.set(t, { peerId: t, priority: e }), this._orderedArray.splice(Math.max(e - 1, 0), 0, t), this.index(t);
    const r = this.index(t);
    this.delete(t);
    const i = this.add(t, e);
    return r !== i ? i : -1;
  }
  delete(t) {
    if (this._map.has(t)) {
      const e = this.index(t);
      this._map.delete(t), this._orderedArray.splice(e, 1);
    }
  }
  index(t) {
    return this._map.has(t) ? this._orderedArray.indexOf(t) : -1;
  }
  [Symbol.iterator]() {
    return this._orderedArray[Symbol.iterator]();
  }
}
class B0 {
  constructor() {
    h(this, "_activeSpeakerPeers");
    h(this, "_compulsoryPeers");
    this._activeSpeakerPeers = new H0(), this._compulsoryPeers = /* @__PURE__ */ new Set();
  }
  add(t, e, r) {
    if (!t)
      return -1;
    if (e < 0)
      return this._compulsoryPeers.add(t), 0;
    const i = r.getValue("logger");
    if (this.compulsoryPeers.includes(t) && (e > 0 || e === 246267631)) {
      if (i.info("DyteSelectedPeer::removing_compulsory_peer", {
        selectedPeer: {
          peerId: t
        }
      }), this._removeFromCompulsoryPeer(t), e === 246267631)
        return -1;
    } else if (e === 229490415)
      return this.delete(t, r), -1;
    return this._activeSpeakerPeers.add(t, e);
  }
  delete(t, e) {
    const r = e == null ? void 0 : e.getValue("logger");
    r == null || r.info("DyteSelectedPeer::deleting_peer_from_selectedPeer", {
      selectedPeer: {
        peerId: t
      }
    }), this._removeFromCompulsoryPeer(t), this._activeSpeakerPeers.delete(t);
  }
  index(t) {
    return this._activeSpeakerPeers.index(t);
  }
  get peers() {
    return Array.from(new Set(this.compulsoryPeers.concat(this.activeSpeakerPeers)));
  }
  get compulsoryPeers() {
    return Array.from(this._compulsoryPeers.values());
  }
  get activeSpeakerPeers() {
    return Array.from(this._activeSpeakerPeers);
  }
  _removeFromCompulsoryPeer(t) {
    this._compulsoryPeers.delete(t);
  }
}
const Kf = new B0();
var q0 = Object.defineProperty, j0 = Object.getOwnPropertyDescriptor, Wt = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? j0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && q0(t, e, i), i;
};
const G0 = ["ACTIVE_GRID", "PAGINATED", "MANUAL"];
var Le, Vi, Eo, Li, _o, mn, Td, xi, wt, Fg;
let Pt = (Fg = class extends qt {
  constructor(t, e, r) {
    const i = t.getValue("logger");
    super(i);
    // eslint-disable-next-line class-methods-use-this
    /**
     * #roomNodeClient could be null or undefined for livestream viewers,
     * because livestream viewers do not join media room.
     */
    g(this, Vi);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, Li);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, mn);
    /**
     * Returns a list of participants waiting to join the meeting.
     */
    h(this, "waitlisted");
    /**
     * Returns a list of all participants in the meeting.
     */
    h(this, "joined");
    /**
     * @deprecated
     * Returns a list of participants whose streams are currently consumed.
     */
    h(this, "active");
    /**
     * Returns a list of participants whose video streams are currently consumed.
     */
    h(this, "videoSubscribed");
    /**
     * Returns a list of participants whose audio streams are currently consumed.
     */
    h(this, "audioSubscribed");
    /**
     * Returns a list of participants who have been pinned.
     */
    h(this, "pinned");
    /**
     * Returns all added participants irrespective of whether they are currently
     * in the meeting or not
     */
    h(this, "all");
    g(this, Le, void 0);
    g(this, xi, void 0);
    g(this, wt, void 0);
    h(this, "rateLimitConfig", {
      maxInvocations: 5,
      period: 1
    });
    /**
     * Indicates whether the meeting is in 'ACTIVE_GRID' mode or 'PAGINATED' mode.
     *
     * In 'ACTIVE_GRID' mode, participants are populated in the participants.active map
     * dynamically. The participants present in the map will keep changing when other
     * participants unmute their audio or turn on their videos.
     *
     * In 'PAGINATED' mode, participants are populated in the participants.active map
     * just once, and the participants in the map will only change if the page number is
     * changed by the user using setPage(page).
     */
    h(this, "viewMode");
    /**
     * This indicates the current page that has been set by the user in PAGINATED mode.
     * If the meeting is in ACTIVE_GRID mode, this value will be 0.
     */
    h(this, "currentPage");
    /**
     * This stores the `participantId` of the last participant who spoke in the meeting.
     */
    h(this, "lastActiveSpeaker");
    /**
     * This constructs a new DyteParticipant object and maintains
     * the maps of active/joined/waitlisted/pinned/selectedPeers maps.
     * @param self : DyteSelf
     */
    /**
     * Keeps a list of all participants who have been present in the selected peers list.
     */
    h(this, "selectedPeers", Kf);
    m(this, Le, t), m(this, xi, e), m(this, wt, r), this.waitlisted = new mi(i), this.joined = new mi(i), this.videoSubscribed = new mi(i), this.audioSubscribed = new mi(i), this.active = this.videoSubscribed, this.pinned = new mi(i), this.all = new F0(i), this.viewMode = "ACTIVE_GRID", this.currentPage = 0, this.setupEvents();
  }
  /**
   * Return the controls for Picture-in-Picture
   */
  get pip() {
    return a(this, Le).getValue("pip");
  }
  get rateLimits() {
    return this.rateLimitConfig;
  }
  updateRateLimits(t, e) {
    this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Le).getValue("telemetry");
  }
  setupEvents() {
    a(this, Le).getValue("peerSessionStore").on(k.E2EE_ACTIVE_CONSUMER, ({ peerId: e }) => {
      var r;
      ((r = a(this, Le).getValue("modules").e2ee) == null ? void 0 : r.enabled) !== !0 && this.emit("media_decode_error", {
        reason: `Got encrypted media for participantId ${e}, but encryption wasn't enabled in init.defaults`,
        code: "1702"
      });
    });
    const t = a(this, Le).getValue("audioPlayback");
    t && this.audioSubscribed.on("participantLeft", (e) => {
      t.removeParticipantTrack(e.id);
    });
  }
  /**
   * Returns the number of participants who are joined in the meeting.
   */
  get count() {
    return this.joined.size;
  }
  /**
   * Returns the maximum number of participants that can be present in
   * the active map.
   */
  get maxActiveParticipantsCount() {
    var t;
    return (t = a(this, Le)) == null ? void 0 : t.getValue("maxPreferredStreams");
  }
  /**
   * Updates the maximum number of participants that are populated in
   * the active map.
   *
   * @param limit: Updated max limit
   */
  setMaxActiveParticipantsCount(t) {
    if (t < 0 || t > 24)
      throw new R("0 <= Max active participants count limit <= 24", "1203");
    a(this, Le).setValue("maxPreferredStreams", t), a(this, mn, Td) && a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  /**
   * Returns the number of pages that are available in the meeting in PAGINATED mode.
   * If the meeting is in ACTIVE_GRID mode, this value will be 0.
   */
  get pageCount() {
    if (this.viewMode === "PAGINATED") {
      const t = this.selectedPeers.compulsoryPeers.length, e = this.joined.toArray().filter((r) => r.stageStatus === "ON_STAGE");
      return Math.ceil(
        (e.length - t) / Math.max(this.maxActiveParticipantsCount - t, 1)
      );
    }
    return 0;
  }
  /**
   * Accepts requests from waitlisted participants if user
   * has appropriate permissions.
   * @param id peerId or userId of the waitlisted participant.
   */
  acceptWaitingRoomRequest(t) {
    var r, i;
    if (!a(this, Li, _o))
      throw new R(
        "Can`t accept waiting room request without joining room",
        "1205"
      );
    const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
    return a(this, wt).acceptWaitingRoomRequest([e]);
  }
  /**
   * We need a new event for socket service events
   * since if we send them all together, sequence of events
   * can be unreliable
   */
  acceptAllWaitingRoomRequest(t) {
    return u(this, null, function* () {
      const e = t.map((r) => {
        var i, n;
        return (n = (i = this.waitlisted.get(r)) == null ? void 0 : i.userId) != null ? n : r;
      });
      return a(this, wt).acceptWaitingRoomRequest(e);
    });
  }
  /**
   * Rejects requests from waitlisted participants if user
   * has appropriate permissions.
   * @param id participantId of the waitlisted participant.
   */
  rejectWaitingRoomRequest(t) {
    return u(this, null, function* () {
      var r, i;
      if (!a(this, Li, _o))
        throw new R(
          "Can`t reject waiting room request without joining room",
          "1205"
        );
      const e = (i = (r = this.waitlisted.get(t)) == null ? void 0 : r.userId) != null ? i : t;
      a(this, wt).rejectWaitingRoomRequest([e]);
    });
  }
  setViewMode(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_view_mode", {
        pageNavigation: {
          viewMode: t,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), !((r) => G0.includes(r))(t))
        throw this.logger.error("DyteParticipants::setViewMode::invalid_view_mode", {
          pageNavigation: {
            viewMode: t,
            currentPage: this.currentPage,
            pageCount: this.pageCount,
            maxActiveParticipantsCount: this.maxActiveParticipantsCount
          }
        }), new R(
          `Invalid view mode: ${t}. Try ACTIVE_GRID, PAGINATED or MANUAL.`,
          "1207"
        );
      if (this.viewMode === t) {
        this.logger.info(
          "DyteParticipants::setViewMode::view_mode_same_as_previous"
        );
        return;
      }
      if (t === "MANUAL")
        throw new R(
          "Manual Subscription is not enabled for your Organization. Please contact support.",
          "1208"
        );
      this.viewMode = t, t === "PAGINATED" ? (this.currentPage = 1, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: this.currentPage })) : t === "ACTIVE_GRID" && (this.currentPage = 0, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE)), this.emit("viewModeChanged", {
        viewMode: t,
        currentPage: this.currentPage,
        pageCount: this.pageCount
      });
    });
  }
  subscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: !0
            }), this.videoSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: !0
            }), this.audioSubscribed.add(o);
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: !0
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: !0
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).createConsumers(i);
    });
  }
  unsubscribe(r) {
    return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
      if (this.viewMode !== "MANUAL")
        throw new R("MANUAL subscription mode was not activated.", "1206");
      const i = [];
      t.forEach((n) => {
        const o = this.joined.get(n);
        if (o) {
          if (e.includes("audio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              audio: !1
            });
            const c = o.producers.find((d) => d.kind === "audio" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("video")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              video: !1
            });
            const c = o.producers.find((d) => d.kind === "video" && !d.screenShare);
            c && i.push(c);
          }
          if (e.includes("screenshareAudio")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareAudio: !1
            });
            const c = o.producers.find(
              (d) => d.kind === "audio" && d.screenShare
            );
            i.push(c);
          }
          if (e.includes("screenshareVideo")) {
            o.manualProducerConfig = B(D({}, o.manualProducerConfig), {
              screenshareVideo: !1
            });
            const c = o.producers.find(
              (d) => d.kind === "video" && d.screenShare
            );
            i.push(c);
          }
        }
      }), yield a(this, Vi, Eo).closeConsumers(i);
    });
  }
  // NOTE(itzmanish): hive systems specific code
  getPeerIdsForCurrentPage() {
    this.logger.info("DyteParticipants::getPeerIdsForCurrentPage()", {
      pageNavigation: {
        viewMode: this.viewMode,
        currentPage: this.currentPage,
        pageCount: this.pageCount,
        maxActiveParticipantsCount: this.maxActiveParticipantsCount
      }
    });
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (c) => this.joined.has(c)
    ), r = Array.from(this.pinned.keys()).filter(
      (c) => !e.includes(c)
    ), i = Array.from(this.joined.toArray().filter((c) => c.stageStatus === "ON_STAGE").map((c) => c.id)), n = Math.max(
      (this.currentPage - 1) * (this.maxActiveParticipantsCount - e.length - r.length)
    ), o = this.currentPage * (this.maxActiveParticipantsCount - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  setPage(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::set_page", {
        pageNavigation: {
          settingPage: t,
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      }), this.viewMode === "PAGINATED") {
        if (!Number.isInteger(t))
          throw this.logger.error("DyteParticipants::invalid_page_number"), new R(`Invalid page: ${t}. Page must be an integer and greater than 0 and less than or equal to .pageCount`, "1202");
        this.currentPage = t, a(this, Le).getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { page: t }), this.emit("pageChanged", {
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount
        });
      }
    });
  }
  disableAllAudio(t) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), !a(this, mn, Td))
        throw new R("Can`t disable all audio without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantAudio)
        return a(this, Vi, Eo).muteAll(t);
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_audio", {
        actions: { disableAllAudio: { allowUnmute: t } }
      }), new R(
        "Unauthorized: User does not have permission to disable peer audio.",
        "1201"
      );
    });
  }
  disableAllVideo() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::disable_all_video"), !a(this, mn, Td))
        throw new R("Can`t disable all video without joining room", "1205");
      if (a(this, xi).permissions.canAllowParticipantVideo)
        return a(this, Vi, Eo).muteAllVideo();
      throw this.logger.error("DyteParticipants::unauthorized_disable_all_video"), new R(
        "Unauthorized: User does not have permission to disable peer video.",
        "1201"
      );
    });
  }
  disableAudio(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableAudio();
    });
  }
  disableVideo(t) {
    return u(this, null, function* () {
      this.joined.get(t).disableVideo();
    });
  }
  kick(t) {
    return u(this, null, function* () {
      yield a(this, Le).getValue("peerSessionStore").emitAsync(k.KICK_PEER, {
        peerId: t
      });
    });
  }
  kickAll() {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::kick_all"), a(this, Le).getValue("viewType") !== "LIVESTREAM" && !a(this, Li, _o))
        throw new R("Can`t kick all without joining room", "1205");
      if (!a(this, xi).permissions.kickParticipant)
        throw this.logger.error("DyteParticipants::unauthorized_kick_all"), new R(
          "Unauthorized: User does not have permission to kick peers.",
          "1201"
        );
      const e = a(this, Le).getValue("flagsmith").hasFeature(X.PROPAGATE_KICK_ALL);
      a(this, wt).kickAll(e);
    });
  }
  broadcastMessage(t, e, r) {
    return u(this, null, function* () {
      if (this.logger.info("DyteParticipants::broadcastMessage"), !a(this, Li, _o))
        throw new R("Can`t broadcast message without joining room", "1205");
      if (!(t != null && t.trim()))
        throw new R("`type` must be a non-empty string.", "1209");
      if (r)
        if ("meetingIds" in r)
          yield a(this, wt).broadcastToMeetings(t, r.meetingIds, e);
        else {
          let i = [];
          "participantIds" in r ? i = r.participantIds : i = this.joined.toArray().filter(
            (n) => {
              var o;
              return (o = r.presetNames) == null ? void 0 : o.includes(n.presetName);
            }
          ).map((n) => n.id), yield a(this, wt).broadcastToPeers(t, i, e);
        }
      else
        yield a(this, wt).broadcastMessage(t, e);
    });
  }
  getAllJoinedPeers(t, e, r) {
    return u(this, null, function* () {
      return (yield a(this, wt).getRoomPeers(t, e, r)).peers.map(_r.formatSocketServiceMessage);
    });
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = this.joined.toArray().filter((n) => t.includes(n.id)).map((n) => n.userId), i = [...new Set(r)];
      if (!i.length)
        throw new R("Cannot update permissions, no valid userIDs found", "1204");
      a(this, wt).updatePermissions(i, e);
    });
  }
  getParticipantsInMeetingPreJoin() {
    return u(this, null, function* () {
      return a(this, wt).getRoomPeersNonPaginated();
    });
  }
}, Le = new WeakMap(), Vi = new WeakSet(), Eo = function() {
  return a(this, Le).getValue("roomNodeClient");
}, Li = new WeakSet(), _o = function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === !0;
}, mn = new WeakSet(), Td = function() {
  var t;
  return ((t = a(this, Le).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === !0;
}, xi = new WeakMap(), wt = new WeakMap(), Fg);
Wt([
  E.trace("DyteParticipants.setViewMode")
], Pt.prototype, "setViewMode", 1);
Wt([
  E.trace("DyteParticipants.setPage")
], Pt.prototype, "setPage", 1);
Wt([
  E.trace("DyteParticipants.disableAllAudio")
], Pt.prototype, "disableAllAudio", 1);
Wt([
  E.trace("DyteParticipants.disableAllVideo")
], Pt.prototype, "disableAllVideo", 1);
Wt([
  E.trace("DyteParticipants.disablePeerAudio")
], Pt.prototype, "disableAudio", 1);
Wt([
  E.trace("DyteParticipants.disablePeerVideo")
], Pt.prototype, "disableVideo", 1);
Wt([
  E.trace("DyteParticipants.kickPeer")
], Pt.prototype, "kick", 1);
Wt([
  E.trace("DyteParticipants.kickAll")
], Pt.prototype, "kickAll", 1);
Wt([
  E.trace("DyteParticipants.broadcastMessage"),
  Dt(zn, "rateLimitConfig")
], Pt.prototype, "broadcastMessage", 1);
Wt([
  E.trace("DyteParticipants.getAllJoinedPeers"),
  Dt({ maxInvocations: 10, period: 60 })
], Pt.prototype, "getAllJoinedPeers", 1);
Wt([
  E.trace("DyteParticipant.updatePermissions"),
  Dt({ maxInvocations: 1e3, period: 60 })
], Pt.prototype, "updatePermissions", 1);
Wt([
  E.trace("DyteParticipants.getParticipantsInMeetingPreJoin")
], Pt.prototype, "getParticipantsInMeetingPreJoin", 1);
Pt = Wt([
  ht("1200")
], Pt);
var xa = /* @__PURE__ */ ((s) => (s.NEW = "new", s.CONNECTING = "connecting", s.RECONNECTING = "reconnecting", s.DISCONNECTED = "disconnected", s.CONNECTED = "connected", s.FAILED = "failed", s.CLOSED = "closed", s))(xa || {}), we = /* @__PURE__ */ ((s) => (s[s.HIVE = 1] = "HIVE", s[s.ROOM_NODE = 2] = "ROOM_NODE", s[s.CF = 3] = "CF", s))(we || {}), W0 = Object.defineProperty, J0 = Object.getOwnPropertyDescriptor, Ea = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? J0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && W0(t, e, i), i;
}, Zs, er, tr, Ui, fn, Hg;
const ba = (Hg = class {
  constructor(s, t, e, r) {
    h(this, "participants");
    h(this, "self");
    h(this, "selectedPeers", Kf);
    h(this, "maxSpatialLayerUpdates", /* @__PURE__ */ new Map());
    h(this, "consumerPeerMap");
    h(this, "events");
    h(this, "roomSocketHandler");
    h(this, "context");
    h(this, "videoPeerConsumerMap", /* @__PURE__ */ new Map());
    g(this, Zs, { mode: "ACTIVE_GRID", page: 0 });
    g(this, er, void 0);
    g(this, tr, void 0);
    g(this, Ui, !1);
    g(this, fn, !1);
    h(this, "updateConsumerSpatialLayers", Ih(() => {
      const s = {}, t = new Map(this.maxSpatialLayerUpdates);
      this.maxSpatialLayerUpdates.clear(), Array.from(t.entries()).forEach(([e, r]) => {
        s[r] === void 0 && (s[r] = {
          layer: r,
          consumerIds: []
        }), s[r].consumerIds.push(e);
      }), Object.keys(s).forEach((e) => {
        const r = s[e];
        this.logger.log(`Switching max spatial layer to ${r.layer}`, { consumerIds: r.consumerIds }), this.roomNodeClient.switchConsumersToLayer(r.consumerIds, r.layer);
      });
    }, 2e3));
    h(this, "updateConsumers", (s, t) => u(this, null, function* () {
      try {
        s.length !== 0 && (this.logger.info("Queueing create consumers for producers", { producers: s }), yield this.roomNodeClient.createConsumers(s));
      } catch (e) {
        this.logger.error("Error activating peers", { error: e });
      }
      try {
        t.length !== 0 && (this.logger.info("Queueing close consumers for producers", { producers: t }), yield this.roomNodeClient.closeConsumers(t));
      } catch (e) {
        this.logger.error("Error deactivating peers", { error: e });
      }
    }));
    this.context = s;
    const i = s.getValue("logger");
    switch (m(this, er, new mi(i)), m(this, tr, new mi(i)), this.roomSocketHandler = e, this.participants = new Pt(s, t, this.roomSocketHandler), this.self = t, this.consumerPeerMap = /* @__PURE__ */ new Map(), r) {
      case we.HIVE: {
        this.events = is;
        break;
      }
      case we.CF: {
        this.events = Ts;
        break;
      }
      default:
        this.events = is;
    }
    t.config.viewType !== "CHAT" && this.setupEventsGlobal(), this.setupEvents();
  }
  get roomNodeClient() {
    return this.context.getValue("roomNodeClient");
  }
  get mediaJoined() {
    var s;
    return ((s = this.roomNodeClient) == null ? void 0 : s.mediaJoined) === !0;
  }
  get pip() {
    return this.context.getValue("pip");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  setupEvents() {
    this.roomSocketHandler.on(
      x.getWaitingRoomRequests,
      this.waitingRoomRequestHandler.bind(this)
    ), this.context.getValue("peerSessionStore").on(k.SOCKET_PEERS, (s) => u(this, null, function* () {
      const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
      if (t) {
        const e = s && (s == null ? void 0 : s.length) < 20 ? {
          peers: JSON.stringify(s.map((r) => r.peerId))
        } : void 0;
        this.logger.info("Processing socket peers", e);
      }
      s == null || s.forEach((e) => {
        e.waitlisted || this.onParticipantJoined(this.fromSocketService(e));
      }), t && this.logger.info("Processed socket peers");
    })), this.roomSocketHandler.on(
      this.events.peerJoinedBroadcast,
      ({ participant: s }) => {
        this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN) && this.logger.info("events.peerJoinedBroadcast", { peers: s.peerId }), this.onMediaJoined(
          s.peerId,
          s.producerStates,
          s.capabilities
        );
      }
    ), this.roomSocketHandler.on(
      this.events.selfJoinComplete,
      ({ participants: s, selectedPeers: t, roomState: e }) => {
        if (this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN)) {
          const n = s && (s == null ? void 0 : s.length) < 20 ? {
            peers: JSON.stringify(s.map((o) => o.peerId))
          } : void 0;
          this.logger.info("events.selfJoinComplete", n);
        }
        s.forEach(({ peerId: n, producerStates: o, capabilities: c }) => this.onMediaJoined(
          n,
          o,
          c
        ));
        const { audioPeers: r, compulsoryPeers: i } = t != null ? t : {};
        e.pinnedPeerIds.length !== 0 && this.onParticipantPinned(e.pinnedPeerIds[0]), this.computeActivateParticipants(r != null ? r : [], i), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: !0 });
      }
    ), this.context.getValue("peerSessionStore").on(
      k.MAX_SPATIAL_LAYER_CHANGE,
      ({ peerId: s, maxSpatialLayer: t }) => {
        const e = this.videoPeerConsumerMap.get(s);
        e && (this.maxSpatialLayerUpdates.set(e, t), this.updateConsumerSpatialLayers());
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_PRODUCER,
      ({ peerId: s, producer: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              },
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        if (e.producers.push(t), this.logger.info(
          "ParticipantController::NEW_PRODUCER::producer_added_to_participant",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        ), this.participants.viewMode === "MANUAL") {
          let r = !1;
          const i = t.kind === "audio", n = t.kind === "video", o = e.manualProducerConfig;
          (i && (o.audio && !t.screenShare || o.screenshareAudio && t.screenShare) || n && (o.video && !t.screenShare || o.screenshareVideo && t.screenShare)) && (r = !0), r ? this.roomNodeClient.createConsumers([t]) : this.logger.info(
            "ParticipantController::NEW_PRODUCER::not_consuming_producer",
            {
              producer: {
                id: t == null ? void 0 : t.producerId,
                peerId: s,
                kind: t == null ? void 0 : t.kind,
                status: "UNKNOWN",
                appData: { screenShare: t == null ? void 0 : t.screenShare }
              }
            }
          );
          return;
        }
        (t == null ? void 0 : t.kind) === "audio" && this.participants.audioSubscribed.get(s) || (t == null ? void 0 : t.kind) === "video" && this.participants.videoSubscribed.get(s) || t != null && t.screenShare ? this.roomNodeClient.createConsumers([t]).catch((r) => {
          this.logger.error("ParticipantController::createConsumer failed", { error: r });
        }) : this.logger.info(
          "ParticipantController::NEW_PRODUCER::not_consuming_producer",
          {
            producer: {
              id: t == null ? void 0 : t.producerId,
              peerId: s,
              kind: t == null ? void 0 : t.kind,
              status: "UNKNOWN",
              appData: { screenShare: t == null ? void 0 : t.screenShare }
            }
          }
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_CLOSED,
      ({ peerId: s, producerId: t }) => {
        const e = this.participants.joined.get(s);
        if (!e) {
          this.logger.warn(
            "ParticipantController::NEW_PRODUCER::participant not found",
            {
              dyteParticipant: { id: s }
            }
          );
          return;
        }
        e.producers = e.producers.filter(
          (r) => r.producerId !== t
        );
      }
    ), this.context.getValue("peerSessionStore").on(
      k.PRODUCER_TOGGLE,
      ({
        peerId: s,
        producerId: t,
        paused: e,
        kind: r
      }) => {
        const i = this.participants.joined.get(s);
        if (i) {
          r === "audio" && i.setAudioEnabled(!e);
          const n = i.producers.find(
            (o) => o.producerId === t
          );
          n && (n.pause = e);
        }
      }
    ), this.roomSocketHandler.on(
      this.events.globalPeerPinBroadcast,
      (s) => {
        let t;
        if (s && (t = s.participantId), !this.mediaJoined)
          return;
        const e = t;
        this.onParticipantPinned(e);
        const r = this.participants.joined.get(e);
        r && this.roomNodeClient.activatePeers(r.producers).catch((i) => {
          this.logger.error("unable to create consumers", {
            error: i
          });
        });
      }
    ), this.roomSocketHandler.on(this.events.selectedPeer, ({ audioPeers: s, compulsoryPeers: t }) => {
      this.mediaJoined && this.onSelectedPeers(t.concat(s));
    }), this.roomSocketHandler.on(this.events.selectedPeerDiff, ({ entries: s }) => {
      if (!this.mediaJoined)
        return;
      const t = s.map((e) => ({
        peerId: e.peerId,
        priority: e.priority
      }));
      this.updateActiveParticipantsWithPriorities(t, !0);
    });
  }
  /**
   * Socket Service only
   */
  waitingRoomRequestHandler(s) {
    const t = s.requests.filter(
      (r) => !this.participants.waitlisted.toArray().find((i) => i.userId === r.userId)
    ), e = this.participants.waitlisted.toArray().filter(
      (r) => !s.requests.find((i) => i.userId === r.userId)
    );
    t.forEach((r) => this.participants.waitlisted.add(
      new yr(
        this.context,
        {
          id: r.peerId,
          displayName: r.displayName,
          audioMuted: !0,
          videoEnabled: !1,
          audioTrack: void 0,
          videoTrack: void 0,
          stageStatus: "OFF_STAGE",
          userId: r.userId,
          flags: {},
          isHost: !1,
          customParticipantId: r.customParticipantId,
          picture: r.picture,
          metadata: {
            preset_name: r.presetName
          }
        },
        this.self,
        this.roomSocketHandler
      )
    )), e.forEach((r) => this.participants.waitlisted.delete(r.id));
  }
  get maxPreferredStreams() {
    return this.participants.maxActiveParticipantsCount;
  }
  selectPagePeers(s) {
    const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
      (d) => this.participants.joined.has(d)
    ), r = Array.from(this.participants.pinned.keys()).filter(
      (d) => !e.includes(d)
    ), i = Array.from(this.participants.joined.toArray().filter((d) => d.stageStatus === "ON_STAGE").map((d) => d.id)), n = Math.max(
      (s - 1) * (this.maxPreferredStreams - e.length - r.length)
    ), o = s * (this.maxPreferredStreams - e.length - r.length);
    return e.concat(r, i.slice(n, o));
  }
  selectActivePeers(s) {
    const t = /* @__PURE__ */ new Map(), e = Array.from(
      this.participants.joined.toArray().filter((p) => p.stageStatus === "ON_STAGE").map((p) => (t.set(p.id, !0), p.id))
    ), r = this.selectedPeers.peers, i = this.participants.pinned.toArray().reduce((p, f) => (f.stageStatus !== "ON_STAGE" ? this.participants.pinned.delete(f.id) : p.push(f.id), p), []), n = this.self.stageStatus === "ON_STAGE" ? 1 : 0, o = s - n, c = new Set(
      r.concat(i).filter((p) => p !== this.self.id && t.has(p))
    );
    let d = Array.from(c);
    const l = o - c.size;
    if (l >= 0) {
      const p = e.filter((f) => !c.has(f) && f !== this.self.id).slice(0, l);
      d = Array.from(c).concat(p);
    } else
      d = d.slice(0, o);
    return d;
  }
  updateSubscriptions(s, t) {
    const { page: e, createAllConsumers: r } = t != null ? t : {};
    s && a(this, Zs).mode !== s && (a(this, Zs).mode = s), e && a(this, Zs).page !== e && (a(this, Zs).page = e);
    const { mode: i, page: n } = a(this, Zs);
    switch (r && (a(this, er).clear(), a(this, tr).clear()), i) {
      case "PAGINATED": {
        if (!n)
          return;
        const o = this.selectPagePeers(n), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMap(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c), this.logger.debug(
          "ParticipantController::updateActive::updating_current_page_peers",
          { peerIds: o }
        );
        break;
      }
      case "ACTIVE_GRID": {
        const o = this.selectActivePeers(this.participants.maxActiveParticipantsCount), c = this.selectActivePeers(
          this.participants.maxActiveParticipantsCount + 4
        );
        this.updateParticipantsMapMinReplacement(this.participants.videoSubscribed, o), this.updateParticipantsMap(this.participants.audioSubscribed, c);
        break;
      }
      default:
        throw new Error(`View mode ${s} not supported`);
    }
    setTimeout(() => this.syncConsumers(), a(this, Zs).mode === "PAGINATED" && !a(this, Ui) ? 200 : 0);
  }
  syncConsumers() {
    return u(this, null, function* () {
      var e, r, i;
      if (((i = (r = (e = this.context.getValue("connectionHandler")) == null ? void 0 : e.mediaState) == null ? void 0 : r.recv) == null ? void 0 : i.state) !== "connected")
        return;
      if (a(this, Ui)) {
        m(this, fn, !0);
        return;
      }
      m(this, Ui, !0), m(this, fn, !1);
      let s = [], t = [];
      if (this.context.getValue("flagsmith").hasFeature(X.NEW_SYNC_CONSUMERS)) {
        const n = [], o = this.participants.videoSubscribed.toArray().reduce((P, w) => w.videoEnabled ? (n.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), c = [], d = this.participants.audioSubscribed.toArray().reduce((P, w) => w.audioEnabled ? (c.push(w.id), P.set(w.id, w)) : P, /* @__PURE__ */ new Map()), [l, p] = ba.mapDiff(
          a(this, er),
          o
        );
        this.updateParticipantsMap(a(this, er), n);
        const [f, S] = ba.mapDiff(
          a(this, tr),
          d
        );
        this.updateParticipantsMap(a(this, tr), c);
        const T = p.filter((P) => !this.participants.videoSubscribed.get(P)), _ = S.filter((P) => !this.participants.audioSubscribed.get(P));
        s = [
          ...this.mapPeerIdsToProducers(l, ["video"]),
          ...this.mapPeerIdsToProducers(f, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(T, ["video"]),
          ...this.mapPeerIdsToProducers(_, ["audio"])
        ];
      } else {
        const [n, o] = ba.mapDiff(
          a(this, er),
          this.participants.videoSubscribed
        );
        this.updateParticipantsMap(
          a(this, er),
          this.participants.videoSubscribed.toArray().filter(({ videoEnabled: l }) => !!l).map(({ id: l }) => l)
        );
        const [c, d] = ba.mapDiff(
          a(this, tr),
          this.participants.audioSubscribed
        );
        this.updateParticipantsMap(
          a(this, tr),
          this.participants.audioSubscribed.toArray().filter(({ audioEnabled: l }) => !!l).map(({ id: l }) => l)
        ), s = [
          ...this.mapPeerIdsToProducers(n, ["video"]),
          ...this.mapPeerIdsToProducers(c, ["audio"])
        ], t = [
          ...this.mapPeerIdsToProducers(o, ["video"]),
          ...this.mapPeerIdsToProducers(d, ["audio"])
        ];
      }
      try {
        (s.length > 0 || t.length > 0) && (yield this.updateConsumers(s, t));
      } finally {
        m(this, Ui, !1);
      }
      a(this, fn) && this.syncConsumers();
    });
  }
  static mapDiff(s, t) {
    const e = [], r = [], i = Array.from(s.keys()), n = Array.from(t.keys());
    return i.forEach((o) => {
      n.includes(o) || r.push(o);
    }), n.forEach((o) => {
      i.includes(o) || e.push(o);
    }), [
      e,
      r
    ];
  }
  computeActivateParticipants(s, t) {
    const e = s.map((i, n) => ({
      peerId: i,
      priority: n + 1
    })), r = t == null ? void 0 : t.map((i, n) => ({
      peerId: i,
      priority: -(n + 1)
    }));
    e.push(...r != null ? r : []), e.length > 0 && this.updateActiveParticipantsWithPriorities(e);
  }
  fromSocketService(s) {
    const t = ba.formatSocketServiceMessage(s);
    return new yr(this.context, B(D({}, t), {
      isHost: !1,
      videoEnabled: !1,
      audioMuted: !0,
      videoTrack: void 0,
      audioTrack: void 0
    }), this.self, this.roomSocketHandler);
  }
  updatePipSource(s, t) {
    var e, r;
    t ? (e = this.pip) == null || e.enableSource(s) : (r = this.pip) == null || r.disableSource(s);
  }
  onMediaJoined(s, t, e) {
    if (!this.mediaJoined || s === this.self.id)
      return;
    const r = this.participants.joined.get(s);
    if (!r) {
      this.logger.warn(`Received media.peerJoinedBroadcast for non-existent peer ${s}`);
      return;
    }
    t.forEach((i) => {
      i.kind === xs.AUDIO && !i.screenShare ? r.setAudioEnabled(!i.pause) : i.kind === xs.VIDEO && !i.screenShare && (r.setVideoEnabled(!i.pause), this.updatePipSource(r.id, !i.pause)), r.producers.push(B(D({}, i), {
        producingTransportId: i.producingTransportId,
        kind: i.kind === xs.AUDIO ? "audio" : "video",
        producingPeerId: s,
        mimeType: i.mimeType
      }));
    }), this.roomNodeClient.handlePeerCapabilities(s, e), this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || this.roomNodeClient.shareWebcam(this.self.videoTrack), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE);
  }
  /**
  	* NOTE(roerohan): The following piece of code updates .active and ensures that the positions
  	* in the peer map are not affected by the order of the peerIds
  	* sent in the input. If a participant is present in the 3rd position in the
  	* map, and room node sends the peerId in the 2nd position, the participant
  	* should remain in the 3rd position.
  */
  updateParticipantsMapMinReplacement(s, t) {
    const e = Array.from(s.keys()), r = new Map(s), i = new Set(t), n = [];
    e.forEach((o, c) => {
      (!i.has(o) || !this.participants.joined.get(o)) && n.push(c);
    }), t.forEach((o) => {
      if (s.get(o))
        return;
      if (e.length < t.length) {
        e.push(o);
        return;
      }
      const c = n.shift();
      e[c] = o;
    }), n.forEach((o) => {
      e.splice(o, 1);
    }), Array.from(s.keys()).forEach((o) => {
      s.delete(o, !i.has(o));
    }), e.forEach((o) => {
      if (!this.participants.joined.get(o)) {
        this.logger.warn(
          "updateActiveParticipants::participant_not_in_joined_list",
          {
            dyteParticipant: { id: o }
          }
        );
        return;
      }
      s.add(
        this.participants.joined.get(o),
        !r.get(o)
      );
    }), s.emit("participantsUpdate");
  }
  updateParticipantsMap(s, t) {
    Array.from(s.keys()).forEach((r) => {
      t.includes(r) || s.delete(r, !0);
    }), t.forEach((r) => {
      s.get(r) || s.add(this.participants.joined.get(r), !0);
    }), s.emit("participantsUpdate");
  }
  updatePinnedParticipants() {
    this.participants.pinned.forEach((s) => {
      s.setIsPinned(!1), this.participants.pinned.delete(s.id);
    });
  }
  setupEventsGlobal() {
    this.roomSocketHandler.on(x.joinRoom, ({ peer: s }) => {
      if (!s.waitlisted) {
        const t = this.context.getValue("flagsmith").hasFeature(X.DEBUG_SOCKET_JOIN);
        t && this.logger.info("Processing socket join", { peers: s.peerId }), this.onParticipantJoined(this.fromSocketService(s)), t && this.logger.info("Processed socket join", { peers: s.peerId });
      }
    }), this.roomSocketHandler.on(x.leaveRoom, (s) => {
      const { peerId: t } = s.peer;
      this.selectedPeers.delete(t, this.context), this.onParticipantLeave(t);
    }), this.context.getValue("peerSessionStore").on(
      k.SOCKET_SERVICE_ROOM_JOINED,
      () => {
        this.self.permissions.acceptWaitingRequests && this.roomSocketHandler.getWaitingRoomRequests();
      }
    ), this.self.permissions.on("permissionsUpdate", (s) => {
      const { acceptWaitingRequests: t } = s;
      t !== void 0 && (t ? this.roomSocketHandler.getWaitingRoomRequests() : this.participants.waitlisted.clear());
    }), this.context.getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, () => {
      this.participants.joined.clear(), this.participants.videoSubscribed.clear(), this.participants.audioSubscribed.clear(), this.participants.pinned.clear(), this.participants.currentPage = 0, this.participants.viewMode = "ACTIVE_GRID", this.participants.emit("viewModeChanged", {
        viewMode: "ACTIVE_GRID",
        currentPage: this.participants.currentPage,
        pageCount: this.participants.pageCount
      });
    }), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_PAUSED,
      ({ id: s }) => {
        this.processConsumerPaused(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_RESUMED,
      ({ id: s }) => {
        this.processConsumerResumed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.NEW_CONSUMER,
      ({ id: s }) => {
        this.processNewConsumer(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_CLOSED,
      ({ id: s }) => {
        this.processConsumerClosed(s);
      }
    ), this.context.getValue("peerSessionStore").on(
      k.ROOM_MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.MESSAGE,
      (r) => u(this, [r], function* ({
        payload: s,
        type: t,
        timestamp: e
      }) {
        t !== "spotlight" && this.participants.emit("broadcastedMessage", {
          type: t,
          payload: s,
          timestamp: e
        });
      })
    ), this.context.getValue("peerSessionStore").on(
      k.LOW_CONSUMER_SCORE,
      ({
        peerId: s,
        score: t,
        kind: e
      }) => {
        const r = this.participants.joined.get(s);
        r && (r.emit("poorConnection", { score: t, kind: e }), this.participants.emit("poorConnection", {
          participantId: s,
          score: t,
          kind: e
        }));
      }
    ), this.context.getValue("peerSessionStore").on(
      k.CONSUMER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        peerId: r,
        scoreStats: i
      }) => {
        var c;
        const n = t === "video" && ((c = e == null ? void 0 : e.screenShare) != null ? c : !1), o = this.participants.joined.get(r);
        o && (o.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }), this.participants.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: n,
          score: s,
          participantId: r,
          scoreStats: i
        }));
      }
    ), this.context.getValue("peerSessionStore").onAsync(k.KICK_PEER, (t) => u(this, [t], function* ({ peerId: s }) {
      const e = this.participants.joined.get(s);
      this.roomNodeClient.kick(s), yield this.roomSocketHandler.kick(s), e ? e.emit("kicked") : this.participants.joined.emit("kicked", { id: s });
    })), this.context.getValue("peerSessionStore").on(k.UPDATE_ACTIVE, (...e) => u(this, [...e], function* ({ page: s, createAllConsumers: t } = {}) {
      this.updateSubscriptions(s ? "PAGINATED" : "ACTIVE_GRID", { page: s, createAllConsumers: t });
    }));
  }
  onParticipantPinned(s) {
    return u(this, null, function* () {
      if (!s) {
        this.self.isPinned && this.self.setIsPinned(!1), this.participants.pinned.size !== 0 && this.updatePinnedParticipants();
        return;
      }
      if (s === this.self.id) {
        this.participants.pinned.size !== 0 && this.updatePinnedParticipants(), this.self.setIsPinned(!0);
        return;
      }
      const t = this.participants.joined.get(s);
      this.self.isPinned && this.self.setIsPinned(!1), this.updatePinnedParticipants(), t.setIsPinned(!0), this.participants.pinned.add(t);
    });
  }
  onParticipantJoined(s) {
    return u(this, null, function* () {
      var t, e, r;
      this.self.id !== s.id && !((t = s.flags) != null && t.recorder) && !((e = s.flags) != null && e.hidden_participant) && !((r = s.flags) != null && r.hiddenParticipant) && (this.participants.videoSubscribed.delete(s.id), this.participants.audioSubscribed.delete(s.id), this.participants.joined.add(s), this.participants.waitlisted.delete(s.id), s.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: s.name,
          userId: s.userId,
          peerId: s.id
        },
        add: !0
      })), this.context.getValue("peerSessionStore").emit(k.PEER_JOINED_INTERNAL, s);
    });
  }
  onParticipantLeave(s) {
    return u(this, null, function* () {
      const t = this.participants.joined.get(s);
      this.participants.joined.delete(s, !0, !0), this.participants.pinned.delete(s, !0, !0), this.participants.waitlisted.delete(s, !0, !0), this.roomNodeClient && (this.roomNodeClient.handlePeerLeaving(s), this.roomNodeClient.closeConsumers(t == null ? void 0 : t.producers)), t && t.stageStatus === "REQUESTED_TO_JOIN_STAGE" && this.context.getValue("peerSessionStore").emit(k.UPDATE_STAGE_REQUESTS, {
        request: {
          displayName: t.name,
          userId: t.userId,
          peerId: t.id
        },
        add: !1
      });
      const { currentPage: e } = this.participants, r = this.maxPreferredStreams * (e - 1), i = this.participants.videoSubscribed.get(s);
      r === 0 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.joined.size <= r ? e === 2 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.setPage(e - 1) : i && this.updateSubscriptions(
        e ? "PAGINATED" : "ACTIVE_GRID",
        { page: e }
      );
    });
  }
  processMedia(s) {
    var f;
    const t = this.roomNodeClient.getConsumers(), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      producerId: o,
      rtpReceiver: c,
      paused: d,
      localId: l
    } = (f = t.get(s)) != null ? f : {};
    if (!e)
      return this.logger.warn("processMedia::Peer ID is undefined", {
        consumer: {
          id: s,
          kind: r,
          peerId: e,
          appData: {
            supportsRemoteControl: !!(i != null && i.supportsRemoteControl),
            screenShare: !!(i != null && i.screenShare)
          },
          remotelyPaused: d,
          producerId: o
        }
      }), {};
    const p = i;
    return r === "video" && p.screenShare !== !0 && this.videoPeerConsumerMap.set(e, s), this.logger.info("ParticipantController::processMedia", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: p,
        remotelyPaused: d,
        producerId: o
      }
    }), this.consumerPeerMap.set(s, {
      type: r,
      peerId: e,
      appData: p,
      remotelyPaused: d,
      producerId: o
    }), {
      peerId: e,
      kind: r,
      appData: p,
      remotelyPaused: d,
      track: n,
      producerId: o,
      rtpReceiver: c,
      localId: l
    };
  }
  processConsumerClosed(s) {
    const {
      peerId: t,
      type: e,
      appData: r,
      remotelyPaused: i,
      producerId: n
    } = this.consumerPeerMap.get(s) || {}, o = this.participants.joined.get(t);
    if (this.logger.info("ParticipantController::processConsumerClosed", {
      consumer: {
        id: s,
        peerId: t,
        appData: r,
        kind: e,
        remotelyPaused: i,
        producerId: n
      }
    }), this.consumerPeerMap.delete(s), e === "video" && r.screenShare !== !0 && this.videoPeerConsumerMap.delete(t), !o)
      return;
    const c = o.producers.find((l) => l.producerId === n);
    c && (c.consumer = {
      id: s,
      peerId: t,
      kind: void 0,
      appData: r,
      paused: i,
      producerId: n,
      rtpReceiver: void 0,
      localId: void 0
    });
    const d = [];
    r && r.screenShare ? (o.setScreenShareEnabled(!1), this.context.getValue("callstats").consumerSharedMediaState(s, { screen: !1 }), o.screenShareTracks.video && d.push(o.screenShareTracks.video.id), o.screenShareTracks.audio && d.push(o.screenShareTracks.audio.id), o.screenShareTracks = {
      audio: void 0,
      video: void 0
    }) : e === "audio" ? (o.setAudioEnabled(!1), o.audioTrack && d.push(o.audioTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { audio: !1 }), o.audioTrack = void 0) : e === "video" && (o.setVideoEnabled(!1), this.updatePipSource(o.id, !1), o.videoTrack && d.push(o.videoTrack.id), this.context.getValue("callstats").consumerSharedMediaState(s, { video: !1 }), o.videoTrack = void 0), r.e2ee && d.forEach((l) => {
      this.context.getValue("peerSessionStore").emit(
        k.E2EE_INACTIVE_CONSUMER,
        {
          peerId: t,
          trackId: l
        }
      );
    });
  }
  processConsumerResumed(s) {
    var S;
    const t = this.processMedia(s), {
      peerId: e,
      kind: r,
      appData: i,
      track: n,
      remotelyPaused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    } = t;
    if (!e)
      return;
    this.logger.info("ParticipantController::processConsumerResumed", {
      consumer: {
        id: s,
        peerId: e,
        kind: r,
        appData: i,
        remotelyPaused: o,
        producerId: c
      }
    });
    const p = this.participants.joined.get(e);
    if (!p)
      return;
    const f = p.producers.find((T) => T.producerId === c);
    if (f && (f.consumer = {
      id: s,
      peerId: e,
      kind: r,
      appData: i,
      paused: o,
      producerId: c,
      rtpReceiver: d,
      localId: l
    }), i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: e, rtpReceiver: d, track: n }), i.screenShare) {
      r === "video" ? p.screenShareTracks.video = n : r === "audio" && (p.screenShareTracks.audio = n), p.setScreenShareEnabled(!0), (S = this.context) == null || S.getValue("callstats").consumerSharedMediaState(s, { screen: !0 });
      return;
    }
    r === "video" ? (p.videoTrack = n, p.setVideoEnabled(!0), this.updatePipSource(p.id, !0), this.context.getValue("callstats").consumerSharedMediaState(s, { video: !0 })) : r === "audio" && (p.audioTrack = n, p.setAudioEnabled(p.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: p.audioEnabled
    }));
  }
  processConsumerPaused(s) {
    this.logger.info(
      `ParticipantController::processConsumerPaused called for consumerId: ${s}`
    );
    const {
      peerId: t,
      kind: e,
      track: r,
      appData: i,
      remotelyPaused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processConsumerPaused", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        appData: i,
        remotelyPaused: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f) => f.producerId === o);
    p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: i,
      paused: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), r && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_CONSUMER, { peerId: t, trackId: r.id }), e === "video" ? (l.videoTrack = r, l.setVideoEnabled(!1), this.updatePipSource(l.id, !1), this.context.getValue("callstats").consumerSharedMediaState(s, { video: !1 })) : e === "audio" && (l.audioTrack = r, l.setAudioEnabled(l.audioEnabled), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: l.audioEnabled
    }));
  }
  processNewConsumer(s) {
    const {
      peerId: t,
      kind: e,
      remotelyPaused: r,
      track: i,
      appData: n,
      producerId: o,
      rtpReceiver: c,
      localId: d
    } = this.processMedia(s);
    if (!t)
      return;
    this.logger.info("ParticipantController::processNewConsumer", {
      consumer: {
        id: s,
        peerId: t,
        kind: e,
        remotelyPaused: r,
        appData: n,
        producerId: o
      }
    });
    const l = this.participants.joined.get(t);
    if (!l)
      return;
    const p = l.producers.find((f) => f.producerId === o);
    if (p && (p.consumer = {
      id: s,
      peerId: t,
      kind: e,
      appData: n,
      paused: r,
      producerId: o,
      rtpReceiver: c,
      localId: d
    }), n.screenShare) {
      e === "video" ? l.screenShareTracks.video = i : e === "audio" && (l.screenShareTracks.audio = i), (!r || this.self.permissions.isRecorder || this.context.getValue("flagsmith").hasFeature(X.SCREEENSHARE_ERR_HACK)) && l.setScreenShareEnabled(!0), n.supportsRemoteControl && (l.supportsRemoteControl = !0), this.participants.broadcastMessage("screenshareConsumerCreated", {
        producerId: o,
        peerId: t,
        screenShare: !0,
        consumerId: s,
        consumerPeerId: this.self.id
      }), this.logger.info("ParticipantController::newScreenshareConsumer::screenshareConsumerCreated", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          remotelyPaused: r,
          appData: n,
          producerId: o
        }
      });
      return;
    }
    e === "video" ? (l.videoTrack = i, r || (l.setVideoEnabled(!0), this.updatePipSource(l.id, !0)), this.context.getValue("callstats").consumerSharedMediaState(s, {
      video: !r
    })) : e === "audio" && (l.audioTrack = i, r || l.setAudioEnabled(!0), this.context.getValue("callstats").consumerSharedMediaState(s, {
      audio: !r
    })), !r && n.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_CONSUMER, { peerId: t, rtpReceiver: c, track: i });
  }
  static formatSocketServiceMessage(s) {
    var e, r, i, n, o, c;
    if (!s)
      return;
    const t = Nh(s.stageType);
    return {
      id: s.peerId,
      userId: s.userId,
      name: s.displayName,
      displayName: s.displayName,
      stageType: t,
      customParticipantId: s.customParticipantId,
      presetId: s.presetId,
      picture: s.displayPictureUrl,
      waitlisted: s.waitlisted,
      stageStatus: t,
      metadata: {
        preset_name: (e = s.flags) == null ? void 0 : e.presetName
      },
      recorderType: (r = s.flags) == null ? void 0 : r.recorderType,
      flags: {
        hiddenParticipant: (i = s.flags) == null ? void 0 : i.hiddenParticipant,
        hidden_participant: (n = s.flags) == null ? void 0 : n.hiddenParticipant,
        recorder: ((o = s.flags) == null ? void 0 : o.recorderType) !== void 0 && ((c = s.flags) == null ? void 0 : c.recorderType) !== "NONE"
      }
    };
  }
  mapPeerIdsToProducers(s, t) {
    const e = (i, n) => i.filter(({ kind: o, screenShare: c }) => n.includes(o) || c && n.includes("screenshare"));
    return s.flatMap((i) => {
      const n = this.participants.joined.get(i);
      if (n)
        return e(n.producers, t);
    }).filter((i) => !!i);
  }
  // XXX dead code, this event is not fired
  onSelectedPeers(s, t) {
    return u(this, null, function* () {
      this.participants.viewMode === "ACTIVE_GRID" && this.computeActivateParticipants(s, t);
    });
  }
  updateActiveParticipantsWithPriorities(s, t = !1) {
    if (!this.mediaJoined) {
      this.logger.warn(
        "Skipped::ParticipantController::updateActiveParticipantsWithPriorities",
        {
          roomJoined: this.mediaJoined
        }
      );
      return;
    }
    s.forEach((r) => {
      this.selectedPeers.add(r.peerId, r.priority, this.context);
    });
    const e = this.selectedPeers.activeSpeakerPeers.at(0);
    e !== void 0 && e !== this.participants.lastActiveSpeaker && (this.participants.lastActiveSpeaker = e, this.participants.emit("activeSpeaker", {
      peerId: e,
      volume: 1
      // priority
    })), t && this.updateSubscriptions(this.participants.viewMode);
  }
}, Zs = new WeakMap(), er = new WeakMap(), tr = new WeakMap(), Ui = new WeakMap(), fn = new WeakMap(), Hg);
let _r = ba;
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEvents", 1);
Ea([
  E.trace("ParticipantController.setupEvents")
], _r.prototype, "setupEventsGlobal", 1);
Ea([
  E.trace("ParticipantController.processMedia")
], _r.prototype, "processMedia", 1);
Ea([
  E.trace("ParticipantController.processConsumerClosed")
], _r.prototype, "processConsumerClosed", 1);
Ea([
  E.trace("ParticipantController.processConsumerResumed")
], _r.prototype, "processConsumerResumed", 1);
Ea([
  E.trace("ParticipantController.processConsumerPaused")
], _r.prototype, "processConsumerPaused", 1);
Ea([
  E.trace("ParticipantController.processNewConsumer")
], _r.prototype, "processNewConsumer", 1);
const he = _s(
  kh().permissions
);
var q, Sn, $i, el, St, Vt;
const Oa = class extends qt {
  constructor(e, r, i, n = !1) {
    const o = e.getValue("logger");
    super(o);
    g(this, St);
    g(this, q, void 0);
    g(this, Sn, void 0);
    g(this, $i, void 0);
    g(this, el, (e) => {
      var p, f, S;
      const l = e, {
        chat: r,
        connectedMeetings: i,
        plugins: n,
        polls: o,
        media: c
      } = l, d = ho(l, [
        "chat",
        "connectedMeetings",
        "plugins",
        "polls",
        "media"
      ]);
      if (r && (r.private && br(a(this, q).chat.private, r.private), r.public && br(a(this, q).chat.public, r.public), this.emit("chatUpdate")), i && br(a(this, q).connectedMeetings, i), c) {
        const T = (P) => {
          switch (P) {
            case Qr.NONE:
              return j.Allowed;
            case Qr.ALLOWED:
              return j.Allowed;
            case Qr.NOT_ALLOWED:
              return j.NotAllowed;
            case Qr.CAN_REQUEST:
              return j.CanRequest;
            default:
              return;
          }
        }, _ = {
          audio: void 0,
          video: void 0,
          screenshare: void 0
        };
        (p = c.audio) != null && p.canProduce && (_.audio = {
          canProduce: T(c.audio.canProduce)
        }), (f = c.video) != null && f.canProduce && (_.video = {
          canProduce: T(c.video.canProduce)
        }), (S = c.screenshare) != null && S.canProduce && (_.screenshare = {
          canProduce: T(c.screenshare.canProduce)
        }), br(a(this, q).media, _);
      }
      n && (br(a(this, q).plugins, n), this.emit("pluginsUpdate")), o && (br(a(this, q).polls, o), this.emit("pollsUpdate")), Object.keys(d).length !== 0 && br(a(this, q), d), this.emit("permissionsUpdate", e);
    });
    if (!r)
      throw this.logger.error("DytePermissionsPreset::load_preset_permissions_failed"), new R("Could not load preset permissions.", "0904");
    m(this, $i, e), m(this, Sn, i), m(this, q, r), n && this.setupEvents();
  }
  setupEvents() {
    a(this, $i).getValue("peerSessionStore").on(k.UPDATE_PERMISSIONS, a(this, el));
  }
  /** @deprecated. Use init() */
  static fromResponse(e, r, i) {
    return new Oa(i, e, r, !0);
  }
  /** @deprecated. Use init() */
  static default(e, r) {
    return new Oa(e, he, r);
  }
  static init(e, r, i) {
    let n;
    return i ? n = new Oa(e, i, r, !0) : n = new Oa(e, he, r), n;
  }
  get mediaRoomType() {
    const { sfu: e } = a(this, $i).getValue("roomNodeOptions");
    return e === we.CF ? "CF" : "HIVE";
  }
  /**
   * The `stageEnabled` property returns a boolean value.
   * If `true`, stage management is available for the participant.
   */
  get stageEnabled() {
    var e;
    return ((e = a(this, q)) == null ? void 0 : e.stageEnabled) || a(this, Sn) === Mt.Webinar || a(this, Sn) === Mt.Livestream;
  }
  get acceptStageRequests() {
    var e, r;
    return this.stageEnabled ? ((e = a(this, q)) == null ? void 0 : e.acceptStageRequests) || ((r = a(this, q)) == null ? void 0 : r.canAcceptProductionRequests) : !1;
  }
  /**
   * The `stageAccess` property dictactes how a user interacts with the stage.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`;
   */
  get stageAccess() {
    var e, r, i;
    return ((e = a(this, q)) == null ? void 0 : e.stageAccess) === j.NotAllowed ? j.NotAllowed : ((r = a(this, q)) == null ? void 0 : r.stageAccess) === j.CanRequest ? j.CanRequest : ((i = a(this, q)) == null ? void 0 : i.stageAccess) === j.Allowed || a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed ? j.Allowed : a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest ? j.CanRequest : j.NotAllowed;
  }
  /**
   * The `acceptWaitingRequests` returns boolean value.
   * If `true`, participant can accept the request of waiting participant.
   */
  get acceptWaitingRequests() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.acceptWaitingRequests) != null ? r : he.acceptWaitingRequests;
  }
  /**
   * The `requestProduceVideo` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing video.
   */
  get requestProduceVideo() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.video) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `requestProduceAudio` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing audio.
   */
  get requestProduceAudio() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.audio) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `requestProduceScreenshare` returns boolean value.
   * If `true`, participant can send request to participants
   * about sharing screen.
   */
  get requestProduceScreenshare() {
    var e, r, i;
    return ((i = (r = (e = a(this, q)) == null ? void 0 : e.media) == null ? void 0 : r.screenshare) == null ? void 0 : i.canProduce) === j.CanRequest;
  }
  /**
   * The `canAllowParticipantAudio` returns boolean value.
   * If `true`, participant can enable other participants` audio.
   */
  get canAllowParticipantAudio() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantAudio) != null ? r : he.disableParticipantAudio;
  }
  /**
   * The `canAllowParticipantScreensharing` returns boolean value.
   * If `true`, participant can enable other participants` screen share.
   */
  get canAllowParticipantScreensharing() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canAcceptProductionRequests) != null ? r : he.canAcceptProductionRequests;
  }
  /**
   * The `canAllowParticipantVideo` returns boolean value.
   * If `true`, participant can enable other participants` video.
   */
  get canAllowParticipantVideo() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.disableParticipantVideo) != null ? r : he.disableParticipantVideo;
  }
  /**
   * If `true`, a participant can disable other participants` audio.
   */
  get canDisableParticipantAudio() {
    return this.canAllowParticipantAudio;
  }
  /**
   * If `true`, a participant can disable other participants` video.
   */
  get canDisableParticipantVideo() {
    return this.canAllowParticipantVideo;
  }
  /**
   * The `kickParticipant` returns boolean value.
   * If `true`, participant can remove other participants from the meeting.
   */
  get kickParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.kickParticipant) != null ? r : he.kickParticipant;
  }
  /**
   * The `pinParticipant` returns boolean value.
   * If `true`, participant can pin a participant in the meeting.
   */
  get pinParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.pinParticipant) != null ? r : he.pinParticipant;
  }
  /**
   * The `canRecord` returns boolean value.
   * If `true`, participant can record the meeting.
   */
  get canRecord() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canRecord) != null ? r : he.canRecord;
  }
  /**
   * @deprecated in favour of `waitingRoomBehaviour`.
   * The `waitingRoomType` returns string value.
   * type of waiting room behavior
   * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
   */
  get waitingRoomType() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  /**
   * The `waitingRoomType` returns string value.
   * type of waiting room behavior
   * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
   */
  get waitingRoomBehaviour() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.waitingRoomType) != null ? r : he.waitingRoomType;
  }
  /**
   * The `plugins` tells if the participant can act on plugins
   * there are 2 permissions with boolean values, `canStart` and `canClose`.
   */
  get plugins() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.plugins) != null ? r : he.plugins;
  }
  /**
   * The `polls` tells if the participant can use polls.
   * There are 3 permissions with boolean values, `canCreate`, `canVote`, `canViewResults`
   */
  get polls() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.polls) != null ? r : he.polls;
  }
  /**
   * @deprecated in favour of `canProduceVideo`
   * The `produceVideo` shows permissions for enabling video.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceVideo() {
    return this.canProduceVideo;
  }
  /**
   * @deprecated
   * The `requestProduce` returns boolean value.
   * If `true`, participant can send request to participants
   * about producing audio, video or screenshare.
   */
  get requestProduce() {
    return a(this, q).media.audio.canProduce === j.CanRequest || a(this, q).media.video.canProduce === j.CanRequest || a(this, q).media.screenshare.canProduce === j.CanRequest;
  }
  /**
   * The `canProduceVideo` shows permissions for enabling video.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceVideo() {
    var r;
    const e = (r = a(this, q).media.video.canProduce) != null ? r : he.media.video.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * @deprecated in favour of `canProduceScreenshare`
   * The `produceVideo` shows permissions for sharing screen.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceScreenshare() {
    return this.canProduceScreenshare;
  }
  /**
   * The `canProduceScreenshare` shows permissions for sharing screen.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceScreenshare() {
    var r;
    const e = (r = a(this, q).media.screenshare.canProduce) != null ? r : he.media.screenshare.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * @deprecated in favour of `canProduceAudio`
   * The `produceAudio` shows permissions for enabling audio.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get produceAudio() {
    return this.canProduceAudio;
  }
  /**
   * The `canProduceAudio` shows permissions for enabling audio.
   * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
   */
  get canProduceAudio() {
    var r;
    const e = (r = a(this, q).media.audio.canProduce) != null ? r : he.media.audio.canProduce;
    return this.stageEnabled && (a(this, St, Vt) === "ACCEPTED_TO_JOIN_STAGE" || a(this, St, Vt) === "ON_STAGE") && e === j.CanRequest ? j.Allowed : this.stageEnabled && (a(this, St, Vt) === "OFF_STAGE" || a(this, St, Vt) === "REQUESTED_TO_JOIN_STAGE") && e === j.Allowed ? j.NotAllowed : e;
  }
  /**
   * The `chatPublic` shows permissions for public chat
   * there are 4 permissions
   * `canSend` - if true, the participant can send chat
   * `text` - if true, the participant can send text
   * `files` - if true, the participant can send files
   */
  get chatPublic() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.public) != null ? i : he.chat.public;
  }
  /**
   * The `chatPrivate` shows permissions for public chat
   * there are 4 permissions
   * `canSend` - if true, the participant can send private chat
   * `text` - if true, the participant can send text as private chat
   * `files` - if true, the participant can send files as private chat
   * `canReceive` - (optional) if true, the participant can receive private chat
   */
  get chatPrivate() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.private) != null ? i : he.chat.private;
  }
  get chatChannel() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.channel) != null ? i : he.chat.channel;
  }
  get chatMessage() {
    var e, r, i;
    return (i = (r = (e = a(this, q)) == null ? void 0 : e.chat) == null ? void 0 : r.message) != null ? i : he.chat.message;
  }
  get connectedMeetings() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.connectedMeetings) != null ? r : he == null ? void 0 : he.connectedMeetings;
  }
  /**
   * The `hiddenParticipant` returns boolean value.
   * If `true`, participant is hidden.
   */
  get hiddenParticipant() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.hiddenParticipant) != null ? r : he.hiddenParticipant;
  }
  /**
   * The `showParticipantList` returns boolean value.
   * If `true`, participant list can be shown to the participant.
   */
  get showParticipantList() {
    var e;
    return (e = a(this, q).showParticipantList) != null ? e : he.showParticipantList;
  }
  /**
   * @deprecated in favour of `canChangeParticipantPermissions`
   * The `canChangeParticipantRole` returns boolean value.
   * If `true`, allow changing the participants' role.
   */
  get canChangeParticipantRole() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  /**
   * The `canChangeParticipantPermissions` returns boolean value.
   * If `true`, allow changing the participants' permissions.
   */
  get canChangeParticipantPermissions() {
    var e, r;
    return (r = (e = a(this, q)) == null ? void 0 : e.canChangeParticipantPermissions) != null ? r : he.canChangeParticipantPermissions;
  }
  /**
   * @deprecated
   * The `canChangeTheme` returns boolean value.
   * If `true`, the participant can change the meeting theme.
   */
  // eslint-disable-next-line class-methods-use-this
  get canChangeTheme() {
    return !1;
  }
  /**
   * @deprecated in favour of individual production settings
   * The `canPresent` returns boolean value.
   * If `true`, the participant can become a presentor.
   */
  get canPresent() {
    return a(this, q).media.audio.canProduce === j.Allowed || a(this, q).media.video.canProduce === j.Allowed || a(this, q).media.screenshare.canProduce === j.Allowed;
  }
  /**
   * @deprecated Use `acceptStageRequests` instead.
   */
  get acceptPresentRequests() {
    return this.acceptStageRequests;
  }
  get canEditDisplayName() {
    var e;
    return (e = a(this, q).canEditDisplayName) != null ? e : !1;
  }
  /**
   * @deprecated DyteSelf.config.maxScreenShareCount
   */
  // eslint-disable-next-line class-methods-use-this
  get maxScreenShareCount() {
    return 1;
  }
  // eslint-disable-next-line class-methods-use-this
  get isRecorder() {
    return a(this, q).isRecorder;
  }
  get canSpotlight() {
    return a(this, q).canSpotlight;
  }
  /** Livestream */
  get canLivestream() {
    return a(this, q).canLivestream;
  }
  get transcriptionEnabled() {
    return a(this, q).transcriptionEnabled;
  }
};
let Qu = Oa;
q = new WeakMap(), Sn = new WeakMap(), $i = new WeakMap(), el = new WeakMap(), St = new WeakSet(), Vt = function() {
  return a(this, $i).getValue("stageStatus");
};
var us;
class zf extends qt {
  constructor() {
    super(...arguments);
    h(this, "localMediaHandler");
    g(this, us, void 0);
  }
  updatePermission() {
    return u(this, null, function* () {
      var d, l;
      const e = (p, f) => {
        this.mediaPermissions[p] = f;
        const S = { message: this.mediaPermissions[p], kind: p };
        f === "DENIED" ? a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_ERROR, S) : a(this, us).getValue("peerSessionStore").emit(k.MEDIA_PERMISSION_UPDATE, S);
      };
      if (Te.getName() === "firefox")
        return;
      const r = "microphone", i = "camera", n = yield (d = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : d.query({ name: r }), o = yield (l = navigator == null ? void 0 : navigator.permissions) == null ? void 0 : l.query({
        name: i
      }), c = (p, f) => {
        switch (f) {
          case "granted":
            e(p, "ACCEPTED");
            break;
          case "denied":
            e(p, "DENIED");
            break;
          case "prompt":
            e(p, "NOT_REQUESTED");
            break;
        }
        this.localMediaHandler.repopulateAvailableDevices();
      };
      n && (n.onchange = () => c("audio", n.state)), o && (o.onchange = () => c("video", o.state));
    });
  }
  // eslint-disable-next-line class-methods-use-this
  populateMediaPermissionsInCallstats(i) {
    return u(this, arguments, function* ({
      message: e,
      kind: r
    }) {
      var n, o, c, d;
      switch (r) {
        case "audio": {
          (n = a(this, us)) == null || n.getValue("callstats").mediaPermission("AUDIO", e), (o = a(this, us)) == null || o.getValue("callstats").mediaPermission("SPEAKER", e);
          break;
        }
        case "video": {
          (c = a(this, us)) == null || c.getValue("callstats").mediaPermission("VIDEO", e);
          break;
        }
        case "screenshare": {
          (d = a(this, us)) == null || d.getValue("callstats").mediaPermission("SCREENSHARE", e);
          break;
        }
      }
    });
  }
  get peerId() {
    var e;
    return (e = a(this, us)) == null ? void 0 : e.getValue("peerId");
  }
  init() {
    return u(this, arguments, function* (e = {}, r = !1, i = null) {
      var n, o, c, d, l, p, f;
      if (Te.init(), !this.localMediaHandler)
        try {
          let S = !0;
          if ((n = i == null ? void 0 : i.getValue("defaults")) != null && n.mediaHandler)
            S = !1, this.localMediaHandler = i.getValue("defaults").mediaHandler.localMediaHandler;
          else if (navigator.RNLocalMediaHandlerImpl) {
            const { RNLocalMediaHandlerImpl: T } = navigator;
            this.localMediaHandler = yield T.init(e);
          } else
            this.localMediaHandler = new Ot(
              i,
              e.constraints,
              (o = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : o.isNonPreferredDevice,
              (c = i == null ? void 0 : i.getValue("defaults")) == null ? void 0 : c.autoSwitchAudioDevice
            );
          if (i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_UPDATE,
            (T) => u(this, null, function* () {
              if (this.populateMediaPermissionsInCallstats({
                message: T.message,
                kind: T.kind
              }), T.message === "NOT_REQUESTED")
                switch (T == null ? void 0 : T.kind) {
                  case "audio":
                    this.rawAudioTrack && (this.logger.info("Disabling audio due to media permission update"), this.disableAudio());
                    break;
                  case "video":
                    this.rawVideoTrack && (this.logger.info("Disabling video due to media permission update"), this.disableVideo());
                    break;
                  default:
                    break;
                }
              this.emit("mediaPermissionUpdate", T);
            })
          ), i == null || i.getValue("peerSessionStore").on(
            k.MEDIA_PERMISSION_ERROR,
            (T) => u(this, null, function* () {
              const { kind: _, message: P, constraints: w } = T;
              this.populateMediaPermissionsInCallstats({
                message: P,
                kind: _
              }), _ === "audio" ? (this.logger.info(`Disabling audio due to media permission error  skipping: ${this.localMediaHandler.audioUpdateInProgress}`), this.localMediaHandler.audioUpdateInProgress === !1 && this.disableAudio()) : _ === "video" && (this.logger.info(`Disabling video due to media permission error skipping: ${this.localMediaHandler.videoUpdateInProgress}`), this.localMediaHandler.videoUpdateInProgress === !1 && this.disableVideo()), this.logger.error("SelfController::mediaPermissionError", {
                error: { message: P },
                constraints: w,
                mediaPermissionsErrors: {
                  kind: _,
                  message: P
                }
              }), this.emit("mediaPermissionError", T), this.emit("mediaPermissionUpdate", { message: P, kind: _ });
            })
          ), S) {
            this.logger.info(`Setting up DyteSelfMedia streams using media handler. audio:${(d = e == null ? void 0 : e.audio) != null ? d : !0} video:${(l = e == null ? void 0 : e.video) != null ? l : !0}`);
            const T = this.localMediaHandler.setupStreams({
              video: (p = e == null ? void 0 : e.video) != null ? p : !0,
              audio: (f = e == null ? void 0 : e.audio) != null ? f : !0
            });
            r || (yield T);
          }
        } catch (S) {
          this.logger.error("DyteSelf::init::Failed To Setup Streams", {
            error: { name: S.name, message: S.message }
          });
        }
    });
  }
  set context(e) {
    m(this, us, e), this.localMediaHandler.context = e;
  }
  /**
   * Returns the `audioTrack`.
   */
  get audioTrack() {
    return this.localMediaHandler.audioTrack;
  }
  /**
   * Returns the `rawAudioTrack` having no middleware executed on it.
   */
  get rawAudioTrack() {
    return this.localMediaHandler.rawAudioTrack;
  }
  /**
   * Returns the current audio and video permissions given by the user.
   * 'ACCEPTED' if the user has given permission to use the media.
   * 'CANCELED' if the user has canceled the screenshare.
   * 'DENIED' if the user has denied permission to use the media.
   * 'SYS_DENIED' if the user's system has denied permission to use the media.
   * 'UNAVAILABLE' if the media is not available (or being used by a different application).
   */
  get mediaPermissions() {
    return this.localMediaHandler.permissions;
  }
  /**
   * Adds the audio middleware to be executed on the raw audio stream.
   * If there are more than 1 audio middlewares,
   * they will be executed in the sequence they were added in.
   * If you want the sequence to be altered, please remove all previous middlewares and re-add.
   */
  addAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addAudioMiddleware(e);
    });
  }
  /**
   * Removes the audio middleware, if it is there.
   */
  removeAudioMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAudioMiddleware(e);
    });
  }
  /**
   * Removes all audio middlewares, if they are there.
   */
  removeAllAudioMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllAudioMiddlewares();
    });
  }
  /**
   * Returns the `videoTrack`.
   */
  get videoTrack() {
    return this.localMediaHandler.videoTrack;
  }
  /**
   * Returns the `videoTrack` having no middleware executed on it.
   */
  get rawVideoTrack() {
    return this.localMediaHandler.rawVideoTrack;
  }
  /**
   * Adds the video middleware to be executed on the raw video stream.
   * If there are more than 1 video middlewares,
   * they will be executed in the sequence they were added in.
   * If you want the sequence to be altered, please remove all previous middlewares and re-add.
   */
  addVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.addVideoMiddleware(e);
    });
  }
  /**
   * Sets global config to be used by video middlewares.
   * @param config config
   * @param config.disablePerFrameCanvasRendering If set to true,
   * Instead of calling Middleware for every frame,
   * Middleware will only be called once that too with empty canvas,
   *  it is the responsibility of the middleware author to keep updating this canvas.
   * `meeting.self.rawVideoTrack` can be used to retrieve video track for the periodic updates.
   */
  setVideoMiddlewareGlobalConfig() {
    return u(this, arguments, function* (e = {
      disablePerFrameCanvasRendering: !1
    }) {
      return this.localMediaHandler.setVideoMiddlewareGlobalConfig(e);
    });
  }
  /**
   * Removes the video middleware, if it is there.
   */
  removeVideoMiddleware(e) {
    return u(this, null, function* () {
      return this.localMediaHandler.removeVideoMiddleware(e);
    });
  }
  /**
   * Removes all video middlewares, if they are there.
   */
  removeAllVideoMiddlewares() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeAllVideoMiddlewares();
    });
  }
  /**
   * Returns the screen share tracks.
   */
  get screenShareTracks() {
    return this.localMediaHandler.screenShareTracks;
  }
  /**
   * Returns true if audio is enabled.
   */
  get audioEnabled() {
    return this.localMediaHandler.audioEnabled;
  }
  /**
   * Returns true if video is enabled.
   */
  get videoEnabled() {
    return this.localMediaHandler.videoEnabled;
  }
  /**
   * Returns true if screen share is enabled.
   */
  get screenShareEnabled() {
    return this.localMediaHandler.screenShareEnabled;
  }
  enableAudio() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      this.localMediaHandler.disableAudio(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.enableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableScreenShare(), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      yield this.localMediaHandler.disableVideo(), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    });
  }
  /**
   * Returns the media devices currently being used.
   */
  getCurrentDevices() {
    return this.localMediaHandler.getCurrentDevices();
  }
  /**
   * Returns the local participant's audio devices.
   */
  getAudioDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getAudioDevices();
    });
  }
  /**
   * Returns the local participant's video devices.
   */
  getVideoDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getVideoDevices();
    });
  }
  /**
   * Returns the local participant's speaker devices.
   */
  getSpeakerDevices() {
    return u(this, null, function* () {
      return yield this.localMediaHandler.getSpeakerDevices();
    });
  }
  /**
   * Returns the local participant's device, indexed by ID and kind.
   * @param deviceId The ID of the device.
   * @param kind The kind of the device: audio, video, or speaker.
   */
  getDeviceById(e, r) {
    let i;
    return r === "audio" ? i = "audioinput" : r === "video" ? i = "videoinput" : r === "speaker" && (i = "audiooutput"), this.localMediaHandler.getDeviceById(e, i);
  }
  /**
   * Change the current media device that is being used by the local participant.
   * @param device The device that is to be used. A device of the same `kind` will be replaced.
   * the primary stream.
   */
  setDevice(e) {
    return u(this, null, function* () {
      switch (e.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(e);
          } catch (r) {
          } finally {
            this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(e);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(e);
          } catch (r) {
          } finally {
            this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
      this.emit("deviceUpdate", {
        device: e
      });
    });
  }
}
us = new WeakMap();
var K0 = Object.defineProperty, z0 = Object.getOwnPropertyDescriptor, Ct = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? z0(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && K0(t, e, i), i;
}, vn, vt, yn, He, sr, di, je, Ze, Tn, Ed, xe, Be, En, _n, ac, Xu, Bg;
let Xe = (Bg = class extends zf {
  constructor(t, e, r, i, n) {
    var c;
    const o = t.getValue("logger");
    super(o);
    g(this, sr);
    // eslint-disable-next-line class-methods-use-this
    g(this, je);
    g(this, Tn);
    /**
     * Returns true if the local participant has joined the meeting.
     */
    g(this, xe);
    g(this, ac);
    h(this, "name");
    h(this, "picture");
    h(this, "customParticipantId");
    h(this, "waitlistStatus");
    g(this, vn, void 0);
    g(this, vt, void 0);
    g(this, yn, void 0);
    h(this, "role");
    h(this, "userId");
    h(this, "organizationId");
    h(this, "supportsRemoteControl", !1);
    h(this, "device");
    g(this, He, void 0);
    h(this, "hidden", !1);
    /* Name of the preset used to join the meeting */
    h(this, "presetName");
    /**
     * Returns the current state of room
     * init - Inital State
     * joined - User is in the meeting
     * waitlisted - User is in the waitlist state
     * rejected - User's was in the waiting room, but the entry was rejected
     * kicked - A priveleged user removed the user from the meeting
     * left - User left the meeting
     * ended - The meeting was ended
     */
    h(this, "roomState", "init");
    g(this, En, /* @__PURE__ */ new Set());
    g(this, _n, /* @__PURE__ */ new Set());
    m(this, He, t), this.userId = e.id, this.name = e.name, this.picture = e.picture, this.customParticipantId = (c = e.customParticipantId) != null ? c : e.clientSpecificId, this.waitlistStatus = "none", m(this, vt, r), m(this, vn, i), this.hidden = !1, m(this, yn, !1), this.organizationId = e.organizationId, this.supportsRemoteControl = Te.isElectron(), this.device = Te.getDeviceInfo(), this.presetName = n, i.viewType !== Mt.Chat && this.updatePermission(), this.updateVideo = this.updateVideo.bind(this), L(this, ac, Xu).call(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, He).getValue("telemetry");
  }
  get stageStatus() {
    return a(this, He).getValue("stageStatus");
  }
  get id() {
    return this.peerId;
  }
  /** NOTE(ishita1805): Discussed with Ravindra, added a duplicate for consistency
   * when using identifiers in DyteLocker.
   * We might want to look at deprecating the `id` sometime later. */
  get peerId() {
    return a(this, He).getValue("peerId");
  }
  static __init__(t, e, r, i, n, o = !1) {
    return u(this, null, function* () {
      var S, T, _, P, w, A;
      let c = (T = (S = t.getValue("defaults")) == null ? void 0 : S.audio) != null ? T : !0, d = (P = (_ = t.getValue("defaults")) == null ? void 0 : _.video) != null ? P : !0;
      r.canProduceAudio !== "ALLOWED" && (c = !1), r.canProduceVideo !== "ALLOWED" && (d = !1);
      const l = new Xe(t, e, r, i, n);
      if (i.viewType === Mt.Chat)
        return l;
      const p = a0(i.mediaConstraints);
      br(p, (w = t.getValue("defaults")) == null ? void 0 : w.mediaConfiguration);
      const f = (A = t.getValue("defaults")) == null ? void 0 : A.mediaHandler;
      return f && (f.context = t), yield l.init({
        audio: c,
        video: d,
        constraints: p
      }, o, t), l.setupEvents(), l;
    });
  }
  cleanupEvents() {
    this.removeAllListeners("videoUpdate"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("VIDEO_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_CHANGE"), this.localMediaHandler.removeAllListeners("DEVICE_LIST_UPDATED"), this.localMediaHandler.removeAllListeners("SCREENSHARE_TRACK_CHANGE"), this.localMediaHandler.removeAllListeners("SCREENSHARE_ENDED"), this.localMediaHandler.removeAllListeners("AUDIO_TRACK_SILENT"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_AUDIO"), this.localMediaHandler.removeAllListeners("FORCE_MUTE_VIDEO"), a(this, vt).removeAllListeners("permissionsUpdate");
  }
  setupEvents() {
    this.on("videoUpdate", L(this, ac, Xu));
    const t = a(this, Tn, Ed);
    t && t.onError((e) => {
      this.emit("autoplayError", e);
    }), this.localMediaHandler.on("AUDIO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::AUDIO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.audioEnabled)
        try {
          yield a(this, je, Ze).shareMic(this.audioTrack);
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::Error while sharing mic", {
            error: e
          }), this.localMediaHandler.disableAudio();
        }
      this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      });
    })), this.localMediaHandler.on("VIDEO_TRACK_CHANGE", () => u(this, null, function* () {
      if (this.logger.info("DyteSelf::setupEvents::VIDEO_TRACK_CHANGE", D({}, gi(this))), a(this, xe, Be) && this.rawVideoTrack === void 0)
        this.logger.info("DyteSelf::VIDEO_TRACK_CHANGE::Forcing_disable_video"), this.disableVideo();
      else if (this.videoEnabled && a(this, xe, Be))
        try {
          const e = yield a(this, je, Ze).shareWebcam(this.videoTrack);
          e && e.id !== this.videoTrack.id && a(this, He).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, je, Ze).shareWebcam(this.videoTrack));
        } catch (e) {
          this.logger.error("DyteSelf::setupEvents::failed shareWebcam", {
            error: e
          }), this.videoEnabled && (yield this.localMediaHandler.disableVideo());
        }
      this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      });
    })), this.localMediaHandler.on(
      "DEVICE_CHANGE",
      (r) => u(this, [r], function* ({ device: e }) {
        var i;
        this.emit("deviceUpdate", {
          device: e
        }), e.kind === "audiooutput" && typeof HTMLAudioElement.prototype.setSinkId == "function" && ((i = a(this, Tn, Ed)) == null || i.setSpeakerDevice(e.deviceId));
      })
    ), this.localMediaHandler.on("DEVICE_LIST_UPDATED", (e) => {
      this.emit("deviceListUpdate", e);
    }), this.localMediaHandler.on("SCREENSHARE_TRACK_CHANGE", () => u(this, null, function* () {
      if (!a(this, xe, Be)) {
        this.logger.error(
          "DyteSelf.SCREENSHARE_TRACK_CHANGE.LocalMediaInitialized_WithoutRoomNode"
        );
        return;
      }
      if (this.screenShareEnabled)
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (e) {
          this.logger.error(
            "DyteSelf::setupEvents::Error while sharing screen",
            {
              error: e
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
      this.logger.info("DyteSelf::setupEvents::SCREENSHARE_TRACK_CHANGE", D({}, gi(this))), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    })), this.localMediaHandler.on("SCREENSHARE_ENDED", () => u(this, null, function* () {
      this.logger.log("Disabling screenshare due to SCREENSHARE_ENDED"), yield this.disableScreenShare(), this.logger.info("DyteSelf::setupEvents::SCREENSHARE_ENDED", D({}, gi(this)));
    })), this.localMediaHandler.on("AUDIO_TRACK_SILENT", () => {
      var e;
      (e = a(this, He)) == null || e.getValue("callstats").mediaTrackMuted("AUDIO");
    }), this.localMediaHandler.on("FORCE_MUTE_AUDIO", () => {
      this.disableAudio();
    }), this.localMediaHandler.on("FORCE_MUTE_VIDEO", () => u(this, null, function* () {
      var e;
      a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (e = a(this, He)) == null || e.getValue("callstats").videoOff();
    })), a(this, vt).on("permissionsUpdate", (e) => {
      var r, i, n;
      (r = e == null ? void 0 : e.media) != null && r.audio && a(this, vt).canProduceAudio !== j.Allowed && (this.disableAudio(), this.logger.info(`Disabled audio due to dynamic preset change: canProduceAudio: ${this.permissions.canProduceAudio}`)), (i = e == null ? void 0 : e.media) != null && i.video && a(this, vt).canProduceVideo !== j.Allowed && (this.disableVideo(), this.logger.info(`Disabled video due to dynamic preset change: canProduceVideo: ${this.permissions.canProduceVideo}`)), (n = e == null ? void 0 : e.media) != null && n.screenshare && a(this, vt).canProduceScreenshare !== j.Allowed && (this.disableScreenShare(), this.logger.info(`Disabled screenshare due to dynamic preset change: canProduceScreenshare: ${this.permissions.canProduceScreenshare}`));
    });
  }
  /**
   * Returns the current permission given to the user for the meeting.
   */
  get permissions() {
    return a(this, vt);
  }
  /**
   * Returns configuration for the meeting.
   */
  get config() {
    return a(this, vn);
  }
  /**
   * Returns true if the local participant has joined the meeting.
   */
  get roomJoined() {
    var t;
    return a(this, vn).viewType === Mt.Livestream && this.stageStatus !== "ON_STAGE" ? ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.socketJoined) === !0 : a(this, xe, Be);
  }
  /**
   * The name of the user can be set by calling this method.
   * This will get reflected to other participants ONLY if
   * this method is called before the room is joined.
   * @param name Name of the user.
   */
  setName(t) {
    if (!t)
      throw new R("Name cannot be empty.", "1103");
    this.name = t;
  }
  setupTracks() {
    return u(this, arguments, function* (t = {}) {
      t.forceReset, yield this.disableAudio(), yield this.disableVideo(), this.localMediaHandler.removeAudioTrack(), this.localMediaHandler.removeVideoTrack(), t.audio && (yield this.enableAudio()), t.video && (yield this.enableVideo());
    });
  }
  destructMediaHandler() {
    return u(this, null, function* () {
      return this.localMediaHandler.destruct();
    });
  }
  removeDocumentEventListeners() {
    return u(this, null, function* () {
      return this.localMediaHandler.removeDocumentEventListeners();
    });
  }
  enableAudio(t) {
    return u(this, null, function* () {
      var e;
      if (this.permissions.canProduceAudio !== j.NotAllowed && !(a(this, vt).canProduceAudio === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.audioEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").audioOn(), yield this.localMediaHandler.enableAudio(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE") {
          if (this.audioTrack)
            try {
              yield a(this, je, Ze).shareMic(this.audioTrack);
            } catch (r) {
              this.logger.error("DyteSelf::enableAudio::Error while sharing mic", {
                error: r
              }), this.localMediaHandler.disableAudio();
            }
          if (!this.audioEnabled)
            return;
          a(this, je, Ze).unmuteSelf();
        }
        this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      }
    });
  }
  enableVideo(t) {
    return u(this, null, function* () {
      var e;
      if (a(this, vt).canProduceVideo !== j.NotAllowed && !(a(this, vt).canProduceVideo === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.videoEnabled) {
        if ((e = a(this, He)) == null || e.getValue("callstats").videoOn(), yield this.localMediaHandler.enableVideo(t), a(this, xe, Be) && this.stageStatus === "ON_STAGE")
          try {
            yield a(this, je, Ze).shareWebcam(this.videoTrack);
          } catch (r) {
            this.logger.error("DyteSelf::enableVideo::Error while sharing video", {
              error: r
            }), this.videoEnabled && this.localMediaHandler.disableVideo();
          }
        this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        }), this.logger.info("DyteSelf.enableVideo", D({}, gi(this)));
      }
    });
  }
  updateVideoConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateVideoConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateVideoConstraints(t);
    });
  }
  enableScreenShare() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t enable screenshare without joining room", "1105");
      if (a(this, vt).canProduceScreenshare !== j.NotAllowed && !(a(this, vt).canProduceScreenshare === j.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.screenShareEnabled && (yield this.localMediaHandler.enableScreenShare(), this.screenShareTracks.audio || this.screenShareTracks.video)) {
        try {
          yield a(this, je, Ze).shareScreen(this.screenShareTracks);
        } catch (t) {
          this.logger.error(
            "DyteSelf::enableScreenShare::Error while sharing screen",
            {
              error: t
            }
          ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
        }
        this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      }
    });
  }
  updateScreenshareConstraints(t) {
    return u(this, null, function* () {
      if (!this.localMediaHandler.updateScreenshareConstraints)
        throw new R("Unsupported", "1102");
      yield this.localMediaHandler.updateScreenshareConstraints(t);
    });
  }
  disableAudio() {
    return u(this, null, function* () {
      var t;
      this.audioEnabled && (this.localMediaHandler.disableAudio(), a(this, xe, Be) && a(this, je, Ze).muteSelf(), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").audioOff());
    });
  }
  disableVideo() {
    return u(this, null, function* () {
      var t;
      this.videoEnabled && (yield this.localMediaHandler.disableVideo(), a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }), (t = a(this, He)) == null || t.getValue("callstats").videoOff());
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare(), a(this, xe, Be) && (yield a(this, je, Ze).disableScreenShare()), this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      }));
    });
  }
  /**
   * Returns all media devices accessible by the local participant.
   */
  getAllDevices() {
    return this.localMediaHandler.getAllDevices();
  }
  /**
   * @access private
   * Not for external use.
   */
  setIsPinned(t, e = !0) {
    var i;
    m(this, yn, t);
    const r = t ? "pinned" : "unpinned";
    (i = a(this, sr, di)) == null || i.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
  }
  /**
   * Returns true if the current user is pinned.
   */
  get isPinned() {
    return a(this, yn);
  }
  /**
   * Returns `self.id` if user has permission
   * to pin participants.
   */
  pin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t pin participants without joining room", "1105");
      return this.show(), a(this, je, Ze).pinPeer(this.id);
    });
  }
  /**
   * Returns `self.id` if user has permission
   * to unpin participants.
   */
  unpin() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t unpin participants without joining room", "1105");
      return a(this, je, Ze).pinPeer(null);
    });
  }
  /**
   * Hide's user's tile in the UI (locally)
   */
  hide() {
    return u(this, null, function* () {
      if (!a(this, xe, Be))
        throw new R("Can`t toggle participant tile without joining room", "1105");
      this.hidden = !0, this.emit("toggleTile", { hidden: this.hidden });
    });
  }
  /**
   * Show's user's tile in the UI if hidden (locally)
   */
  show() {
    if (!a(this, xe, Be))
      throw new R("Can`t toggle participant tile without joining room", "1105");
    this.hidden = !1, this.emit("toggleTile", { hidden: this.hidden });
  }
  setDevice(t) {
    return u(this, null, function* () {
      var r, i, n;
      if (!t)
        throw new R("No device selected", "1104");
      const e = this.getCurrentDevices();
      if (t.deviceId && (((r = e == null ? void 0 : e.audio) == null ? void 0 : r.deviceId) === t.deviceId || ((i = e == null ? void 0 : e.video) == null ? void 0 : i.deviceId) === t.deviceId || ((n = e == null ? void 0 : e.speaker) == null ? void 0 : n.deviceId) === t.deviceId) && (this.logger.warn("DyteSelf.setDevice.setting_to_in_use_device", { devices: [t] }), a(this, He).getValue("flagsmith").hasFeature(X.SKIP_SETTING_IN_USE_DEVICE)))
        throw new R("Cannot set device currently in use", "1106");
      switch (t.kind) {
        case "audioinput":
          try {
            yield this.localMediaHandler.setAudioDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).muteSelf()), this.emit("audioUpdate", {
              audioEnabled: this.audioEnabled,
              audioTrack: this.audioTrack
            });
          }
          break;
        case "audiooutput":
          yield this.localMediaHandler.setSpeakerDevice(t);
          break;
        case "videoinput":
          try {
            yield this.localMediaHandler.setVideoDevice(t);
          } catch (o) {
            a(this, xe, Be) && (yield a(this, je, Ze).pauseWebcam()), this.emit("videoUpdate", {
              videoEnabled: this.videoEnabled,
              videoTrack: this.videoTrack
            });
          }
          break;
      }
    });
  }
  cleanUpTracks() {
    var t, e, r, i;
    (t = this.audioTrack) == null || t.stop(), (e = this.rawAudioTrack) == null || e.stop(), (r = this.videoTrack) == null || r.stop(), (i = this.rawVideoTrack) == null || i.stop();
  }
  playAudio() {
    var t;
    return (t = a(this, Tn, Ed)) == null ? void 0 : t.play();
  }
  registerVideoElement(t, e = !1) {
    var r, i;
    t && (e ? a(this, En).add(t) : a(this, _n).add(t), this.updateVideo(t), e || (i = a(this, sr, di)) == null || i.addSource(
      this.id,
      t,
      this.videoEnabled,
      this.isPinned,
      this.name,
      this.picture,
      (r = this.raised) != null ? r : !1
    ));
  }
  deregisterVideoElement(t, e = !1) {
    if (!t) {
      a(this, sr, di).removeSource(this.id);
      return;
    }
    t.srcObject = void 0, e ? a(this, En).delete(t) : (a(this, _n).delete(t), a(this, sr, di).removeSource(this.id));
  }
  /**
   * Internal method, do not use
   */
  updateVideo(t, e = !1) {
    var r, i, n;
    if (this.videoEnabled) {
      if (this.videoTrack == null)
        return;
      const o = (r = t.srcObject) == null ? void 0 : r.getTracks()[0];
      if ((o == null ? void 0 : o.id) === this.videoTrack.id)
        return;
      const c = new MediaStream();
      c.addTrack(this.videoTrack), t.srcObject = c, e || (i = a(this, sr, di)) == null || i.enableSource(this.id);
    } else
      t.srcObject = void 0, e || (n = a(this, sr, di)) == null || n.disableSource(this.id);
    t.style.display = this.videoEnabled ? "block" : "none";
  }
}, vn = new WeakMap(), vt = new WeakMap(), yn = new WeakMap(), He = new WeakMap(), sr = new WeakSet(), di = function() {
  return a(this, He).getValue("pip");
}, je = new WeakSet(), Ze = function() {
  return a(this, He).getValue("roomNodeClient");
}, Tn = new WeakSet(), Ed = function() {
  return a(this, He).getValue("audioPlayback");
}, xe = new WeakSet(), Be = function() {
  var t;
  return ((t = a(this, He).getValue("connectionHandler")) == null ? void 0 : t.mediaJoined) === !0;
}, En = new WeakMap(), _n = new WeakMap(), ac = new WeakSet(), Xu = function() {
  Array.from(a(this, _n)).forEach((t) => this.updateVideo(t, !1)), Array.from(a(this, En)).forEach((t) => this.updateVideo(t, !0));
}, Bg);
Ct([
  E.trace("DyteSelf.cleanupEvents")
], Xe.prototype, "cleanupEvents", 1);
Ct([
  E.trace("DyteSelf.setupEvents")
], Xe.prototype, "setupEvents", 1);
Ct([
  E.trace("DyteSelf.setupTracks")
], Xe.prototype, "setupTracks", 1);
Ct([
  E.trace("DyteSelf.destructMediaHandler")
], Xe.prototype, "destructMediaHandler", 1);
Ct([
  E.trace("DyteSelf.removeDocumentEventListeners")
], Xe.prototype, "removeDocumentEventListeners", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableAudio")
], Xe.prototype, "enableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.enableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.enableVideo")
], Xe.prototype, "enableVideo", 1);
Ct([
  E.trace("DyteSelf.updateVideoConstraints")
], Xe.prototype, "updateVideoConstraints", 1);
Ct([
  E.trace("DyteSelf.enableScreenShare"),
  Er.executeWithLock({
    methodName: "meeting.self.enableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  })
], Xe.prototype, "enableScreenShare", 1);
Ct([
  E.trace("DyteSelf.updateScreenshareConstraints")
], Xe.prototype, "updateScreenshareConstraints", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableAudio",
    lockName: "DyteSelf.toggleAudio",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableAudio")
], Xe.prototype, "disableAudio", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableVideo",
    lockName: "DyteSelf.toggleVideo",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableVideo")
], Xe.prototype, "disableVideo", 1);
Ct([
  Er.executeWithLock({
    methodName: "meeting.self.disableScreenShare",
    lockName: "DyteSelf.toggleScreenShare",
    timeout: 3e3
  }),
  E.trace("DyteSelf.disableScreenShare")
], Xe.prototype, "disableScreenShare", 1);
Ct([
  E.trace("DyteSelf.setDevice")
], Xe.prototype, "setDevice", 1);
Xe = Ct([
  ht("1100")
], Xe);
class Fh extends Error {
  constructor(t) {
    super(t != null ? t : "AwaitQueue stopped"), this.name = "AwaitQueueStoppedError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Fh);
  }
}
class Hh extends Error {
  constructor(t) {
    super(t != null ? t : "AwaitQueue task removed"), this.name = "AwaitQueueRemovedTaskError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Hh);
  }
}
var nc;
class Zu {
  constructor(t, e = !1) {
    // Queue of pending tasks (map of PendingTasks indexed by id).
    h(this, "pendingTasks", /* @__PURE__ */ new Map());
    // Incrementing PendingTask id.
    h(this, "nextTaskId", 0);
    // Whether stop() method is stopping all pending tasks.
    h(this, "stopping", !1);
    g(this, nc, void 0);
    this.log = e, m(this, nc, { info: e && t ? t.info : () => {
    } });
  }
  get size() {
    return this.pendingTasks.size;
  }
  push(t, e, r) {
    return u(this, null, function* () {
      if (e = e != null ? e : t.name, typeof t != "function")
        throw new TypeError("given task is not a function");
      if (e)
        try {
          Object.defineProperty(t, "name", { value: e });
        } catch (i) {
        }
      return new Promise((i, n) => {
        const o = {
          id: this.nextTaskId++,
          task: t,
          metadata: r,
          name: e,
          enqueuedAt: Date.now(),
          executedAt: void 0,
          completed: !1,
          resolve: (c) => {
            if (o.completed)
              return;
            o.completed = !0, this.pendingTasks.delete(o.id), i(c);
            const [d] = this.pendingTasks.values();
            d && !d.executedAt && this.execute(d);
          },
          reject: (c) => {
            if (!o.completed && (o.completed = !0, this.pendingTasks.delete(o.id), n(c), !this.stopping)) {
              const [d] = this.pendingTasks.values();
              d && !d.executedAt && this.execute(d);
            }
          }
        };
        this.pendingTasks.set(o.id, o), this.pendingTasks.size === 1 && this.execute(o);
      });
    });
  }
  stop() {
    this.stopping = !0;
    for (const t of this.pendingTasks.values())
      t.reject(new Fh());
    this.stopping = !1;
  }
  remove(t) {
    const e = Array.from(this.pendingTasks.values())[t];
    e && e.reject(new Hh());
  }
  get(t) {
    return Array.from(this.pendingTasks.values())[t];
  }
  dump() {
    const t = Date.now();
    let e = 0;
    return Array.from(this.pendingTasks.values()).map((r) => ({
      idx: e++,
      task: r.task,
      name: r.name,
      enqueuedTime: r.executedAt ? r.executedAt - r.enqueuedAt : t - r.enqueuedAt,
      executionTime: r.executedAt ? t - r.executedAt : 0
    }));
  }
  execute(t) {
    return u(this, null, function* () {
      if (t.executedAt)
        throw new Error("task already being executed");
      t.executedAt = Date.now();
      try {
        const e = this.pendingTasks.size, r = yield t.task(), i = Date.now();
        a(this, nc).info(
          `AwaitQueue.push(${t.name})_timings`,
          {
            awaitQueueTask: {
              id: t.id,
              metadata: t.metadata,
              queueSizeAtStart: e,
              execTime: (i - t.executedAt) / 1e3,
              taskStartTime: (t.executedAt - t.enqueuedAt) / 1e3
            }
          }
        ), t.resolve(r);
      } catch (e) {
        t.reject(e);
      }
    });
  }
}
nc = new WeakMap();
function Y0(s, t) {
  const e = new Error(t);
  return e.name = s, e;
}
class Uo extends R {
  constructor(t) {
    super(t), this.name = "UnsupportedError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, Uo) : this.stack = new Error(t).stack;
  }
}
class At extends R {
  constructor(t) {
    super(t), this.name = "InvalidStateError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, At) : this.stack = new Error(t).stack;
  }
}
class fi extends R {
  constructor(t) {
    super(t), this.name = "TransportConnectionError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, At) : this.stack = new Error(t).stack;
  }
}
const fg = (s) => new Promise((t) => setTimeout(t, s));
function Yf(s, t) {
  return u(this, null, function* () {
    return new Promise((e, r) => u(this, null, function* () {
      const { strategy: i, maxRetryCount: n, delayTime: o } = D({
        strategy: "linear",
        maxRetryCount: 3,
        delayTime: 10
      }, t);
      let c = 0, d, l = !1;
      const p = (f) => {
        l = !0, r(f);
      };
      for (; c < n; ) {
        try {
          const f = yield s(c, p);
          return e(f);
        } catch (f) {
          if (d = f, l)
            break;
          if (c < n)
            i === "linear" ? yield fg(o * (c + 1)) : i === "exponential" && (yield fg(o * (c + Math.max(0, c - 1))));
          else
            break;
        }
        c += 1;
      }
      return r(d);
    }));
  });
}
function Q0(s) {
  return s.map((t) => ({
    channels: t.channels,
    clockRate: t.clockRate,
    mimeType: t.mimeType,
    sdpFmtpLine: t.sdpFmtpLine
  }));
}
function X0(s) {
  return s.map((t) => ({
    uri: t.uri
  }));
}
function dd(s) {
  return {
    codecs: Q0(s.codecs),
    headerExtensions: X0(s.headerExtensions ? s.headerExtensions : [])
  };
}
function Z0(s) {
  const t = RTCRtpReceiver.getCapabilities("audio"), e = RTCRtpReceiver.getCapabilities("video"), r = RTCRtpSender.getCapabilities("audio"), i = RTCRtpSender.getCapabilities("video");
  s && (e.codecs = e.codecs.filter(({ mimeType: d }) => s === d), i.codecs = i.codecs.filter(({ mimeType: d }) => s === d));
  const n = {
    audio: dd(t),
    video: dd(e)
  };
  return {
    sender: {
      audio: dd(r),
      video: dd(i)
    },
    receiver: n
  };
}
var ze;
class eD {
  constructor(t, e) {
    g(this, ze, void 0);
    h(this, "events");
    h(this, "sfuType");
    m(this, ze, t), this.sfuType = e, this.events = e === we.CF ? Ts : is;
  }
  joinRoom(t, e, r, i = !1, n = null) {
    return u(this, null, function* () {
      const o = {
        roomUuid: t,
        displayName: e,
        prejoined: i,
        capabilities: r
      };
      return n && (o.location = n), (yield a(this, ze).sendMessagePromiseWithTimeout({
        event: this.events.joinRoom,
        protobuf: gR.toBinary(o),
        timeout: 5e3
      })).payload;
    });
  }
  connectTransport(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.createWebRTCTransport,
        BC.toBinary(t)
      )).payload, { transportId: r, description: i, producerIds: n } = lf.fromBinary(e), o = {
        sdp: i == null ? void 0 : i.sdp,
        type: i.type
      };
      return {
        transportId: r,
        answer: o,
        producerIds: n
      };
    });
  }
  produce(t) {
    return u(this, null, function* () {
      var n, o;
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.produce,
        IR.toBinary(t)
      )).payload, r = uw.fromBinary(e);
      return {
        answer: {
          sdp: (n = r == null ? void 0 : r.description) == null ? void 0 : n.sdp,
          type: (o = r == null ? void 0 : r.description) == null ? void 0 : o.type
        },
        producerId: r.producerId
      };
    });
  }
  consume(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.consume,
        PR.toBinary(t)
      )).payload, {
        consumerIdsMap: { map: r },
        description: i
      } = dw.fromBinary(e);
      return { consumerStateMap: r, sessionDescription: i };
    });
  }
  closeProducer(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.closeProducer,
        LR.toBinary(t)
      )).payload, { description: r } = vw.fromBinary(e);
      return r;
    });
  }
  closeConsumer(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Hive does not support socket consumer operations");
      return (yield a(this, ze).sendMessagePromise(
        this.events.closeConsumer,
        UR.toBinary(t)
      )).payload;
    });
  }
  updateConsumersSimulcastConfig(t) {
    return u(this, null, function* () {
      if (this.sfuType === we.HIVE)
        throw new Error("Method not implemented");
      return (yield a(this, ze).sendMessagePromise(
        this.events.updateConsumersSimulcastConfig,
        bR.toBinary(t)
      )).payload;
    });
  }
  hostControlForPeer(t, e) {
    return u(this, null, function* () {
      const r = {
        audio: e === "audio",
        screeShare: !1,
        video: e === "video",
        participantId: t
      }, i = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlPeer,
        jR.toBinary(r)
      )).payload;
      if (!i)
        return !1;
      const { status: n } = Rw.fromBinary(i);
      return n === "success";
    });
  }
  hostControlForAll(t) {
    return u(this, null, function* () {
      const e = {
        audio: t === "audio",
        screenShare: !1,
        video: t === "video"
      }, r = (yield a(this, ze).sendMessagePromise(
        this.events.hostControlAllPeers,
        WR.toBinary(e)
      )).payload;
      if (!r)
        return !1;
      const { status: i } = bw.fromBinary(r);
      return i === "success";
    });
  }
  /**
   * Ideally should have been async with a response but
   * this is basically a fire and forget since socket does not
   * send a response at the moment
   */
  kickAll() {
    return u(this, null, function* () {
      const t = {
        propagateKickAcrossRooms: !1
      };
      a(this, ze).sendMessagePromise(
        /**
         * Does not use mediaEventSlugs is the same irrespective of the SFU
         */
        x.kickAll,
        gf.toBinary(t)
      );
    });
  }
  /**
   * Ideally should have been async with a response but
   * this is basically a fire and forget since socket does not
   * send a response at the moment
   */
  kickPeer(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessagePromise(
        /**
         * Does not use mediaEventSlugs is the same irrespective of the SFU
         */
        x.kick,
        yf.toBinary(t)
      );
    });
  }
  changeDisplayName(t) {
    return u(this, null, function* () {
      const e = (yield a(this, ze).sendMessagePromise(
        this.events.changeDisplayName,
        BR.toBinary(t)
      )).payload;
      if (!e)
        return !1;
      const { status: r } = Iw.fromBinary(e);
      return r === "success";
    });
  }
  notifySelfJoinComplete() {
    return u(this, null, function* () {
      const t = {}, e = (yield a(this, ze).sendMessagePromise(
        this.events.selfJoinComplete,
        fR.toBinary(t)
      )).payload;
      return Du.fromBinary(e);
    });
  }
  audioActivity(t) {
    return u(this, null, function* () {
      a(this, ze).sendMessage(this.events.audioActivity, jC.toBinary(t));
    });
  }
}
ze = new WeakMap();
var oc;
class Yl extends ut.EventEmitter {
  constructor(e) {
    super();
    g(this, oc, void 0);
    m(this, oc, e), this.setMaxListeners(1 / 0);
  }
  get logger() {
    return a(this, oc).getValue("logger");
  }
  safeEmit(e, ...r) {
    const i = this.listenerCount(e);
    try {
      return this.emit(e, ...r);
    } catch (n) {
      return this.logger.error(
        `EnhancedEventEmitter:: safeEmit() | event listener ${e} threw an error`,
        {
          error: n
        }
      ), Boolean(i);
    }
  }
  safeEmitAsPromise(e, ...r) {
    return u(this, null, function* () {
      const i = {}.EVENT_PROMISE_TIMEOUT ? parseInt({}.EVENT_PROMISE_TIMEOUT, 10) : 1e4;
      return this.safeEmitAsPromiseWithTimeout(e, i, ...r);
    });
  }
  safeEmitAsPromiseWithTimeout(e, r, ...i) {
    return u(this, null, function* () {
      return new Promise((n, o) => {
        setTimeout(o, r, "event request timeout");
        try {
          this.emit(e.toString(), ...i, n, o);
        } catch (c) {
          this.logger.error(
            `EnhancedEventEmitter:: safeEmitAsPromise() | event listener for event ${e.toString()} threw an error [event:%s]:%o`,
            {
              error: c
            }
          ), o(c);
        }
      });
    });
  }
}
oc = new WeakMap();
class Bh extends Yl {
  constructor() {
    super(...arguments);
    /** Local stream for sending general media tracks. */
    h(this, "_sendWebStream", new MediaStream());
    /** Local stream for sending screenshare tracks. */
    h(this, "_sendScreenShareStream", new MediaStream());
    /** Handler direction. */
    h(this, "_direction");
    /** RTCPeerConnection instance. */
    h(this, "pc");
    /** Got transport local and remote parameters. */
    h(this, "_transportReady", !1);
    // Map of RTCTransceivers indexed by MID.
    h(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
    h(this, "enableHighBitrate", !1);
    h(this, "enableStereo", !1);
    h(this, "enableDtx", !0);
    h(this, "sfu", we.HIVE);
  }
  get midTransceiverMap() {
    return this._mapMidTransceiver;
  }
  close() {
    if (this.logger.debug(`${this.name}::close()`), this.pc)
      try {
        this.pc.close();
      } catch (e) {
        this.logger.error(`${this.name}::pc.close()`, { error: e });
      }
  }
  restartIce() {
    return u(this, null, function* () {
      this.logger.debug(`${this.name}::restartIce()`);
      const e = yield this.pc.createOffer({
        iceRestart: !0
      });
      return this.logger.debug(`${this.name}::restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), {
        offerSdp: e,
        callback: (i) => u(this, null, function* () {
          this.logger.info(`${this.name}::restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(i)}]`), yield this.pc.setRemoteDescription(i);
        })
      };
    });
  }
  init({
    direction: e,
    iceServers: r,
    iceTransportPolicy: i,
    additionalSettings: n,
    proprietaryConstraints: o,
    onTrackHandler: c
  }) {
    this.logger.debug("HandlerInterface::init()"), this._direction = e, this.pc = new RTCPeerConnection(
      D({
        iceServers: r || [],
        iceTransportPolicy: i || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require"
      }, n),
      o
    ), c && this.pc.addEventListener("track", (d) => {
      c(d);
    }), this._addEventListeners();
  }
  connect() {
    return u(this, null, function* () {
      let e;
      this.sfu === we.CF ? this.pc.addTransceiver("video", { direction: "sendonly" }) : e = this.pc.createDataChannel("dyte");
      const r = yield this.pc.createOffer();
      return yield this.pc.setLocalDescription(r), this.logger.info(`connect offer: ${JSON.stringify(r)}`), {
        offerSdp: r,
        callback: (n) => u(this, null, function* () {
          this.logger.debug(`${this.name}::connect() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`), yield this.pc.setRemoteDescription(n), e == null || e.close();
        })
      };
    });
  }
  getTransportStats() {
    return u(this, null, function* () {
      return this.pc.getStats();
    });
  }
  _assertSendDirection() {
    if (this._direction !== "send")
      throw new Error(
        'method can just be called for handlers with "send" direction'
      );
  }
  _assertRecvDirection() {
    if (this._direction !== "recv")
      throw new Error(
        'method can just be called for handlers with "recv" direction'
      );
  }
  getReceiverStats(e) {
    return u(this, null, function* () {
      this._assertRecvDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.receiver.getStats();
    });
  }
  stopSending(e) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`stopSending() [localId:${e}]`);
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      r.sender.replaceTrack(null), this.pc.removeTrack(r.sender), r.direction = "inactive";
      const i = yield this.pc.createOffer();
      return this.logger.debug(`stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(i)}]`), yield this.pc.setLocalDescription(i), {
        offerSdp: i,
        callback: (o) => u(this, null, function* () {
          this.logger.debug(`stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(o)}]`), yield this.pc.setRemoteDescription(o), this.midTransceiverMap.delete(e);
        })
      };
    });
  }
  replaceTrack(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), r ? this.logger.debug(`replaceTrack() [localId:${e}, track.id:${r.id}]`) : this.logger.debug(`replaceTrack() [localId:${e}, no track]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      yield i.sender.replaceTrack(r);
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          c <= r ? o.active = !0 : o.active = !1;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  setRtpEncodingParameters(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters();
      n.encodings.forEach(
        (o, c) => {
          n.encodings[c] = D(D({}, o), r);
        }
      ), yield i.sender.setParameters(n);
    });
  }
  getSenderStats(e) {
    this._assertSendDirection();
    const r = this.midTransceiverMap.get(e);
    if (!r)
      throw new Error("associated RTCRtpTransceiver not found");
    return r.sender.getStats();
  }
  _addEventListeners() {
    this.pc.addEventListener(
      "icecandidate",
      (e) => {
        e.candidate && this.emit("@icecandidate", {
          candidate: e.candidate
        });
      }
    ), this.pc.addEventListener("iceconnectionstatechange", () => {
      switch (this.pc.iceConnectionState) {
        case "checking":
          this.emit("@connectionstatechange", "connecting");
          break;
        case "connected":
        case "completed":
          this.emit("@connectionstatechange", "connected"), this._transportReady = !0;
          break;
        case "failed":
          this.emit("@connectionstatechange", "failed");
          break;
        case "disconnected":
          this.emit("@connectionstatechange", "disconnected");
          break;
        case "closed":
          this.emit("@connectionstatechange", "closed");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("negotiationneeded", () => {
      this.emit("@negotiationneeded", {}), this.logger.debug("negotiationneeded");
    }), this.pc.addEventListener("icegatheringstatechange", () => {
      switch (this.pc.iceGatheringState) {
        case "gathering":
          this.logger.debug("icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
          break;
        case "complete":
          this.logger.debug("icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
          break;
        default:
          this.logger.warn("unknown state");
          break;
      }
    }), this.pc.addEventListener("icecandidateerror", (e) => {
      this.logger.warn("icecandidateerror", {
        error: {
          code: e.errorCode,
          message: e.errorText
        }
      });
    }), this.pc.addEventListener("datachannel", (e) => {
      this.logger.info("data channel created: ", {
        rtcChannel: {
          label: e.channel.label
        }
      });
      const { channel: r } = e;
      r.onopen = () => {
        this.logger.info("data channel open: ", {
          rtcChannel: {
            label: e.channel.label
          }
        }), this.safeEmit("dc_open", e.channel);
      }, r.onclose = () => {
        this.logger.warn("data channel closed: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
      }, r.onerror = () => {
        this.logger.error("data channel error: ", {
          rtcChannel: {
            label: e.channel.label
          }
          // error: error as unknown as LogData, // Need to fix this, where to get message, reason
        });
      };
    }), this.addCustomEventListeners();
  }
  // eslint-disable-next-line class-methods-use-this
  addCustomEventListeners() {
  }
}
class qh extends Bh {
  /**
   * Creates a factory function.
   */
  static createFactory(t) {
    return () => new qh(t);
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Chrome74";
  }
  init({
    direction: t,
    iceServers: e,
    iceTransportPolicy: r,
    additionalSettings: i,
    proprietaryConstraints: n,
    onTrackHandler: o
  }) {
    this._direction = t, this.pc = new RTCPeerConnection(
      D({
        iceServers: e || [],
        iceTransportPolicy: r || "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        sdpSemantics: "unified-plan"
      }, i),
      n
    ), o && this.pc.addEventListener("track", (c) => {
      o(c);
    }), this._addEventListeners();
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection();
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      });
      if (!navigator.isReactNative) {
        this.logger.debug("creating new transceiver");
        const l = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
        this.logger.info(`senders available params: ${JSON.stringify(l)}`);
        const p = [];
        r && r.length && r.forEach((f) => {
          var T;
          const S = l.codecs.find((_) => _.mimeType.includes(f.name));
          if (f.parameters) {
            this.logger.debug(`codecOption.parameters:${JSON.stringify(f.parameters)}`);
            const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
            _.push(...f.parameters);
            const P = Array.from(new Set(_).values());
            S.sdpFmtpLine = P.join(";");
          }
          p.push(S);
        }), this.logger.info(`selected codecs: ${JSON.stringify(p)}`), o.setCodecPreferences(p);
      }
      const c = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(c), r && r.findIndex(({ name: l }) => l === "opus") >= 0) {
        const { enableDtx: l, enableStereo: p } = this, f = this.enableHighBitrate ? p ? 128e3 : 64e3 : p ? 64e3 : 32e3;
        c.sdp = c.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${l ? "usedtx=1;" : ""}${p ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${f}`
        ), c.sdp += `a=rtcp-fb:111 nack\r
`;
      }
      this.midTransceiverMap.set(o.mid, o);
      const d = (l) => u(this, null, function* () {
        return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(l)}]`), yield this.pc.setRemoteDescription(l), o.mid;
      });
      return this.logger.debug(`send() | calling pc.setLocalDescription() [offer: ${JSON.stringify(c, void 0, 2)}]`), {
        offerSdp: c,
        callback: d,
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => {
        this.safeEmit(
          "datachannel",
          t.channel,
          String.fromCharCode(...new Uint8Array(r.data))
        );
      };
    });
  }
}
class xd extends Bh {
  // eslint-disable-next-line no-useless-constructor
  constructor(e, r) {
    super(e);
    h(this, "supportsSendEncodings", !1);
    this.supportsSendEncodings = r.supportsSendEncodings;
  }
  /**
   * Creates a factory function.
   */
  static createFactory(e, r) {
    return () => new xd(
      e,
      r
    );
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Firefox60";
  }
  send(o) {
    return u(this, arguments, function* ({
      track: e,
      encodings: r,
      codecOptions: i,
      screenShare: n
    }) {
      this._assertSendDirection();
      const c = this.supportsSendEncodings && r !== void 0 ? { sendEncodings: r } : {}, d = this.pc.addTransceiver(e, D({
        direction: "sendonly",
        streams: [
          n ? this._sendScreenShareStream : this._sendWebStream
        ]
      }, c));
      if (!this.supportsSendEncodings && r) {
        r.reverse();
        const S = d.sender.getParameters();
        S.encodings = r, yield d.sender.setParameters(S);
      }
      const l = (S, T) => {
        var $;
        const _ = cs.parse(S), P = _.media[_.media.length - 1], w = P.rtp.filter((F) => T.some((K) => K.name === F.codec)), A = P.fmtp.filter((F) => w.some((K) => K.payload === F.payload)), N = ($ = P.rtcpFb) == null ? void 0 : $.filter((F) => w.some((K) => K.payload === F.payload)), H = w.map((F) => F.payload);
        return _.media[_.media.length - 1].rtp = w, _.media[_.media.length - 1].fmtp = A, _.media[_.media.length - 1].rtcpFb = N, _.media[_.media.length - 1].payloads = H.join(" "), cs.write(_);
      }, p = yield this.pc.createOffer();
      if (p.sdp = l(p.sdp, i), this.logger.debug(`send() | calling pc.setLocalDescription() [offer:${JSON.stringify(p)}]`), yield this.pc.setLocalDescription(p), e === "audio" || e.kind === "audio") {
        const { enableDtx: S, enableStereo: T } = this, _ = this.enableHighBitrate ? T ? 128e3 : 64e3 : T ? 64e3 : 32e3;
        p.sdp = p.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${T ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${_}`
        );
      }
      return this.midTransceiverMap.set(d.mid, d), {
        offerSdp: p,
        callback: (S) => u(this, null, function* () {
          return this.logger.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(S)}]`), yield this.pc.setRemoteDescription(S), d.mid;
        }),
        sender: d.sender,
        mid: d.mid
      };
    });
  }
  setMaxSpatialLayer(e, r) {
    return u(this, null, function* () {
      this._assertSendDirection(), this.logger.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
      const i = this.midTransceiverMap.get(e);
      if (!i)
        throw new Error("associated RTCRtpTransceiver not found");
      const n = i.sender.getParameters(), o = n.encodings.length - 1 - r;
      n.encodings.forEach(
        (c, d) => {
          d >= o ? c.active = !0 : c.active = !1;
        }
      ), yield i.sender.setParameters(n);
    });
  }
  addCustomEventListeners() {
    this.pc.addEventListener("datachannel", (e) => {
      const { channel: r } = e;
      r.onmessage = (i) => u(this, null, function* () {
        const n = yield i.data.arrayBuffer();
        this.safeEmit(
          "datachannel",
          e.channel,
          String.fromCharCode(...new Uint8Array(n))
        );
      });
    });
  }
}
class jh extends Bh {
  /**
   * Creates a factory function.
   */
  static createFactory(t) {
    return () => new jh(t);
  }
  // eslint-disable-next-line class-methods-use-this
  get name() {
    return "Safari12";
  }
  send(n) {
    return u(this, arguments, function* ({
      track: t,
      encodings: e,
      codecOptions: r,
      screenShare: i
    }) {
      this._assertSendDirection(), this.logger.debug("Safari12::creating new transceiver");
      const o = this.pc.addTransceiver(t, {
        direction: "sendonly",
        streams: [
          i ? this._sendScreenShareStream : this._sendWebStream
        ],
        sendEncodings: e
      }), c = RTCRtpSender.getCapabilities(typeof t == "string" ? t : t.kind);
      this.logger.info(`Safari12::senders available params: ${JSON.stringify(c)}`);
      const d = [];
      r && r.length > 0 && r.forEach((f) => {
        var T;
        const S = c.codecs.find(
          (_) => _.mimeType.includes(f.name)
        );
        if (f.parameters) {
          this.logger.info(`Safari12::codecOption.parameters:, ${JSON.stringify(f.parameters)}`);
          const _ = ((T = S.sdpFmtpLine) == null ? void 0 : T.split(";")) || [];
          _.push(...f.parameters);
          const P = [...new Set(_).values()];
          S.sdpFmtpLine = P.join(";");
        }
        d.push(S);
      }), this.logger.info(`Safari12::selected codecs: ${JSON.stringify(d)}`), o.setCodecPreferences(d);
      const l = yield this.pc.createOffer();
      if (yield this.pc.setLocalDescription(l), t === "audio" || t.kind === "audio") {
        const { enableStereo: f, enableDtx: S } = this, T = this.enableHighBitrate ? f ? 128e3 : 64e3 : f ? 64e3 : 32e3;
        l.sdp = l.sdp.replace(
          "minptime=10;useinbandfec=1",
          `minptime=10;useinbandfec=1;${S ? "usedtx=1;" : ""}${f ? "stereo=1;sprop-stereo=1;" : ""}maxaveragebitrate=${T}`
        );
      }
      return this.midTransceiverMap.set(o.mid, o), {
        offerSdp: l,
        callback: (f) => u(this, null, function* () {
          return this.logger.debug(
            `Safari12::send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(f)}]`
          ), yield this.pc.setRemoteDescription(f), o.mid;
        }),
        sender: o.sender,
        mid: o.mid
      };
    });
  }
  addCustomEventListeners() {
    this.pc.ondatachannel = (t) => {
      const { channel: e } = t;
      e.onmessage = (r) => u(this, null, function* () {
        const i = String.fromCharCode(
          ...new Uint8Array(r.data)
        );
        this.safeEmit("datachannel", t.channel, i);
      });
    };
  }
}
function tD(s, t) {
  return typeof s == "undefined" ? t : typeof window != "undefined" && Object.getOwnPropertyDescriptor(window, "structuredClone") ? structuredClone(s) : JSON.parse(JSON.stringify(s));
}
var cc, Fi, Ds, tl, Os, kr, dc, eh, sl, Qf, rl, Xf;
class sD extends Yl {
  constructor(e, r) {
    var i;
    super(e);
    g(this, Os);
    g(this, dc);
    g(this, sl);
    g(this, rl);
    /**
     * Associated transciever RTCRtpSender object
     */
    h(this, "rtpReceiver");
    /**
     * Consumer ID
     */
    h(this, "id");
    /**
     * Consumer's local ID
     */
    h(this, "localId");
    /**
     * Producer ID associated with this consumer
     */
    h(this, "producerId");
    /**
     * Transport ID of the producing transport on the producing peer
     */
    h(this, "producingTransportId");
    /**
     * Mime type of the consumer stream
     */
    h(this, "mimeType");
    /**
     * The track associated with this consumer
     */
    h(this, "track");
    /**
     * Producing peer id corresponding to this consumer
     */
    h(this, "peerId");
    /**
     *	Custom data attached to this consumer
     */
    h(this, "appData");
    h(this, "transceiver");
    /**
     *  RTCRtpReceiver associated with the consumer
     */
    g(this, cc, void 0);
    g(this, Fi, void 0);
    g(this, Ds, void 0);
    g(this, tl, void 0);
    this.id = r.id, this.localId = r.localId, m(this, cc, r.handler), this.appData = r.appData, this.peerId = r.producingPeerId, this.producingTransportId = r.producingTransportId, m(this, Ds, !1), this.producerId = r.producerId, this.track = r.track, m(this, Fi, (i = r.paused) != null ? i : !1), this.mimeType = r.mimeType, this.transceiver = r.transceiver, this.rtpReceiver = r.rtpReceiver, L(this, sl, Qf).call(this), m(this, tl, e);
  }
  /**
   * Indicates whether this consumer is closed
   */
  get closed() {
    return a(this, Ds);
  }
  /**
   * Kind of media on to this consumer
   */
  get kind() {
    return this.track.kind;
  }
  /**
   * Indicates whether the consumer is paused
   */
  get paused() {
    return a(this, Fi);
  }
  /**
   * Closes the Consumer.
   */
  close(e, r) {
    a(this, Ds) || (this.logger.debug(`Consumer::close() ${e ? `with reason ${e}` : ""}`, a(this, Os, kr)), m(this, Ds, !0), r && (L(this, rl, Xf).call(this), this.transceiver.stop()), this.safeEmit("close", e));
  }
  /**
   * Get associated RTCRtpReceiver stats.
   */
  getStats() {
    return u(this, null, function* () {
      if (a(this, Ds))
        throw new At("closed");
      return a(this, cc).getReceiverStats(this.localId);
    });
  }
  /**
   * Pauses receiving media.
   */
  pause() {
    if (this.logger.debug("consumer::pause()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("consumer::pause() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, !0), this.track.enabled = !1, this.safeEmit("pause");
  }
  /**
   * Resumes receiving media.
   */
  resume() {
    if (this.logger.debug("consumer::resume()", a(this, Os, kr)), a(this, Ds)) {
      this.logger.error("Consumer::resume() | Consumer closed", a(this, Os, kr));
      return;
    }
    m(this, Fi, !1), this.track.enabled = !0, this.safeEmit("resume");
  }
}
cc = new WeakMap(), Fi = new WeakMap(), Ds = new WeakMap(), tl = new WeakMap(), Os = new WeakSet(), kr = function() {
  return {
    consumer: {
      id: this.id,
      appData: this.appData,
      peerId: this.peerId,
      kind: this.kind
    }
  };
}, dc = new WeakSet(), eh = function() {
  this.logger.debug('Consumer::track "ended" event', a(this, Os, kr)), this.safeEmit("trackended");
}, sl = new WeakSet(), Qf = function() {
  this.track.addEventListener("ended", L(this, dc, eh).bind(this));
}, rl = new WeakSet(), Xf = function() {
  try {
    this.track.removeEventListener("ended", L(this, dc, eh)), this.track.stop();
  } catch (e) {
    this.logger.error("Consumer::destroyTrack()", B(D({}, a(this, Os, kr)), {
      error: e
    }));
  }
};
var hs, Pn, Cn, Hi, es, et, jr, Rn, il, Ft, os;
class rD extends Yl {
  /**
   * @emits transportclose
   * @emits trackended
   * @emits @replacetrack - (track: MediaStreamTrack | null)
   * @emits @setmaxspatiallayer - (spatialLayer: string)
   * @emits @setrtpencodingparameters - (params: any)
   * @emits @getstats
   */
  constructor(e, r) {
    var i, n;
    super(e);
    g(this, Ft);
    /**
     * Producer ID.
     */
    h(this, "id");
    /**
     * Local ID.
     */
    h(this, "localId");
    /**
     * Associated RTCRtpSender.
     */
    g(this, hs, void 0);
    /**
     * Kind of media on to this producer
     */
    h(this, "kind");
    /**
     * App custom data.
     */
    h(this, "appData");
    /**
     * Associated transciever RTCRtpSender object
     */
    h(this, "rtpSender");
    /**
     * Whether the Producer should call stop() in given tracks.
     */
    g(this, Pn, void 0);
    /**
     * Specify if the Producer track should be disabled with track.enabled = false when paused.
     */
    g(this, Cn, void 0);
    /**
     * Specify if we should replace the RTCRtpSender.track with null when paused.
     */
    g(this, Hi, void 0);
    g(this, es, !1);
    g(this, et, void 0);
    g(this, jr, void 0);
    g(this, Rn, void 0);
    g(this, il, void 0);
    this.id = r.id, this.localId = r.localId, m(this, et, r.track), this.kind = (i = r.track) == null ? void 0 : i.kind, m(this, jr, r.disableTrackOnPause ? !((n = r.track) != null && n.enabled) : !1), m(this, Rn, void 0), m(this, Pn, r.stopTracks), m(this, Cn, r.disableTrackOnPause), m(this, Hi, r.zeroRtpOnPause), this.appData = r.appData || {}, this._onTrackEnded = this._onTrackEnded.bind(this), m(this, hs, r.handler), this.rtpSender = r.rtpSender, this._handleTrack(), m(this, il, e);
  }
  /**
   * Whether the Producer is closed.
   */
  get closed() {
    return a(this, es);
  }
  /**
   * The associated track.
   */
  get track() {
    return a(this, et);
  }
  /**
   * Whether the Producer is paused.
   */
  get paused() {
    return a(this, jr);
  }
  /**
   * Max spatial layer.
   *
   * @type {Number | undefined}
   */
  get maxSpatialLayer() {
    return a(this, Rn);
  }
  /**
   * Closes the Producer.
   */
  close(e) {
    return u(this, null, function* () {
      if (a(this, es))
        return;
      if (this.logger.debug(`Producer::close() ${e ? `with reason ${e}` : ""}`, a(this, Ft, os)), m(this, es, !0), this._destroyTrack(), e === Ud) {
        this.safeEmit("close", { reason: e });
        return;
      }
      const { offerSdp: r, callback: i } = yield a(this, hs).stopSending(this.localId), { answer: n } = yield this.safeEmitAsPromise("close", { offer: r, reason: e });
      i(n);
    });
  }
  /**
   * Get associated RTCRtpSender stats.
   */
  getStats() {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      return a(this, hs).getSenderStats(this.localId);
    });
  }
  /**
   * Pauses sending media.
   */
  pause() {
    this.logger.debug("Producer::pause()", a(this, Ft, os)), a(this, es) && this.logger.error("Producer::pause() | Producer closed", a(this, Ft, os)), m(this, jr, !0), a(this, et) && a(this, Cn) && (a(this, et).enabled = !1), a(this, Hi) && a(this, hs).replaceTrack(this.localId, null), this.emit("pause");
  }
  /**
   * Resumes sending media.
   */
  resume() {
    if (this.logger.debug("Producer::resume()", a(this, Ft, os)), a(this, es)) {
      this.logger.error("Producer::resume() | Producer closed", a(this, Ft, os));
      return;
    }
    m(this, jr, !1), a(this, et) && a(this, Cn) && (a(this, et).enabled = !0), a(this, Hi) && a(this, hs).replaceTrack(this.localId, a(this, et)), this.emit("resume");
  }
  /**
   * Replaces the current track with a new one or null.
   */
  replaceTrack(r) {
    return u(this, arguments, function* ({
      track: e
    }) {
      if (this.logger.debug(`Producer::replaceTrack() trackId: ${e == null ? void 0 : e.id}`, a(this, Ft, os)), a(this, es)) {
        if (e && a(this, Pn))
          try {
            e.stop();
          } catch (i) {
            this.logger.error("Producer::replaceTrack", B(D({}, a(this, Ft, os)), {
              error: i
            }));
          }
        throw new At("closed");
      } else if (e && e.readyState === "ended")
        throw new At("track ended");
      if (e === a(this, et)) {
        this.logger.debug(`replaceTrack() | same track, ignored trackId: ${e.id}`, a(this, Ft, os));
        return;
      }
      (!a(this, Hi) || !a(this, jr)) && (yield a(this, hs).replaceTrack(this.localId, e)), this._destroyTrack(), m(this, et, e), this._handleTrack();
    });
  }
  /**
   * Sets the video max spatial layer to be sent.
   */
  setMaxSpatialLayer(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (this.kind !== "video")
        throw new Uo("not a video Producer");
      if (typeof e != "number")
        throw new TypeError("invalid spatialLayer");
      yield a(this, hs).setMaxSpatialLayer(this.localId, e), m(this, Rn, e);
    });
  }
  /**
   * Sets the DSCP value.
   */
  setRtpEncodingParameters(e) {
    return u(this, null, function* () {
      if (a(this, es))
        throw new At("closed");
      if (typeof e != "object")
        throw new TypeError("invalid params");
      yield a(this, hs).setRtpEncodingParameters(this.localId, e);
    });
  }
  _onTrackEnded() {
    this.logger.debug(`Producer::track "ended" event trackId: ${this.track.id}`, a(this, Ft, os)), this.safeEmit("trackended", this.track.id);
  }
  _handleTrack() {
    a(this, et) && a(this, et).addEventListener("ended", this._onTrackEnded);
  }
  _destroyTrack() {
    var e;
    if (a(this, et))
      try {
        a(this, et).removeEventListener("ended", this._onTrackEnded), a(this, Pn) && a(this, et).stop();
      } catch (r) {
        this.logger.error(`Producer::_destroyTrack trackId: ${(e = this.track) == null ? void 0 : e.id}`, B(D({}, a(this, Ft, os)), {
          error: r
        }));
      }
  }
}
hs = new WeakMap(), Pn = new WeakMap(), Cn = new WeakMap(), Hi = new WeakMap(), es = new WeakMap(), et = new WeakMap(), jr = new WeakMap(), Rn = new WeakMap(), il = new WeakMap(), Ft = new WeakSet(), os = function() {
  return {
    producer: {
      id: this.id,
      appData: this.appData,
      kind: this.kind
    }
  };
};
function Zf(s) {
  return typeof s == "object" && !Array.isArray(s) && s !== null;
}
function yu(s) {
  return Math.random().toString(36).substring(2, 2 + s);
}
const ld = 1;
function Sg(s) {
  const t = s;
  return delete t.payload._bolt, t;
}
function iD(s) {
  return s.payload && Zf(s.payload);
}
function eS(s) {
  var t, e;
  return iD(s) && (e = (t = s.payload._bolt) == null ? void 0 : t.id) != null ? e : "";
}
var Gr, al, Bi;
const Na = class extends ut.EventEmitter {
  constructor(e, r, i, n) {
    super();
    h(this, "channel");
    h(this, "queue");
    h(this, "serverProtocolVersion");
    g(this, Gr, /* @__PURE__ */ new Map());
    g(this, al, void 0);
    g(this, Bi, void 0);
    h(this, "respond", (e, r, i = !1) => {
      let n;
      i ? n = Na.createErrorResponse(e, r) : n = Na.createResponse(e, r), this.channel.send(JSON.stringify(n));
    });
    h(this, "notify", (e) => {
      const r = Na.createNotification(e);
      this.channel.send(JSON.stringify(r));
    });
    h(this, "request", (e) => u(this, null, function* () {
      const r = Na.createRequest(e), i = new Promise((n, o) => {
        const { id: d } = r.payload._bolt, l = {
          id: d,
          method: r.type,
          resolve: (p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), n(p));
          },
          timer: setTimeout(() => {
            this.queue.delete(d) && o(new Error(`request timeout for message id: ${d}`));
          }, 2e4),
          cancel: (p) => {
            this.queue.delete(d) && (clearTimeout(l.timer), o(p));
          }
        };
        this.queue.set(d, l);
      });
      return this.channel.send(JSON.stringify(r)), i;
    }));
    h(this, "send", (e) => {
      const r = JSON.stringify(e), i = 16384;
      if (r.length > i) {
        const n = i - 200, o = Math.ceil(r.length / n), c = [];
        for (let l = 0; l < o; l += 1) {
          const p = l * n, f = (l + 1) * n;
          c.push(r.slice(p, f));
        }
        const d = ua();
        for (let l = 0; l < o; l += 1) {
          const p = c[l], S = JSON.stringify({
            id: d,
            count: o,
            chunkIndex: l,
            chunk: p
          });
          a(this, Bi).debug(`Sending message chunk over dc: ${S}`), this.channel.send(S);
        }
      } else
        a(this, Bi).debug(`Sending message over dc: ${r}`), this.channel.send(r);
    });
    h(this, "processMessage", (e) => {
      var i;
      a(this, Gr).has(e.id) || a(this, Gr).set(e.id, []);
      const r = a(this, Gr).get(e.id);
      if (r[e.chunkIndex] = e, (r == null ? void 0 : r.length) === e.count && !r.some((n) => n === void 0)) {
        const n = a(this, Gr).get(e.id), o = n == null ? void 0 : n.reduce((d, l) => d + l.chunk, "");
        a(this, Gr).delete(e.id);
        const c = JSON.parse(o);
        if (!c.payload || !Zf(c.payload))
          throw new Error("corrupted incoming message over dc", {
            cause: { code: "CORRUPT_DC_MESSAGE", values: c }
          });
        if (this.processBoltHandshake(c))
          return;
        if (this.serverProtocolVersion = (i = c.payload._bolt) == null ? void 0 : i.version, !this.processResponseMsg(c))
          return c;
      }
    });
    h(this, "processResponseMsg", (e) => {
      const { id: r } = e.payload._bolt, i = this.queue.get(r);
      return i ? (a(this, Bi).debug(`resolving pending request with id: ${r}, complete response: ${JSON.stringify(e)}`), e.type === "error" ? i.cancel(Sg(e)) : i.resolve(Sg(e)), !0) : !1;
    });
    h(this, "processBoltHandshake", (e) => {
      var r, i;
      return e.type === "_bolt" || e.type === "handshake" ? (this.respond((i = (r = e.payload._bolt) == null ? void 0 : r.id) != null ? i : yu(8), { type: "_bolt", payload: { message: "pong" } }), !0) : !1;
    });
    this.label = i, this.transportId = n, m(this, al, e), m(this, Bi, e.getValue("logger")), this.channel = r, this.queue = /* @__PURE__ */ new Map();
  }
};
let li = Na;
Gr = new WeakMap(), al = new WeakMap(), Bi = new WeakMap(), h(li, "createRequest", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      _bolt: {
        id: yu(8),
        type: "REQUEST",
        version: ld
      }
    })
  };
}), h(li, "createResponse", (e, r) => {
  var i;
  if ((i = r.payload) != null && i._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: r.type,
    payload: B(D({}, r.payload), {
      _bolt: {
        id: e,
        type: "RESPONSE",
        version: ld
      }
    })
  };
}), h(li, "createNotification", (e) => {
  var r;
  if ((r = e.payload) != null && r._bolt)
    throw new Error("rpc fields are internal values");
  return {
    type: e.type,
    payload: B(D({}, e.payload), {
      bolt: {
        id: yu(8),
        type: "NOTIFY",
        version: ld
      }
    })
  };
}), h(li, "createErrorResponse", (e, r) => ({
  type: "error",
  payload: {
    error: r.message,
    _bolt: {
      id: e,
      type: "RESPONSE",
      version: ld
    }
  }
}));
const Ud = "transport closed";
var qi, ji;
const Va = class extends Yl {
  constructor(e, r, {
    id: i,
    direction: n,
    handlerFactory: o,
    iceServers: c,
    iceTransportPolicy: d,
    proprietaryConstraints: l,
    additionalSettings: p,
    appData: f,
    config: S
  }) {
    var P, w, A;
    super(e);
    h(this, "awaitQueue");
    h(this, "observer");
    g(this, qi, void 0);
    // Id.
    h(this, "id");
    h(this, "serverId");
    // Direction.
    h(this, "direction");
    // SCTP max message size if enabled, null otherwise.
    h(this, "maxSctpMessageSize");
    // RTC handler isntance.
    h(this, "handler");
    // Transport connection state.
    h(this, "connectionState", "new");
    // Producers map
    h(this, "producers");
    // Consumers map
    h(this, "consumers");
    // Datachannels map
    h(this, "datachannels");
    h(this, "connected", !1);
    h(this, "eventsDCReadyPromise");
    h(this, "eventsDCReadyPromiseResolver");
    h(this, "eventsDCFailureTimer");
    h(this, "transportConnectionPromise");
    h(this, "consumerTrackEvents");
    h(this, "unknownTracksMap");
    // App custom data.
    h(this, "appData");
    g(this, ji, void 0);
    m(this, ji, e);
    const T = e.getValue("logger");
    T.debug(`constructor() [id: ${i}, direction: ${n}]`), m(this, qi, r), this.id = i, this.direction = n;
    const _ = tD(p, {});
    delete _.iceServers, delete _.iceTransportPolicy, delete _.bundlePolicy, delete _.rtcpMuxPolicy, delete _.sdpSemantics, this.producers = /* @__PURE__ */ new Map(), this.consumers = /* @__PURE__ */ new Map(), this.datachannels = /* @__PURE__ */ new Map(), this.consumerTrackEvents = /* @__PURE__ */ new Map(), this.unknownTracksMap = /* @__PURE__ */ new Map(), this.awaitQueue = new Zu(T, !0), this.handler = o(), this.handler.enableHighBitrate = (P = S == null ? void 0 : S.enableHighBitrate) != null ? P : !1, this.handler.enableStereo = (w = S == null ? void 0 : S.enableStereo) != null ? w : !1, this.handler.enableDtx = (A = S == null ? void 0 : S.enableDtx) != null ? A : !0, this.handler.sfu = a(this, qi), this.handler.init({
      onTrackHandler: this._ontrack.bind(this),
      direction: n,
      iceServers: c,
      iceTransportPolicy: d,
      additionalSettings: p,
      proprietaryConstraints: l
    }), this.appData = f || {}, this.transportConnectionPromise = new Promise((N) => {
      this.once("connected", () => {
        N(!0);
      }), this.once("disconnect", () => {
        N(!1);
      }), this.once("close", () => {
        N(!1);
      });
    }), this.eventsDCReadyPromise = new Promise((N) => {
      this.eventsDCReadyPromiseResolver = N;
    }), this.handler.on(
      "@connectionstatechange",
      (N) => {
        N !== this.connectionState && (this.logger.debug(`connection state changed to ${N}`), this.connectionState = N, N === "connected" && (this.connected = !0, this.emit("connected")), N === "disconnected" && (this.connected = !1, this.emit("disconnect")), (N === "failed" || N === "closed") && (this.connected = !1, this.emit("close")), this.closed || this.safeEmit("connectionstatechange", N));
      }
    ), this.handler.on(
      "@icecandidate",
      ({ candidate: N }) => {
        this.closed || this.safeEmit("icecandidate", N);
      }
    ), this.handler.on("dc_open", (N) => {
      let H = this.datachannels.get(N.label);
      H || (H || (H = new li(a(this, ji), N, N.label, this.serverId), this.datachannels.set(N.label, H)), this.eventsDCFailureTimer = setTimeout(() => {
        N.label === "events" && (this.eventsDCReadyPromiseResolver(!1), this.safeEmit("dc_error", N.label));
      }, 5e3));
    }), this.handler.on("datachannel", (N, H) => {
      N.label === "events" && (this.eventsDCReadyPromiseResolver(!0), this.eventsDCFailureTimer && clearTimeout(this.eventsDCFailureTimer));
      const $ = this.datachannels.get(N.label);
      if (!$) {
        this.logger.error("unregistered datachannel for message", {
          rtcChannel: {
            label: N.label,
            message: H
          }
        });
        return;
      }
      try {
        const F = JSON.parse(H);
        this.logger.debug("datachannel message chunk recieved", {
          dataChannelMessageChunk: {
            id: F.id,
            count: F.count,
            chunkIndex: F.chunkIndex,
            chunk: F.chunk,
            transprtId: this.serverId
          }
        });
        const K = $.processMessage(F);
        if (!K)
          return;
        this.logger.debug(
          `datachannel message with id:${F.id} on transport:${this.serverId}complete - ${JSON.stringify(K)}`
        ), this.emit(`datachannel:${N.label}`, $.label, K);
      } catch (F) {
        this.logger.error("error parsing message", {
          error: F
        });
      }
    });
  }
  get closed() {
    return this.connectionState === "closed";
  }
  setServerId(e) {
    this.serverId = e;
  }
  getDatachannel(e) {
    return this.datachannels.get(e);
  }
  get isEventsDCReady() {
    return this.eventsDCReadyPromise;
  }
  /**
  	* Close the Transport.
  	*/
  close() {
    this.closed || (this.logger.debug("Transport close called"), this.connectionState = "closed", this.awaitQueue.stop(), this.awaitQueue = void 0, this.connected = !1, this.handler.close(), Array.from(this.producers.values()).forEach(
      (e) => {
        e.close(Ud).catch(() => {
        });
      }
    ), this.producers.clear(), Array.from(this.consumers.values()).forEach((e) => {
      e.close(Ud);
    }), this.consumers.clear(), this.consumerTrackEvents.clear(), this.emit("close"));
  }
  /**
  	 * Get associated Transport (RTCPeerConnection) stats.
  	 *
  	 * @returns {RTCStatsReport}
  	 */
  getStats() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      return this.handler.getTransportStats();
    });
  }
  connect(e) {
    return u(this, null, function* () {
      try {
        if (yield this.awaitQueue.push(() => u(this, null, function* () {
          const { offerSdp: r, callback: i } = yield this.handler.connect(), {
            transportId: n,
            answer: o
          } = yield e(r);
          this.setServerId(n), yield i(o);
        })), !(yield this.transportConnectionPromise))
          throw new Error("ice connection failed");
        if (a(this, qi) === we.HIVE && !(yield this.isEventsDCReady))
          throw new Error("events datachannel not open");
      } catch (r) {
        throw this.logger.error("transport failed to connect:", { error: r }), r;
      }
    });
  }
  /**
  * Restart ICE connection.
  */
  restartIce() {
    return u(this, null, function* () {
      if (this.logger.debug("restartIce()"), this.closed)
        throw new At("closed");
      return this.handler.restartIce();
    });
  }
  canProduce(e) {
    return u(this, null, function* () {
      const { track: r, appData: i } = e;
      if (r) {
        if (this.direction !== "send")
          throw new Uo("not a sending Transport");
        if (r.readyState === "ended")
          throw new At("track ended");
        if (i && typeof i != "object")
          throw new TypeError("if given, appData must be an object");
      } else
        throw new TypeError("missing track");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return !0;
    });
  }
  produce(e, r) {
    return u(this, null, function* () {
      if (!(yield this.canProduce(e)))
        throw new Error("Cannot produce");
      const {
        track: n,
        encodings: o,
        codecOptions: c,
        stopTracks: d = !0,
        disableTrackOnPause: l = !0,
        zeroRtpOnPause: p = !1,
        appData: f = {}
      } = e;
      this.logger.debug(`produce() [track:${n.id}]`);
      const { producerId: S, localId: T, rtpSender: _ } = yield this.awaitQueue.push(() => u(this, null, function* () {
        const {
          offerSdp: P,
          callback: w,
          sender: A,
          mid: N
        } = yield this.handler.send({
          track: n,
          encodings: o,
          codecOptions: c,
          screenShare: f == null ? void 0 : f.screenShare
        }), { answer: H, producerId: $ } = yield r(
          {
            offer: P,
            kind: n.kind,
            paused: l ? !n.enabled || Object.hasOwn(n, "fakeTracks") : !1,
            appData: B(D({}, f || {}), { mid: N }),
            codecOptions: c,
            producingTransportId: this.serverId
          }
        ), F = yield w(H);
        return { producerId: $, localId: F, rtpSender: A };
      }), "Transport.produce");
      return this.createProducerObject({
        id: S,
        localId: T,
        track: n,
        stopTracks: d,
        disableTrackOnPause: l,
        zeroRtpOnPause: p,
        appData: f,
        handler: this.handler,
        rtpSender: _
      });
    });
  }
  createProducerObject(e) {
    return u(this, null, function* () {
      const r = new rD(a(this, ji), e);
      return this.producers.set(r.id, r), r.once("close", () => {
        this.producers.delete(r.id);
      }), this.emit("newproducer", r), r;
    });
  }
  closeProducer(e) {
    return u(this, null, function* () {
      yield this.awaitQueue.push(e.close.bind(e), "Transport.closeProducer");
    });
  }
  canConsume() {
    return u(this, null, function* () {
      if (this.closed)
        throw new At("closed");
      if (this.direction !== "recv")
        throw new Uo("not a receiving transport");
      if (!(yield this.transportConnectionPromise))
        throw new fi("transport not connected");
      return !0;
    });
  }
  consume(e, r, i) {
    return u(this, null, function* () {
      return this.awaitQueue.push(() => u(this, null, function* () {
        const n = {}, {
          consumerStates: o,
          sessionDescription: c,
          failedProducers: d
        } = yield r(e);
        o.forEach((p, f) => {
          n[f] = this.createConsumerObjectAndWaitForTrack(B(D({}, p), {
            producerId: f
          }));
        }), c && (this.logger.info("Session description found, sending negotiation request"), yield i(c));
        const l = [];
        return yield Promise.all(Object.entries(n).map(
          ([p, f]) => f.then((S) => l.push(S)).catch(() => {
            this.logger.error(`Failed to create consumer object, producer: ${p}`, {
              error: { message: "This should not happen" },
              transport: { serverId: this.serverId }
            });
          })
        )), { consumers: l, failedProducers: d };
      }), "Transport.consume", { producersLength: e.length });
    });
  }
  static parseCodecAndFmtpMappings(e, r) {
    const i = cs.parse(e.sdp), n = {};
    return i.media.forEach((o) => {
      r.includes(o.mid.toString()) && (n[o.mid.toString()] = {
        rtp: o.rtp,
        fmtp: o.fmtp,
        payloads: o.payloads,
        rtcpFb: o.rtcpFb
      });
    }), n;
  }
  static setCodecAndFmtpMappings(e, r, i) {
    const n = cs.parse(e.sdp);
    return n.media = n.media.map((c) => {
      if (r.includes(c.mid.toString())) {
        const d = D({}, c);
        return d.rtp = i[c.mid.toString()].rtp, d.fmtp = i[c.mid.toString()].fmtp, d.payloads = i[c.mid.toString()].payloads, d.rtcpFb = i[c.mid.toString()].rtcpFb, d;
      }
      return c;
    }), B(D({}, e), {
      sdp: cs.write(n)
    });
  }
  static parseHeaderExtensionMappings(e) {
    const r = cs.parse(e.sdp), i = {};
    return r.media.forEach((n) => {
      i[n.mid] = n.ext;
    }), i;
  }
  static setHeaderExtensionMappings(e, r) {
    const i = cs.parse(e.sdp);
    return i.media = i.media.map((o) => {
      const c = D({}, o);
      return c.ext = r[o.mid], c;
    }), B(D({}, e), {
      sdp: cs.write(i)
    });
  }
  closeConsumers(e, r) {
    return u(this, null, function* () {
      try {
        const i = e.map((l) => l.transceiver.mid), n = Va.parseCodecAndFmtpMappings(
          this.handler.pc.remoteDescription,
          i
        ), o = Va.parseHeaderExtensionMappings(
          this.handler.pc.remoteDescription
        );
        this.logger.info("Stopping transceivers", { consumerIds: e.map(({ id: l }) => l) }), e.forEach((l) => l.close(void 0, !0));
        let c = yield this.handler.pc.createOffer();
        this.logger.info("Created offer for closing consumers", { sdp: c.sdp }), c = Va.setCodecAndFmtpMappings(
          c,
          i,
          n
        ), c = Va.setHeaderExtensionMappings(
          c,
          o
        ), this.logger.info("Updated codec and fmtp mappings in close consumer offer", { sdp: c.sdp }), yield this.setLocalDescription(c), this.logger.info("Successfully set local description in close consumers");
        const d = yield r(e, c);
        this.logger.info("Received answer in close consumers", { sdp: d.sdp }), yield this.setRemoteDescription(d), this.logger.info("Remote description was set successfully in close consumers", { sdp: d.sdp });
      } catch (i) {
        this.logger.error("Failed to close consumers", { error: i });
      }
    });
  }
  setRemoteOffer(e) {
    return u(this, null, function* () {
      try {
        this.logger.info("Received offer from SFU", { sdp: e.sdp }), yield this.setRemoteDescription(e);
        const r = yield this.handler.pc.createAnswer();
        this.logger.info("Created answer corresponding to received offer", { sdp: r.sdp });
        const i = cs.parse(r.sdp);
        return i.media = i.media.map((n) => {
          if (n.type === "audio") {
            const o = D({}, n), c = o.fmtp.find(
              (l) => l.payload === 111
            );
            return c && (c.config += ";stereo=1;sprop-stereo=1"), o.rtcpFb || (o.rtcpFb = []), o.rtcpFb.some(
              (l) => l.type === "nack"
            ) || o.rtcpFb.push({
              payload: parseInt(o.payloads, 10),
              type: "nack"
            }), o;
          }
          return n;
        }), r.sdp = cs.write(i), this.logger.info("Setting munged SDP", { sdp: r.sdp }), yield this.setLocalDescription(r), this.logger.info("Successfully set local description", { sdp: r.sdp }), r;
      } catch (r) {
        throw this.logger.error("Set remote offer failed", { error: r }), r;
      }
    });
  }
  _ontrack(e) {
    const { track: r, transceiver: i, streams: n } = e;
    this.logger.info(`track event received [trackId: ${r.id}] [mid: ${i.mid}]`);
    let o;
    a(this, qi) === we.HIVE ? o = `${n[0].id}:${r.kind}` : o = `${i.mid}:${r.kind}`, r.addEventListener("ended", () => {
      this.logger.info(`rtc consumer track ended [trackId: ${r.id}]`), this.unknownTracksMap.delete(o);
    });
    const c = this.consumerTrackEvents.get(o);
    c ? (c(r, i), this.consumerTrackEvents.delete(o)) : (this.logger.warn(`track event handler not found ${o}`), this.unknownTracksMap.set(o, e));
  }
  sendErrorOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i, !0);
  }
  sendResponseOverDC(e, r, i) {
    const n = this.getDatachannel(e);
    if (!n)
      throw new Error("datachannel not found", {
        cause: { code: "DC_NOT_FOUND", values: { label: e } }
      });
    n.respond(r, i);
  }
  createConsumerObjectAndWaitForTrack(e) {
    return u(this, null, function* () {
      const {
        consumerId: r,
        producerId: i,
        producingPeerId: n,
        producingTransportId: o,
        streamId: c,
        paused: d,
        screenShare: l,
        appData: p,
        kind: f,
        mimeType: S
      } = e, T = `${c}:${f}`, _ = B(D({}, e), {
        name: "consumer creation task error",
        message: "consumer creation failed"
      });
      return new Promise((P, w) => u(this, null, function* () {
        const A = setTimeout(() => {
          this.logger.warn(`Timed out waiting for track event ${T} producingPeerId: ${n}`), this.consumerTrackEvents.delete(T), _.isTimedout = !0, w(_);
        }, 5e3), N = ($, F) => {
          try {
            if ($.readyState === "ended")
              clearTimeout(A), w(_);
            else {
              const K = $;
              K.enabled = !0, this.handler.midTransceiverMap.set(F.mid, F);
              const re = new sD(a(this, ji), {
                id: r,
                localId: F.mid,
                transceiver: F,
                track: K,
                paused: d,
                producerId: i,
                producingPeerId: n,
                producingTransportId: o,
                handler: this.handler,
                appData: B(D({}, p), { screenShare: l, peerId: n }),
                rtpReceiver: F.receiver,
                mimeType: S
              });
              this.consumers.set(r, re), re.once("close", () => {
                this.consumers.delete(re.id), this.handler.midTransceiverMap.delete(F.mid);
              }), this.logger.info("consumer created for ", {
                consumer: {
                  id: r,
                  kind: f,
                  appData: {
                    screenShare: l
                  },
                  peerId: n,
                  producerId: i
                }
              }), this.emit("newconsumer", re), clearTimeout(A), P(re);
            }
          } catch (K) {
            this.logger.warn("error while creating consumer:", K), clearTimeout(A), w(_);
          }
        }, H = this.unknownTracksMap.get(T);
        H ? (this.logger.info(`track event already received [trackId: ${H.track.id}] [mid: ${H.transceiver.mid}]`), this.unknownTracksMap.delete(T), N(H.track, H.transceiver)) : (this.logger.info(`Registering onTrack handler for key ${T} [producingPeerId: ${n}]`), this.consumerTrackEvents.set(T, N));
      }));
    });
  }
  setRemoteDescription(e) {
    return u(this, null, function* () {
      yield this.handler.pc.setRemoteDescription(e);
    });
  }
  setLocalDescription(e) {
    return u(this, null, function* () {
      this.logger.debug(`${this.direction}() {transportId: ${this.serverId}} | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), yield this.handler.pc.setLocalDescription(e);
    });
  }
  sendDataChannelMessage(e, r) {
    return u(this, null, function* () {
      const i = this.getDatachannel(e);
      if (!i)
        throw Y0("DC_NOT_READY", `${e} datachannel not ready`);
      const n = (yield i.request(r)).payload;
      return this.logger.info(`sendDataChannelMessage::response ${JSON.stringify(n)}`), n;
    });
  }
};
let th = Va;
qi = new WeakMap(), ji = new WeakMap();
function aD(s) {
  if (typeof navigator == "object" && navigator.product === "ReactNative") {
    if (typeof RTCPeerConnection == "undefined") {
      s.warn(
        "Device::this._detectDevice() | unsupported ReactNative without RTCPeerConnection"
      );
      return;
    }
    return s.debug("Device::this._detectDevice() | ReactNative handler chosen"), "Chrome74";
  }
  if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
    const t = navigator.userAgent, e = Kg.getParser(t), r = e.getEngine();
    if (e.satisfies({
      chrome: ">=74",
      chromium: ">=74",
      "microsoft edge": ">=88"
    }))
      return "Chrome74";
    if (e.satisfies({ chrome: ">=55", chromium: ">=55" }))
      return;
    if (e.satisfies({ firefox: ">=110" }))
      return "Firefox110";
    if (e.satisfies({ firefox: ">=60" }))
      return "Firefox60";
    if (e.satisfies({ ios: { OS: ">=14.3", firefox: ">=30.0" } }) || e.satisfies({ safari: ">=12.0" }) && typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection"))
      return "Safari12";
    if (e.satisfies({ safari: ">=11" }) || e.satisfies({ "microsoft edge": ">=11" }) && e.satisfies({ "microsoft edge": "<=18" }))
      return;
    if (r.name && r.name.toLowerCase() === "blink") {
      const i = t.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
      return i ? Number(i[1]) >= 74 ? "Chrome74" : void 0 : "Chrome74";
    }
    if (r.name.toLowerCase() === "webkit" && e.getOS().name.toLowerCase() === "ios")
      return typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") ? "Safari12" : void 0;
    s.warn("Device::this._detectDevice() | browser not supported");
    return;
  }
  s.warn("Device::this._detectDevice() | unknown device");
}
var lc, rr, Gi;
class nD {
  constructor(t, e, { handlerName: r, handlerFactory: i } = {}) {
    // RTC handler factory.
    h(this, "handlerFactory");
    g(this, lc, void 0);
    g(this, rr, void 0);
    g(this, Gi, void 0);
    const n = t.getValue("logger");
    if (n.debug("constructor()"), m(this, rr, t), m(this, Gi, n), m(this, lc, e), r && i)
      throw new TypeError(
        "just one of handlerName or handlerInterface can be given"
      );
    if (i)
      this.handlerFactory = i;
    else {
      if (r)
        a(this, Gi).debug(`Device::constructor() | handler given: ${r}`);
      else if (r = aD(a(this, Gi)), r)
        a(this, Gi).debug(`Device::constructor() | detected handler: ${r}`);
      else
        throw new Error("device not supported");
      switch (r) {
        case "Chrome74":
          this.handlerFactory = qh.createFactory(a(this, rr));
          break;
        case "Safari12":
          this.handlerFactory = jh.createFactory(a(this, rr));
          break;
        case "Firefox60":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: !1 }
          );
          break;
        case "Firefox110":
          this.handlerFactory = xd.createFactory(
            a(this, rr),
            { supportsSendEncodings: !0 }
          );
          break;
        default:
          throw new TypeError(`unknown handlerName "${r}"`);
      }
    }
  }
  /**
   * Creates a Transport for receiving media.
   *
   * @throws {InvalidStateError} if not loaded.
   * @throws {TypeError} if wrong arguments.
   */
  createTransport(t) {
    const e = ua();
    return new th(a(this, rr), a(this, lc), B(D({
      id: e
    }, t), {
      handlerFactory: this.handlerFactory
    }));
  }
}
lc = new WeakMap(), rr = new WeakMap(), Gi = new WeakMap();
const oD = 2e3;
var wn, ot, ct, uc, hc, Wi, bn, kn, In, Ji, Ns, An, Mn, _d, pc, sh, nl, tS, gc, rh, ol, sS, cl, rS, dl, iS, ll, aS, ul, nS, mc, ih, fc, ah;
class cD extends ut.EventEmitter {
  constructor(e, r, i) {
    super();
    g(this, Mn);
    g(this, pc);
    g(this, nl);
    g(this, gc);
    g(this, ol);
    g(this, cl);
    g(this, dl);
    g(this, ll);
    g(this, ul);
    g(this, mc);
    g(this, fc);
    h(this, "context");
    g(this, wn, void 0);
    g(this, ot, void 0);
    g(this, ct, void 0);
    g(this, uc, void 0);
    g(this, hc, void 0);
    g(this, Wi, void 0);
    g(this, bn, void 0);
    g(this, kn, void 0);
    g(this, In, {
      transportFailureCount: {
        send: 0,
        recv: 0
      },
      lastConnectionTime: 0
    });
    g(this, Ji, void 0);
    g(this, Ns, "all");
    g(this, An, void 0);
    switch (this.context = e, m(this, Wi, r), m(this, An, i), m(this, wn, new nD(e, i)), m(this, bn, new eD(r, i)), i) {
      case we.CF: {
        m(this, kn, Ts);
        break;
      }
      case we.HIVE:
      default: {
        m(this, kn, is);
        break;
      }
    }
    a(this, Mn, _d).mediaState = {
      send: { state: xa.NEW },
      recv: { state: xa.NEW }
    }, (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy initially set to ${a(this, Ns)}`), L(this, pc, sh).call(this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  get socket() {
    return a(this, Wi);
  }
  get socketHandler() {
    return a(this, bn);
  }
  get sendTransport() {
    return a(this, ot);
  }
  get recvTransport() {
    return a(this, ct);
  }
  get events() {
    return a(this, kn);
  }
  get nodeType() {
    return a(this, An);
  }
  set sendTransportConnectedCallback(e) {
    m(this, uc, e);
  }
  set recvTransportConnectedCallback(e) {
    m(this, hc, e);
  }
  setupTransports(e) {
    return u(this, null, function* () {
      yield L(this, nl, tS).call(this, e);
      let r, i;
      e.send && (r = L(this, gc, rh).call(this, a(this, ot)).then((n) => {
        try {
          a(this, uc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run send transport callback");
        }
      })), e.recv && (i = L(this, gc, rh).call(this, a(this, ct)).then((n) => {
        try {
          a(this, hc).call(this, n);
        } catch (o) {
          this.logger.error("Failed to run recv transport callback");
        }
      })), yield Promise.all([r, i]);
    });
  }
  stopTransports(e) {
    var r, i;
    if (e.send && this.sendTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ot);
      this.logger.info("Closing send transport", { transport: { id: n, serverId: o, type: c } }), a(this, ot).close(), a(this, ot).removeAllListeners(), m(this, ot, void 0);
    }
    if (e.recv && this.recvTransport !== void 0) {
      const { id: n, serverId: o, direction: c } = a(this, ct);
      this.logger.info("Closing recv transport", { transport: { id: n, serverId: o, type: c } }), (r = a(this, ct)) == null || r.close(), (i = a(this, ct)) == null || i.removeAllListeners(), m(this, ct, void 0);
    }
    L(this, pc, sh).call(this);
  }
  stopAllTransports() {
    this.logger.info("Closing all transports"), this.stopTransports({ send: !0, recv: !0 });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  handleErrors(e) {
    throw new Error("Method not implemented.");
  }
}
wn = new WeakMap(), ot = new WeakMap(), ct = new WeakMap(), uc = new WeakMap(), hc = new WeakMap(), Wi = new WeakMap(), bn = new WeakMap(), kn = new WeakMap(), In = new WeakMap(), Ji = new WeakMap(), Ns = new WeakMap(), An = new WeakMap(), Mn = new WeakSet(), _d = function() {
  return this.context.getValue("connectionHandler");
}, pc = new WeakSet(), sh = function() {
  m(this, Ji, {
    send: void 0,
    recv: void 0
  });
}, nl = new WeakSet(), tS = function(e) {
  return u(this, null, function* () {
    var o, c, d, l, p, f, S, T;
    (Gn(this.context, "forceRelay") || this.context.getValue("flagsmith").hasFeature(X.FORCE_RELAY)) && m(this, Ns, "relay"), this.logger.info(`ICE Transport Policy set to ${a(this, Ns)}`);
    const n = yield lt().getICEServers().catch((_) => (this.logger.warn(`failed to get iceservers from server: ${_.message}`), []));
    if (e.send) {
      const _ = this.context.getValue("flagsmith").hasFeature(
        X.DISABLE_OPUS_DTX_CF
      );
      L(this, cl, rS).call(this, {
        iceServers: n,
        additionalSettings: {
          encodedInsertableStreams: (o = this.context.getValue("modules").e2ee) == null ? void 0 : o.enabled
        },
        config: {
          enableHighBitrate: (l = (d = (c = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : c.audio) == null ? void 0 : d.enableHighBitrate) != null ? l : !1,
          enableStereo: (S = (f = (p = this.context.getValue("defaults").mediaConfiguration) == null ? void 0 : p.audio) == null ? void 0 : f.enableStereo) != null ? S : !1,
          enableDtx: a(this, An) === we.HIVE ? !0 : !!_
        },
        iceTransportPolicy: a(this, Ns)
      });
    }
    e.recv && L(this, dl, iS).call(this, {
      iceServers: n,
      additionalSettings: {
        encodedInsertableStreams: (T = this.context.getValue("modules").e2ee) == null ? void 0 : T.enabled
      },
      iceTransportPolicy: a(this, Ns)
    });
  });
}, gc = new WeakSet(), rh = function(e) {
  return u(this, null, function* () {
    const { id: r, serverId: i, direction: n } = e;
    L(this, ll, aS).call(this, e);
    try {
      const o = this.context.getValue("flagsmith").hasFeature(
        X.ENABLE_HIVE_INFINITE_RETRIES
      ) ? 1 / 0 : 3;
      return yield Yf((c, d) => u(this, null, function* () {
        c > 0 && this.logger.debug(`Retrying transport connect, count: ${c}`, {
          transport: { id: r, serverId: i, type: n }
        });
        try {
          if (e.closed)
            throw new fi("Cannot reconnect closed transport");
          yield L(this, ol, sS).call(this, e);
        } catch (l) {
          if (l instanceof fi) {
            d(l);
            return;
          }
          throw this.logger.error("Failed to connect transport, retrying", { transport: e, error: l }), l;
        }
      }), {
        delayTime: 100,
        strategy: "exponential",
        maxRetryCount: o
      }), e;
    } catch (o) {
      throw this.logger.error(
        `Failed to connect send transport after retry: ${e.id}`,
        {
          error: o,
          transport: { id: r, serverId: i, type: n }
        }
      ), e.close(), e.removeAllListeners(), o;
    }
  });
}, ol = new WeakSet(), sS = function(e) {
  return u(this, null, function* () {
    const { id: r, direction: i } = e;
    if (this.logger.info(`Connecting ${i} transport`, {
      transport: { id: r, type: i }
    }), !a(this, Wi).isConnected)
      throw new fi("Socket is not connected");
    if (e.connectionState === "closed")
      throw new fi("Transport is closed");
    try {
      yield e.connect(
        (n) => L(this, ul, nS).call(this, i, n)
      ), this.logger.info(`Connected ${i} transport`, {
        transport: { id: r, serverId: e.serverId, type: i }
      });
    } catch (n) {
      throw a(this, In).transportFailureCount[i] += 1, n.message === "ice connection failed" ? new fi(n.message) : n;
    }
  });
}, cl = new WeakSet(), rS = function(e) {
  var r, i;
  if (a(this, ot) && a(this, ot).connected) {
    this.logger.info("Transport send is already connected", {
      transport: {
        id: (r = a(this, ot)) == null ? void 0 : r.id,
        serverId: (i = a(this, ot)) == null ? void 0 : i.serverId,
        type: "send"
      }
    });
    return;
  }
  m(this, ot, a(this, wn).createTransport(B(D({}, e), {
    direction: "send"
  }))), this.context.getValue("callstats").configureSendTransport(a(this, ot));
}, dl = new WeakSet(), iS = function(e) {
  var r, i;
  if (a(this, ct) && a(this, ct).connected) {
    this.logger.info("Transport recv is already connected", {
      transport: {
        id: (r = a(this, ct)) == null ? void 0 : r.id,
        serverId: (i = a(this, ct)) == null ? void 0 : i.serverId,
        type: "recv"
      }
    });
    return;
  }
  m(this, ct, a(this, wn).createTransport(B(D({}, e), {
    direction: "recv"
  }))), this.context.getValue("callstats").configureRecvTransport(a(this, ct));
}, ll = new WeakSet(), aS = function(e) {
  const { direction: r, id: i } = e;
  e.on("connectionstatechange", (n) => u(this, null, function* () {
    L(this, fc, ah).call(this, { state: n, direction: r }), this.logger.info(
      `Transport connection state changed for ${r} transport`,
      {
        transport: {
          id: i,
          serverId: e.serverId,
          type: r,
          status: n
        }
      }
    );
    const o = () => {
      const c = a(this, Ji)[r];
      c !== void 0 && (clearTimeout(c), a(this, Ji)[r] = void 0);
    };
    switch (n) {
      case "connected":
        o(), a(this, In).lastConnectionTime = performance.now();
        break;
      case "disconnected":
        a(this, Ji)[r] = setTimeout(() => u(this, null, function* () {
          this.logger.warn(`${r} transport is in disconnected state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        }), oD);
        break;
      case "failed":
        if (e.closed)
          return;
        o(), this.logger.warn(`${r} transport is in failed state, reconnecting transport`, { transport: { id: i, serverId: e.serverId, type: r } }), yield L(this, mc, ih).call(this, e.direction);
        break;
    }
  })), e.on("icecandidate", (n) => u(this, null, function* () {
    this.logger.debug("Sending iceCandidate:", { iceCandidate: n });
  })), e.on("datachannel:events", (n, o) => u(this, null, function* () {
    var c, d;
    this.logger.debug("Got data channel message on event:", {
      rtcChannel: { label: n, message: o }
    });
    try {
      switch (o.type) {
        case "handshake": {
          const l = {
            type: "handshake",
            payload: {
              message: "pong"
            }
          };
          e.sendResponseOverDC(n, eS(o), l);
          break;
        }
        case "hub-disconnect": {
          this.logger.debug(`media hub disconnected, full_reconnect: ${(c = o.payload) == null ? void 0 : c.full_reconnect}`), ((d = o.payload) == null ? void 0 : d.full_reconnect) === !0 && this.handleErrors("rejoin");
          break;
        }
        case "error":
          break;
        default:
          break;
      }
    } catch (l) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${n}`
      );
    }
  })), e.on("dc_error", () => {
    e.direction === "recv" && (this.logger.warn("Events datachannel did not open in 5s", { country: E.location.country }), this.handleErrors("reconnectRecvTransport"));
  });
}, ul = new WeakSet(), nS = function(e, r) {
  return u(this, null, function* () {
    const i = e === "recv";
    try {
      const { sdp: n, type: o } = r, c = {
        consuming: i,
        description: {
          sdp: n,
          type: o,
          target: i ? vr.SUBSCRIBER : vr.PUBLISHER
        },
        producers: []
      };
      return a(this, bn).connectTransport(c);
    } catch (n) {
      throw this.logger.error(
        `Error in ${e} transport connection:`,
        { error: n, country: E.location.country }
      ), n;
    }
  });
}, mc = new WeakSet(), ih = function(e) {
  return u(this, null, function* () {
    switch (this.logger.info("Called reconnect transport", { transport: { type: e } }), this.stopTransports({ [e]: !0 }), this.context.getValue("flagsmith").hasFeature(
      X.HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED
    ) && a(this, Wi).isConnected && a(this, In).transportFailureCount[e] > 2 && (this.logger.warn(`Multiple disconnections in ${e} transport, forcing relay`), m(this, Ns, "relay")), yield this.setupTransports({ [e]: !0 }), e) {
      case "send": {
        this.logger.info("Transport reconnected", { transport: a(this, ot) }), this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE);
        break;
      }
      case "recv": {
        this.logger.info("Transport reconnected", { transport: a(this, ct) }), this.context.getValue("peerSessionStore").emit(k.UPDATE_ACTIVE, { createAllConsumers: !0 });
        break;
      }
      default:
        this.logger.warn("Unknown transport direction", { transport: { type: e } });
    }
    L(this, fc, ah).call(this, {
      state: xa.CONNECTED,
      direction: e
    });
  });
}, fc = new WeakSet(), ah = function(e) {
  const { state: r, direction: i } = e;
  a(this, Mn, _d).mediaState[i] = {
    state: r
  }, this.context.getValue("peerSessionStore").emit(
    k.TRANSPORT_STATE_UPDATE,
    D({
      transport: i
    }, a(this, Mn, _d).mediaState[i])
  );
};
var Sc, hl, oS;
class dD {
  /* eslint-disable-next-line no-useless-constructor, no-empty-function */
  constructor(t, e) {
    g(this, hl);
    g(this, Sc, void 0);
    this.recvTransport = e, L(this, hl, oS).call(this), m(this, Sc, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Sc).getValue("logger");
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const r = {
        type: "create_consumer",
        payload: {
          producers: t.map(({
            producerId: c,
            producingTransportId: d,
            kind: l,
            mimeType: p
          }) => ({
            producerId: c,
            producingTransportId: d,
            preferredCodec: D(D({}, l === "video" && p ? { video: p } : {}), l === "audio" && p ? { audio: p } : {})
          }))
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), n = /* @__PURE__ */ new Map();
      t.forEach((c) => n.set(c.producerId, c));
      const o = /* @__PURE__ */ new Map();
      return Object.entries(i).forEach(([c, d]) => {
        const l = n.get(d.producerId);
        l && o.set(d.producerId, {
          consumerId: c,
          producingTransportId: l.producingTransportId,
          producingPeerId: l.producingPeerId,
          kind: l.kind,
          paused: l.pause,
          streamId: d.streamId,
          trackId: d.trackId,
          screenShare: l.screenShare,
          mimeType: l.mimeType,
          appData: {}
        });
      }), { consumerStates: o };
    });
  }
  negotiate(t, e, r) {
    return u(this, null, function* () {
      try {
        this.logger.debug(`Received offer over dc: ${t.sdp} for transport`);
        const i = yield this.recvTransport.setRemoteOffer(t), n = {
          type: "answer",
          payload: {
            type: i.type,
            sdp: i.sdp
          }
        };
        return this.logger.debug(`datachannel answer: ${JSON.stringify(n)}`), this.recvTransport.sendResponseOverDC(r, e, n), i;
      } catch (i) {
        throw this.logger.error("datachannel:events::Error:", i), i.code !== "DC_NOT_FOUND" && this.recvTransport.sendErrorOverDC(r, e, i), i;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = t.map((o) => o.id);
      this.logger.info(`Closing consumers: ${JSON.stringify(e)}`);
      const r = {
        type: "close_consumers",
        payload: {
          consumers: e
        }
      }, i = yield this.recvTransport.sendDataChannelMessage("events", r), { failedConsumers: n } = i;
      return { failedConsumers: n };
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      var o;
      const r = this.recvTransport.getDatachannel("events");
      if (!r) {
        this.logger.warn("events datachannel not found");
        return;
      }
      const i = (o = t == null ? void 0 : t.map(({ id: c }) => c)) != null ? o : [], n = {
        type: "switch_consumer_layer",
        payload: {
          consumerIds: i,
          layer: e
        }
      };
      yield r.request(n), this.logger.info(`Consumers switched layers to ${e}`, { consumerIds: i });
    });
  }
}
Sc = new WeakMap(), hl = new WeakSet(), oS = function() {
  this.recvTransport.on("datachannel:events", (e, r) => u(this, null, function* () {
    try {
      switch (r.type) {
        case "negotiation": {
          const { sdp: i } = r.payload, n = {
            sdp: i,
            type: "offer"
          };
          this.negotiate(n, eS(r), e);
          break;
        }
        default:
          break;
      }
    } catch (i) {
      this.logger.error(
        `Unable to handle the incoming datachannel message on channel ${e}`
      );
    }
  }));
};
var vc, ts;
class lD {
  constructor(t, e, r, i, n) {
    /* eslint-disable-next-line no-useless-constructor */
    g(this, vc, void 0);
    g(this, ts, void 0);
    this.events = e, this.recvTransport = r, this.socket = i, this.socketHandler = n, m(this, vc, t), m(this, ts, t.getValue("logger"));
  }
  create(t) {
    return u(this, null, function* () {
      if (!t || t && t.length === 0)
        throw new Error("List of producers is required");
      const e = /* @__PURE__ */ new Map(), r = [];
      t.forEach((d) => {
        const { producingPeerId: l, producerId: p, producingTransportId: f } = d, S = a(this, vc).getValue("flagsmith").hasFeature(X.ENABLE_CF_SIMULCAST) ? {
          simulcast: {
            preferredRid: "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        } : {};
        e.set(p, l), r.push(D({
          producingPeerId: l,
          producerId: p,
          producingTransportId: f
        }, S));
      });
      const i = yield this.socketHandler.consume({
        requests: r,
        consumingTransportId: this.recvTransport.serverId
      }), n = /* @__PURE__ */ new Map();
      t.forEach((d) => n.set(d.producerId, d));
      const o = /* @__PURE__ */ new Map(), c = [];
      return Object.entries(i.consumerStateMap).forEach(([d, l]) => {
        const p = n.get(d);
        if (!p)
          return;
        if (l.errorCode) {
          a(this, ts).warn(`Consumer request failed for producer ${d}`, {
            error: { message: l.errorCode }
          }), c.push(B(D({}, p), { errorCode: l.errorCode }));
          return;
        }
        let f = {};
        try {
          f = JSON.parse(l.producerState.appData);
        } catch (S) {
        }
        o.set(d, {
          consumerId: l.consumerId,
          producingTransportId: p.producingTransportId,
          producingPeerId: p.producingPeerId,
          kind: p.kind,
          paused: p.pause,
          streamId: l.producerTrack.streamId,
          trackId: l.producerTrack.trackId,
          screenShare: p.screenShare,
          mimeType: p.mimeType,
          appData: f
        });
      }), { consumerStates: o, sessionDescription: i.sessionDescription, failedProducers: c };
    });
  }
  negotiate(t) {
    return u(this, null, function* () {
      try {
        a(this, ts).info("Negotiating socket consumer", { transport: this.recvTransport }), a(this, ts).debug(`setting remote offer: ${JSON.stringify(t)} on recvTransport`, {
          transport: this.recvTransport
        });
        const e = yield this.recvTransport.setRemoteOffer(t), r = {
          transportId: this.recvTransport.serverId,
          description: {
            sdp: e.sdp,
            type: e.type,
            target: vr.SUBSCRIBER
          }
        };
        return a(this, ts).debug(`sending renegotiate request: ${JSON.stringify(r)} on recvTransport`, {
          transport: this.recvTransport
        }), yield this.socket.sendMessagePromise(
          this.events.renegotiateSessionDescription,
          JC.toBinary(r)
        ), a(this, ts).info("Renegotiation done", { transport: this.recvTransport }), e;
      } catch (e) {
        a(this, ts).error("Failed to renegotiate", { error: e });
        return;
      }
    });
  }
  close(t) {
    return u(this, null, function* () {
      if (!t.length)
        return {};
      const e = (r, i) => u(this, null, function* () {
        const n = r.map((l) => l.localId);
        a(this, ts).info(`Closing consumers: ${JSON.stringify(n)}`);
        const o = {
          description: {
            sdp: i.sdp,
            type: i.type,
            target: vr.SUBSCRIBER
          },
          consumerIds: n,
          consumingTransportId: this.recvTransport.serverId
        }, c = yield this.socketHandler.closeConsumer(o), d = Tw.fromBinary(c).description;
        return {
          sdp: d.sdp,
          type: d.type
        };
      });
      return yield this.recvTransport.awaitQueue.push(() => this.recvTransport.closeConsumers(t, e), "ConsumerStrategy.close", { consumersLength: t.length }), {};
    });
  }
  switchConsumersToLayer(t, e) {
    return u(this, null, function* () {
      const r = {
        requests: [],
        consumingTransportId: this.recvTransport.serverId
      }, i = t.filter((n) => n && n.id);
      i.forEach(({ id: n, producingTransportId: o, localId: c }) => {
        r.requests.push({
          producerId: n,
          producingTransportId: o,
          mid: c,
          simulcast: {
            preferredRid: e === 0 ? "q" : "h",
            priorityOrdering: "asciibetical",
            ridNotAvailable: "asciibetical"
          }
        });
      }), yield this.socketHandler.updateConsumersSimulcastConfig(r), a(this, ts).info(`Consumers switched layers to ${e}`, { consumerIds: i == null ? void 0 : i.map(({ id: n }) => n) });
    });
  }
}
vc = new WeakMap(), ts = new WeakMap();
class Gh {
  /* eslint-disable-next-line no-useless-constructor, no-empty-function */
  constructor(t) {
    this.socketHandler = t;
  }
  static getMSIDFromSDP(t, e) {
    return cs.parse(t).media.filter(
      (n) => e === "video" ? n.type === "video" : n.type === "audio"
    ).at(-1).msid;
  }
  create(c) {
    return u(this, arguments, function* ({
      offer: t,
      kind: e,
      paused: r,
      appData: i,
      codecOptions: n,
      producingTransportId: o
    }) {
      var S, T;
      const d = Gh.getMSIDFromSDP(t.sdp, e), l = {
        description: {
          sdp: t.sdp,
          type: t.type,
          target: vr.PUBLISHER
        },
        paused: r,
        kind: e,
        msid: d,
        appData: JSON.stringify(i),
        screenShare: (S = i.screenShare) != null ? S : !1,
        mimeType: `${e}/${(T = n[0]) == null ? void 0 : T.name}`,
        producingTransportId: o
      }, { answer: p, producerId: f } = yield this.socketHandler.produce(l);
      return { answer: p, producerId: f };
    });
  }
}
var Ki, Wr, Dn, yc, ps, pl, ir, On, Tc, nh, gl, cS, ml, dS, fl, lS, Sl, uS;
class uD extends cD {
  constructor(e, r, i) {
    super(e, r, i);
    g(this, Tc);
    g(this, gl);
    g(this, ml);
    g(this, fl);
    g(this, Sl);
    g(this, Ki, void 0);
    g(this, Wr, void 0);
    g(this, Dn, void 0);
    g(this, yc, void 0);
    g(this, ps, void 0);
    g(this, pl, {
      producerCreationFailureCount: 0,
      consumerCreationFailureCount: 0,
      producerNotReadyFailureCount: 0
    });
    g(this, ir, []);
    g(this, On, void 0);
    this.context = e, this.sendTransportConnectedCallback = () => u(this, null, function* () {
      m(this, yc, new Gh(this.socketHandler));
    }), this.recvTransportConnectedCallback = (n) => u(this, null, function* () {
      switch (a(this, Dn).clear(), this.nodeType) {
        case we.CF: {
          m(this, ps, new lD(
            this.context,
            this.events,
            n,
            this.socket,
            this.socketHandler
          ));
          break;
        }
        case we.HIVE:
        default:
          m(this, ps, new dD(this.context, n));
      }
    }), this.reset();
  }
  get socketHandler() {
    return super.socketHandler;
  }
  get producers() {
    return a(this, Ki);
  }
  get consumers() {
    return a(this, Wr);
  }
  get producerIdToConsumerIdMap() {
    return a(this, Dn);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  reset() {
    m(this, Ki, /* @__PURE__ */ new Map()), m(this, Wr, /* @__PURE__ */ new Map()), m(this, Dn, /* @__PURE__ */ new Map());
  }
  createProducer(e, r) {
    return u(this, null, function* () {
      var i;
      if (!this.sendTransport || this.sendTransport.closed)
        throw new Error("Send transport is closed");
      try {
        const n = yield this.sendTransport.produce(
          e,
          L(this, gl, cS).bind(this)
        );
        return (i = e.appData) != null && i.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, n), L(this, ml, dS).call(this, n, r), n;
      } catch (n) {
        throw this.logger.error("Failed to create producer", { error: n }), a(this, pl).producerCreationFailureCount += 1, n;
      }
    });
  }
  closeProducer(e, r) {
    return u(this, null, function* () {
      var n;
      const i = this.producers.get(e);
      if (!i) {
        this.logger.warn(`Producer with ID ${e} was not found`);
        return;
      }
      r != null && r.stopTrack && i.track.stop();
      try {
        yield this.sendTransport.closeProducer(i), (n = this.context.getValue("modules").e2ee) != null && n.enabled && this.context.getValue("peerSessionStore").emit(k.E2EE_INACTIVE_PRODUCER, i);
      } catch (o) {
        this.logger.error("Failed to close producer on server", { error: o, producer: i });
      }
    });
  }
  closeAllProducers() {
    return Promise.all(Array.from(a(this, Ki).entries()).map(([, e]) => e.close()));
  }
  createConsumer(e) {
    return this.createConsumers([e]);
  }
  createConsumers(e) {
    return u(this, null, function* () {
      a(this, On) || clearTimeout(a(this, On)), m(this, ir, a(this, ir).concat(e)), yield L(this, Tc, nh).call(this);
    });
  }
  closeConsumer(e) {
    return this.closeConsumers([e]);
  }
  closeConsumers(e) {
    return u(this, null, function* () {
      if (!a(this, ps))
        return;
      const r = e.map((n) => this.consumers.get(n)).filter((n) => n !== void 0);
      if (r.length === 0)
        return;
      const { failedConsumers: i } = yield a(this, ps).close(r);
      i != null && i.length && this.logger.warn("Failed to close some consumers", { consumerIds: i });
    });
  }
  closeAllConsumers() {
    return this.closeConsumers(Array.from(a(this, Wr).keys()));
  }
  switchConsumersToLayer(e, r) {
    return u(this, null, function* () {
      a(this, ps).switchConsumersToLayer(e, r);
    });
  }
}
Ki = new WeakMap(), Wr = new WeakMap(), Dn = new WeakMap(), yc = new WeakMap(), ps = new WeakMap(), pl = new WeakMap(), ir = new WeakMap(), On = new WeakMap(), Tc = new WeakSet(), nh = function() {
  return u(this, null, function* () {
    if (!this.recvTransport || this.recvTransport.closed)
      throw new Error("Recv transport is closed");
    const e = 500, r = a(this, ir).splice(0, a(this, ir).length);
    try {
      const i = new Set(Array.from(this.consumers.values()).map(({ producerId: d }) => d)), n = r.filter(({ producerId: d }) => !this.producers.get(d) && !i.has(d));
      if (n.length === 0)
        return;
      const { consumers: o, failedProducers: c } = yield this.recvTransport.consume(
        n,
        L(this, fl, lS).bind(this),
        a(this, ps).negotiate.bind(a(this, ps))
      );
      if (o.forEach(L(this, Sl, uS).bind(this)), c != null && c.length) {
        this.logger.error("Failed to create consumers for producers", { producers: c });
        const d = c.filter(({ errorCode: l, producerId: p }) => l === "not_found_track_error" ? (this.logger.error(`Track not found for producer: ${p}. This will not be retried.`), !1) : l === "backend_error" ? (this.logger.error("Unrecoverable error: backend error"), !1) : !0);
        m(this, ir, a(this, ir).concat(d)), m(this, On, setTimeout(
          L(this, Tc, nh).bind(this),
          e
        ));
      }
    } catch (i) {
      if (this.logger.error("failed to consume on transport", { error: i }), i.errorCode === "internal_error" && i.errorDescription === "Backend error" || i.errorCode === "invalid_session_description") {
        this.logger.error(
          "Irrecoverable error, closing current recvTransport to create a new one",
          {
            transport: this.recvTransport,
            error: { code: i.errorCode, message: i.errorDescription }
          }
        );
        try {
          this.stopTransports({ recv: !0 });
        } catch (n) {
        }
        yield this.setupTransports({ recv: !0 });
      }
    }
  });
}, gl = new WeakSet(), cS = function(e) {
  return a(this, yc).create(e);
}, ml = new WeakSet(), dS = function(e, r) {
  e.on("close", (i, n) => u(this, null, function* () {
    const { offer: o, reason: c } = i;
    if (this.logger.info("producer::closing", {
      debuggingHint: c,
      producer: B(D({}, e), { status: "closing" })
    }), c !== Ud) {
      const d = {
        producerId: e.id,
        description: {
          sdp: o.sdp,
          type: o.type,
          target: vr.PUBLISHER
        }
      };
      try {
        const l = yield this.socketHandler.closeProducer(d), p = {
          sdp: l == null ? void 0 : l.sdp,
          type: l == null ? void 0 : l.type
        };
        this.logger.info("producer::closed", { producer: B(D({}, e), { status: "closed" }) }), n({ answer: p });
      } catch (l) {
        this.logger.error("producer close error", l);
      }
    }
    this.producers.delete(e.id), r();
  })), e.on("trackended", () => {
    this.logger.info("producer::trackended", { producer: B(D({}, e), { status: "UNKNOWN" }) });
  }), a(this, Ki).set(e.id, e);
}, fl = new WeakSet(), lS = function(e) {
  return u(this, null, function* () {
    try {
      return yield this.recvTransport.canConsume(), yield a(this, ps).create(e);
    } catch (r) {
      throw this.logger.error("Error in consume request", { error: r }), r;
    }
  });
}, Sl = new WeakSet(), uS = function(e) {
  e.on("close", (r) => u(this, null, function* () {
    this.logger.debug("consumer closed", {
      consumer: {
        closureReason: r,
        id: e.id,
        kind: e.kind,
        appData: e.appData
      }
    }), a(this, Wr).delete(e.id), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, { id: e.id });
  })), a(this, Wr).set(e.id, e), this.producerIdToConsumerIdMap.set(e.producerId, e.id), this.context.getValue("peerSessionStore").emit(k.NEW_CONSUMER, {
    id: e.id,
    appData: e.appData,
    peerId: e.peerId
  });
};
var Ec, _c, Pc, Nn, Vn, Ln, Cc, Rc, xn, bt, gs, ms, zi, Yi, ar, wc, vl, hS, yl, pS, Tl, gS, El, mS;
const _l = class {
  constructor({
    initialEnergyThreshold: t = 0.015,
    zeroCrossingThreshold: e = 20,
    minVoiceDuration: r = 3,
    hangoverFrames: i = 5,
    noiseAdaptationRate: n = 0.95,
    voiceAdaptationRate: o = 0.99,
    minEnergyThreshold: c = 5e-3,
    maxEnergyThreshold: d = 0.2,
    energyRatioThreshold: l = 1.5,
    noiseHistorySize: p = 50
  } = {}) {
    /**
     * Update the energy threshold based on current noise conditions
     */
    g(this, vl);
    /**
     * Update the background noise estimate
     */
    g(this, yl);
    // Core VAD parameters
    g(this, Ec, void 0);
    g(this, _c, void 0);
    // in frames
    g(this, Pc, void 0);
    // Adaptive energy threshold parameters
    g(this, Nn, void 0);
    g(this, Vn, void 0);
    g(this, Ln, void 0);
    g(this, Cc, void 0);
    g(this, Rc, void 0);
    g(this, xn, void 0);
    // State variables
    g(this, bt, void 0);
    g(this, gs, void 0);
    g(this, ms, !1);
    g(this, zi, 0);
    g(this, Yi, 0);
    g(this, ar, []);
    g(this, wc, void 0);
    m(this, Nn, t), m(this, bt, t), m(this, Ec, e), m(this, _c, r), m(this, Pc, i), m(this, Vn, n), m(this, Ln, o), m(this, Cc, c), m(this, Rc, d), m(this, xn, l), m(this, wc, p), m(this, gs, t / 2);
  }
  get voiceDetected() {
    return a(this, ms);
  }
  /**
   * Process an audio chunk and determine if it contains voice activity
   * @param audioChunk - Float32Array containing audio samples in range [-1, 1]
   * @returns boolean indicating if voice activity is detected
   */
  processAudioChunk(t) {
    var o, c;
    const e = L(o = _l, Tl, gS).call(o, t), r = L(c = _l, El, mS).call(c, t);
    return L(this, vl, hS).call(this, e), e / a(this, gs) > a(this, xn) && e > a(this, bt) && r > a(this, Ec) ? (m(this, zi, a(this, zi) + 1), m(this, Yi, a(this, Pc)), a(this, zi) >= a(this, _c) && m(this, ms, !0)) : (m(this, zi, 0), a(this, Yi) > 0 ? m(this, Yi, a(this, Yi) - 1) : a(this, ms) && m(this, ms, !1), a(this, ms) || L(this, yl, pS).call(this, e)), { energy: e, isVoice: a(this, ms) };
  }
  /**
   * Reset the detector state
   */
  reset() {
    m(this, ms, !1), m(this, zi, 0), m(this, Yi, 0), m(this, bt, a(this, Nn)), m(this, gs, a(this, Nn) / 2), m(this, ar, []);
  }
  /**
   * Get current adaptive threshold values for debugging/visualization
   */
  getThresholdInfo() {
    return {
      currentEnergyThreshold: a(this, bt),
      backgroundNoiseEnergy: a(this, gs),
      energyRatioThreshold: a(this, xn)
    };
  }
};
let Po = _l;
Ec = new WeakMap(), _c = new WeakMap(), Pc = new WeakMap(), Nn = new WeakMap(), Vn = new WeakMap(), Ln = new WeakMap(), Cc = new WeakMap(), Rc = new WeakMap(), xn = new WeakMap(), bt = new WeakMap(), gs = new WeakMap(), ms = new WeakMap(), zi = new WeakMap(), Yi = new WeakMap(), ar = new WeakMap(), wc = new WeakMap(), vl = new WeakSet(), hS = function(t) {
  a(this, ms) ? m(this, bt, a(this, Ln) * a(this, bt) + (1 - a(this, Ln)) * t) : m(this, bt, a(this, Vn) * a(this, bt) + (1 - a(this, Vn)) * a(this, gs)), m(this, bt, Math.max(
    a(this, Cc),
    Math.min(a(this, Rc), a(this, bt))
  ));
}, yl = new WeakSet(), pS = function(t) {
  if (t < a(this, bt) * 1.2)
    if (a(this, ar).push(t), a(this, ar).length > a(this, wc) && a(this, ar).shift(), a(this, ar).length >= 10) {
      const e = [...a(this, ar)].sort((i, n) => i - n), r = Math.floor(e.length / 2);
      m(this, gs, e[r]);
    } else
      m(this, gs, 0.95 * a(this, gs) + 0.05 * t);
}, Tl = new WeakSet(), gS = function(t) {
  return Math.sqrt(
    t.map((e) => e * e).reduce((e, r) => e + r) / t.length
  );
}, El = new WeakSet(), mS = function(t) {
  let e = 0;
  for (let r = 1; r < t.length; r += 1)
    (t[r] >= 0 && t[r - 1] < 0 || t[r] < 0 && t[r - 1] >= 0) && (e += 1);
  return e;
}, g(Po, Tl), g(Po, El);
var bc;
class vg {
  constructor(t) {
    h(this, "RNAudioSampleHandler");
    g(this, bc, void 0);
    m(this, bc, t);
    const { RNAudioSampleHandlerImpl: e } = navigator;
    e == null || e.init().then((r) => {
      this.RNAudioSampleHandler = r;
    }).catch((r) => {
      this.logger.error("ReactNativeAudioSampler: Failed to initialize audio sampler", r);
    });
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, bc).getValue("logger");
  }
  get samples() {
    var e;
    const t = new Float32Array(1024);
    return (e = this.RNAudioSampleHandler) == null || e.getFloatTimeDomainData(t), t;
  }
  stop() {
    var t;
    (t = this.RNAudioSampleHandler) == null || t.destructor();
  }
}
bc = new WeakMap();
var kc;
class yg {
  constructor(t) {
    h(this, "audioContext");
    h(this, "analyser");
    g(this, kc, void 0);
    m(this, kc, t), this.audioContext = new AudioContext(), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2048;
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, kc).getValue("logger");
  }
  get samples() {
    if (this.audioContext.state === "suspended")
      try {
        this.audioContext.resume();
      } catch (e) {
        this.logger.error("AudioContextSampler: Failed to resume audio context", e);
      }
    const t = new Float32Array(this.analyser.frequencyBinCount);
    return this.analyser.getFloatTimeDomainData(t), t;
  }
  set audioTrack(t) {
    const e = new MediaStream();
    e.addTrack(t), this.audioContext.createMediaStreamSource(e).connect(this.analyser);
  }
}
kc = new WeakMap();
class hD {
  static setInterval(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setInterval(t, e, ...r) : global.setInterval(t, e, ...r);
  }
  static clearInterval(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearInterval(t) : global.clearInterval(t);
  }
  static setTimeout(t, e = 0, ...r) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.setTimeout(t, e, ...r) : global.setTimeout(t, e, ...r);
  }
  static clearTimeout(t) {
    return navigator && navigator.RNBackgroundTimerImpl ? navigator.RNBackgroundTimerImpl.clearTimeout(t) : global.clearTimeout(t);
  }
}
const pD = 60, gD = 400;
var nr, or, fs, Ic, Qi, Un, cr, Jr, $n, dr, lr, Vs, Pl, fS, Ac, oh, Cl, SS, Rl, vS;
const No = class {
  constructor(t, e) {
    g(this, Pl);
    g(this, Cl);
    g(this, nr, void 0);
    g(this, or, void 0);
    g(this, fs, void 0);
    g(this, Ic, void 0);
    g(this, Qi, void 0);
    g(this, Un, void 0);
    g(this, cr, void 0);
    g(this, Jr, void 0);
    g(this, $n, void 0);
    g(this, dr, void 0);
    g(this, lr, void 0);
    g(this, Vs, void 0);
    this.reportRequest = e, m(this, dr, t), m(this, Un, new Po());
    const { isReactNative: r } = navigator;
    m(this, lr, r ? new vg(a(this, dr)) : new yg(a(this, dr))), m(this, Vs, r ? hD : ud);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, dr).getValue("logger");
  }
  set producerId(t) {
    m(this, fs, t);
  }
  set audioTrack(t) {
    m(this, Ic, t), a(this, lr) instanceof yg && (a(this, lr).audioTrack = t);
  }
  start() {
    this.logger.debug(`AudioActivityReporter: Starting audio activity reporter: ${a(this, fs)}`), a(this, nr) && a(this, Vs).clearInterval(a(this, nr)), m(this, nr, a(this, Vs).setInterval(() => u(this, null, function* () {
      var i;
      if (!a(this, Ic) || !a(this, fs))
        return;
      const { energy: t } = L(this, Pl, fS).call(this), e = L(i = No, Ac, oh).call(i, t);
      let r = 0.9;
      a(this, $n) !== e && a(this, $n) ? r = 0.9 : e ? r = 0.3 : r = 0.5, m(this, Qi, (a(this, Qi) || 0) * (1 - r) + t * r);
    }), pD)), a(this, or) && a(this, Vs).clearInterval(a(this, or)), m(this, or, a(this, Vs).setInterval(
      L(this, Cl, SS).bind(this),
      gD
    ));
  }
  stop() {
    try {
      this.logger.debug(`AudioActivityReporter: Stopping audio activity reporter: ${a(this, fs)}`), a(this, nr) && (a(this, Vs).clearInterval(a(this, nr)), m(this, nr, void 0)), a(this, or) && (a(this, Vs).clearInterval(a(this, or)), m(this, or, void 0));
    } catch (t) {
    }
    a(this, Un).reset(), a(this, lr) instanceof vg && a(this, lr).stop();
  }
};
let Co = No;
nr = new WeakMap(), or = new WeakMap(), fs = new WeakMap(), Ic = new WeakMap(), Qi = new WeakMap(), Un = new WeakMap(), cr = new WeakMap(), Jr = new WeakMap(), $n = new WeakMap(), dr = new WeakMap(), lr = new WeakMap(), Vs = new WeakMap(), Pl = new WeakSet(), fS = function() {
  var o;
  const { samples: t } = a(this, lr), { energy: e, isVoice: r } = a(this, Un).processAudioChunk(t), i = L(o = No, Rl, vS).call(o, e);
  return a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(
    `AudioActivityReporter: producer: ${a(this, fs)}, energy: ${a(this, Qi)},
				slogScale: ${i}, isVoice: ${r}, minEnergy: ${a(this, cr)},
				maxEnergy: ${a(this, Jr)}`
  ), i === -1 / 0 || e < 1e-6 ? { energy: 0, isVoice: !1 } : ((!a(this, cr) || i < a(this, cr)) && m(this, cr, i), (!a(this, Jr) || i > a(this, Jr)) && m(this, Jr, i), { energy: (i - a(this, cr)) / (a(this, Jr) - a(this, cr)) * 10 || 0, isVoice: r });
}, Ac = new WeakSet(), oh = function(t) {
  return t < 5;
}, Cl = new WeakSet(), SS = function(t = a(this, Qi)) {
  var r;
  if (!a(this, fs) || !t) {
    a(this, dr).getValue("flagsmith").hasFeature(X.ENABLE_AUDIO_ACTIVITY_DEBUG_LOGS) && this.logger.debug(`AudioActivityReporter: No producerId or energy to report: ${a(this, fs)}`);
    return;
  }
  const e = {
    producerId: a(this, fs),
    energy: Math.round(t),
    silent: L(r = No, Ac, oh).call(r, t)
  };
  m(this, $n, e.silent), this.reportRequest(e);
}, Rl = new WeakSet(), vS = function(t) {
  const e = Math.log10(t);
  return Math.round(e);
}, g(Co, Ac), g(Co, Rl);
const mD = (s = !1) => {
  if ("MediaStreamTrackGenerator" in window && "AudioData" in window)
    try {
      const e = new window.MediaStreamTrackGenerator({ kind: "audio" }), r = e.writable.getWriter(), i = 48e3, n = 128, o = 1;
      let c = 0, d = null;
      const l = () => u(void 0, null, function* () {
        try {
          const S = new Float32Array(n * o), T = new window.AudioData({
            format: "f32",
            sampleRate: i,
            numberOfFrames: n,
            numberOfChannels: o,
            timestamp: c,
            data: S
          });
          c += n / i * 1e6, yield r.ready, yield r.write(T);
        } catch (S) {
          d && clearInterval(d), r.releaseLock(), e.writable.abort();
        }
      });
      d = window.setInterval(l, 100);
      const f = new MediaStream([e]).getAudioTracks()[0];
      return f.addEventListener("ended", () => {
        d && clearInterval(d), r.releaseLock(), e.writable.abort();
      }), Object.assign(f, { fakeTracks: "fakeTracks:fakeAudioTrack" }), f.enabled = s, f;
    } catch (e) {
    }
  const t = window.AudioContext || window.webkitAudioContext;
  if (t)
    try {
      const e = new t();
      if (!e || e.state !== "running" || !e.destination)
        return;
      const r = e.createOscillator();
      r.frequency.value = 0, r.type = "sine";
      const i = e.createGain();
      i.gain.value = 0, r.connect(i);
      const n = e.createMediaStreamDestination();
      i.connect(n), r.start();
      const o = n.stream.getAudioTracks()[0];
      return o ? (Object.assign(o, { fakeTracks: "fakeTracks:fakeAudioTrack" }), o.enabled = s, o) : void 0;
    } catch (e) {
      return;
    }
}, fD = (s = !1) => {
  var n, o;
  const t = new MediaStream().getVideoTracks()[0], e = document.createElement("canvas");
  e.height = (n = t == null ? void 0 : t.getSettings().height) != null ? n : 720, e.width = (o = t == null ? void 0 : t.getSettings().width) != null ? o : 1280;
  const r = e.getContext("2d");
  r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height), setInterval(() => {
    r.fillStyle = "black", r.fillRect(0, 0, e.width, e.height);
  }, 1e3);
  const i = e.captureStream().getVideoTracks()[0];
  return Object.assign(i, { fakeTracks: "fakeTracks:fakeVideoTrack" }), i.enabled = s, i;
};
var SD = Object.defineProperty, vD = Object.getOwnPropertyDescriptor, le = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? vD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && SD(t, e, i), i;
};
const Nt = ["video/VP9", "video/VP8"];
var Mc, Dc, dt, G, Fn, Ls, yt, Xi, Zi, ea, Oc, ss, ur, Nc, ta, sa, Tt, kt, Kr, ka, wl, TS, bl, ES, kl, _S, Vc, ch, Il, Tu, PS, Al, CS, Ml, RS, Dl, wS, tt, gt, ra, Ro, Ol, bS, Nl, kS, Vl, IS;
const yS = (Tu = class {
  constructor(s, t, e) {
    g(this, Kr);
    /**
     * Wait for the transports to be established and notify join room completion
     */
    g(this, wl);
    g(this, bl);
    /**
     * Reports room joined analytics to call stats
    	 * @param roomUuid - The UUID of the room
     */
    g(this, kl);
    /**
     * Initializes the connection to the SFU by establishing
     * a socket connection and setting up transports.
     */
    g(this, Vc);
    g(this, Al);
    g(this, Ml);
    g(this, Dl);
    g(this, tt);
    g(this, ra);
    g(this, Ol);
    g(this, Nl);
    g(this, Vl);
    h(this, "context");
    h(this, "authToken");
    h(this, "e2ee");
    g(this, Mc, void 0);
    g(this, Dc, void 0);
    g(this, dt, void 0);
    g(this, G, void 0);
    g(this, Fn, void 0);
    g(this, Ls, void 0);
    g(this, yt, void 0);
    g(this, Xi, void 0);
    g(this, Zi, void 0);
    g(this, ea, void 0);
    g(this, Oc, void 0);
    g(this, ss, null);
    g(this, ur, void 0);
    g(this, Nc, void 0);
    // NOTE(roerohan): If a peer ID is present in a set corresponding
    // to a video codec, it implies that the video codec is the best
    // codec that the peer can send
    g(this, ta, void 0);
    g(this, sa, void 0);
    g(this, Tt, void 0);
    g(this, kt, void 0);
    var i, n;
    this.context = s;
    const {
      socket: r
    } = e;
    this.mediaJoined = !1, m(this, ta, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, sa, /* @__PURE__ */ new Map([
      ["video/VP9", /* @__PURE__ */ new Set()],
      ["video/VP8", /* @__PURE__ */ new Set()]
    ])), m(this, Ls, t), m(this, dt, r), m(this, Xi, !1), m(this, G, new uD(s, r, t)), m(this, yt, a(this, G).events), m(this, ur, /* @__PURE__ */ new Set()), m(this, Tt, /* @__PURE__ */ new Map()), m(this, Zi, !1), m(this, ea, new Zu(s.getValue("logger"))), t === we.CF && m(this, kt, new Co(
      this.context,
      a(this, G).socketHandler.audioActivity.bind(a(this, G).socketHandler)
    )), this.e2ee = (n = (i = s.getValue("modules").e2ee) == null ? void 0 : i.enabled) != null ? n : !1, this.handleSocketEvents(), this.handleCallstatsEvents(), m(this, Oc, Ih(
      () => u(this, null, function* () {
        if (!a(this, Kr, ka).mediaJoinAttempted)
          return;
        const { roomJoined: o } = yield this.joinRoom(
          a(this, Dc),
          a(this, Mc),
          !0,
          !0
        );
        o && (this.context.getValue("peerSessionStore").emit(k.RESET_PRODUCER_STATE), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_RECONNECTED));
      }),
      5e3,
      { leading: !0, maxWait: 1e3 }
    ));
  }
  get peerId() {
    return this.context.getValue("peerId");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return this.context.getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return this.context.getValue("logger");
  }
  get mediaJoined() {
    return a(this, Kr, ka).mediaJoined;
  }
  set mediaJoined(s) {
    a(this, Kr, ka).mediaJoined = s;
  }
  reset() {
    a(this, G).closeAllProducers(), a(this, G).closeAllConsumers(), a(this, Tt).clear(), a(this, ur).clear(), m(this, ss, null), a(this, ea).stop(), a(this, G).stopAllTransports(), a(this, G).reset(), m(this, ea, new Zu());
  }
  joinRoom(n, o) {
    return u(this, arguments, function* (s, t, e = !1, r = !1, i = {}) {
      a(this, Kr, ka).mediaJoinAttempted = !0, m(this, Xi, !0), e && this.reset();
      try {
        return yield a(this, ea).push(
          () => L(this, wl, TS).call(this, s, t, r, i),
          "joinRoom"
        );
      } catch (c) {
        return this.logger.error("Error in room joining process", { error: c }), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_FAILED), { roomJoined: !1 };
      }
    });
  }
  /**
   * Initialize connection to the SFU.
   * This can be used to start establishing a connection
   * before the full join process.
   */
  initializeConnection(i, n) {
    return u(this, arguments, function* (s, t, e = !1, r = {}) {
      return a(this, ss) ? a(this, ss) : (m(this, ss, (() => u(this, null, function* () {
        try {
          yield L(this, Vc, ch).call(this, s, t, e, r);
        } catch (o) {
          throw m(this, ss, null), o;
        }
      }))()), a(this, ss));
    });
  }
  getConsumers() {
    return a(this, G).consumers;
  }
  leaveRoom() {
    return u(this, null, function* () {
      a(this, G).stopAllTransports(), m(this, Zi, !1), a(this, Kr, ka).mediaJoinAttempted = !1;
      const s = {
        closeRoom: !1
      };
      a(this, dt).sendMessagePromise(
        a(this, yt).leaveRoom,
        vR.toBinary(s)
      ).then((e) => {
        var r;
        (r = nw.fromBinary(e.payload)) != null && r.closed && this.logger.warn("Weird state on peer closed and should not happen");
      }).catch((e) => {
        this.logger.error("error on sending leave room request", { error: e });
      }), this.context.getValue("callstats").callEnded(), this.context.getValue("telemetry").destruct();
    });
  }
  activatePeers(s) {
    return u(this, null, function* () {
      return this.createConsumers(s);
    });
  }
  createConsumers(s) {
    return u(this, null, function* () {
      return s.length === 0 ? Promise.resolve() : a(this, G).createConsumers(s);
    });
  }
  closeConsumers(s) {
    return u(this, null, function* () {
      if (!s.length)
        return;
      const t = s.reduce((e, r) => {
        const i = a(this, G).producerIdToConsumerIdMap.get(
          r.producerId
        );
        return i ? (e.push(i), e) : (this.logger.warn(
          `consumer not found in close consumers: ${r.producerId}`
        ), e);
      }, []);
      yield a(this, G).closeConsumers(t);
    });
  }
  _shareWebcam(s, t) {
    return u(this, null, function* () {
      const e = t === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, r = L(this, tt, gt).call(this, e);
      if (r) {
        const p = yield r;
        if (a(this, G).producers.has(p)) {
          const f = a(this, G).producers.get(p);
          if (!f.closed)
            return yield f.replaceTrack({ track: s }), yield this.resumeWebcam(e), s;
          yield this.disableWebcam(t);
        }
        return this._shareWebcam(s, t);
      }
      const i = [t].concat(Nt.filter((p) => p !== t)), n = L(this, Vl, IS).call(this, s, i), o = Gn(this.context, "disableSimulcast"), c = a(this, Ls) === we.CF ? X.ENABLE_CF_SIMULCAST : X.ENABLE_HIVE_SIMULCAST;
      !o && this.context.getValue("flagsmith").hasFeature(c) ? (this.logger.info(`Simulcast enabled for SFU: ${a(this, Ls)}`), n.encodings = r0(this.context, s)) : this.logger.info(`Simulcast disabled for webcam producer, SFU: ${a(this, Ls)}`), this.context.getValue("flagsmith").hasFeature(X.TRACK_HINT) && (n.track.contentHint = this.context.getValue("flagsmith").getValue(
        X.TRACK_HINT
      ));
      const d = () => {
        this.logger.info("Disabling video due to the producer closure"), a(this, Tt).delete(e);
      }, l = a(this, G).createProducer(
        n,
        d
      );
      return L(this, ra, Ro).call(this, e, l.then((p) => p.id)), l.then((p) => p.track);
    });
  }
  shareWebcam(s) {
    return u(this, null, function* () {
      var r;
      if (s === void 0)
        return null;
      const t = (r = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : r.toString();
      if (t)
        return this.logger.debug(`Calling _shareWebcam with forced video codec: ${t}`), this._shareWebcam(s, t);
      const e = Nt.filter((i) => {
        var n, o;
        return (
          // NOTE(roerohan): If the codec is supported
          ((o = (n = a(this, Fn).sender) == null ? void 0 : n.video) == null ? void 0 : o.codecs.findIndex(
            (c) => c.mimeType === i
          )) >= 0 && a(this, sa).get(i).size > 0
        );
      });
      return e.length === 0 && e.push(Nt[0]), yield Promise.all(e.map((i) => (this.logger.debug(`Calling _shareWebcam with video codec: ${i}`), this._shareWebcam(s, i)))), s;
    });
  }
  shareScreen(s) {
    return u(this, null, function* () {
      const { video: t, audio: e } = s;
      if (t === void 0)
        return;
      const r = {
        track: t,
        codecOptions: [
          {
            name: "VP8"
          }
        ],
        appData: {
          screenShare: !0,
          e2ee: this.e2ee,
          supportsRemoteControl: Te.isElectron()
        },
        stopTracks: !1
      }, i = () => {
        this.logger.info("Disabling screenShare due to the producer closure"), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
      }, n = a(this, G).createProducer(
        r,
        i
      );
      L(this, ra, Ro).call(this, pe.SCREENSHARE_VIDEO, n.then((c) => c.id));
      let o;
      if (e) {
        const c = {
          track: e,
          codecOptions: [{ name: "opus" }],
          appData: {
            screenShare: !0,
            e2ee: this.e2ee,
            supportsRemoteControl: Te.isElectron()
          },
          stopTracks: !1,
          zeroRtpOnPause: a(this, Ls) !== we.CF
        }, d = () => {
        };
        o = a(this, G).createProducer(
          c,
          d
        ), L(this, ra, Ro).call(this, pe.SCREENSHARE_AUDIO, o.then((l) => l.id));
      }
      yield Promise.all([n, o || Promise.resolve()]), this.context.getValue("callstats").screenShareStart();
    });
  }
  shareMic(s) {
    return u(this, null, function* () {
      try {
        if (s === void 0)
          throw new At("track undefined");
        const t = L(this, tt, gt).call(this, pe.MIC);
        if (t) {
          const n = yield t;
          if (a(this, G).producers.has(n)) {
            const o = a(this, G).producers.get(n);
            if (!o.closed) {
              yield o.replaceTrack({ track: s }), yield this.resumeMic(), a(this, kt) && (a(this, kt).audioTrack = s, a(this, kt).producerId = n, a(this, kt).start());
              return;
            }
            yield a(this, G).closeProducer(n, { stopTrack: !1 });
          }
          yield this.shareMic(s);
          return;
        }
        const e = L(this, Nl, kS).call(this, s), r = () => {
          a(this, Tt).delete(pe.MIC);
        }, i = a(this, G).createProducer(
          e,
          r
        );
        L(this, ra, Ro).call(this, pe.MIC, i.then((n) => n.id)), yield i.then((n) => {
          a(this, kt) && (a(this, kt).audioTrack = n.track, a(this, kt).producerId = n.id, a(this, kt).start());
        });
      } catch (t) {
        throw new R(t);
      }
    });
  }
  pauseMic() {
    return u(this, null, function* () {
      var r;
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("pauseMic::could_not_find_mic_producer");
        return;
      }
      if (t.paused) {
        this.logger.info("pauseMic::mic_producer_already_paused");
        return;
      }
      t.pause(), (r = a(this, kt)) == null || r.stop();
      const e = {
        producerId: t.id,
        pause: !0
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  pauseWebcam() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.WEBCAM), t = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP), e = a(this, G).producers.get(s), r = a(this, G).producers.get(t);
      if (!e && !r) {
        this.logger.error("pauseWebcam::could_not_find_webcam_producer");
        return;
      }
      const i = (n) => {
        const o = {
          producerId: n.id,
          pause: !0
        };
        a(this, dt).sendMessage(
          a(this, yt).toggleProducer,
          id.toBinary(o)
        );
      };
      e && (e.pause(), i(e)), r && (r.pause(), i(r));
    });
  }
  resumeMic() {
    return u(this, null, function* () {
      const s = yield L(this, tt, gt).call(this, pe.MIC), t = a(this, G).producers.get(s);
      if (!t) {
        this.logger.error("resumeMic::could_not_find_mic_producer");
        return;
      }
      if (!t.pause) {
        this.logger.info("resumeMic::mic_producer_already_resumed");
        return;
      }
      t.resume(), t.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, t);
      const e = {
        producerId: t.id,
        pause: !1
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(e)
      );
    });
  }
  resumeWebcam() {
    return u(this, arguments, function* (s = pe.WEBCAM) {
      const t = yield L(this, tt, gt).call(this, s), e = a(this, G).producers.get(t);
      if (!e) {
        this.logger.error("resumeWebcam::could_not_find_webcam_producer");
        return;
      }
      if (!e.paused) {
        this.logger.info("resumeWebcam::webcam_producer_already_resumed");
        return;
      }
      e.resume(), e.appData.e2ee && this.context.getValue("peerSessionStore").emit(k.E2EE_ACTIVE_PRODUCER, e);
      const r = {
        producerId: e.id,
        pause: !1
      };
      a(this, dt).sendMessage(
        a(this, yt).toggleProducer,
        id.toBinary(r)
      );
    });
  }
  disableWebcam(s) {
    return u(this, null, function* () {
      const t = s === "video/VP9" ? pe.WEBCAM : pe.WEBCAM_BACKUP, e = yield L(this, tt, gt).call(this, t);
      L(this, Ol, bS).call(this, t), e && (yield a(this, G).closeProducer(e));
    });
  }
  disableMic() {
    return u(this, null, function* () {
      var t;
      const s = yield L(this, tt, gt).call(this, pe.MIC);
      s && (yield a(this, G).closeProducer(s)), (t = a(this, kt)) == null || t.stop(), a(this, Tt).delete(pe.MIC);
    });
  }
  disableScreenShare() {
    return u(this, null, function* () {
      this.logger.info("screen_sharing_stopped"), this.context.getValue("callstats").screenShareStop();
      const s = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO), t = yield L(this, tt, gt).call(this, pe.SCREENSHARE_AUDIO);
      s && (yield a(this, G).closeProducer(s)), t && (yield a(this, G).closeProducer(t)), a(this, ur).clear(), a(this, Tt).delete(pe.SCREENSHARE_VIDEO), a(this, Tt).delete(pe.SCREENSHARE_AUDIO);
    });
  }
  muteSelf() {
    return u(this, null, function* () {
      this.pauseMic();
    });
  }
  /* eslint-disable-next-line class-methods-use-this */
  unmuteSelf() {
    return u(this, null, function* () {
    });
  }
  resetVideoProducers(s, t) {
    return u(this, null, function* () {
      if (s) {
        const e = yield L(this, tt, gt).call(this, pe.WEBCAM), r = yield L(this, tt, gt).call(this, pe.WEBCAM_BACKUP);
        yield a(this, G).closeProducer(e, { stopTrack: !1 }), yield a(this, G).closeProducer(r, { stopTrack: !1 }), this.shareWebcam(s);
      }
      if (t) {
        const e = yield L(this, tt, gt).call(this, pe.SCREENSHARE_VIDEO);
        yield a(this, G).closeProducer(
          e,
          { stopTrack: !1 }
        ), this.shareScreen({ video: t });
      }
    });
  }
  changeDisplayName(s, t) {
    return u(this, null, function* () {
      const e = {
        displayName: s,
        participantId: t != null ? t : this.peerId
      };
      if (!(yield a(this, G).socketHandler.changeDisplayName(e)))
        throw new Error("failed to change display name!");
    });
  }
  kick(s) {
    const t = {
      peerIds: [s]
    };
    a(this, G).socketHandler.kickPeer(t);
  }
  kickAll() {
    a(this, G).socketHandler.kickAll();
  }
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
  muteAll(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("audio")))
        throw new Error("failed to mute all participant");
    });
  }
  muteAllVideo() {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForAll("video")))
        throw new Error("failed to mute all video participant");
    });
  }
  disableAudio(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "audio"
      )))
        throw new Error("failed to mute given participant");
    });
  }
  disableVideo(s) {
    return u(this, null, function* () {
      if (!(yield a(this, G).socketHandler.hostControlForPeer(
        s,
        "video"
      )))
        throw new Error("failed to mute video of given participant");
    });
  }
  pinPeer(s) {
    return u(this, null, function* () {
      const t = {
        participantId: s != null ? s : ""
      };
      try {
        yield a(this, dt).sendMessagePromise(
          a(this, yt).globalPinPeer,
          DR.toBinary(t)
        );
      } catch (e) {
        this.logger.error("Error in pinning peer:", { error: e });
      }
    });
  }
  validateScreenShare(s) {
    return this.peerId === s.peerId && a(this, G).producers.get(s.producerId) && a(this, ur).add(s.consumerPeerId), a(this, ur).size;
  }
  switchConsumersToLayer(s, t) {
    return u(this, null, function* () {
      const e = s.map((r) => this.getConsumers().get(r));
      a(this, G).switchConsumersToLayer(e, t);
    });
  }
  handleSocketEvents() {
    return u(this, null, function* () {
      a(this, dt).on(
        a(this, yt).peerProducerCreateBroadcast,
        ({ payload: s }) => {
          var t, e;
          if (this.mediaJoined)
            try {
              const { participantId: r, producerState: i } = Lw.fromBinary(s);
              if (r === this.peerId)
                return;
              if (i != null && i.mimeType || (i.mimeType = i.kind === xs.AUDIO ? "audio/opus" : "video/VP8"), i.kind === xs.VIDEO && !i.screenShare && // Can receive vp9
              ((e = (t = a(this, Fn).receiver) == null ? void 0 : t.video) == null ? void 0 : e.codecs.findIndex(
                (n) => n.mimeType === Nt[0]
              )) >= 0 && a(this, ta).get(Nt[0]).has(r) && i.mimeType !== Nt[0]) {
                this.logger.warn(`Ignoring producer: ${i.producerId}`);
                return;
              }
              this.logger.info(
                `producer created broadcast: ${r}, producer state: ${i}`
              ), this.context.getValue("peerSessionStore").emit(k.NEW_PRODUCER, {
                peerId: r,
                producer: B(D({}, i), {
                  kind: i.kind === xs.AUDIO ? "audio" : "video",
                  producingPeerId: r
                })
              });
            } catch (r) {
              this.logger.error("error in peer-producer-create-broadcast", {
                error: r
              });
            }
        }
      ), a(this, dt).on(
        a(this, yt).peerProducerToggleBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                initiatorParticipantId: e,
                producerState: { kind: r, pause: i, producerId: n }
              } = Wp.fromBinary(s), o = r === xs.AUDIO ? "audio" : "video";
              if (this.logger.info(
                `producer toggle broadcast: ${t}, producerId: ${n}, kind:${o}, paused:${i} payload: ${JSON.stringify(Wp.fromBinary(s))}`
              ), t === this.peerId && e !== this.peerId && i && this.context.getValue("peerSessionStore").emit(
                o === "audio" ? k.MUTE_SELF : k.MUTE_SELF_VIDEO
              ), t === this.peerId)
                return;
              this.context.getValue("peerSessionStore").emit(k.PRODUCER_TOGGLE, {
                peerId: t,
                producerId: n,
                paused: i,
                kind: o
              }), Array.from(
                this.getConsumers().values()
              ).filter((d) => d.producerId === n).forEach((d) => {
                d.paused !== i && (this.logger.debug(
                  `consumer state mismatched for ${d.id}. updating consumer pause state ${d.paused} to ${i}`
                ), i ? (d.pause(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_PAUSED, {
                  id: d.id
                })) : (d.resume(), this.context.getValue("peerSessionStore").emit(k.CONSUMER_RESUMED, {
                  id: d.id
                })));
              });
            } catch (t) {
              this.logger.error("error in producer toggle broadcast handler", {
                error: t
              });
            }
        }
      ), a(this, dt).on(a(this, yt).peerLeaveBroadcast, ({ payload: s }) => {
        if (this.mediaJoined)
          try {
            const { participantId: t } = Ou.fromBinary(s);
            if (t === this.peerId)
              return;
            this.logger.info(`peer left broadcast:${t}`), a(this, ur).delete(t), a(this, G).consumers.forEach(
              (e) => {
                e.peerId === t && e.close();
              }
            ), this.context.getValue("peerSessionStore").emit(k.PEER_CLOSED, { id: t });
          } catch (t) {
            this.logger.error("error in peer left broadcast", { error: t });
          }
      }), a(this, dt).on(
        a(this, yt).peerProducerCloseBroadcast,
        ({ payload: s }) => {
          if (this.mediaJoined)
            try {
              const {
                participantId: t,
                producerState: { producerId: e }
              } = $w.fromBinary(s);
              if (t === this.peerId)
                return;
              this.logger.info(`producer closed broadcast:${t}`), this.context.getValue("peerSessionStore").emit(k.PRODUCER_CLOSED, {
                peerId: t,
                producerId: e
              });
              const r = a(this, G).producerIdToConsumerIdMap.get(e);
              if (!r) {
                this.logger.warn(`no consumer found for producer:${e}`);
                return;
              }
              this.logger.info(
                `closing consumer ${r}, producer id: ${e}`
              ), a(this, G).closeConsumer(r).then(() => {
                this.logger.info(`closed consumer: ${r}`), a(this, G).producerIdToConsumerIdMap.delete(e), this.context.getValue("peerSessionStore").emit(k.CONSUMER_CLOSED, {
                  id: r
                });
              }).catch((i) => {
                this.logger.error("error closing consumer", { error: i });
              });
            } catch (t) {
              this.logger.error("error on producer close broadcast", { error: t });
            }
        }
      ), a(this, dt).on(
        a(this, yt).mediaRoomTerminationBroadcastResponse,
        () => {
          !this.mediaJoined && !a(this, Xi) && !a(this, Zi) || (this.logger.warn(
            "media hub termination broadcast received, rejoining room"
          ), this.context.getValue("peerSessionStore").emit(k.ROOM_NODE_DISCONNECTED), a(this, Oc).call(this));
        }
      );
    });
  }
  handleCallstatsEvents() {
    this.context.getValue("callstats").onConsumerScore((s) => {
      s.forEach((t, e) => {
        const r = a(this, G).consumers.get(e);
        r && this.context.getValue("peerSessionStore").emit(k.CONSUMER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          peerId: r.peerId,
          score: t.score,
          scoreStats: t
        });
      });
    }), this.context.getValue("callstats").onProducerScore((s) => {
      s.forEach((t, e) => {
        const r = Array.from(a(this, G).producers.values()).find(
          (i) => i.id === e
        );
        r && this.context.getValue("peerSessionStore").emit(k.PRODUCER_SCORE_UPDATE, {
          id: e,
          kind: r.kind,
          appData: r.appData,
          score: t.score,
          scoreStats: t
        });
      });
    });
  }
  handlePeerCapabilities(s, t) {
    var e, r, i, n;
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (
        // if the codec is present in the peer capabilities
        ((r = (e = t == null ? void 0 : t.receiver) == null ? void 0 : e.video) == null ? void 0 : r.codecs.findIndex(
          (d) => d.mimeType === c
        )) >= 0 || o === Nt.length - 1
      ) {
        a(this, sa).get(c).add(s);
        break;
      }
    }
    for (let o = 0; o <= Nt.length; o += 1) {
      const c = Nt[o];
      if (
        // if the codec is present in the peer capabilities
        ((n = (i = t == null ? void 0 : t.sender) == null ? void 0 : i.video) == null ? void 0 : n.codecs.findIndex(
          (d) => d.mimeType === c
        )) >= 0 || o === Nt.length - 1
      ) {
        a(this, ta).get(c).add(s);
        break;
      }
    }
  }
  handlePeerLeaving(s) {
    this.context.getValue("flagsmith").hasFeature(X.FORCE_VIDEO_CODEC) || (a(this, ta).forEach((t) => t.delete(s)), a(this, sa).forEach((t, e) => {
      t.delete(s), !(t.size !== 0 || e === Nt[0]) && this.disableWebcam(e);
    }));
  }
}, Mc = new WeakMap(), Dc = new WeakMap(), dt = new WeakMap(), G = new WeakMap(), Fn = new WeakMap(), Ls = new WeakMap(), yt = new WeakMap(), Xi = new WeakMap(), Zi = new WeakMap(), ea = new WeakMap(), Oc = new WeakMap(), ss = new WeakMap(), ur = new WeakMap(), Nc = new WeakMap(), ta = new WeakMap(), sa = new WeakMap(), Tt = new WeakMap(), kt = new WeakMap(), Kr = new WeakSet(), ka = function() {
  return this.context.getValue("connectionHandler");
}, wl = new WeakSet(), TS = function(s, t, e, r) {
  return u(this, null, function* () {
    m(this, Dc, s);
    try {
      return a(this, ss) ? yield a(this, ss) : yield L(this, Vc, ch).call(this, s, t, e, r), L(this, kl, _S).call(this, t), { roomJoined: yield L(this, bl, ES).call(this) };
    } catch (i) {
      return this.logger.error("Failed to complete room join", { error: i }), { roomJoined: !1 };
    } finally {
      m(this, ss, null);
    }
  });
}, bl = new WeakSet(), ES = function() {
  return u(this, null, function* () {
    try {
      this.mediaJoined = !0;
      const { roomState: s } = yield a(this, G).socketHandler.notifySelfJoinComplete();
      return m(this, Mc, s.roomUuid), m(this, Zi, !0), m(this, Xi, !1), !0;
    } catch (s) {
      return this.logger.error("Error completing room join", { error: s }), this.mediaJoined = !1, !1;
    }
  });
}, kl = new WeakSet(), _S = function(s) {
  navigator.product !== "ReactNative" && setTimeout(() => {
    try {
      const e = {
        userId: this.context.getValue("userId"),
        peerId: this.peerId,
        roomUUID: s,
        roomViewType: "groupCall",
        deviceInfo: B(D({}, Te.getDeviceInfo()), {
          userAgent: navigator.userAgent,
          memory: navigator.deviceMemory,
          cpus: navigator.hardwareConcurrency
        }),
        sdkName: this.context.getValue("sdkName"),
        sdkVersion: this.context.getValue("sdkVersion"),
        metaData: {},
        permissions: {}
      };
      this.context.getValue("callstats").roomJoined(e);
    } catch (t) {
      this.logger.error("Error reporting room joined analytics", { error: t });
    }
  }, 0);
}, Vc = new WeakSet(), ch = function(s, t, e, r) {
  return u(this, null, function* () {
    var i, n;
    try {
      (n = a(this, Nc)) != null || m(this, Nc, L(i = yS, Il, PS).call(i));
      const o = L(this, Al, CS).call(this);
      yield L(this, Ml, RS).call(this, s, t, e, o), yield a(this, G).setupTransports({ send: !0, recv: !0 }), yield L(this, Dl, wS).call(this, r);
    } catch (o) {
      throw this.logger.error("Failed to initialize connection", { error: o }), o;
    }
  });
}, Il = new WeakSet(), PS = function() {
  const { ipInfo: s } = lt();
  if (!(s != null && s.loc))
    return;
  const [t, e] = s.loc.split(",").map(parseFloat);
  return { latitude: t, longitude: e };
}, Al = new WeakSet(), CS = function() {
  var e;
  const s = (e = this.context.getValue("flagsmith").getValue(X.FORCE_VIDEO_CODEC)) == null ? void 0 : e.toString(), t = Z0(s);
  return m(this, Fn, t), t;
}, Ml = new WeakSet(), RS = function(s, t, e, r) {
  return u(this, null, function* () {
    yield Yf(
      (i, n) => u(this, null, function* () {
        if (!a(this, dt).isConnected) {
          n(new Error("Socket is not connected"));
          return;
        }
        i > 0 && this.logger.warn("Retry: send joinRoom message", {
          debuggingHint: `Retry attempt ${i}`
        });
        try {
          yield a(this, G).socketHandler.joinRoom(
            t,
            s,
            r,
            e,
            a(this, Nc)
          );
        } catch (o) {
          throw this.logger.error("Failed to send joinRoom message after retries", { error: o }), o;
        }
      }),
      {
        delayTime: 1e3,
        strategy: "exponential",
        maxRetryCount: this.context.getValue("flagsmith").hasFeature(X.ENABLE_HIVE_INFINITE_RETRIES) ? 1 / 0 : 3
      }
    );
  });
}, Dl = new WeakSet(), wS = function(s) {
  return u(this, null, function* () {
    if (!(a(this, Ls) === we.HIVE || !this.context.getValue("flagsmith").hasFeature(
      X.PRECREATE_PRODUCERS
    ) || !s))
      try {
        const e = [];
        if (s.canProduceVideo === j.Allowed && e.push(this.shareWebcam(fD(!1))), s.canProduceAudio === j.Allowed) {
          const r = mD(!1);
          r && e.push(this.shareMic(r));
        }
        e.length > 0 && (yield Promise.all(e));
      } catch (e) {
        this.logger.warn("Failed to precreate producers", { error: e });
      }
  });
}, tt = new WeakSet(), gt = function(s) {
  return a(this, Tt).get(s);
}, ra = new WeakSet(), Ro = function(s, t) {
  return a(this, Tt).set(s, t);
}, Ol = new WeakSet(), bS = function(s) {
  return a(this, Tt).delete(s);
}, Nl = new WeakSet(), kS = function(s) {
  return {
    track: s,
    encodings: [
      {
        priority: "high"
      }
    ],
    codecOptions: [
      {
        name: "opus"
      }
    ],
    appData: {
      e2ee: this.e2ee
    },
    stopTracks: !1,
    zeroRtpOnPause: a(this, Ls) !== we.CF
  };
}, Vl = new WeakSet(), IS = function(s, t) {
  return {
    track: s,
    codecOptions: t ? t.map((e) => ({
      name: e.split("/")[1]
    })) : [{ name: "VP8" }],
    appData: {
      screenShare: !1,
      e2ee: this.e2ee
    },
    stopTracks: !1
  };
}, g(Tu, Il), Tu);
let oe = yS;
le([
  E.trace("MediaNodeClient.reset", { country: E.location.country })
], oe.prototype, "reset", 1);
le([
  E.trace("MediaNodeClient.joinRoom")
], oe.prototype, "joinRoom", 1);
le([
  E.trace("MediaNodeClient.leaveRoom")
], oe.prototype, "leaveRoom", 1);
le([
  E.trace("MediaNodeClient.activatePeers")
], oe.prototype, "activatePeers", 1);
le([
  E.trace("MediaNodeClient.createConsumers")
], oe.prototype, "createConsumers", 1);
le([
  E.trace("MediaNodeClient.closeConsumers")
], oe.prototype, "closeConsumers", 1);
le([
  E.trace("MediaNodeClient._shareWebcam")
], oe.prototype, "_shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareWebcam")
], oe.prototype, "shareWebcam", 1);
le([
  E.trace("MediaNodeClient.shareScreen")
], oe.prototype, "shareScreen", 1);
le([
  E.trace("MediaNodeClient.shareMic")
], oe.prototype, "shareMic", 1);
le([
  E.trace("MediaNodeClient.pauseMic")
], oe.prototype, "pauseMic", 1);
le([
  E.trace("MediaNodeClient.pauseWebcam")
], oe.prototype, "pauseWebcam", 1);
le([
  E.trace("MediaNodeClient.resumeMic")
], oe.prototype, "resumeMic", 1);
le([
  E.trace("MediaNodeClient.resumeWebcam")
], oe.prototype, "resumeWebcam", 1);
le([
  E.trace("MediaNodeClient.disableWebcam")
], oe.prototype, "disableWebcam", 1);
le([
  E.trace("HiveClient.disableMic")
], oe.prototype, "disableMic", 1);
le([
  E.trace("HiveClient.disableScreenShare")
], oe.prototype, "disableScreenShare", 1);
le([
  E.trace("MediaNodeClient.muteSelf")
], oe.prototype, "muteSelf", 1);
le([
  E.trace("MediaNodeClient.resetVideoProducers")
], oe.prototype, "resetVideoProducers", 1);
le([
  E.trace("MediaNodeClient.changeDisplayName")
], oe.prototype, "changeDisplayName", 1);
le([
  E.trace("MediaNodeClient.kickPeer")
], oe.prototype, "kick", 1);
le([
  E.trace("MediaNodeClient.kickAllPeers")
], oe.prototype, "kickAll", 1);
le([
  E.trace("MediaNodeClient.muteAll")
], oe.prototype, "muteAll", 1);
le([
  E.trace("MediaNodeClient.muteAllVideo")
], oe.prototype, "muteAllVideo", 1);
le([
  E.trace("MediaNodeClient.disableAudio")
], oe.prototype, "disableAudio", 1);
le([
  E.trace("MediaNodeClient.disableVideo")
], oe.prototype, "disableVideo", 1);
le([
  E.trace("MediaNodeClient.pinPeer")
], oe.prototype, "pinPeer", 1);
le([
  E.trace("MediaNodeClient.validateScreenShare")
], oe.prototype, "validateScreenShare", 1);
function AS(s, t, e) {
  const r = s.getValue("roomNodeClient");
  if (r) {
    if (r)
      return r;
    throw new Error("Room node client already set up.");
  }
  const i = new oe(s, t, e);
  return s.setValue("roomNodeClient", i), i;
}
function MS(s) {
  const t = s.getValue("roomNodeClient");
  try {
    t == null || t.leaveRoom();
  } catch (e) {
    s.getValue("logger").error("roomNodeClient::cleanupRoomNodeClient");
  }
  s.setValue("roomNodeClient", void 0);
}
var yD = Object.defineProperty, TD = Object.getOwnPropertyDescriptor, _a = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? TD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && yD(t, e, i), i;
}, ia, Ss, te, Et, Lt, qg;
const DS = (qg = class {
  /**
   * Use await SelfController.init(roomNodeClient) instead
   */
  constructor(s, t, e, r) {
    // eslint-disable-next-line class-methods-use-this
    g(this, Et);
    h(this, "self");
    h(this, "authToken");
    g(this, ia, void 0);
    h(this, "viewType");
    g(this, Ss, void 0);
    g(this, te, void 0);
    const { socket: i } = e, n = s.getValue("authToken");
    this.self = t, m(this, te, s), this.viewType = r, this.authToken = n, m(this, ia, i), m(this, Ss, e), t.config.viewType !== Mt.Chat && this.setupEvents();
  }
  get peerId() {
    return a(this, te).getValue("peerId");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, te).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, te).getValue("logger");
  }
  get mediaJoined() {
    return a(this, te).getValue("connectionHandler").mediaJoined;
  }
  static init(s, t, e, r, i) {
    return u(this, null, function* () {
      const n = lt(), o = s.getValue("peerId"), c = !!s.getValue("cachedUserDetails"), d = yield Xe.__init__(
        s,
        e,
        r,
        i,
        i.name,
        c
      );
      s.setValue("self", d);
      const l = s.getValue("logger");
      if (navigator.product !== "ReactNative") {
        const p = !s.getValue("flagsmith").hasFeature(X.PRECALL_BANDWIDTH_TEST);
        setTimeout(() => u(this, null, function* () {
          const f = yield d.getAllDevices();
          l.info("populated_full_device_list", {
            devices: JSON.stringify(f)
          }), s.getValue("callstats").devices("AUDIO", f == null ? void 0 : f.filter((S) => S.kind === "audioinput")), s.getValue("callstats").devices("VIDEO", f == null ? void 0 : f.filter((S) => S.kind === "videoinput")), s.getValue("callstats").devices("SPEAKER", f == null ? void 0 : f.filter((S) => S.kind === "audiooutput")), l.info("Callstats:: initializing");
          try {
            yield s.getValue("callstats").initialize({
              peerId: o,
              engineName: Te.getDeviceInfo().engineName,
              env: s.getValue("env"),
              iceServers: yield n.getICEServers(),
              apiBase: s.getValue("apiBase"),
              flags: s.getValue("flagsmith").getAllFlags(),
              logger: l,
              apiHostnames: cf(s),
              skipConnectivityChecks: p
            }), l.info("Callstats:: initialized");
          } catch (S) {
            l.error("Callstats:: initialization failed", { error: S });
          }
        }), 0);
      } else
        l.info("Callstats:: Skipped initialization due to navigator product being ReactNative.");
      return new DS(s, d, t, i.viewType);
    });
  }
  shareMediaTracks() {
    return u(this, null, function* () {
      var c;
      const {
        audioTrack: s,
        videoTrack: t,
        permissions: e,
        audioEnabled: r,
        videoEnabled: i,
        screenShareEnabled: n,
        screenShareTracks: o
      } = this.self;
      if (e.canProduceAudio === j.Allowed && r)
        try {
          yield a(this, Et, Lt).shareMic(s), this.self.audioEnabled || a(this, Et, Lt).pauseMic();
        } catch (d) {
          this.self.disableAudio();
        }
      if (e.canProduceVideo === j.Allowed && i)
        try {
          const d = yield a(this, Et, Lt).shareWebcam(t);
          d && d.id !== t.id && a(this, te).getValue("flagsmith").hasFeature(X.EXP_RESHARE) && (yield a(this, Et, Lt).shareWebcam(d)), this.self.videoEnabled || a(this, Et, Lt).pauseWebcam();
        } catch (d) {
          this.self.disableVideo();
        }
      if (e.canProduceScreenshare === j.Allowed && n)
        try {
          yield (c = a(this, Et, Lt)) == null ? void 0 : c.shareScreen({
            video: o.video,
            audio: o.audio
          });
        } catch (d) {
          this.self.disableScreenShare();
        }
    });
  }
  kickHandler(s) {
    return u(this, null, function* () {
      let t = "kicked";
      (s == null ? void 0 : s.kickType) === "kickAll" && (t = "ended"), this.leaveRoom(t);
    });
  }
  /**
   * Waitlist handlers
   */
  waitlistedHandler() {
    this.logger.info("SelController.waitlisted"), this.self.waitlistStatus = "waiting", this.self.roomState = "waitlisted", this.self.emit("waitlisted");
  }
  waitlistAcceptHandler() {
    if (this.logger.info("SelController.waitlistAccepted"), this.self.waitlistStatus === "accepted") {
      this.logger.warn("SelfController.WAITLIST_ACCEPTED.UserAlreadyAccepted");
      return;
    }
    this.self.waitlistStatus = "accepted", this.joinRoom();
  }
  waitlistRejectedHandler() {
    if (this.logger.info("SelfController.waitlistRejected"), this.self.waitlistStatus === "rejected") {
      this.logger.warn("SelfController.WAITLIST_REJECTED.UserAlreadyRejected");
      return;
    }
    this.self.waitlistStatus = "rejected", this.leaveRoom("rejected");
  }
  resetSelf(s) {
    return u(this, null, function* () {
      a(this, te).getValue("callstats").callEnded(), a(this, Et, Lt).reset(), s && (yield this.joinRoom(s));
    });
  }
  setupEvents() {
    a(this, te).getValue("peerSessionStore").on(k.RESET_PRODUCER_STATE, () => u(this, null, function* () {
      this.mediaJoined && this.shareMediaTracks();
    })), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_RECONNECTED, () => {
      this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: !0 });
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_DISCONNECTED, () => {
      this.self.roomState !== "disconnected" && (this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" }));
    }), a(this, te).getValue("peerSessionStore").on(k.ROOM_NODE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_RECONNECTED, ({ wasJoinAttempted: s }) => {
      s === !1 && (this.self.roomState = "init"), this.resetSelf(s);
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_DISCONNECTED, ({ joinAttempted: s }) => {
      if (this.self.roomState === "disconnected")
        return;
      let { peerId: t } = this;
      s && a(this, te).getValue("flagsmith").hasFeature(X.REFRESH_ID_ON_DISCONNECTION) && (t = ua()), a(this, ia).updateURL(t), a(this, te).getValue("telemetry").resetPeerId(t), lt().setHeader("dyte-tracing-id", t), mr.remapContext(t, a(this, te)), this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" });
    }), a(this, te).getValue("peerSessionStore").on(k.SOCKET_SERVICE_FAILED, () => {
      this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
    }), a(this, Ss).on(x.waitingRoomRequestAccepted, () => {
      this.waitlistAcceptHandler();
    }), a(this, Ss).on(fd.updateUserPreset, (s) => {
      s.updatePeersPresets.forEach((t) => {
        t.userIds === this.self.userId && a(this, te).getValue("peerSessionStore").emit(k.UPDATE_PERMISSIONS, t.patch);
      });
    }), a(this, Ss).on(x.waitingRoomRequestDenied, () => {
      this.waitlistRejectedHandler();
    }), a(this, Ss).on(x.kick, () => {
      this.kickHandler({ kickType: "kick" });
    }), a(this, Ss).on(x.kickAll, () => {
      this.kickHandler({ kickType: "kickAll" });
    }), a(this, te).getValue("peerSessionStore").onAsync(k.JOIN_MEDIA_ROOM, this.joinMediaRoom.bind(this)), a(this, te).getValue("peerSessionStore").on(
      k.PRODUCER_SCORE_UPDATE,
      ({
        score: s,
        kind: t,
        appData: e,
        scoreStats: r
      }) => {
        var n;
        const i = (n = e == null ? void 0 : e.screenShare) != null ? n : !1;
        this.self.emit("mediaScoreUpdate", {
          kind: t,
          isScreenshare: i,
          score: s,
          participantId: this.self.id,
          scoreStats: r
        });
      }
    ), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF, () => u(this, null, function* () {
      this.self.audioEnabled && (yield this.self.disableAudio(), a(this, te).getValue("callstats").audioOff());
    })), a(this, te).getValue("peerSessionStore").on(k.MUTE_SELF_VIDEO, () => u(this, null, function* () {
      this.self.videoEnabled && (yield this.self.disableVideo(), a(this, te).getValue("callstats").videoOff());
    })), a(this, te).getValue("peerSessionStore").onAsync(
      k.LEAVE_MEDIA_ROOM,
      this.leaveMediaRoom.bind(this)
    ), a(this, te).getValue("peerSessionStore").on(
      k.PIP_HANGUP,
      this.leaveRoom.bind(this)
    );
  }
  joinRoom(s = !1) {
    return u(this, null, function* () {
      try {
        const { peer: t } = yield a(this, Ss).joinRoom(
          this.self
        );
        a(this, Ss).socket.flush();
        const e = Nh(t.stageType);
        if (a(this, te).setValue("stageStatus", e, !1), t.waitlisted) {
          this.waitlistedHandler();
          return;
        }
        yield this.joinMediaRoom(s), a(this, te).notify("stageStatus");
      } catch (t) {
        throw this.logger.error("Error in joinRoom", { error: t }), t;
      }
    });
  }
  leaveRoom(s = "left") {
    return u(this, null, function* () {
      var t, e;
      if (this.logger.info(`Leaving room with state: ${s}`), (t = a(this, te).getValue("roomSocketHandler")) == null || t.cleanup(), s === "rejected") {
        this.self.roomState = s, this.self.emit("roomLeft", { state: s });
        return;
      }
      this.self.setIsPinned(!1), a(this, te).setValue("stageStatus", "OFF_STAGE", !1), yield this.leaveMediaRoom(s), a(this, te).notify("stageStatus");
      try {
        (e = a(this, ia)) == null || e.disconnect();
      } catch (r) {
        this.logger.error("SelfController::leaveRoom::socketDisconnect");
      }
      MS(a(this, te)), this.self.roomState = s, this.self.emit("roomLeft", { state: s }), this.logger.info(`roomLeft event emitted with state: ${s}`);
    });
  }
  joinMediaRoom(s = !1) {
    return u(this, null, function* () {
      var c, d;
      const {
        peerId: t,
        viewType: e,
        meetingId: r,
        stageStatus: i,
        roomNodeOptions: n
      } = a(this, te).getAllValues(), { sfu: o } = n;
      try {
        if (e === Mt.Livestream) {
          if (i !== "ON_STAGE") {
            this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
            return;
          }
          AS(a(this, te), o, {
            socket: a(this, ia),
            peerId: t
          });
        }
        const { canProduceAudio: l, canProduceVideo: p, canProduceScreenshare: f } = this.self.permissions, { roomJoined: S } = (d = yield (c = a(this, Et, Lt)) == null ? void 0 : c.joinRoom(
          this.self.name,
          r,
          s,
          s,
          {
            canProduceAudio: l,
            canProduceVideo: p,
            canProduceScreenshare: f
          }
        )) != null ? d : {};
        if (!S)
          return;
        i === "ON_STAGE" && (yield this.shareMediaTracks()), this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
      } catch (l) {
        throw this.logger.error("Error:SelfController.mediaRoomJoin", { error: l }), new R("Error: could not join media room", "0002");
      }
    });
  }
  leaveMediaRoom(s) {
    return u(this, null, function* () {
      const t = a(this, te).getValue("viewType");
      s !== "connected-meeting" && (yield this.cleanupSelf()), !(s === "stageLeft" && t === Mt.Webinar) && a(this, Et, Lt) && (a(this, Et, Lt).mediaJoined && s !== "disconnected" && (yield a(this, Et, Lt).leaveRoom()), !(s === "stageLeft" && t === Mt.Livestream) && (a(this, Et, Lt).mediaJoined = !1));
    });
  }
  cleanupSelf() {
    return u(this, null, function* () {
      yield this.self.disableAudio(), yield this.self.disableVideo(), yield this.self.disableScreenShare(), this.self.cleanUpTracks(), this.self.destructMediaHandler(), navigator.isReactNative || this.self.removeDocumentEventListeners();
    });
  }
}, ia = new WeakMap(), Ss = new WeakMap(), te = new WeakMap(), Et = new WeakSet(), Lt = function() {
  return a(this, te).getValue("roomNodeClient");
}, qg);
let ai = DS;
_a([
  E.trace("SelfController.resetSelf")
], ai.prototype, "resetSelf", 1);
_a([
  E.trace("SelfController.setupEvents")
], ai.prototype, "setupEvents", 1);
_a([
  E.trace("SelfController.joinRoom")
], ai.prototype, "joinRoom", 1);
_a([
  E.trace("SelfController.leaveRoom")
], ai.prototype, "leaveRoom", 1);
_a([
  E.trace("SelfController.joinMediaRoom")
], ai.prototype, "joinMediaRoom", 1);
_a([
  E.trace("SelfController.leaveMediaRoom")
], ai.prototype, "leaveMediaRoom", 1);
_a([
  E.trace("SelfController.init")
], ai, "init", 1);
var Lc;
class ED {
  constructor(t) {
    g(this, Lc, void 0);
    m(this, Lc, t);
  }
  on(t, e) {
    let r;
    t === x.roomPeerCount ? r = zp.fromBinary.bind(zp) : r = ng.fromBinary.bind(ng), a(this, Lc).on(t, ({ payload: i }) => {
      if (t === x.roomPeerCount && !i)
        return;
      const n = r(i);
      e(n);
    });
  }
}
Lc = new WeakMap();
var xc, Uc;
class _D {
  constructor(t, e) {
    g(this, xc, void 0);
    g(this, Uc, void 0);
    m(this, xc, e), m(this, Uc, t);
  }
  /**
   * @private access
   * Not for external use
   */
  get logger() {
    return a(this, Uc).getValue("logger");
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.transcript: {
        r = lu.fromBinary.bind(
          lu
        ), i = lu.create();
        break;
      }
      default: {
        this.logger.debug("AISocketHandler switch case hit default, event not accounted for.");
        break;
      }
    }
    a(this, xc).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("chatSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
}
xc = new WeakMap(), Uc = new WeakMap();
var PD = Object.defineProperty, CD = Object.getOwnPropertyDescriptor, Wh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? CD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && PD(t, e, i), i;
}, hr, Hn;
class Ql {
  constructor(t, e) {
    g(this, hr, void 0);
    g(this, Hn, void 0);
    m(this, hr, e), m(this, Hn, t);
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Hn).getValue("logger");
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Hn).getValue("telemetry");
  }
  getPolls() {
    return a(this, hr).sendMessagePromise(qs.getPolls);
  }
  createPoll(t, e, r = !1, i = !1) {
    const n = {
      anonymous: r,
      hideVotes: i,
      question: t,
      options: e
    };
    return a(this, hr).sendMessage(
      qs.createPoll,
      bA.toBinary(n)
    );
  }
  votePoll(t, e) {
    const r = {
      index: e,
      pollId: t
    };
    return a(this, hr).sendMessage(
      qs.votePoll,
      IA.toBinary(r)
    );
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case qs.updatePoll:
      case qs.createPoll:
      case qs.votePoll: {
        r = fu.fromBinary.bind(fu), i = fu.create();
        break;
      }
    }
    a(this, hr).on(t, ({ payload: n }) => {
      let o = i;
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("pollSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  removeListeners(t) {
    a(this, hr).removeListeners(t);
  }
}
hr = new WeakMap(), Hn = new WeakMap();
Wh([
  E.trace("PollSocketHandler.getPolls")
], Ql.prototype, "getPolls", 1);
Wh([
  E.trace("PollSocketHandler.createPoll")
], Ql.prototype, "createPoll", 1);
Wh([
  E.trace("PollSocketHandler.votePoll")
], Ql.prototype, "votePoll", 1);
var RD = Object.defineProperty, wD = Object.getOwnPropertyDescriptor, bD = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? wD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && RD(t, e, i), i;
}, Ht;
class OS {
  constructor(t, e) {
    h(this, "socket");
    g(this, Ht, void 0);
    m(this, Ht, t), this.socket = e, this.handleSocketEvents(), a(this, Ht).setValue("roomSocketHandler", this);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, Ht).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, Ht).getValue("logger");
  }
  cleanup() {
    var t;
    try {
      (t = this.socket) == null || t.disconnect();
    } catch (e) {
      this.logger.error("roomSocketHandler::cleanup");
    }
  }
  joinRoom(t) {
    return u(this, null, function* () {
      var i;
      this.socket.joinAttempted = !0;
      const e = {
        capabilities: [],
        peer: {
          displayName: (i = t.name) != null ? i : "Participant",
          customParticipantId: t.customParticipantId,
          peerId: t.id,
          userId: t.userId,
          displayPictureUrl: t.picture,
          waitlisted: !1
        },
        roomUuid: ""
      }, r = this.socket.sendMessagePromise(
        x.joinRoom,
        gb.toBinary(e)
      );
      try {
        const { peer: n } = Ca.fromBinary((yield r).payload);
        a(this, Ht).getValue("connectionHandler").socketJoined = !0, a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_ROOM_JOINED, { peer: n });
        const o = this.getRoomState(), c = this.getRoomPeersNonPaginated(), [{ room: d }, { peers: l }] = yield Promise.all([o, c]);
        return a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_STATE, d), a(this, Ht).getValue("peerSessionStore").emit(k.SOCKET_PEERS, l), { peer: n };
      } catch (n) {
        throw this.logger.error("RoomSocketHandler.joinRoom.failed", {
          error: n
        }), new R(
          "Error: RoomSocketHandler.joinRoom failed.",
          "0002",
          this.logger,
          n
        );
      }
    });
  }
  getAllAddedParticipants() {
    return u(this, null, function* () {
      try {
        return Xb.fromBinary(
          (yield this.socket.sendMessagePromise(x.getAllAddedParticipants)).payload
        ).participants.map(
          (i) => {
            var n = i, { id: e } = n, r = ho(n, ["id"]);
            return B(D({}, r), { userId: e });
          }
        );
      } catch (t) {
        return [];
      }
    });
  }
  getRoomPeers(t, e, r) {
    return u(this, null, function* () {
      let i;
      try {
        const n = {
          // F
          seachQuery: t,
          limit: e,
          offset: r
        }, o = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo,
          ib.toBinary(n)
        );
        i = uu.fromBinary(o.payload);
      } catch (n) {
        this.logger.error("getRoomPeers::binary_decode_error", { error: n });
      }
      return i;
    });
  }
  getRoomPeersNonPaginated() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  /**
   *  TODO:(ishita1805): uncomment this code when
   * socket service sends entire peer objects for roomEvents.getStagePeers
   */
  getStagePeers() {
    return u(this, null, function* () {
      let t;
      try {
        const e = yield this.socket.sendMessagePromise(
          x.getRoomPeersInfo
        );
        t = uu.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomJoinedPeers::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      let e;
      try {
        const r = yield this.socket.sendMessagePromise(
          x.getPeerInfo,
          Sf.toBinary({ peerId: t })
        );
        e = Ca.fromBinary(r.payload);
      } catch (r) {
        this.logger.error("getPeerInfo::binary_decode_error", { error: r });
      }
      return e;
    });
  }
  getRoomState() {
    return u(this, null, function* () {
      let t = Yp.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomInfo);
        t = Yp.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  getRoomStageState() {
    return u(this, null, function* () {
      let t = eg.create();
      try {
        const e = yield this.socket.sendMessagePromise(x.getRoomStageState);
        t = eg.fromBinary(e.payload);
      } catch (e) {
        this.logger.error("getRoomStageState::binary_decode_error", { error: e });
      }
      return t;
    });
  }
  broadcastMessage(t, e) {
    return u(this, null, function* () {
      const r = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(e)),
        timestamp: Date.now(),
        ids: []
        // broadcast to all in all cases, this field has no value
      };
      return this.socket.sendMessagePromise(
        x.broadcastMessage,
        fo.toBinary(r)
      );
    });
  }
  broadcastToMeetings(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        // Broadcast to given meetings
        broadcastType: 1
        // meetings
      };
      return this.socket.sendMessagePromise(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  broadcastToPeers(t, e, r) {
    return u(this, null, function* () {
      const i = {
        type: t,
        payload: new TextEncoder().encode(JSON.stringify(r)),
        timestamp: Date.now(),
        ids: e,
        // Broadcast to peers
        broadcastType: 0
        // peers
      };
      return this.socket.sendMessage(
        x.broadcastToEntity,
        fo.toBinary(i)
      );
    });
  }
  leaveRoom() {
    return u(this, null, function* () {
      this.socket.joinAttempted = !1, this.socket.sendMessagePromise(
        x.leaveRoom,
        fb.toBinary({})
      );
    });
  }
  kick(t) {
    return u(this, null, function* () {
      const e = {
        peerIds: [t]
      };
      this.socket.sendMessage(
        x.kick,
        yf.toBinary(e)
      );
    });
  }
  kickAll(t = !1) {
    return u(this, null, function* () {
      const e = {
        propagateKickAcrossRooms: t
      };
      this.socket.sendMessage(
        x.kickAll,
        gf.toBinary(e)
      );
    });
  }
  getWaitingRoomRequests() {
    this.socket.sendMessage(x.getWaitingRoomRequests);
  }
  acceptWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.acceptWaitingRoomRequests,
      ik.toBinary(e)
    );
  }
  rejectWaitingRoomRequest(t) {
    const e = {
      userIds: t
    };
    this.socket.sendMessage(
      x.denyWaitingRoomRequests,
      nk.toBinary(e)
    );
  }
  updatePermissions(t, e) {
    return u(this, null, function* () {
      const r = {
        updatePeersPresets: []
      };
      return t.forEach((i) => {
        r.updatePeersPresets.push({
          userIds: i,
          patch: e
        });
      }), this.socket.sendMessagePromise(
        fd.updateUserPreset,
        Vk.toBinary(r)
      );
    });
  }
  handleSocketEvents() {
    this.socket.on(x.broadcastMessage, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.ROOM_MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode broadcast message:", e);
      }
    }), this.socket.on(x.broadcastToEntity, ({ payload: t }) => {
      try {
        const e = fo.fromBinary(t);
        a(this, Ht).getValue("peerSessionStore").emit(k.MESSAGE, {
          payload: JSON.parse(new TextDecoder().decode(e.payload)),
          type: e.type,
          timestamp: e.timestamp
        });
      } catch (e) {
        this.logger.error("failed to decode peer broadcast message:", e);
      }
    });
  }
  on(t, e) {
    let r, i;
    switch (t) {
      case x.joinRoom:
      case x.leaveRoom:
      case x.kick:
      case x.kickAll: {
        r = Ca.fromBinary.bind(Ca), i = Ca.create();
        break;
      }
      case x.getWaitingRoomRequests: {
        r = (n, o) => n ? Zp.fromBinary(n, o) : { requests: [] }, i = Zp.create();
        break;
      }
      case x.recordingPaused:
      case x.recordingStarted:
      case x.recordingStopped: {
        r = dg.fromBinary.bind(dg);
        break;
      }
      case fd.updateUserPreset: {
        r = tg.fromBinary.bind(tg);
        break;
      }
      case Ts.peerJoinedBroadcast:
      case is.peerJoinedBroadcast: {
        r = jp.fromBinary.bind(jp);
        break;
      }
      case Ts.selfJoinComplete:
      case is.selfJoinComplete: {
        r = Du.fromBinary.bind(Du);
        break;
      }
      case Ts.globalPeerPinBroadcast:
      case is.globalPeerPinBroadcast: {
        r = Jp.fromBinary.bind(Jp);
        break;
      }
      case Ts.selectedPeer:
      case is.selectedPeer: {
        r = Mu.fromBinary.bind(Mu);
        break;
      }
      case Ts.selectedPeerDiff:
      case is.selectedPeerDiff: {
        r = qp.fromBinary.bind(qp);
        break;
      }
      case Ts.leaveRoom:
      case is.leaveRoom: {
        r = Ou.fromBinary.bind(Ou);
        break;
      }
    }
    this.socket.on(t, ({ payload: n }) => {
      let o = i;
      if (!r)
        return e(void 0);
      try {
        o = r(n);
      } catch (c) {
        this.logger.error("roomSocketHandler::on::binary_decode_error", {
          error: c
        });
      }
      return e(o);
    });
  }
  getUserPermissions(t) {
    return u(this, null, function* () {
      const e = {
        userIds: [t]
      };
      try {
        const r = yield this.socket.sendMessagePromise(
          fd.getUserPresets,
          kk.toBinary(e)
        ), i = Dk.fromBinary(r.payload).peerPresets[0], n = new TextDecoder().decode(i.preset), o = JSON.parse(n).permissions;
        return { chat: o.chat, polls: o.polls, plugins: o.plugins };
      } catch (r) {
        throw this.logger.error("Error in getting user preset", { error: r }), r;
      }
    });
  }
}
Ht = new WeakMap();
bD([
  E.trace("RoomSocketHandler.joinRoom")
], OS.prototype, "joinRoom", 1);
var It;
class kD {
  constructor(t) {
    g(this, It, void 0);
    m(this, It, t);
  }
  getStageRequests() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, It).sendMessagePromise(
        x.getStageRequests
      );
      return t ? mu.fromBinary(t) : { stageRequests: [] };
    });
  }
  requestAccess() {
    a(this, It).sendMessage(x.requestStageAccess);
  }
  cancelRequestAccess() {
    a(this, It).sendMessage(x.cancelStageRequest);
  }
  grantAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.grantStageAccess,
        SA.toBinary(e)
      );
    });
  }
  denyAccess(t) {
    return u(this, null, function* () {
      const e = {
        userIds: t
      };
      a(this, It).sendMessage(
        x.denyStageAccess,
        yA.toBinary(e)
      );
    });
  }
  joinStage() {
    return a(this, It).sendMessagePromise(
      x.joinStage,
      void 0,
      void 0,
      x.peerStageStatusUpdate
    );
  }
  leaveStage(t) {
    const e = {
      userIds: [t]
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e),
      void 0,
      x.peerStageStatusUpdate
    );
  }
  kick(t) {
    const e = {
      userIds: t
    };
    return a(this, It).sendMessagePromise(
      x.leaveStage,
      cg.toBinary(e)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case x.grantStageAccess:
      case x.denyStageAccess: {
        r = void 0;
        break;
      }
      case x.getStagePeers: {
        r = og.fromBinary.bind(
          og
        );
        break;
      }
      case x.getStageRequests:
      case x.requestStageAccess:
      case x.cancelStageRequest: {
        r = mu.fromBinary.bind(
          mu
        );
        break;
      }
      case x.peerStageStatusUpdate: {
        r = Kp.fromBinary.bind(Kp);
        break;
      }
    }
    a(this, It).on(t, ({ payload: i, id: n }) => {
      if (!i || !r)
        return e(void 0, n);
      const o = r(i);
      return e(o, n);
    });
  }
  getPeerInfo(t) {
    return u(this, null, function* () {
      const e = yield a(this, It).sendMessagePromise(
        x.getPeerInfo,
        Sf.toBinary({ peerId: t })
      );
      return Ca.fromBinary(e.payload);
    });
  }
}
It = new WeakMap();
var Ge, $c;
class ID {
  constructor(t, e) {
    g(this, Ge, void 0);
    g(this, $c, void 0);
    m(this, Ge, e), m(this, $c, t);
  }
  /**
   * @private access
   * Not available for external use
   */
  get logger() {
    return a(this, $c).getValue("logger");
  }
  addPlugin(t, e) {
    a(this, Ge).sendMessage(
      W.addPlugin,
      NI.toBinary({ pluginId: t, staggered: e })
    );
  }
  removePlugin(t) {
    a(this, Ge).sendMessage(
      W.removePlugin,
      LI.toBinary({ pluginId: t, staggered: !1 })
    );
  }
  getActivePlugins() {
    return u(this, null, function* () {
      const { payload: t } = yield a(this, Ge).sendMessagePromise(
        W.getPlugins
      );
      return t ? aA.fromBinary(t) : { plugins: [] };
    });
  }
  customPluginEventToRoom(t, e, r) {
    const i = {
      pluginId: t,
      pluginData: new TextEncoder().encode(JSON.stringify(e))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToRoom,
      WI.toBinary(i),
      r
    );
  }
  customPluginEventToPeers(t, e, r, i) {
    const n = {
      pluginId: t,
      peerIds: e,
      pluginData: new TextEncoder().encode(JSON.stringify(r))
    };
    a(this, Ge).sendMessage(
      W.customPluginEventToPeers,
      KI.toBinary(n),
      i
    );
  }
  enablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.enablePluginForRoom,
      UI.toBinary({ pluginId: t }),
      e
    );
  }
  enablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.enablePluginForPeers,
      BI.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  disablePluginForRoom(t, e) {
    a(this, Ge).sendMessage(
      W.disablePluginForRoom,
      FI.toBinary({ pluginId: t }),
      e
    );
  }
  disablePluginForPeers(t, e, r) {
    a(this, Ge).sendMessage(
      W.disablePluginForPeers,
      jI.toBinary({ pluginId: t, peerIds: e }),
      r
    );
  }
  storeInsertKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      insertKeys: r.map((o) => ({
        storeKey: o.key,
        payload: new TextEncoder().encode(JSON.stringify(o.payload))
      }))
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(n),
      i
    );
  }
  storeGetKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      getKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeGetKeys,
      XI.toBinary(n),
      i
    );
  }
  storeDeleteKeys(t, e, r, i) {
    const n = {
      pluginId: t,
      storeName: e,
      deleteKeys: r.map((o) => ({ storeKey: o.key }))
    };
    a(this, Ge).sendMessage(
      W.storeDeleteKeys,
      eA.toBinary(n),
      i
    );
  }
  storeDelete(t, e, r) {
    a(this, Ge).sendMessage(
      W.storeDelete,
      sA.toBinary({ pluginId: t, storeName: e }),
      r
    );
  }
  /**
   * @deprecated
   */
  // eslint-disable-next-line class-methods-use-this
  getPluginDataOld(t, e) {
    this.logger.info("getPluginDataOld", {
      plugin: { id: t, storeName: e }
    });
  }
  /**
   * @deprecated
   */
  storePluginDataOld(t, e, r) {
    const i = {
      pluginId: t,
      storeName: e,
      insertKeys: [
        {
          storeKey: r.key,
          payload: new TextEncoder().encode(JSON.stringify(r))
        }
      ]
    };
    a(this, Ge).sendMessage(
      W.storeInsertKeys,
      sg.toBinary(i)
    );
  }
  on(t, e) {
    let r;
    switch (t) {
      case W.addPlugin:
      case W.enablePluginForPeers:
      case W.enablePluginForRoom: {
        r = xu.fromBinary.bind(xu);
        break;
      }
      case W.removePlugin:
      case W.disablePluginForPeers:
      case W.disablePluginForRoom: {
        r = rg.fromBinary.bind(
          rg
        );
        break;
      }
      case W.customPluginEventToPeers:
      case W.customPluginEventToRoom: {
        r = ag.fromBinary.bind(ag);
        break;
      }
      case W.storeInsertKeys:
      case W.storeGetKeys:
      case W.storeDeleteKeys:
      case W.storeDelete: {
        r = ig.fromBinary.bind(ig);
        break;
      }
    }
    a(this, Ge).on(t, ({ payload: i, id: n }) => {
      const o = r(i);
      return e(o, n);
    });
  }
}
Ge = new WeakMap(), $c = new WeakMap();
var AD = Object.defineProperty, MD = (s, t, e) => t in s ? AD(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e, DD = (s, t, e) => (MD(s, typeof t != "symbol" ? t + "" : t, e), e), Jh = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
}, M = (s, t, e) => (Jh(s, t, "read from private field"), e ? e.call(s) : t.get(s)), Se = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
}, ne = (s, t, e, r) => (Jh(s, t, "write to private field"), r ? r.call(s, e) : t.set(s, e), e), _e = (s, t, e) => (Jh(s, t, "access private method"), e), $d = {}, OD = {
  get exports() {
    return $d;
  },
  set exports(s) {
    $d = s;
  }
}, Ua = typeof Reflect == "object" ? Reflect : null, Tg = Ua && typeof Ua.apply == "function" ? Ua.apply : function(s, t, e) {
  return Function.prototype.apply.call(s, t, e);
}, Pd;
Ua && typeof Ua.ownKeys == "function" ? Pd = Ua.ownKeys : Object.getOwnPropertySymbols ? Pd = function(s) {
  return Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s));
} : Pd = function(s) {
  return Object.getOwnPropertyNames(s);
};
function ND(s) {
  console && console.warn && console.warn(s);
}
var NS = Number.isNaN || function(s) {
  return s !== s;
};
function de() {
  de.init.call(this);
}
OD.exports = de;
$d.once = UD;
de.EventEmitter = de;
de.prototype._events = void 0;
de.prototype._eventsCount = 0;
de.prototype._maxListeners = void 0;
var Eg = 10;
function Xl(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(de, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Eg;
  },
  set: function(s) {
    if (typeof s != "number" || s < 0 || NS(s))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
    Eg = s;
  }
});
de.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
de.prototype.setMaxListeners = function(s) {
  if (typeof s != "number" || s < 0 || NS(s))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + s + ".");
  return this._maxListeners = s, this;
};
function VS(s) {
  return s._maxListeners === void 0 ? de.defaultMaxListeners : s._maxListeners;
}
de.prototype.getMaxListeners = function() {
  return VS(this);
};
de.prototype.emit = function(s) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t.push(arguments[e]);
  var r = s === "error", i = this._events;
  if (i !== void 0)
    r = r && i.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var n;
    if (t.length > 0 && (n = t[0]), n instanceof Error)
      throw n;
    var o = new Error("Unhandled error." + (n ? " (" + n.message + ")" : ""));
    throw o.context = n, o;
  }
  var c = i[s];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    Tg(c, this, t);
  else
    for (var d = c.length, l = FS(c, d), e = 0; e < d; ++e)
      Tg(l[e], this, t);
  return !0;
};
function LS(s, t, e, r) {
  var i, n, o;
  if (Xl(e), n = s._events, n === void 0 ? (n = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit(
    "newListener",
    t,
    e.listener ? e.listener : e
  ), n = s._events), o = n[t]), o === void 0)
    o = n[t] = e, ++s._eventsCount;
  else if (typeof o == "function" ? o = n[t] = r ? [e, o] : [o, e] : r ? o.unshift(e) : o.push(e), i = VS(s), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = o.length, ND(c);
  }
  return s;
}
de.prototype.addListener = function(s, t) {
  return LS(this, s, t, !1);
};
de.prototype.on = de.prototype.addListener;
de.prototype.prependListener = function(s, t) {
  return LS(this, s, t, !0);
};
function VD() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function xS(s, t, e) {
  var r = { fired: !1, wrapFn: void 0, target: s, type: t, listener: e }, i = VD.bind(r);
  return i.listener = e, r.wrapFn = i, i;
}
de.prototype.once = function(s, t) {
  return Xl(t), this.on(s, xS(this, s, t)), this;
};
de.prototype.prependOnceListener = function(s, t) {
  return Xl(t), this.prependListener(s, xS(this, s, t)), this;
};
de.prototype.removeListener = function(s, t) {
  var e, r, i, n, o;
  if (Xl(t), r = this._events, r === void 0)
    return this;
  if (e = r[s], e === void 0)
    return this;
  if (e === t || e.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[s], r.removeListener && this.emit("removeListener", s, e.listener || t));
  else if (typeof e != "function") {
    for (i = -1, n = e.length - 1; n >= 0; n--)
      if (e[n] === t || e[n].listener === t) {
        o = e[n].listener, i = n;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? e.shift() : LD(e, i), e.length === 1 && (r[s] = e[0]), r.removeListener !== void 0 && this.emit("removeListener", s, o || t);
  }
  return this;
};
de.prototype.off = de.prototype.removeListener;
de.prototype.removeAllListeners = function(s) {
  var t, e, r;
  if (e = this._events, e === void 0)
    return this;
  if (e.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : e[s] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete e[s]), this;
  if (arguments.length === 0) {
    var i = Object.keys(e), n;
    for (r = 0; r < i.length; ++r)
      n = i[r], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = e[s], typeof t == "function")
    this.removeListener(s, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(s, t[r]);
  return this;
};
function US(s, t, e) {
  var r = s._events;
  if (r === void 0)
    return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? xD(i) : FS(i, i.length);
}
de.prototype.listeners = function(s) {
  return US(this, s, !0);
};
de.prototype.rawListeners = function(s) {
  return US(this, s, !1);
};
de.listenerCount = function(s, t) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t) : $S.call(s, t);
};
de.prototype.listenerCount = $S;
function $S(s) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[s];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
de.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Pd(this._events) : [];
};
function FS(s, t) {
  for (var e = new Array(t), r = 0; r < t; ++r)
    e[r] = s[r];
  return e;
}
function LD(s, t) {
  for (; t + 1 < s.length; t++)
    s[t] = s[t + 1];
  s.pop();
}
function xD(s) {
  for (var t = new Array(s.length), e = 0; e < t.length; ++e)
    t[e] = s[e].listener || s[e];
  return t;
}
function UD(s, t) {
  return new Promise(function(e, r) {
    function i(o) {
      s.removeListener(t, n), r(o);
    }
    function n() {
      typeof s.removeListener == "function" && s.removeListener("error", i), e([].slice.call(arguments));
    }
    HS(s, t, n, { once: !0 }), t !== "error" && $D(s, i, { once: !0 });
  });
}
function $D(s, t, e) {
  typeof s.on == "function" && HS(s, "error", t, e);
}
function HS(s, t, e, r) {
  if (typeof s.on == "function")
    r.once ? s.once(t, e) : s.on(t, e);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t, function i(n) {
      r.once && s.removeEventListener(t, i), e(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
class FD extends v {
  constructor() {
    super("message.v1.SocketMessage", [
      {
        no: 1,
        name: "event",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        opt: !0,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "payload",
        kind: "scalar",
        opt: !0,
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 4,
        name: "metadata",
        kind: "scalar",
        opt: !0,
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
}
const _g = new FD();
class BS {
  static encode(t) {
    return _g.toBinary(t);
  }
  static decode(t) {
    return _g.fromBinary(new Uint8Array(t));
  }
}
function HD(s, t) {
  return Math.floor(Math.random() * (t - s + 1) + s);
}
var Ir;
class BD {
  constructor(t = {}) {
    DD(this, "opts"), Se(this, Ir, void 0), this.opts = {
      initialTimeout: t.initialTimeout || 1e3,
      maxTimeout: t.maxTimeout || 1e4,
      factor: t.factor || 2
    }, ne(this, Ir, 0);
  }
  wait() {
    return u(this, null, function* () {
      ne(this, Ir, M(this, Ir) + 1);
      const t = HD(0, Math.min(this.opts.maxTimeout, this.opts.initialTimeout * ep(2, M(this, Ir))));
      yield new Promise((e) => {
        setTimeout(e, t);
      });
    });
  }
  getAttempts() {
    return M(this, Ir);
  }
  reset() {
    ne(this, Ir, 0);
  }
}
Ir = /* @__PURE__ */ new WeakMap();
const wr = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
var ui, hi;
class qD {
  constructor(t) {
    Se(this, ui, void 0), Se(this, hi, void 0), ne(this, ui, console), ne(this, hi, t);
  }
  debug(...t) {
    wr[M(this, hi)] > wr.debug || M(this, ui).debug("[Sockrates]:", ...t);
  }
  info(...t) {
    wr[M(this, hi)] > wr.info || M(this, ui).info("[Sockrates]:", ...t);
  }
  warn(...t) {
    wr[M(this, hi)] > wr.warn || M(this, ui).warn("[Sockrates]:", ...t);
  }
  error(...t) {
    wr[M(this, hi)] > wr.error || M(this, ui).error("[Sockrates]:", ...t);
  }
}
ui = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap();
var qS = /* @__PURE__ */ ((s) => (s[s.CONNECTING = 0] = "CONNECTING", s[s.OPEN = 1] = "OPEN", s[s.CLOSING = 2] = "CLOSING", s[s.CLOSED = 3] = "CLOSED", s))(qS || {});
const jD = "2", GD = "3";
var Ae, Ia, Ee, Ue, Ar, Ye, gr, Xr, ys, Aa, Bs, dh, jS, wo, Cd, lh, GS, uh, Pg, Fd, hh, ph, WS, Ao, Rd, Mo, Hd, Bd, gh, $a, Do, Oo, qd;
class WD {
  constructor(t, e) {
    var S, T, _, P, w, A, N, H, $, F;
    Se(this, dh), Se(this, wo), Se(this, lh), Se(this, uh), Se(this, Fd), Se(this, ph), Se(this, Ao), Se(this, Mo), Se(this, Bd), Se(this, $a), Se(this, Oo), Se(this, Ae, void 0), Se(this, Ia, void 0), Se(this, Ee, void 0), Se(this, Ue, void 0), Se(this, Ar, void 0), Se(this, Ye, void 0), Se(this, gr, void 0), Se(this, Xr, void 0), Se(this, ys, void 0), Se(this, Aa, void 0), Se(this, Bs, void 0);
    var r, i, n, o, c, d, l, p, f;
    ne(this, Ia, t), ne(this, Ar, []), ne(this, Ye, new $d()), ne(this, gr, !0), ne(this, ys, !1), ne(this, Ee, e != null ? e : {}), (S = (r = M(this, Ee)).autoReconnect) != null || (r.autoReconnect = !0), (T = (i = M(this, Ee)).retryConnectionInterval) != null || (i.retryConnectionInterval = 1e3), (_ = (n = M(this, Ee)).pingTimeout) != null || (n.pingTimeout = 3e4), (P = (o = M(this, Ee)).connectionTimeout) != null || (o.connectionTimeout = 5e3), (w = (c = M(this, Ee)).debug) != null || (c.debug = !0), (A = (d = M(this, Ee)).maxReconnectionAttempts) != null || (d.maxReconnectionAttempts = 10), (N = (l = M(this, Ee)).disconnectOnPingTimeout) != null || (l.disconnectOnPingTimeout = !0), (H = (p = M(this, Ee)).queueOnDisconnect) != null || (p.queueOnDisconnect = !1), ($ = (f = M(this, Ee)).flushOnReconnect) != null || (f.flushOnReconnect = !1), ne(this, Xr, {
      code: void 0,
      reason: void 0
    }), ne(this, Ue, (F = M(this, Ee).logger) != null ? F : new qD(M(this, Ee).debug ? "debug" : "info")), ne(this, Bs, new BD());
  }
  /**
   * Ready state of the current WebSocket.
   */
  get readyState() {
    var t;
    return (t = M(this, Ae)) == null ? void 0 : t.readyState;
  }
  /**
   * Sockrates connection URL.
   */
  get url() {
    return M(this, Ia);
  }
  /**
   * Update connection URL.
   */
  updateURL(t) {
    ne(this, Ia, t), _e(this, ph, WS).call(this);
  }
  /**
   * Configuration options passed to Sockrates.
   */
  get config() {
    return M(this, Ee);
  }
  /**
   * Messages that got queued due to the
   * socket not being connected.
   */
  get sendQueue() {
    return M(this, Ar);
  }
  /**
   * Flushes all messages that were queued
   * due to the socket not being connected.
   */
  flush() {
    if (!M(this, Ee).queueOnDisconnect)
      return !1;
    const t = [];
    return M(this, Ar).forEach((e) => {
      this.send(e.event, e.id, e.payload, e.metadata) || t.push(e);
    }), ne(this, Ar, t), M(this, Ar);
  }
  connect(t = !1) {
    return u(this, null, function* () {
      if (!t && [
        0,
        1
        /* OPEN */
      ].includes(this.readyState)) {
        M(this, Ue).debug("Websocket was already connecting or connected.");
        return;
      }
      if (M(this, gr) !== !1)
        return new Promise((e, r) => {
          _e(this, $a, Do).call(this), _e(this, Oo, qd).call(this);
          try {
            ne(this, Ae, new WebSocket(_e(this, dh, jS).call(this, M(this, Ia)))), M(this, Ae).binaryType = "arraybuffer", M(this, Ue).debug("Connecting");
            const i = setTimeout(() => {
              M(this, Ue).debug("Connection timeout. Closing socket"), ne(this, gr, !0), _e(this, Oo, qd).call(this), M(this, Ae).close(3001, "Connection Timeout"), M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ye).emit(
                "reconnecting"
                /* reconnecting */
              ), _e(this, Ao, Rd).call(this)), r(new Error("Connection timed out!"));
            }, M(this, Ee).connectionTimeout);
            M(this, Ae).onopen = () => {
              M(this, Ue).debug(`Ready State: ${qS[M(this, Ae).readyState]}`), i && clearTimeout(i), _e(this, Bd, gh).call(this), ne(this, Xr, {
                code: void 0,
                reason: void 0
              }), M(this, Ye).emit(
                "connected"
                /* connected */
              ), M(this, Ee).flushOnReconnect && this.flush(), e();
            }, M(this, Ae).onclose = (n) => {
              try {
                i && clearTimeout(i);
                const { code: o, reason: c } = n;
                r(c), M(this, Ue).debug("Socket closed. Close event:", { event: n }), M(this, Ue).debug(`Connection closed code: ${o}`), M(this, Ue).debug(`Connection closed reason: ${c}`), M(this, ys) || _e(this, Fd, hh).call(this, o, c);
              } catch (o) {
                _e(this, wo, Cd).call(this, o);
              }
            }, M(this, Ae).onerror = (n) => {
              _e(this, wo, Cd).call(this, n);
            }, M(this, Ae).onmessage = (n) => _e(this, lh, GS).call(this, n);
          } catch (i) {
            _e(this, wo, Cd).call(this, i, r);
          }
        });
    });
  }
  /**
   * Send a message to the socket server.
   * @returns {boolean} Returns true if the payload was sent successfully.
   */
  send(t, e, r, i) {
    const n = { event: t, id: e, payload: r, metadata: i };
    if (M(this, Ee).queueOnDisconnect && (!M(this, Ae) || M(this, Ae).readyState !== 1))
      return M(this, Ue).debug("Queuing message since socket is not connected!", n), M(this, Ar).push(n), !1;
    const o = BS.encode(n);
    return _e(this, Mo, Hd).call(this, o);
  }
  /**
   * Alias for `send`.
   */
  emit(t, e, r, i) {
    return this.send(t, e, r, i);
  }
  /**
   * Send a raw message to the socket server.
   */
  sendRaw(t) {
    return _e(this, Mo, Hd).call(this, t);
  }
  /**
   * Alias to `on`.
   */
  receive(t, e) {
    return M(this, Ye).on(t.toString(), e);
  }
  /**
   * Event listener that is fired on receiving socket messages.
   */
  on(t, e) {
    if (typeof t == "string" && (t === "connected" || t === "disconnected" || t === "errored" || t === "reconnected" || t === "reconnecting" || t === "reconnectAttempt" || t === "reconnectFailure" || t === "failed")) {
      M(this, Ye).on(t, e);
      return;
    }
    this.receive(t, e);
  }
  /**
   * Remove all event listeners that were added using `on`.
   */
  removeAllListeners() {
    M(this, Ye).removeAllListeners();
  }
  /**
   * Alias to `removeListener`.
   */
  removeReceiver(t, e) {
    this.removeListener(t, e);
  }
  /**
   * Remove a specific listener that was added using `on`.
   */
  removeListener(t, e) {
    M(this, Ye).removeListener(t.toString(), e);
  }
  /**
   * Alias to `removeListeners`.
   */
  removeReceivers(t) {
    this.removeListeners(t);
  }
  /**
   * Remove all listeners for a specific event.
   */
  removeListeners(t) {
    M(this, Ye).listeners(t.toString()).map(
      (e) => this.removeListener(t, e)
    );
  }
  /**
   * Disconnect the socket.
   */
  disconnect() {
    ne(this, gr, !1), _e(this, $a, Do).call(this), this.removeAllListeners(), ne(this, Xr, {
      code: 1e3,
      reason: "Sockrates disconnect method called"
    }), M(this, Ae).close(1e3, "Sockrates disconnect method called.");
  }
}
Ae = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), Ee = /* @__PURE__ */ new WeakMap(), Ue = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), gr = /* @__PURE__ */ new WeakMap(), Xr = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Bs = /* @__PURE__ */ new WeakMap(), dh = /* @__PURE__ */ new WeakSet(), jS = function(s) {
  if (s.startsWith("ws://") || s.startsWith("wss://"))
    return s;
  if (s.startsWith("https://"))
    return `wss://${s.substring(8)}`;
  if (s.startsWith("http://"))
    return `ws://${s.substring(7)}`;
  throw new Error("Invalid URL. URL must start with http(s):// or ws(s)://.");
}, wo = /* @__PURE__ */ new WeakSet(), Cd = function(s, t) {
  M(this, Ue).error("Error:", { error: s }), M(this, Ye).emit("errored", { error: s }), t == null || t(s);
}, lh = /* @__PURE__ */ new WeakSet(), GS = function(s) {
  if (_e(this, Bd, gh).call(this), s.data === jD) {
    M(this, Ue).debug("Received ping from server"), _e(this, Mo, Hd).call(this, GD);
    return;
  }
  const t = BS.decode(s.data), { id: e, payload: r } = t;
  M(this, Ue).debug("Received message", { event: t.event, messageID: e }), M(this, Ye).emit(t.event.toString(), { id: e, payload: r });
}, uh = /* @__PURE__ */ new WeakSet(), Pg = function() {
  return M(this, Ae).readyState === 1;
}, Fd = /* @__PURE__ */ new WeakSet(), hh = function(s, t) {
  ne(this, Xr, { reason: t, code: s }), M(this, Ye).emit("disconnected", { code: s, reason: t });
}, ph = /* @__PURE__ */ new WeakSet(), WS = function() {
  const { reason: s, code: t } = M(this, Xr);
  t && t !== 1e3 && M(this, gr) && M(this, Ee).autoReconnect && !M(this, ys) && (M(this, Ue).debug(`Triggering reconnection due to ${s}.`), M(this, Ye).emit(
    "reconnecting"
    /* reconnecting */
  ), _e(this, Ao, Rd).call(this));
}, Ao = /* @__PURE__ */ new WeakSet(), Rd = function(s = !0) {
  return u(this, null, function* () {
    if (s && M(this, ys)) {
      M(this, Ue).debug("Reconnect called when already in a reconnect loop. Ignoring.");
      return;
    }
    if (M(this, ys) || M(this, Bs).reset(), M(this, Ee).maxReconnectionAttempts !== null && M(this, Bs).getAttempts() >= M(this, Ee).maxReconnectionAttempts) {
      M(this, Ye).emit(
        "failed"
        /* failed */
      ), ne(this, ys, !1);
      return;
    }
    ne(this, ys, !0), _e(this, Oo, qd).call(this), _e(this, $a, Do).call(this);
    try {
      if (yield M(this, Bs).wait(), M(this, gr) === !1)
        return;
      if (M(this, Ue).debug(`Reconnection attempt ${M(this, Bs).getAttempts()}`), M(this, Ye).emit("reconnectAttempt", { attempt: M(this, Bs).getAttempts() }), yield this.connect(), !_e(this, uh, Pg).call(this))
        throw Error("Reconnect Failed");
      ne(this, ys, !1), ne(this, Xr, {
        code: void 0,
        reason: void 0
      }), M(this, Ye).emit(
        "reconnected"
        /* reconnected */
      );
    } catch (t) {
      M(this, Ue).debug("Failed to reconnect."), M(this, Ye).emit("reconnectFailure", { attempt: M(this, Bs).getAttempts() }), _e(this, Ao, Rd).call(this, !1);
    }
  });
}, Mo = /* @__PURE__ */ new WeakSet(), Hd = function(s) {
  try {
    return M(this, Ae).send(s), !0;
  } catch (t) {
    return M(this, Ue).error(t.message), !1;
  }
}, Bd = /* @__PURE__ */ new WeakSet(), gh = function() {
  this.config.disconnectOnPingTimeout && (M(this, Ue).debug("Resetting ping timeout"), _e(this, $a, Do).call(this), ne(this, Aa, setTimeout(() => {
    var s;
    M(this, Ue).debug("Disconnecting the socket due to ping timeout"), ne(this, gr, !0);
    const t = 3002, e = "Ping timeout";
    (s = M(this, Ae)) == null || s.close(t, e), _e(this, Fd, hh).call(this, t, e);
  }, M(this, Ee).pingTimeout)));
}, $a = /* @__PURE__ */ new WeakSet(), Do = function() {
  M(this, Aa) && (clearTimeout(M(this, Aa)), ne(this, Aa, void 0));
}, Oo = /* @__PURE__ */ new WeakSet(), qd = function() {
  M(this, Ae) && (M(this, Ae).onopen = void 0, M(this, Ae).onerror = void 0, M(this, Ae).onmessage = void 0, M(this, Ae).onclose = void 0);
};
var JD = Object.defineProperty, KD = Object.getOwnPropertyDescriptor, Zl = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? KD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && JD(t, e, i), i;
};
const Cg = 65535, zD = 3e3;
var zr, Pe, Ce, De, rs, st, Fc, mh, Hc, fh, jg;
const JS = (jg = class {
  constructor(s, {
    peerId: t,
    meetingId: e,
    authToken: r,
    capabilities: i
  }) {
    g(this, Ce);
    g(this, Fc);
    g(this, Hc);
    g(this, zr, void 0);
    g(this, Pe, void 0);
    h(this, "roomName");
    h(this, "authToken");
    h(this, "capabilities");
    g(this, rs, void 0);
    g(this, st, void 0);
    var n;
    if (!t || !e || !r)
      throw new R("peerId, meetingId, or authToken can not be empty", "0404");
    m(this, rs, void 0), m(this, st, s), this.capabilities = i, this.roomName = e, this.authToken = r, m(this, zr, L(this, Fc, mh).call(this, t)), m(this, Pe, new WD(a(this, zr), {
      autoReconnect: !0,
      disconnectOnPingTimeout: (n = i.includes("PING")) != null ? n : !1,
      queueOnDisconnect: !0,
      flushOnReconnect: !1,
      logger: this.logger
    })), this.handleSocketConnectionEvents();
  }
  get joinAttempted() {
    return a(this, Ce, De).socketJoinAttempted;
  }
  set joinAttempted(s) {
    a(this, Ce, De).socketJoinAttempted = s;
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, st).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, st).getValue("logger");
  }
  get peerId() {
    return a(this, st).getValue("peerId");
  }
  updateURL(s) {
    s !== this.peerId && (m(this, zr, L(this, Fc, mh).call(this, s)), this.logger.debug("SocketService:: Connection URL updated.")), a(this, Pe).updateURL(a(this, zr));
  }
  static getSocketEdgeDomain(s) {
    return da({ servicePrefix: "socket-edge", baseURI: s });
  }
  get url() {
    return a(this, zr);
  }
  connect() {
    return u(this, null, function* () {
      a(this, Ce, De).socketJoinAttempted = !0, yield a(this, Pe).connect(), a(this, Ce, De).socketJoinAttempted = !0, a(this, Ce, De).socketState = {
        state: "connected",
        reconnected: !1,
        reconnectionAttempt: void 0
      };
    });
  }
  disconnect() {
    a(this, Ce, De).socketJoinAttempted = !1, a(this, Pe).disconnect(), a(this, Ce, De).socketJoinAttempted = !0, a(this, Ce, De).socketState = {
      state: "disconnected",
      reconnected: !1,
      reconnectionAttempt: void 0
    };
  }
  get isConnected() {
    try {
      return a(this, Pe).readyState === 1;
    } catch (s) {
      return !1;
    }
  }
  sendMessage(s, t, e) {
    const r = {};
    return a(this, st).getValue("telemetry").injectContext(r), a(this, Pe).send(
      s,
      e != null ? e : L(this, Hc, fh).call(this),
      t,
      new TextEncoder().encode(JSON.stringify(r))
    );
  }
  sendMessagePromise(s, t, e, r) {
    const i = parseInt({}.SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT, 10) || 2e4;
    return this.sendMessagePromiseWithTimeout({
      event: s,
      timeout: i,
      protobuf: t,
      messageId: e,
      resp: r
    });
  }
  sendMessagePromiseWithTimeout({
    event: s,
    timeout: t,
    protobuf: e,
    messageId: r,
    resp: i
  }) {
    const n = i != null ? i : s;
    return new Promise(
      (o, c) => {
        const d = (_, P) => {
          a(this, Pe).removeListener(n, _), a(this, Pe).removeListener(Cg, P), a(this, Pe).removeListener(
            is.errorResponse,
            P
          ), a(this, Pe).removeListener(
            Ts.errorResponse,
            P
          );
        }, l = r != null ? r : L(this, Hc, fh).call(this), p = {};
        a(this, st).getValue("telemetry").injectContext(p);
        const S = ({
          id: _,
          payload: P
        }) => {
          if (l === _) {
            let w;
            try {
              const A = YR.fromBinary(P);
              w = new Error(A.errorMessage);
            } catch (A) {
              w = new Error("failed to parse error message", { cause: A });
              try {
                const N = Qw.fromBinary(P);
                w = new Error(N.message);
              } catch (N) {
                w = new Error("failed to parse error message", { cause: N });
              }
            }
            c(w), d(T, S);
          }
        }, T = ({
          id: _,
          payload: P
        }) => {
          l === _ && (o({ id: _, payload: P }), d(T, S));
        };
        a(this, Pe).on(n, T), a(this, Pe).on(Cg, S), a(this, Pe).on(is.errorResponse, S), a(this, Pe).on(Ts.errorResponse, S), setTimeout(() => {
          d(T, S), c(new Error(`request timeout for callback eventId:${s}`));
        }, t), a(this, Pe).send(
          s,
          l,
          e,
          new TextEncoder().encode(JSON.stringify(p))
        );
      }
    );
  }
  on(s, t) {
    a(this, Pe).on(s, t);
  }
  onStateEvent(s, t) {
    a(this, Pe).on(s, t);
  }
  removeListener(s, t) {
    a(this, Pe).removeListener(s, t);
  }
  removeListeners(s) {
    a(this, Pe).removeListeners(s);
  }
  flush() {
    return a(this, Pe).flush();
  }
  handleSocketConnectionEvents() {
    this.onStateEvent("connected", () => u(this, null, function* () {
      this.logger.info("SocketService::Connected to socket-edge"), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, Ce, De).updateSocketConnectionState("connected");
    })), this.onStateEvent("disconnected", ({ code: s, reason: t }) => {
      var i;
      this.logger.info("SocketService::Disconnected from socket-edge", { error: { code: s, reason: t }, country: E.location.country });
      const { recv: e, send: r } = (i = a(this, Ce, De).mediaState) != null ? i : {};
      e != null && e.state && (e == null ? void 0 : e.state) !== xa.CONNECTED || r != null && r.state && (r == null ? void 0 : r.state) !== xa.CONNECTED ? a(this, st).getValue("peerSessionStore").emit(
        k.SOCKET_SERVICE_DISCONNECTED,
        {
          joinAttempted: a(this, Ce, De).joinAttempted
        }
      ) : m(this, rs, setTimeout(() => {
        a(this, st).getValue("peerSessionStore").emit(
          k.SOCKET_SERVICE_DISCONNECTED,
          { joinAttempted: a(this, Ce, De).joinAttempted }
        ), m(this, rs, void 0);
      }, zD)), a(this, Ce, De).updateSocketConnectionState("disconnected");
    }), this.onStateEvent("reconnecting", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnecting to socket-edge", { country: E.location.country }), a(this, Ce, De).updateSocketConnectionState("reconnecting");
    })), this.onStateEvent("reconnectAttempt", (t) => u(this, [t], function* ({ attempt: s }) {
      this.logger.info("SocketService::Attempting to reconnect to socket-edge", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectAttempt", s);
    })), this.onStateEvent("reconnectFailure", ({ attempt: s }) => {
      this.logger.info("SocketService::Reconnect attempt to socket-edge failed", {
        socket: {
          retryAttempt: s
        }
      }), a(this, Ce, De).updateSocketConnectionState("reconnectFailure", s);
    }), this.onStateEvent("reconnected", () => u(this, null, function* () {
      this.logger.info("SocketService::Reconnected to socket-edge", { connectionState: { joinAttempted: a(this, Ce, De).mediaJoinAttempted } }), a(this, rs) && (clearTimeout(a(this, rs)), m(this, rs, void 0)), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_RECONNECTED, {
        wasJoinAttempted: a(this, Ce, De).mediaJoinAttempted
      }), a(this, Ce, De).updateSocketConnectionState("reconnected");
    })), this.onStateEvent("failed", () => u(this, null, function* () {
      this.logger.info("SocketService::Failed to connect to socket-edge", { country: E.location.country }), a(this, st).getValue("peerSessionStore").emit(k.SOCKET_SERVICE_FAILED), a(this, Ce, De).updateSocketConnectionState("failed");
    }));
  }
}, zr = new WeakMap(), Pe = new WeakMap(), Ce = new WeakSet(), De = function() {
  return a(this, st).getValue("connectionHandler");
}, rs = new WeakMap(), st = new WeakMap(), Fc = new WeakSet(), mh = function(s) {
  let t = JS.getSocketEdgeDomain(a(this, st).getValue("baseURI"));
  typeof Gn(a(this, st), "socket_server_base") == "string" && (t = Gn(a(this, st), "socket_server_base"));
  const e = `wss://${t}`, r = new URL(`${e}/ws`), i = this.peerId, n = B(D({
    roomID: this.roomName,
    peerID: s,
    authToken: this.authToken,
    useMediaV2: !0
  }, i !== s && { oldPeerID: i }), {
    ping: this.capabilities.includes("PING"),
    capabilities: this.capabilities.map((o) => Nd[o]).join(" "),
    joinWithDetails: !0,
    useCfWorker: !0,
    useStartSession: !0
  });
  return Object.entries(n).forEach(([o, c]) => {
    r.searchParams.append(o, c.toString());
  }), r.href;
}, Hc = new WeakSet(), fh = function() {
  return `${this.peerId}-${(Math.random() + 1).toString(36).substring(7)}`;
}, jg);
let Xc = JS;
Zl([
  E.trace("SocketService.connect")
], Xc.prototype, "connect", 1);
Zl([
  E.trace("SocketService.disconnect")
], Xc.prototype, "disconnect", 1);
Zl([
  E.trace("SocketService.sendMessagePromise")
], Xc.prototype, "sendMessagePromise", 1);
Zl([
  E.trace("SocketService.sendMessagePromiseWithTimeout")
], Xc.prototype, "sendMessagePromiseWithTimeout", 1);
class YD {
  constructor(t) {
    h(this, "socketService");
    this.socketService = t;
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsDumpRaw({ payload: t }) {
    var n;
    const e = Cb.fromBinary(t), r = e.meetings.map((o) => {
      var c;
      return {
        id: o.id,
        title: o.title,
        participants: (c = o.participants) != null ? c : []
      };
    });
    return {
      parentMeeting: {
        id: e.parentMeeting.id,
        title: e.parentMeeting.title,
        participants: (n = e.parentMeeting.participants) != null ? n : []
      },
      meetings: r
    };
  }
  // eslint-disable-next-line class-methods-use-this
  handleTransferPeerRaw({ payload: t }) {
    const e = Yb.fromBinary(t);
    return { authToken: e.authToken, meetingId: e.meetingId };
  }
  // eslint-disable-next-line class-methods-use-this
  handleMovedPeerRaw({ payload: t }) {
    const e = vf.fromBinary(t);
    return {
      meetingId: e.meetingId,
      customParticipantId: e.customParticipantId
    };
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsUpdatedRaw({ payload: t }) {
    return Xp.fromBinary(t).payloads.map((r) => ({
      id: r.id,
      title: r.title
    }));
  }
  // eslint-disable-next-line class-methods-use-this
  handleConnectedRoomsDeletedRaw({ payload: t }) {
    return Fb.fromBinary(t).payloads;
  }
  getConnectedRoomsDump() {
    return u(this, null, function* () {
      const t = yield this.socketService.sendMessagePromise(
        x.getConnectedRoomsDump
      );
      return this.handleConnectedRoomsDumpRaw(t);
    });
  }
  createConnectedRooms(t) {
    return u(this, null, function* () {
      const { payload: e } = yield this.socketService.sendMessagePromise(
        x.createConnectedRooms,
        kb.toBinary({ payloads: t })
      );
      return Xp.fromBinary(e).payloads.map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this
  updateConnectedRooms(t) {
    return u(this, null, function* () {
    });
  }
  disableConnectedRooms(t) {
    return u(this, null, function* () {
      const e = t.map((i) => ({ id: i })), r = yield this.socketService.sendMessagePromise(
        x.deleteConnectedRooms,
        Ub.toBinary({ payloads: e })
      );
      return this.handleConnectedRoomsDeletedRaw(
        r
      );
    });
  }
  movePeersBetweenRooms(t) {
    return u(this, null, function* () {
      try {
        const e = yield this.socketService.sendMessagePromise(
          x.movePeers,
          Wb.toBinary({
            sourceMeetingId: t.sourceMeetingId,
            destinationMeetingId: t.destinationMeetingId,
            participants: t.participants
          })
        );
        return new TextDecoder().decode(e.payload).includes("error") ? { success: !1, error: "failed to move participants" } : { success: !0 };
      } catch (e) {
        return { success: !1, error: e };
      }
    });
  }
}
var QD = Object.defineProperty, XD = Object.getOwnPropertyDescriptor, ZD = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? XD(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && QD(t, e, i), i;
}, vs;
class KS extends qt {
  constructor(e) {
    const r = e.getValue("logger");
    super(r);
    h(this, "meetings", []);
    h(this, "parentMeeting", null);
    g(this, vs, void 0);
    m(this, vs, e);
  }
  get supportsConnectedMeetings() {
    return a(this, vs).getValue("self").id !== "";
  }
  get isActive() {
    return this.meetings.length !== 0;
  }
  validateConnectedMeetingsAction() {
    if (!this.supportsConnectedMeetings)
      throw new Error(`You are not allowed to perform this action.
						Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
  }
  getConnectedMeetings() {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").getConnectedRoomsDump();
    });
  }
  /**
   * create connected meetings
   */
  createMeetings(e) {
    return u(this, null, function* () {
      return this.validateConnectedMeetingsAction(), (yield a(this, vs).getValue("connectedMeetingsSocketHandler").createConnectedRooms(
        e
      )).map((i) => ({
        id: i.id,
        title: i.title
      }));
    });
  }
  /**
   * update meeting title
   */
  updateMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction(), yield a(this, vs).getValue("connectedMeetingsSocketHandler").updateConnectedRooms(
        e.map((r) => ({ meetingId: r.id, title: r.title }))
      );
    });
  }
  /**
   * delete connected meetings
   */
  deleteMeetings(e) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const r = this.meetings.map((n) => e.includes(n.id) && n.participants.length !== 0 ? this.moveParticipants(
        n.id,
        this.parentMeeting.id,
        n.participants.map((o) => o.id)
      ) : Promise.resolve());
      return yield Promise.all(r), yield a(this, vs).getValue("connectedMeetingsSocketHandler").disableConnectedRooms(
        e
      );
    });
  }
  /**
   * Trigger event to move participants
   *
   * @param {string} sourceMeetingId - id of source meeting
   * @param {string} destinationMeetingId - id of destination meeting
   * @param {string[]} participantIds - list of id of the participants
   */
  moveParticipants(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i.map((o) => ({
            id: o
          }))
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i), n;
    });
  }
  /**
   * Trigger event to move participants with custom preset
   */
  moveParticipantsWithCustomPreset(e, r, i) {
    return u(this, null, function* () {
      this.validateConnectedMeetingsAction();
      const n = yield a(this, vs).getValue("connectedMeetingsSocketHandler").movePeersBetweenRooms(
        {
          sourceMeetingId: e,
          destinationMeetingId: r,
          participants: i
        }
      );
      return n.success && this.moveSuccessHandler(e, r, i.map((o) => o.id)), n;
    });
  }
  moveSuccessHandler(e, r, i) {
    const n = /* @__PURE__ */ new Map();
    [
      ...this.parentMeeting.participants,
      ...this.meetings.flatMap((o) => o.participants)
    ].forEach((o) => n.set(o.id, o)), r === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.concat(
      i.map((o) => n.get(o))
    )), e === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.filter(
      (o) => !i.includes(o.id)
    )), this.meetings = this.meetings.map((o) => {
      if (r === o.id) {
        const c = o.participants.concat(
          i.map((d) => n.get(d))
        );
        return B(D({}, o), {
          participants: c
        });
      }
      if (e === o.id) {
        const c = o.participants.filter(
          (d) => !i.includes(d.id)
        );
        return B(D({}, o), {
          participants: c
        });
      }
      return o;
    });
  }
}
vs = new WeakMap();
ZD([
  Dt({ maxInvocations: 60, period: 60 })
], KS.prototype, "getConnectedMeetings", 1);
var eO = Object.defineProperty, tO = Object.getOwnPropertyDescriptor, Kh = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? tO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && eO(t, e, i), i;
}, me, Gg;
const zS = (Gg = class {
  constructor(s) {
    h(this, "connectedMeetings");
    g(this, me, void 0);
    m(this, me, s), this.connectedMeetings = new KS(s);
  }
  /**
   * @access private
   * Not for external use
   */
  get telemetry() {
    return a(this, me).getValue("telemetry");
  }
  /**
   * @access private
   * Not for external use
   */
  get logger() {
    return a(this, me).getValue("logger");
  }
  static init(s) {
    const t = new zS(
      s
    );
    return t.connectedMeetings.supportsConnectedMeetings && (t.setupEvents(), s.getValue("self").once(
      "roomJoined",
      () => t.getConnectedMeetings()
    )), t;
  }
  getConnectedMeetings() {
    this.connectedMeetings.getConnectedMeetings();
  }
  setupEvents() {
    a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.getConnectedRoomsDump,
      this.handleConnectedRoomsDump.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.transferPeer,
      this.handleTransferPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.movedPeer,
      this.handleMovedPeer.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsUpdated,
      this.handleConnectedRoomsUpdated.bind(this)
    ), a(this, me).getValue("connectedMeetingsSocketHandler").socketService.on(
      x.connectedRoomsDeleted,
      this.handleConnectedRoomsDeleted.bind(this)
    );
  }
  // event handlers
  handleTransferPeer(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleTransferPeerRaw(s);
    return this.switchMeeting(t);
  }
  switchMeeting(e) {
    return u(this, arguments, function* ({
      authToken: s,
      meetingId: t
    }) {
      var n, o, c, d;
      if (!this.connectedMeetings.supportsConnectedMeetings)
        throw new Error(`You are not allowed to perform this action.
								Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
      this.logger.info("ConnectedMeetingsController::switchMeeting:: asking ui-kit to show switching breakout UI"), this.connectedMeetings.emit("changingMeeting", t);
      const r = {
        video: a(this, me).getValue("self").videoEnabled,
        audio: a(this, me).getValue("self").audioEnabled
      };
      try {
        a(this, me).getValue("self").cleanupEvents(), yield a(this, me).getValue("meeting").leave("connected-meeting");
      } catch (l) {
        this.logger.error(`ConnectedMeetingsController:: switchMeeting:: issues in leaving previous meeting. Meeting Id: ${(o = (n = a(this, me).getValue("meeting")) == null ? void 0 : n.meta) == null ? void 0 : o.meetingId}`, { error: l });
      }
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initializing new meeting. Meeting Id: ${t}`);
      const i = yield lO.init(B(D({}, a(this, me).getValue("options")), {
        cachedUserDetails: null,
        defaults: B(D(D({}, a(this, me).getValue("options").defaults), r), {
          /**
           * NOTE(ravindra-dyte):
           * Protected methods & variables of DyteSelfMedia,
           * such as localMediaHandler cannot be type checked outside class hierarchy,
           * therefore typecasting DyteSelf to DyteSelfMedia,
           * Even though DyteSelf extends DyteSelfMedia.
           *
           * Alternative approach is to make either DyteSelfMedia methods public
           * or expose a public wrapper on DyteSelf.
           */
          mediaHandler: a(this, me).getValue("self")
        }),
        authToken: s
      }));
      this.logger.info(`ConnectedMeetingsController::switchMeeting:: initialized new meeting. Meeting Id: ${(c = i == null ? void 0 : i.meta) == null ? void 0 : c.meetingId}`);
      try {
        const { hidden: l } = a(this, me).getValue("self");
        i.self.setName(a(this, me).getValue("self").name), yield i.join(), l && i.self.hide();
      } catch (l) {
        this.logger.error("ConnectedMeetingsController.joinRoom", { error: l });
      }
      return this.logger.info(`ConnectedMeetingsController::switchMeeting:: asking ui-kit to show in-meeting ui of newly joined meeting id: ${(d = i == null ? void 0 : i.meta) == null ? void 0 : d.meetingId}`), this.connectedMeetings.emit("meetingChanged", i), i;
    });
  }
  handleConnectedRoomsDump(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDumpRaw(s);
    this.connectedMeetings.meetings = t.meetings.map((e) => ({
      id: e.id,
      title: e.title,
      participants: e.participants || []
    })), this.connectedMeetings.parentMeeting = {
      id: t.parentMeeting.id,
      title: t.parentMeeting.title,
      participants: t.parentMeeting.participants
    }, this.emitStateUpdate();
  }
  // eslint-disable-next-line class-methods-use-this
  handleMovedPeer(s) {
    return a(this, me).getValue("connectedMeetingsSocketHandler").handleMovedPeerRaw(s);
  }
  handleConnectedRoomsUpdated(s) {
    const t = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsUpdatedRaw(s), e = /* @__PURE__ */ new Map();
    this.connectedMeetings.meetings.forEach((r) => {
      e.set(r.id, r);
    }), t.forEach((r) => {
      e.has(r.id) ? e.get(r.id).title = r.title : e.set(r.id, B(D({}, r), { participants: [] }));
    }), this.connectedMeetings.meetings = Array.from(e.values()), this.emitStateUpdate();
  }
  handleConnectedRoomsDeleted(s) {
    const e = a(this, me).getValue("connectedMeetingsSocketHandler").handleConnectedRoomsDeletedRaw(s).map((r) => r.id);
    this.connectedMeetings.meetings = this.connectedMeetings.meetings.filter(
      (r) => !e.includes(r.id)
    ), this.emitStateUpdate();
  }
  emitStateUpdate() {
    this.connectedMeetings.emit("stateUpdate", {
      meetings: this.connectedMeetings.meetings,
      parentMeeting: this.connectedMeetings.parentMeeting
    });
  }
}, me = new WeakMap(), Gg);
let eu = zS;
Kh([
  E.trace("ConnectedMeetingsController.getConnectedMeetings")
], eu.prototype, "getConnectedMeetings", 1);
Kh([
  E.trace("ConnectedMeetingsController.setupEvents")
], eu.prototype, "setupEvents", 1);
Kh([
  E.trace("ConnectedMeetingsController.switchMeeting")
], eu.prototype, "switchMeeting", 1);
var sO = Object.defineProperty, rO = Object.getOwnPropertyDescriptor, tu = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? rO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && sO(t, e, i), i;
};
const Ma = class {
  constructor(s, t, e) {
    h(this, "apiBase");
    h(this, "selfController");
    h(this, "pollController");
    h(this, "chatController");
    h(this, "metaController");
    h(this, "storesManager");
    h(this, "stageController");
    h(this, "pluginController");
    h(this, "internalsController");
    h(this, "recordingController");
    h(this, "livestreamController");
    h(this, "participantController");
    h(this, "connectedMeetingsController");
    /**
     * @access private
     * Not for external use
     */
    h(this, "telemetry");
    /**
     * @access private
     * Not for external use
     */
    h(this, "logger");
    this.apiBase = s, this.storesManager = t.storesManager, this.metaController = t.metaController, this.selfController = t.selfController, this.chatController = t.chatController, this.pollController = t.pollController, this.stageController = t.stageController, this.pluginController = t.pluginController, this.recordingController = t.recordingController, this.internalsController = t.internalsController, this.participantController = t.participantController, this.livestreamController = t.livestreamController, this.connectedMeetingsController = t.connectedMeetingsController, this.telemetry = e.getValue("telemetry"), this.logger = e.getValue("logger");
  }
  static init(s) {
    return u(this, null, function* () {
      var F, K;
      const {
        peerId: t,
        apiBase: e,
        authToken: r,
        meetingId: i,
        organizationId: n,
        cachedUserDetails: o,
        logger: c
      } = s.getAllValues();
      if (MS(s), Te.isSupported() === !1)
        throw new R("Browser not supported", "0010", c, !0);
      const d = cM(
        s,
        {
          authToken: r,
          baseURL: e,
          cachedUserDetails: o
        }
      );
      d.setRoomName(i), d.setRoomUUID(i), d.setOrganizationId(n), d.setHeader("dyte-tracing-id", t), s.setValue("apiClient", d);
      const l = new jM(s);
      s.setValue("connectionHandler", l);
      const p = Ma.createSocketService(s), f = p.connect(), S = d.getUserDetails(), T = d.getPlugins();
      let _ = we.HIVE, P, w = "";
      try {
        yield Ma.setupFlagsmith(s);
      } catch (re) {
        c.error("Failed to setup flagsmith", { error: re });
      }
      try {
        yield f;
      } catch (re) {
        c.error(
          "[Controller]: Failed to connect to socket server:",
          { error: re }
        );
      }
      try {
        ({ sfu: _, meetingTitle: w } = yield d.getRoomNodeData()), P = yield S, c.info(`SFU ${_} is being used.`), s.setValue("presetName", P.preset.name), s.setValue("roomNodeOptions", { sfu: _ });
      } catch (re) {
        c.error("Failed to get room metadata", { error: re });
      }
      const A = Ku.init(P.preset, !s.getValue("modules").theme), N = Qu.init(
        s,
        A.viewType,
        P.preset.permissions
      ), H = Ma.setupControllers(
        p,
        s,
        P,
        T,
        w,
        A,
        N
      );
      OM(A) && ((F = Ma.createRoomNodeClient(s, p).initializeConnection(
        P.participant.name,
        i,
        !1,
        N
      )) == null || F.catch((Je) => {
        c.error(
          "[Controller]: Failed to queue partial media room promise:",
          { error: Je }
        );
      })), E.location.country = (K = d.ipInfo) == null ? void 0 : K.country;
      const { controllers: $ } = yield H;
      return MC(), new Ma(e, $, s);
    });
  }
  static setupFlagsmith(s) {
    return u(this, null, function* () {
      var l;
      const {
        peerId: t,
        baseURI: e,
        overrides: r,
        meetingId: i,
        organizationId: n,
        logger: o
      } = s.getAllValues(), c = AC(i), d = B(D({
        entity: Iu.PEER,
        clientId: n,
        isAnonUser: !n,
        sdkVersion: s.getValue("sdkVersion"),
        presetName: s.getValue("presetName"),
        meetingHash: c,
        roomName: i
      }, Te.getDeviceInfo()), {
        isReactNative: navigator.isReactNative
      });
      try {
        const p = (l = r == null ? void 0 : r.whitelabelled_flags_endpoint) == null || l ? da({ servicePrefix: "flags", baseURI: e }) : "edge.api.flagsmith.com";
        yield s.getValue("flagsmith").identify(
          `${Iu.PEER}_${t}`,
          JSON.parse(JSON.stringify(d)),
          !1,
          // force evaluate
          5e3,
          // timeout
          p,
          o
        ), o.info(
          "flagsmith::allFlags",
          { flags: JSON.stringify(s.getValue("flagsmith").getAllFlags()) },
          !0
        );
      } catch (p) {
        o.error("Failed to fetch flagsmith flags");
      }
    });
  }
  static setupControllers(s, t, e, r, i, n, o) {
    return u(this, null, function* () {
      var $e, Cr, Rr;
      const c = t.getValue("modules"), { participant: d } = e, l = t.getValue("defaults"), p = t.getValue("logger"), { sfu: f } = t.getValue("roomNodeOptions"), { viewType: S, mediaConstraints: { audio: T } } = n;
      t.setValue("viewType", S), t.setValue("defaults", D({
        mediaConfiguration: {
          audio: {
            enableHighBitrate: ($e = T.enableHighBitrate) != null ? $e : !1,
            enableStereo: (Cr = T.enableStereo) != null ? Cr : !1
          }
        }
      }, l)), t.setValue("maxPreferredStreams", Te.isMobile() ? n.maxVideoStreams.mobile : n.maxVideoStreams.desktop);
      let _, P, w, A, N, H, $, F, K;
      const re = new _D(t, s), Je = new YD(
        s
      );
      t.setValue("connectedMeetingsSocketHandler", Je);
      const ks = new Ql(t, s), Pr = new as(t, s), ni = new kD(s), I = new OS(t, s), y = new ID(t, s), C = new ED(s), U = new pa(t, s), ie = yield ai.init(
        t,
        I,
        d,
        o,
        n
      );
      t.setValue("selfController", ie);
      const Me = yield Of.init(
        t,
        ie.self,
        I,
        re,
        i
      );
      if (c.participant && (F = new _r(
        t,
        ie.self,
        I,
        f
      )), (Rr = c.e2ee) != null && Rr.enabled && c.e2ee.manager.init(p, t.getValue("peerSessionStore")), c.chat && (P = yield Es.init(
        t,
        Pr,
        U,
        ie.self,
        F.participants
      )), c.internals && (N = yield Lh.init(t)), c.livestream && n.viewType === Mt.Livestream && t.getValue("flagsmith").hasFeature(X.LIVESTREAM) && ($ = new Bf(
        t,
        ie.self,
        C
      )), n.viewType !== Mt.Chat) {
        if (c.poll && (_ = yield If.init(
          t,
          ie.self,
          ks
        )), c.recording && (H = new xf(
          t,
          ie.self,
          I
        )), c.stage && (w = new Nf(
          t,
          ni,
          I,
          ie.self,
          F.participants
        )), c.plugin) {
          if (!F)
            throw new R(
              "The plugin module cannot be initialized without the `participant` module",
              "0102"
            );
          const Fs = yield r;
          A = yield Kc.init(
            t,
            Fs,
            y,
            Pr,
            P == null ? void 0 : P.chat,
            ie.self,
            F.participants,
            i
          );
        }
        if (c.connectedMeetings && (K = yield eu.init(
          t
        )), c.pip) {
          const Fs = yield Au._init(t, ie.self);
          t.setValue("pip", Fs);
        }
      }
      const b = {
        storesManager: new V0(t, y),
        pollController: _,
        selfController: ie,
        metaController: Me,
        chatController: P,
        stageController: w,
        pluginController: A,
        recordingController: H,
        internalsController: N,
        livestreamController: $,
        participantController: F,
        connectedMeetingsController: K
      };
      return {
        theme: n,
        permissions: o,
        controllers: b
      };
    });
  }
  static createRoomNodeClient(s, t) {
    const {
      peerId: e,
      roomNodeOptions: r
    } = s.getAllValues(), { sfu: i } = r;
    return AS(s, i, {
      socket: t,
      peerId: e
    });
  }
  static createSocketService(s) {
    const {
      peerId: t,
      meetingId: e,
      authToken: r
    } = s.getAllValues(), i = ["PING"];
    return new Xc(s, {
      peerId: t,
      meetingId: e,
      authToken: r,
      capabilities: i
    });
  }
};
let Zc = Ma;
tu([
  E.trace("Controller.init")
], Zc, "init", 1);
tu([
  E.trace("setupFlagsmith")
], Zc, "setupFlagsmith", 1);
tu([
  E.trace("Controller.createRoomNodeClient")
], Zc, "createRoomNodeClient", 1);
tu([
  E.trace("Controller.createSocketService")
], Zc, "createSocketService", 1);
class iO {
  constructor() {
    h(this, "battery");
    h(this, "logger");
    h(this, "init", (t) => u(this, null, function* () {
      this.logger = t;
      try {
        "getBattery" in navigator && (this.battery = yield navigator.getBattery(), this.battery.addEventListener("chargingchange", this.updateChargeInfo), this.battery.addEventListener("levelchange", this.updateLevelInfo), this.updateLevelInfo(), this.updateChargeInfo());
      } catch (e) {
        t.error("Error getting battery", e);
      }
    }));
    h(this, "updateChargeInfo", () => {
      var t;
      this.logger.log(
        `Battery charging? ${(t = this.battery) != null && t.charging ? "Yes" : "No"}`
      );
    });
    h(this, "updateLevelInfo", () => {
      if (!this.battery) {
        this.logger.log("Battery level: Not known");
        return;
      }
      this.logger.log(`Battery level: ${this.battery.level * 100}%`);
    });
    h(this, "cleanup", () => {
      var t, e;
      "getBattery" in navigator && ((t = this.battery) == null || t.removeEventListener(
        "chargingchange",
        this.updateChargeInfo
      ), (e = this.battery) == null || e.removeEventListener("levelchange", this.updateLevelInfo));
    });
  }
}
const Rg = new iO();
function aO(s, t) {
  s.startsWith("eyJ") || console.error("Invalid auth token provided. Ensure you are passing a %cparticipant `authToken`%c — not an Org API Key or an incorrectly formatted token.\nYou get the participant token from the Add Participant API: https://docs.dyte.io/api#/operations/add_participant", "font-weight: bold", "font-weight: normal");
  try {
    const { meetingId: e, orgId: r, participantId: i } = JSON.parse(atob(s.split(".")[1]));
    if (!e)
      throw Error(`Received V1 auth token ${s}`);
    let n = "dyte.io";
    t && (n = t);
    const o = `https://${da({ servicePrefix: "api", baseURI: n })}`;
    return {
      meetingId: e,
      orgId: r,
      participantId: i,
      baseURI: n,
      apiBase: o
    };
  } catch (e) {
    throw new R("Invalid auth token", "0004");
  }
}
var Yr, aa, na, Bc, Ll, YS;
class nO {
  constructor() {
    g(this, Ll);
    g(this, Yr, new Audio());
    g(this, aa, new MediaStream());
    g(this, na, /* @__PURE__ */ new Map());
    g(this, Bc, void 0);
    a(this, Yr).srcObject = a(this, aa), a(this, Yr).autoplay = !0;
  }
  playTracks(t) {
    return u(this, null, function* () {
      return t.forEach((e) => {
        a(this, na).has(e.id) || (a(this, aa).addTrack(e), a(this, na).set(e.id, e));
      }), this.play();
    });
  }
  setSpeakerDevice(t) {
    typeof HTMLAudioElement.prototype.setSinkId == "function" && a(this, Yr).setSinkId(t);
  }
  removeTrack(t) {
    const e = a(this, na).get(t);
    e && (a(this, aa).removeTrack(e), a(this, na).delete(t));
  }
  play() {
    return u(this, null, function* () {
      return a(this, Yr).srcObject = a(this, aa), a(this, Yr).play().catch((t) => {
        L(this, Ll, YS).call(this, t);
      });
    });
  }
  onError(t) {
    m(this, Bc, t);
  }
}
Yr = new WeakMap(), aa = new WeakMap(), na = new WeakMap(), Bc = new WeakMap(), Ll = new WeakSet(), YS = function(t) {
  var e;
  (e = a(this, Bc)) == null || e.call(this, t);
};
var oa;
class oO extends nO {
  constructor() {
    super();
    /** Maps participantId to trackId */
    g(this, oa, void 0);
    m(this, oa, /* @__PURE__ */ new Map());
  }
  addParticipantTrack(e, r) {
    a(this, oa).set(e, r.id), this.playTracks([r]);
  }
  removeParticipantTrack(e) {
    const r = a(this, oa).get(e);
    r && this.removeTrack(r), a(this, oa).delete(e);
  }
}
oa = new WeakMap();
var cO = Object.defineProperty, dO = Object.getOwnPropertyDescriptor, su = (s, t, e, r) => {
  for (var i = r > 1 ? void 0 : r ? dO(t, e) : t, n = s.length - 1, o; n >= 0; n--)
    (o = s[n]) && (i = (r ? o(t, e, i) : o(i)) || i);
  return r && i && cO(t, e, i), i;
}, We, ca, Wg;
let ri = (Wg = class {
  constructor(t, e) {
    g(this, We, void 0);
    g(this, ca, void 0);
    m(this, ca, t), m(this, We, e);
  }
  get peerId() {
    return a(this, ca).getValue("peerId");
  }
  static initMedia(t = {}, e = !1, r = void 0) {
    var d;
    const i = (d = r == null ? void 0 : r.peerId) != null ? d : ua(), n = mr.createContext(i, {
      peerId: i
    }), o = n.getValue("logger");
    o.init(n);
    const c = new zf(o);
    return c.init(t, e, n), n.setValue("defaults", { mediaHandler: c }), c;
  }
  static init(t) {
    return u(this, null, function* () {
      var T, _, P, A, N, H, $;
      Te.init();
      const { mediaHandler: e } = (T = t.defaults) != null ? T : {}, r = (e == null ? void 0 : e.peerId) || ((P = (_ = t == null ? void 0 : t.cachedUserDetails) == null ? void 0 : _.peerId) != null ? P : ua()), { authToken: i, baseURI: n } = t, w = aO(i, n), { meetingId: o } = w, c = ho(w, ["meetingId"]);
      window.__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = !0;
      const d = ri.setupContext(
        r,
        t,
        o,
        c
      ), l = d.getValue("telemetry"), p = d.getValue("logger");
      av(p), Rg.init(p), l.init(d, {
        roomName: o,
        userId: c.participantId,
        organizationId: c.orgId,
        peerId: r
      }, (N = (A = t.modules) == null ? void 0 : A.tracing) != null ? N : !0), p.init(d), p.info("DyteClient::init::options", {
        dyteClientInitOptions: B(D({}, t), {
          authToken: `${(H = t.authToken) == null ? void 0 : H.slice(0, 10)}...
				${($ = t.authToken) == null ? void 0 : $.slice(-10)}`
        })
      });
      const f = yield Zc.init(d), S = new ri(d, f);
      return d.setValue("meeting", S), S;
    });
  }
  static setupContext(t, e, r, i) {
    var d, l;
    const n = mr.createContext(t, e), o = D(D({}, _C), e == null ? void 0 : e.modules), c = e.defaults || {
      audio: !0,
      video: !0
    };
    return n.setValue("options", e), n.setValue("peerId", t), n.setValue("modules", o), n.setValue("sdkName", "web-core"), n.setValue("meetingId", r), n.setValue("apiBase", i.apiBase), n.setValue("baseURI", i.baseURI), n.setValue("userId", i.participantId), n.setValue("organizationId", i.orgId), n.setValue("authToken", e.authToken), n.setValue("overrides", (d = e.overrides) != null ? d : {}), n.setValue("env", PC({ baseURI: i.baseURI })), n.setValue("defaults", c), n.setValue("onError", e.onError || (() => {
    })), n.setValue("cachedUserDetails", _s(e.cachedUserDetails)), n.setValue("sdkVersion", "3.1.7"), (l = e.modules) != null && l.experimentalAudioPlayback && n.setValue("audioPlayback", new oO()), n;
  }
  join() {
    return u(this, null, function* () {
      const { selfController: t } = a(this, We);
      return t.self.roomJoined ? null : t.joinRoom();
    });
  }
  leave(t) {
    return u(this, null, function* () {
      Rg.cleanup(), a(this, ca).getValue("peerSessionStore").reset();
      const { selfController: e } = a(this, We);
      return e.leaveRoom(t);
    });
  }
  /**
   * The `participants` object consists of 4 maps of participants,
   * `waitlisted`, `joined`, `active`, `pinned`. The maps are indexed by
   * `peerId`s, and the values are the corresponding participant objects.
   */
  get participants() {
    var t;
    return (t = a(this, We).participantController) == null ? void 0 : t.participants;
  }
  /**
   * The `self` object can be used to manipulate audio and video settings,
   * and other configurations for the local participant. This exposes methods
   * to enable and disable media tracks, share the user's screen, etc.
   */
  get self() {
    var t;
    return (t = a(this, We).selfController) == null ? void 0 : t.self;
  }
  /**
   * The `room` object stores information about the current meeting, such
   * as chat messages, polls, room name, etc.
   */
  get meta() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.meta;
  }
  /**
   * The `ai` object is used to interface with Dyte's AI features.
   * You can obtain the live meeting transcript and use other meeting AI
   * features such as summary, and agenda using this object.
   */
  get ai() {
    var t;
    return (t = a(this, We).metaController) == null ? void 0 : t.ai;
  }
  /**
   * The `plugins` object stores information about the plugins available in
   * the current meeting. It exposes methods to activate and deactivate them.
   */
  get plugins() {
    var t;
    return (t = a(this, We).pluginController) == null ? void 0 : t.plugins;
  }
  /**
   * The chat object stores the chat messages that were sent in the meeting.
   * This includes text messages, images, and files.
   */
  get chat() {
    var t;
    return (t = a(this, We).chatController) == null ? void 0 : t.chat;
  }
  /**
   * The polls object stores the polls that were initiated in the meeting.
   * It exposes methods to create and vote on polls.
   */
  get polls() {
    var t;
    return (t = a(this, We).pollController) == null ? void 0 : t.polls;
  }
  /**
   * The connectedMeetings object stores the connected meetings states.
   * It exposes methods to create/read/update/delete methods for connected meetings.
   */
  get connectedMeetings() {
    var t;
    return (t = a(this, We).connectedMeetingsController) == null ? void 0 : t.connectedMeetings;
  }
  /*
   * The recording object stores the recording state of the meeting.
   * It exposes methods to start and stop recording.
   */
  get recording() {
    var t;
    return (t = a(this, We).recordingController) == null ? void 0 : t.recording;
  }
  get livestream() {
    var t;
    return (t = a(this, We).livestreamController) == null ? void 0 : t.livestream;
  }
  get stage() {
    var t;
    return (t = a(this, We).stageController) == null ? void 0 : t.stage;
  }
  get stores() {
    return a(this, We).storesManager;
  }
  get audio() {
    return a(this, ca).getValue("audioPlayback");
  }
  /**
   * The __internals__ object exposes the internal tools & utilities such as features and logger
   * so that client can utilise the same to build their own feature based UI.
   * DyteLogger (__internals__.logger) can be used to send logs to Dyte's servers
   *	to inform Dyte of issues, if any, proactively.
   */
  get __internals__() {
    var t;
    return (t = a(this, We).internalsController) == null ? void 0 : t.internals;
  }
  /** @deprecated Use `join()` instead */
  joinRoom() {
    return u(this, null, function* () {
      return this.join();
    });
  }
  /** @deprecated Use `leave()` instead */
  leaveRoom(t) {
    return u(this, null, function* () {
      return this.leave(t);
    });
  }
}, We = new WeakMap(), ca = new WeakMap(), Wg);
su([
  ht("0002"),
  Er.executeWithLock({
    methodName: "meeting.join",
    lockName: "DyteClient.join",
    timeout: 3e3
  })
], ri.prototype, "join", 1);
su([
  ht("0003")
], ri.prototype, "leave", 1);
su([
  ht("0001"),
  Er.executeWithLock({
    methodName: "DyteClient.init",
    lockName: "DyteClient.init",
    timeout: 3e3
  })
], ri, "init", 1);
ri = su([
  ht("0000")
], ri);
const lO = ri;
export {
  lO as default
};
